[
    {
        "repo_name": "gravitee-io_graviteeio-access-management",
        "commit": "3b353da5a24425e4e40d325433c00f49bbf87ab9",
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/controller/LoginController.java",
        "definition": "@Controller\npublic class LoginController {\n\n    private final static Logger logger = LoggerFactory.getLogger(LoginController.class);\n    private final static String LOGIN_VIEW = \"login\";\n    private final static List<String> socialProviders = Arrays.asList(\"github\", \"google\", \"twitter\", \"facebook\", \"bitbucket\");\n    private final static String errorPage = \"forward:/oauth/error\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @RequestMapping(value = \"/login\")\n    public ModelAndView login(\n            @RequestParam(value = OAuth2Utils.CLIENT_ID) String clientId, HttpServletRequest request) {\n        if (clientId == null || clientId.isEmpty()) {\n            logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n        }\n\n        Client client;\n        try {\n            // TODO async call\n            client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n        }\n\n        Map<String, Object> params = new HashMap<>();\n        params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n        params.put(\"domain\", domain);\n\n        Set<String> clientOAuth2Providers = client.getOauth2Identities();\n        if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n            params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n                IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n                String identityProviderType = identityProvider.getType();\n                Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n                if (identityProviderSocialType.isPresent()) {\n                    identityProvider.setType(identityProviderSocialType.get());\n                }\n                return identityProvider;\n            }).collect(Collectors.toSet()));\n\n            Map<String, String> authorizeUrls = new HashMap<>();\n            clientOAuth2Providers.forEach(identity -> {\n                OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n                if (oAuth2AuthenticationProvider != null) {\n                    OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                    builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                    builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                    builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                    if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                        builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                    }\n                    authorizeUrls.put(identity, builder.build(false).toUriString());\n                }\n            });\n            params.put(\"authorizeUrls\", authorizeUrls);\n        }\n\n        return new ModelAndView(LOGIN_VIEW, params);\n    }\n\n    @RequestMapping(value = \"/login/callback\")\n    public void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n        if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n            final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n            response.sendRedirect(savedRequest.getRedirectUrl());\n        } else {\n            response.sendRedirect(\"/login\");\n        }\n    }\n\n    private String buildRedirectUri(HttpServletRequest request, String identity) {\n        UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        } else {\n            builder.scheme(request.getScheme());\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        } else {\n            builder.host(request.getServerName());\n            if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n                builder.port(request.getServerPort());\n            }\n        }\n        // append context path\n        builder.path(request.getContextPath());\n        builder.pathSegment(\"login/callback\");\n\n        // append identity provider id\n        builder.queryParam(\"provider\", identity);\n\n        return builder.build().toUriString();\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.controller;",
        "tree_path": "LoginController",
        "name": "LoginController",
        "modifiers": "@Controller\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final static Logger logger = LoggerFactory.getLogger(LoginController.class);\n    private final static String LOGIN_VIEW = \"login\";\n    private final static List<String> socialProviders = Arrays.asList(\"github\", \"google\", \"twitter\", \"facebook\", \"bitbucket\");\n    private final static String errorPage = \"forward:/oauth/error\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @RequestMapping(value = \"/login\")\n    public ModelAndView login(\n            @RequestParam(value = OAuth2Utils.CLIENT_ID) String clientId, HttpServletRequest request) {\n        if (clientId == null || clientId.isEmpty()) {\n            logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n        }\n\n        Client client;\n        try {\n            // TODO async call\n            client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n        }\n\n        Map<String, Object> params = new HashMap<>();\n        params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n        params.put(\"domain\", domain);\n\n        Set<String> clientOAuth2Providers = client.getOauth2Identities();\n        if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n            params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n                IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n                String identityProviderType = identityProvider.getType();\n                Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n                if (identityProviderSocialType.isPresent()) {\n                    identityProvider.setType(identityProviderSocialType.get());\n                }\n                return identityProvider;\n            }).collect(Collectors.toSet()));\n\n            Map<String, String> authorizeUrls = new HashMap<>();\n            clientOAuth2Providers.forEach(identity -> {\n                OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n                if (oAuth2AuthenticationProvider != null) {\n                    OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                    builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                    builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                    builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                    if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                        builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                    }\n                    authorizeUrls.put(identity, builder.build(false).toUriString());\n                }\n            });\n            params.put(\"authorizeUrls\", authorizeUrls);\n        }\n\n        return new ModelAndView(LOGIN_VIEW, params);\n    }\n\n    @RequestMapping(value = \"/login/callback\")\n    public void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n        if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n            final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n            response.sendRedirect(savedRequest.getRedirectUrl());\n        } else {\n            response.sendRedirect(\"/login\");\n        }\n    }\n\n    private String buildRedirectUri(HttpServletRequest request, String identity) {\n        UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        } else {\n            builder.scheme(request.getScheme());\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        } else {\n            builder.host(request.getServerName());\n            if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n                builder.port(request.getServerPort());\n            }\n        }\n        // append context path\n        builder.path(request.getContextPath());\n        builder.pathSegment(\"login/callback\");\n\n        // append identity provider id\n        builder.queryParam(\"provider\", identity);\n\n        return builder.build().toUriString();\n    }\n\n}",
        "start_point": {
            "row": 47,
            "column": 0
        },
        "end_point": {
            "row": 165,
            "column": 1
        },
        "file_mode": "Renamed-Modified",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/controller/LoginController.java",
        "methods": [
            {
                "definition": "@RequestMapping(value = \"/login\")\npublic ModelAndView login(\n        @RequestParam(value = OAuth2Utils.CLIENT_ID) String clientId, HttpServletRequest request) {\n    if (clientId == null || clientId.isEmpty()) {\n        logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n    }\n\n    Client client;\n    try {\n        // TODO async call\n        client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n    }\n\n    Map<String, Object> params = new HashMap<>();\n    params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n    params.put(\"domain\", domain);\n\n    Set<String> clientOAuth2Providers = client.getOauth2Identities();\n    if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n        params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n            IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n            String identityProviderType = identityProvider.getType();\n            Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n            if (identityProviderSocialType.isPresent()) {\n                identityProvider.setType(identityProviderSocialType.get());\n            }\n            return identityProvider;\n        }).collect(Collectors.toSet()));\n\n        Map<String, String> authorizeUrls = new HashMap<>();\n        clientOAuth2Providers.forEach(identity -> {\n            OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n            if (oAuth2AuthenticationProvider != null) {\n                OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                    builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                }\n                authorizeUrls.put(identity, builder.build(false).toUriString());\n            }\n        });\n        params.put(\"authorizeUrls\", authorizeUrls);\n    }\n\n    return new ModelAndView(LOGIN_VIEW, params);\n}",
                "name": "login",
                "modifiers": "@RequestMapping(value = \"/login\")\n    public",
                "return_type": "ModelAndView",
                "parameters": [
                    {
                        "type": "@RequestParam(value = OAuth2Utils.CLIENT_ID)",
                        "name": "String"
                    },
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    }
                ],
                "body": "{\n    if (clientId == null || clientId.isEmpty()) {\n        logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n    }\n\n    Client client;\n    try {\n        // TODO async call\n        client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n    }\n\n    Map<String, Object> params = new HashMap<>();\n    params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n    params.put(\"domain\", domain);\n\n    Set<String> clientOAuth2Providers = client.getOauth2Identities();\n    if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n        params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n            IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n            String identityProviderType = identityProvider.getType();\n            Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n            if (identityProviderSocialType.isPresent()) {\n                identityProvider.setType(identityProviderSocialType.get());\n            }\n            return identityProvider;\n        }).collect(Collectors.toSet()));\n\n        Map<String, String> authorizeUrls = new HashMap<>();\n        clientOAuth2Providers.forEach(identity -> {\n            OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n            if (oAuth2AuthenticationProvider != null) {\n                OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                    builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                }\n                authorizeUrls.put(identity, builder.build(false).toUriString());\n            }\n        });\n        params.put(\"authorizeUrls\", authorizeUrls);\n    }\n\n    return new ModelAndView(LOGIN_VIEW, params);\n}",
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 117,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/login/callback\")\npublic void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n    if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n        final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n        response.sendRedirect(savedRequest.getRedirectUrl());\n    } else {\n        response.sendRedirect(\"/login\");\n    }\n}",
                "name": "loginCallback",
                "modifiers": "@RequestMapping(value = \"/login/callback\")\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "HttpSession",
                        "name": "session"
                    }
                ],
                "body": "{\n    if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n        final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n        response.sendRedirect(savedRequest.getRedirectUrl());\n    } else {\n        response.sendRedirect(\"/login\");\n    }\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "private String buildRedirectUri(HttpServletRequest request, String identity) {\n    UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    } else {\n        builder.scheme(request.getScheme());\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    } else {\n        builder.host(request.getServerName());\n        if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n            builder.port(request.getServerPort());\n        }\n    }\n    // append context path\n    builder.path(request.getContextPath());\n    builder.pathSegment(\"login/callback\");\n\n    // append identity provider id\n    builder.queryParam(\"provider\", identity);\n\n    return builder.build().toUriString();\n}",
                "name": "buildRedirectUri",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "String",
                        "name": "identity"
                    }
                ],
                "body": "{\n    UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    } else {\n        builder.scheme(request.getScheme());\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    } else {\n        builder.host(request.getServerName());\n        if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n            builder.port(request.getServerPort());\n        }\n    }\n    // append context path\n    builder.path(request.getContextPath());\n    builder.pathSegment(\"login/callback\");\n\n    // append identity provider id\n    builder.queryParam(\"provider\", identity);\n\n    return builder.build().toUriString();\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 163,
                    "column": 5
                }
            }
        ]
    }
]