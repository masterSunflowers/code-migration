[
    {
        "repo_name": "apache_dubbo-admin",
        "commit": "80013ffc38b3d737bd891a2b574ef75a93450bd9",
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/RegistryServerSync.java",
        "definition": "@Component\npublic class RegistryServerSync implements InitializingBean, DisposableBean, NotifyListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(RegistryServerSync.class);\n\n    private static final URL SUBSCRIBE = new URL(Constants.ADMIN_PROTOCOL, NetUtils.getLocalHost(), 0, \"\",\n            Constants.INTERFACE_KEY, Constants.ANY_VALUE,\n            Constants.GROUP_KEY, Constants.ANY_VALUE,\n            Constants.VERSION_KEY, Constants.ANY_VALUE,\n            Constants.CLASSIFIER_KEY, Constants.ANY_VALUE,\n            Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY + \",\"\n            + Constants.CONSUMERS_CATEGORY + \",\"\n            + Constants.ROUTERS_CATEGORY + \",\"\n            + Constants.CONFIGURATORS_CATEGORY,\n            Constants.ENABLED_KEY, Constants.ANY_VALUE,\n            Constants.CHECK_KEY, String.valueOf(false));\n\n    private static final AtomicLong ID = new AtomicLong();\n\n    /**\n     * Make sure ID never changed when the same url notified many times\n     */\n    private final ConcurrentHashMap<String, String> URL_IDS_MAPPER = new ConcurrentHashMap<>();\n\n    // ConcurrentMap<category, ConcurrentMap<servicename, Map<MD5, URL>>>\n    private final ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>>\n        registryCache = new ConcurrentHashMap<>();\n    @Autowired\n    private RegistryService registryService;\n\n    public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n        return registryCache;\n    }\n\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Init Dubbo Admin Sync Cache...\");\n        registryService.subscribe(SUBSCRIBE, this);\n    }\n\n    public void destroy() throws Exception {\n        registryService.unsubscribe(SUBSCRIBE, this);\n    }\n\n    // Notification of of any service with any type (override\u3001subcribe\u3001route\u3001provider) is full.\n    public void notify(List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            return;\n        }\n        // Map<category, Map<servicename, Map<Long, URL>>>\n        final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n        String interfaceName = null;\n        for (URL url : urls) {\n            String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n            if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n                ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n                if (services != null) {\n                    String group = url.getParameter(Constants.GROUP_KEY);\n                    String version = url.getParameter(Constants.VERSION_KEY);\n                    // NOTE: group and version in empty protocol is *\n                    if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                        services.remove(url.getServiceKey());\n                    } else {\n                        for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                            String service = serviceEntry.getKey();\n                            if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                    && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                    && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                                services.remove(service);\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (StringUtils.isEmpty(interfaceName)) {\n                    interfaceName = url.getServiceInterface();\n                }\n                Map<String, Map<String, URL>> services = categories.get(category);\n                if (services == null) {\n                    services = new HashMap<>();\n                    categories.put(category, services);\n                }\n                String service = url.getServiceKey();\n                Map<String, URL> ids = services.get(service);\n                if (ids == null) {\n                    ids = new HashMap<>();\n                    services.put(service, ids);\n                }\n\n                // Make sure we use the same ID for the same URL\n                if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                    ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n                } else {\n                    String md5 = MD5Util.MD5_16bit(url.toFullString());\n                    ids.put(md5, url);\n                    URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n                }\n            }\n        }\n        if (categories.size() == 0) {\n            return;\n        }\n        for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n            String category = categoryEntry.getKey();\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services == null) {\n                services = new ConcurrentHashMap<String, Map<String, URL>>();\n                registryCache.put(category, services);\n            } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n                Set<String> keys = new HashSet<String>(services.keySet());\n                for (String key : keys) {\n                    if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                        services.remove(key);\n                    }\n                }\n            }\n            services.putAll(categoryEntry.getValue());\n        }\n    }\n}",
        "package": "package org.apache.dubbo.admin.service;",
        "tree_path": "RegistryServerSync",
        "name": "RegistryServerSync",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements InitializingBean, DisposableBean, NotifyListener",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(RegistryServerSync.class);\n\n    private static final URL SUBSCRIBE = new URL(Constants.ADMIN_PROTOCOL, NetUtils.getLocalHost(), 0, \"\",\n            Constants.INTERFACE_KEY, Constants.ANY_VALUE,\n            Constants.GROUP_KEY, Constants.ANY_VALUE,\n            Constants.VERSION_KEY, Constants.ANY_VALUE,\n            Constants.CLASSIFIER_KEY, Constants.ANY_VALUE,\n            Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY + \",\"\n            + Constants.CONSUMERS_CATEGORY + \",\"\n            + Constants.ROUTERS_CATEGORY + \",\"\n            + Constants.CONFIGURATORS_CATEGORY,\n            Constants.ENABLED_KEY, Constants.ANY_VALUE,\n            Constants.CHECK_KEY, String.valueOf(false));\n\n    private static final AtomicLong ID = new AtomicLong();\n\n    /**\n     * Make sure ID never changed when the same url notified many times\n     */\n    private final ConcurrentHashMap<String, String> URL_IDS_MAPPER = new ConcurrentHashMap<>();\n\n    // ConcurrentMap<category, ConcurrentMap<servicename, Map<MD5, URL>>>\n    private final ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>>\n        registryCache = new ConcurrentHashMap<>();\n    @Autowired\n    private RegistryService registryService;\n\n    public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n        return registryCache;\n    }\n\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Init Dubbo Admin Sync Cache...\");\n        registryService.subscribe(SUBSCRIBE, this);\n    }\n\n    public void destroy() throws Exception {\n        registryService.unsubscribe(SUBSCRIBE, this);\n    }\n\n    // Notification of of any service with any type (override\u3001subcribe\u3001route\u3001provider) is full.\n    public void notify(List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            return;\n        }\n        // Map<category, Map<servicename, Map<Long, URL>>>\n        final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n        String interfaceName = null;\n        for (URL url : urls) {\n            String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n            if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n                ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n                if (services != null) {\n                    String group = url.getParameter(Constants.GROUP_KEY);\n                    String version = url.getParameter(Constants.VERSION_KEY);\n                    // NOTE: group and version in empty protocol is *\n                    if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                        services.remove(url.getServiceKey());\n                    } else {\n                        for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                            String service = serviceEntry.getKey();\n                            if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                    && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                    && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                                services.remove(service);\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (StringUtils.isEmpty(interfaceName)) {\n                    interfaceName = url.getServiceInterface();\n                }\n                Map<String, Map<String, URL>> services = categories.get(category);\n                if (services == null) {\n                    services = new HashMap<>();\n                    categories.put(category, services);\n                }\n                String service = url.getServiceKey();\n                Map<String, URL> ids = services.get(service);\n                if (ids == null) {\n                    ids = new HashMap<>();\n                    services.put(service, ids);\n                }\n\n                // Make sure we use the same ID for the same URL\n                if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                    ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n                } else {\n                    String md5 = MD5Util.MD5_16bit(url.toFullString());\n                    ids.put(md5, url);\n                    URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n                }\n            }\n        }\n        if (categories.size() == 0) {\n            return;\n        }\n        for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n            String category = categoryEntry.getKey();\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services == null) {\n                services = new ConcurrentHashMap<String, Map<String, URL>>();\n                registryCache.put(category, services);\n            } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n                Set<String> keys = new HashSet<String>(services.keySet());\n                for (String key : keys) {\n                    if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                        services.remove(key);\n                    }\n                }\n            }\n            services.putAll(categoryEntry.getValue());\n        }\n    }\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 156,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n    return registryCache;\n}",
                "name": "getRegistryCache",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return registryCache;\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                }
            },
            {
                "definition": "public void afterPropertiesSet() throws Exception {\n    logger.info(\"Init Dubbo Admin Sync Cache...\");\n    registryService.subscribe(SUBSCRIBE, this);\n}",
                "name": "afterPropertiesSet",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Init Dubbo Admin Sync Cache...\");\n    registryService.subscribe(SUBSCRIBE, this);\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "public void destroy() throws Exception {\n    registryService.unsubscribe(SUBSCRIBE, this);\n}",
                "name": "destroy",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    registryService.unsubscribe(SUBSCRIBE, this);\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "public void notify(List<URL> urls) {\n    if (urls == null || urls.isEmpty()) {\n        return;\n    }\n    // Map<category, Map<servicename, Map<Long, URL>>>\n    final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n    String interfaceName = null;\n    for (URL url : urls) {\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services != null) {\n                String group = url.getParameter(Constants.GROUP_KEY);\n                String version = url.getParameter(Constants.VERSION_KEY);\n                // NOTE: group and version in empty protocol is *\n                if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                    services.remove(url.getServiceKey());\n                } else {\n                    for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                        String service = serviceEntry.getKey();\n                        if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                            services.remove(service);\n                        }\n                    }\n                }\n            }\n        } else {\n            if (StringUtils.isEmpty(interfaceName)) {\n                interfaceName = url.getServiceInterface();\n            }\n            Map<String, Map<String, URL>> services = categories.get(category);\n            if (services == null) {\n                services = new HashMap<>();\n                categories.put(category, services);\n            }\n            String service = url.getServiceKey();\n            Map<String, URL> ids = services.get(service);\n            if (ids == null) {\n                ids = new HashMap<>();\n                services.put(service, ids);\n            }\n\n            // Make sure we use the same ID for the same URL\n            if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n            } else {\n                String md5 = MD5Util.MD5_16bit(url.toFullString());\n                ids.put(md5, url);\n                URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n            }\n        }\n    }\n    if (categories.size() == 0) {\n        return;\n    }\n    for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n        String category = categoryEntry.getKey();\n        ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n        if (services == null) {\n            services = new ConcurrentHashMap<String, Map<String, URL>>();\n            registryCache.put(category, services);\n        } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n            Set<String> keys = new HashSet<String>(services.keySet());\n            for (String key : keys) {\n                if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                    services.remove(key);\n                }\n            }\n        }\n        services.putAll(categoryEntry.getValue());\n    }\n}",
                "name": "notify",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<URL>",
                        "name": "urls"
                    }
                ],
                "body": "{\n    if (urls == null || urls.isEmpty()) {\n        return;\n    }\n    // Map<category, Map<servicename, Map<Long, URL>>>\n    final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n    String interfaceName = null;\n    for (URL url : urls) {\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services != null) {\n                String group = url.getParameter(Constants.GROUP_KEY);\n                String version = url.getParameter(Constants.VERSION_KEY);\n                // NOTE: group and version in empty protocol is *\n                if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                    services.remove(url.getServiceKey());\n                } else {\n                    for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                        String service = serviceEntry.getKey();\n                        if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                            services.remove(service);\n                        }\n                    }\n                }\n            }\n        } else {\n            if (StringUtils.isEmpty(interfaceName)) {\n                interfaceName = url.getServiceInterface();\n            }\n            Map<String, Map<String, URL>> services = categories.get(category);\n            if (services == null) {\n                services = new HashMap<>();\n                categories.put(category, services);\n            }\n            String service = url.getServiceKey();\n            Map<String, URL> ids = services.get(service);\n            if (ids == null) {\n                ids = new HashMap<>();\n                services.put(service, ids);\n            }\n\n            // Make sure we use the same ID for the same URL\n            if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n            } else {\n                String md5 = MD5Util.MD5_16bit(url.toFullString());\n                ids.put(md5, url);\n                URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n            }\n        }\n    }\n    if (categories.size() == 0) {\n        return;\n    }\n    for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n        String category = categoryEntry.getKey();\n        ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n        if (services == null) {\n            services = new ConcurrentHashMap<String, Map<String, URL>>();\n            registryCache.put(category, services);\n        } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n            Set<String> keys = new HashSet<String>(services.keySet());\n            for (String key : keys) {\n                if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                    services.remove(key);\n                }\n            }\n        }\n        services.putAll(categoryEntry.getValue());\n    }\n}",
                "start_point": {
                    "row": 82,
                    "column": 4
                },
                "end_point": {
                    "row": 155,
                    "column": 5
                }
            }
        ]
    }
]