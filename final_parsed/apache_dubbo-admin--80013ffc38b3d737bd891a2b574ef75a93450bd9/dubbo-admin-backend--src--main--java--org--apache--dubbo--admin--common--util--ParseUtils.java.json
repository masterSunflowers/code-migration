[
    {
        "repo_name": "apache_dubbo-admin",
        "commit": "80013ffc38b3d737bd891a2b574ef75a93450bd9",
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/common/util/ParseUtils.java",
        "definition": "public class ParseUtils {\n\n    private static final ConcurrentMap<String, Pattern>\n        REPLACE_PARAMETER_PATTERNS = new ConcurrentHashMap<String, Pattern>();\n    public static String METHOD_SPLIT = \",\";\n    private static Pattern VARIABLE_PATTERN = Pattern.compile(\n            \"\\\\$\\\\s*\\\\{?\\\\s*([\\\\._0-9a-zA-Z]+)\\\\s*\\\\}?\");\n    private static Pattern QUERY_PATTERN = Pattern\n            .compile(\"([&=]?)\\\\s*([^&=\\\\s]+)\");\n\n    private ParseUtils() {\n    }\n\n    /**\n     * Execute interpolation (variable insertion).\n     *\n     * @param expression Expression string containing variables. Variable names in expressions can also be enclosed in <code> {} </ code>\u3002\n     * @param params Variable set. Variable names can include <code>. </ Code>, <code> _ </ code> characters.\n     * @return After the completion of the interpolation string. Such as: <code> <pre> xxx $ {name} zzz -> xxxjerryzzz </ pre> </ code> (where the variable name = \"jerry\")\n     * @throws IllegalStateException The variables used in the expression string are not in the variable set\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static String interpolate(String expression, Map<String, String> params) {\n        if (expression == null || expression.length() == 0) {\n            throw new IllegalArgumentException(\"glob pattern is empty!\");\n        }\n        if (expression.indexOf('$') < 0) {\n            return expression;\n        }\n        Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) { // match one by one\n            String key = matcher.group(1);\n            String value = params == null ? null : params.get(key);\n            if (value == null) {\n                value = \"\";\n            }\n            matcher.appendReplacement(sb, value);\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static List<String> interpolate(List<String> expressions, Map<String, String> params) {\n        List<String> ret = new ArrayList<String>();\n\n        if (null == expressions || expressions.isEmpty()) {\n            return ret;\n        }\n\n        for (String expr : expressions) {\n            ret.add(interpolate(expr, params));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Match Glob mode. The current implementation only supports <code>*</ code> and supports only one. Does not support <code>?</ Code>.\n     * @return For code or value of <code> null </ code>, return <code> false </ code> directly.\n     */\n    public static boolean isMatchGlobPattern(String pattern, String value) {\n        if (\"*\".equals(pattern))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                && (value == null || value.length() == 0))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                || (value == null || value.length() == 0))\n            return false;\n\n        int i = pattern.lastIndexOf('*');\n        // No asterisk found\n        if (i == -1) {\n            return value.equals(pattern);\n        }\n        // Asterisk at the end\n        else if (i == pattern.length() - 1) {\n            return value.startsWith(pattern.substring(0, i));\n        }\n        // Asterisk at the beginning\n        else if (i == 0) {\n            return value.endsWith(pattern.substring(i + 1));\n        }\n        // Asterisk in the middle of the string\n        else {\n            String prefix = pattern.substring(0, i);\n            String suffix = pattern.substring(i + 1);\n            return value.startsWith(prefix) && value.endsWith(suffix);\n        }\n    }\n\n    /**\n     * Whether to match Glob mode. Glob mode is the expression to be interpolated. Glob pattern has more than one, as long as matching a pattern, that match is successful.\n     *\n     * @param patternsNeedInterpolate Multiple Glob patterns to interpolate\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param interpolateParams Set of variables used for interpolation\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param value Glob mode value\n     */\n    public static boolean isMatchGlobPatternsNeedInterpolate(\n        Collection<String> patternsNeedInterpolate,\n        Map<String, String> interpolateParams, String value) {\n        if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n            for (String patternNeedItp : patternsNeedInterpolate) {\n                if (StringUtils.isEmpty(patternNeedItp)) {\n                    continue;\n                }\n                // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n                // FIXME ERROR!! Should be confirmed with Liang Fei!!\n                String pattern = interpolate(patternNeedItp, interpolateParams);\n                if (isMatchGlobPattern(pattern, value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns the entries in the collection that match the Glob pattern.\n     */\n    public static Set<String> filterByGlobPattern(String pattern, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (pattern == null || values == null) {\n            return ret;\n        }\n\n        for (String v : values) {\n            if (isMatchGlobPattern(pattern, v)) {\n                ret.add(v);\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Find the string that matches the Glob pattern. Multiple patterns, as long as a match pattern, it returns this string.\n     */\n    public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n            return ret;\n        }\n\n        for (String p : patterns) {\n            for (String v : values) {\n                if (isMatchGlobPattern(p, v)) {\n                    ret.add(v);\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Whether two Glob patterns have intersection.\n     */\n    public static boolean hasIntersection(String glob1, String glob2) {\n        if (null == glob1 || null == glob2) {\n            return false;\n        }\n\n        if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n            int index1 = glob1.indexOf(\"*\");\n            int index2 = glob2.indexOf(\"*\");\n\n            String s11 = glob1.substring(0, index1);\n            String s12 = glob1.substring(index1 + 1, glob1.length());\n\n            String s21 = glob2.substring(0, index2);\n            String s22 = glob2.substring(index2 + 1, glob2.length());\n\n            if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n            if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n            return true;\n        } else if (glob1.contains(\"*\")) {\n            return isMatchGlobPattern(glob1, glob2);\n        } else if (glob2.contains(\"*\")) {\n            return isMatchGlobPattern(glob2, glob1);\n        } else {\n            return glob1.equals(glob2);\n        }\n    }\n\n    /**\n     * Parse Query String into Map. For strings that have only Key, key3 = </ code> is ignored.\n     *\n     * @param keyPrefix In the output of the Map Key plus a unified prefix.\n     * @param query Query String\uff0cFor example: <code>key1=value1&key2=value2</code>\n     * @return When Query String is <code>key1=value1&key2=value2</code>, and prefix is <code>pre.</code>,\n     *         then <code>Map{pre.key1=value1, pre.key=value2}</code> will be returned.\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static Map<String, String> parseQuery(String keyPrefix, String query) {\n        if (query == null)\n            return new HashMap<String, String>();\n        if (keyPrefix == null)\n            keyPrefix = \"\";\n\n        Matcher matcher = QUERY_PATTERN.matcher(query);\n        Map<String, String> routeQuery = new HashMap<String, String>();\n        String key = null;\n        while (matcher.find()) { // Match one by one\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            if (separator == null || separator.length() == 0\n                    || \"&\".equals(separator)) {\n                if (key != null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                key = content;\n            } else if (\"=\".equals(separator)) {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                routeQuery.put(keyPrefix + key, content);\n                key = null;\n            } else {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n            }\n        }\n        /*if (key != null)\n        throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n                + \"\\\", The error in the end char: \" + key);*/\n        return routeQuery;\n    }\n\n    public static Map<String, String> parseQuery(String query) {\n        return parseQuery(\"\", query);\n    }\n\n    /**\n     * Replace the value of the url parameter.\n     */\n    public static String replaceParameter(String query, String key, String value) {\n        if (query == null || query.length() == 0) {\n            return key + \"=\" + value;\n        }\n        if (query.indexOf(key + \"=\") == -1) {\n            return query + \"&\" + key + \"=\" + value;\n        }\n        Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n        if (pattern == null) {\n            pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n        }\n        Matcher matcher = pattern.matcher(query);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static String appendParamToUri(String uri, String name, String value) {\n        if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n        if (uri.indexOf('?') != -1) {\n            uri += \"&\" + name + \"=\" + value;\n        } else {\n            uri += \"?\" + name + \"=\" + value;\n        }\n        return uri;\n    }\n\n    public static String appendParamsToUri(String uri, Map<String, String> params) {\n        StringBuilder buf = new StringBuilder(uri);\n        boolean first = (uri.indexOf('?') < 0);\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n                continue;\n            if (first) {\n                buf.append(\"?\");\n                first = false;\n            } else {\n                buf.append(\"&\");\n            }\n            buf.append(key);\n            buf.append(\"=\");\n            buf.append(value);\n        }\n        return buf.toString();\n    }\n\n    public static boolean matchEndStarPattern(String value, String pattern) {\n        if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n        String perfix = pattern.substring(0, pattern.length() - 1);\n        return value.startsWith(perfix);\n    }\n}",
        "package": "package org.apache.dubbo.admin.common.util;",
        "tree_path": "ParseUtils",
        "name": "ParseUtils",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private static final ConcurrentMap<String, Pattern>\n        REPLACE_PARAMETER_PATTERNS = new ConcurrentHashMap<String, Pattern>();\n    public static String METHOD_SPLIT = \",\";\n    private static Pattern VARIABLE_PATTERN = Pattern.compile(\n            \"\\\\$\\\\s*\\\\{?\\\\s*([\\\\._0-9a-zA-Z]+)\\\\s*\\\\}?\");\n    private static Pattern QUERY_PATTERN = Pattern\n            .compile(\"([&=]?)\\\\s*([^&=\\\\s]+)\");\n\n    private ParseUtils() {\n    }\n\n    /**\n     * Execute interpolation (variable insertion).\n     *\n     * @param expression Expression string containing variables. Variable names in expressions can also be enclosed in <code> {} </ code>\u3002\n     * @param params Variable set. Variable names can include <code>. </ Code>, <code> _ </ code> characters.\n     * @return After the completion of the interpolation string. Such as: <code> <pre> xxx $ {name} zzz -> xxxjerryzzz </ pre> </ code> (where the variable name = \"jerry\")\n     * @throws IllegalStateException The variables used in the expression string are not in the variable set\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static String interpolate(String expression, Map<String, String> params) {\n        if (expression == null || expression.length() == 0) {\n            throw new IllegalArgumentException(\"glob pattern is empty!\");\n        }\n        if (expression.indexOf('$') < 0) {\n            return expression;\n        }\n        Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) { // match one by one\n            String key = matcher.group(1);\n            String value = params == null ? null : params.get(key);\n            if (value == null) {\n                value = \"\";\n            }\n            matcher.appendReplacement(sb, value);\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static List<String> interpolate(List<String> expressions, Map<String, String> params) {\n        List<String> ret = new ArrayList<String>();\n\n        if (null == expressions || expressions.isEmpty()) {\n            return ret;\n        }\n\n        for (String expr : expressions) {\n            ret.add(interpolate(expr, params));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Match Glob mode. The current implementation only supports <code>*</ code> and supports only one. Does not support <code>?</ Code>.\n     * @return For code or value of <code> null </ code>, return <code> false </ code> directly.\n     */\n    public static boolean isMatchGlobPattern(String pattern, String value) {\n        if (\"*\".equals(pattern))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                && (value == null || value.length() == 0))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                || (value == null || value.length() == 0))\n            return false;\n\n        int i = pattern.lastIndexOf('*');\n        // No asterisk found\n        if (i == -1) {\n            return value.equals(pattern);\n        }\n        // Asterisk at the end\n        else if (i == pattern.length() - 1) {\n            return value.startsWith(pattern.substring(0, i));\n        }\n        // Asterisk at the beginning\n        else if (i == 0) {\n            return value.endsWith(pattern.substring(i + 1));\n        }\n        // Asterisk in the middle of the string\n        else {\n            String prefix = pattern.substring(0, i);\n            String suffix = pattern.substring(i + 1);\n            return value.startsWith(prefix) && value.endsWith(suffix);\n        }\n    }\n\n    /**\n     * Whether to match Glob mode. Glob mode is the expression to be interpolated. Glob pattern has more than one, as long as matching a pattern, that match is successful.\n     *\n     * @param patternsNeedInterpolate Multiple Glob patterns to interpolate\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param interpolateParams Set of variables used for interpolation\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param value Glob mode value\n     */\n    public static boolean isMatchGlobPatternsNeedInterpolate(\n        Collection<String> patternsNeedInterpolate,\n        Map<String, String> interpolateParams, String value) {\n        if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n            for (String patternNeedItp : patternsNeedInterpolate) {\n                if (StringUtils.isEmpty(patternNeedItp)) {\n                    continue;\n                }\n                // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n                // FIXME ERROR!! Should be confirmed with Liang Fei!!\n                String pattern = interpolate(patternNeedItp, interpolateParams);\n                if (isMatchGlobPattern(pattern, value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns the entries in the collection that match the Glob pattern.\n     */\n    public static Set<String> filterByGlobPattern(String pattern, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (pattern == null || values == null) {\n            return ret;\n        }\n\n        for (String v : values) {\n            if (isMatchGlobPattern(pattern, v)) {\n                ret.add(v);\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Find the string that matches the Glob pattern. Multiple patterns, as long as a match pattern, it returns this string.\n     */\n    public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n            return ret;\n        }\n\n        for (String p : patterns) {\n            for (String v : values) {\n                if (isMatchGlobPattern(p, v)) {\n                    ret.add(v);\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Whether two Glob patterns have intersection.\n     */\n    public static boolean hasIntersection(String glob1, String glob2) {\n        if (null == glob1 || null == glob2) {\n            return false;\n        }\n\n        if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n            int index1 = glob1.indexOf(\"*\");\n            int index2 = glob2.indexOf(\"*\");\n\n            String s11 = glob1.substring(0, index1);\n            String s12 = glob1.substring(index1 + 1, glob1.length());\n\n            String s21 = glob2.substring(0, index2);\n            String s22 = glob2.substring(index2 + 1, glob2.length());\n\n            if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n            if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n            return true;\n        } else if (glob1.contains(\"*\")) {\n            return isMatchGlobPattern(glob1, glob2);\n        } else if (glob2.contains(\"*\")) {\n            return isMatchGlobPattern(glob2, glob1);\n        } else {\n            return glob1.equals(glob2);\n        }\n    }\n\n    /**\n     * Parse Query String into Map. For strings that have only Key, key3 = </ code> is ignored.\n     *\n     * @param keyPrefix In the output of the Map Key plus a unified prefix.\n     * @param query Query String\uff0cFor example: <code>key1=value1&key2=value2</code>\n     * @return When Query String is <code>key1=value1&key2=value2</code>, and prefix is <code>pre.</code>,\n     *         then <code>Map{pre.key1=value1, pre.key=value2}</code> will be returned.\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static Map<String, String> parseQuery(String keyPrefix, String query) {\n        if (query == null)\n            return new HashMap<String, String>();\n        if (keyPrefix == null)\n            keyPrefix = \"\";\n\n        Matcher matcher = QUERY_PATTERN.matcher(query);\n        Map<String, String> routeQuery = new HashMap<String, String>();\n        String key = null;\n        while (matcher.find()) { // Match one by one\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            if (separator == null || separator.length() == 0\n                    || \"&\".equals(separator)) {\n                if (key != null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                key = content;\n            } else if (\"=\".equals(separator)) {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                routeQuery.put(keyPrefix + key, content);\n                key = null;\n            } else {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n            }\n        }\n        /*if (key != null)\n        throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n                + \"\\\", The error in the end char: \" + key);*/\n        return routeQuery;\n    }\n\n    public static Map<String, String> parseQuery(String query) {\n        return parseQuery(\"\", query);\n    }\n\n    /**\n     * Replace the value of the url parameter.\n     */\n    public static String replaceParameter(String query, String key, String value) {\n        if (query == null || query.length() == 0) {\n            return key + \"=\" + value;\n        }\n        if (query.indexOf(key + \"=\") == -1) {\n            return query + \"&\" + key + \"=\" + value;\n        }\n        Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n        if (pattern == null) {\n            pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n        }\n        Matcher matcher = pattern.matcher(query);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static String appendParamToUri(String uri, String name, String value) {\n        if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n        if (uri.indexOf('?') != -1) {\n            uri += \"&\" + name + \"=\" + value;\n        } else {\n            uri += \"?\" + name + \"=\" + value;\n        }\n        return uri;\n    }\n\n    public static String appendParamsToUri(String uri, Map<String, String> params) {\n        StringBuilder buf = new StringBuilder(uri);\n        boolean first = (uri.indexOf('?') < 0);\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n                continue;\n            if (first) {\n                buf.append(\"?\");\n                first = false;\n            } else {\n                buf.append(\"&\");\n            }\n            buf.append(key);\n            buf.append(\"=\");\n            buf.append(value);\n        }\n        return buf.toString();\n    }\n\n    public static boolean matchEndStarPattern(String value, String pattern) {\n        if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n        String perfix = pattern.substring(0, pattern.length() - 1);\n        return value.startsWith(perfix);\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 328,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "private ParseUtils() {\n}",
                "name": "ParseUtils",
                "modifiers": "private",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 41,
                    "column": 5
                }
            },
            {
                "definition": "public static String interpolate(String expression, Map<String, String> params) {\n    if (expression == null || expression.length() == 0) {\n        throw new IllegalArgumentException(\"glob pattern is empty!\");\n    }\n    if (expression.indexOf('$') < 0) {\n        return expression;\n    }\n    Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) { // match one by one\n        String key = matcher.group(1);\n        String value = params == null ? null : params.get(key);\n        if (value == null) {\n            value = \"\";\n        }\n        matcher.appendReplacement(sb, value);\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "name": "interpolate",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "expression"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "params"
                    }
                ],
                "body": "{\n    if (expression == null || expression.length() == 0) {\n        throw new IllegalArgumentException(\"glob pattern is empty!\");\n    }\n    if (expression.indexOf('$') < 0) {\n        return expression;\n    }\n    Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) { // match one by one\n        String key = matcher.group(1);\n        String value = params == null ? null : params.get(key);\n        if (value == null) {\n            value = \"\";\n        }\n        matcher.appendReplacement(sb, value);\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "public static List<String> interpolate(List<String> expressions, Map<String, String> params) {\n    List<String> ret = new ArrayList<String>();\n\n    if (null == expressions || expressions.isEmpty()) {\n        return ret;\n    }\n\n    for (String expr : expressions) {\n        ret.add(interpolate(expr, params));\n    }\n\n    return ret;\n}",
                "name": "interpolate",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<String>",
                        "name": "expressions"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "params"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n\n    if (null == expressions || expressions.isEmpty()) {\n        return ret;\n    }\n\n    for (String expr : expressions) {\n        ret.add(interpolate(expr, params));\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 85,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean isMatchGlobPattern(String pattern, String value) {\n    if (\"*\".equals(pattern))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            && (value == null || value.length() == 0))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            || (value == null || value.length() == 0))\n        return false;\n\n    int i = pattern.lastIndexOf('*');\n    // No asterisk found\n    if (i == -1) {\n        return value.equals(pattern);\n    }\n    // Asterisk at the end\n    else if (i == pattern.length() - 1) {\n        return value.startsWith(pattern.substring(0, i));\n    }\n    // Asterisk at the beginning\n    else if (i == 0) {\n        return value.endsWith(pattern.substring(i + 1));\n    }\n    // Asterisk in the middle of the string\n    else {\n        String prefix = pattern.substring(0, i);\n        String suffix = pattern.substring(i + 1);\n        return value.startsWith(prefix) && value.endsWith(suffix);\n    }\n}",
                "name": "isMatchGlobPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "pattern"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (\"*\".equals(pattern))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            && (value == null || value.length() == 0))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            || (value == null || value.length() == 0))\n        return false;\n\n    int i = pattern.lastIndexOf('*');\n    // No asterisk found\n    if (i == -1) {\n        return value.equals(pattern);\n    }\n    // Asterisk at the end\n    else if (i == pattern.length() - 1) {\n        return value.startsWith(pattern.substring(0, i));\n    }\n    // Asterisk at the beginning\n    else if (i == 0) {\n        return value.endsWith(pattern.substring(i + 1));\n    }\n    // Asterisk in the middle of the string\n    else {\n        String prefix = pattern.substring(0, i);\n        String suffix = pattern.substring(i + 1);\n        return value.startsWith(prefix) && value.endsWith(suffix);\n    }\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 120,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean isMatchGlobPatternsNeedInterpolate(\n    Collection<String> patternsNeedInterpolate,\n    Map<String, String> interpolateParams, String value) {\n    if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n        for (String patternNeedItp : patternsNeedInterpolate) {\n            if (StringUtils.isEmpty(patternNeedItp)) {\n                continue;\n            }\n            // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n            // FIXME ERROR!! Should be confirmed with Liang Fei!!\n            String pattern = interpolate(patternNeedItp, interpolateParams);\n            if (isMatchGlobPattern(pattern, value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
                "name": "isMatchGlobPatternsNeedInterpolate",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "patternsNeedInterpolate"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "interpolateParams"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n        for (String patternNeedItp : patternsNeedInterpolate) {\n            if (StringUtils.isEmpty(patternNeedItp)) {\n                continue;\n            }\n            // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n            // FIXME ERROR!! Should be confirmed with Liang Fei!!\n            String pattern = interpolate(patternNeedItp, interpolateParams);\n            if (isMatchGlobPattern(pattern, value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "public static Set<String> filterByGlobPattern(String pattern, Collection<String> values) {\n    Set<String> ret = new HashSet<String>();\n    if (pattern == null || values == null) {\n        return ret;\n    }\n\n    for (String v : values) {\n        if (isMatchGlobPattern(pattern, v)) {\n            ret.add(v);\n        }\n    }\n    return ret;\n}",
                "name": "filterByGlobPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "pattern"
                    },
                    {
                        "type": "Collection<String>",
                        "name": "values"
                    }
                ],
                "body": "{\n    Set<String> ret = new HashSet<String>();\n    if (pattern == null || values == null) {\n        return ret;\n    }\n\n    for (String v : values) {\n        if (isMatchGlobPattern(pattern, v)) {\n            ret.add(v);\n        }\n    }\n    return ret;\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 163,
                    "column": 5
                }
            },
            {
                "definition": "public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values) {\n    Set<String> ret = new HashSet<String>();\n    if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n        return ret;\n    }\n\n    for (String p : patterns) {\n        for (String v : values) {\n            if (isMatchGlobPattern(p, v)) {\n                ret.add(v);\n            }\n        }\n    }\n    return ret;\n}",
                "name": "filterByGlobPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "patterns"
                    },
                    {
                        "type": "Collection<String>",
                        "name": "values"
                    }
                ],
                "body": "{\n    Set<String> ret = new HashSet<String>();\n    if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n        return ret;\n    }\n\n    for (String p : patterns) {\n        for (String v : values) {\n            if (isMatchGlobPattern(p, v)) {\n                ret.add(v);\n            }\n        }\n    }\n    return ret;\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 182,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean hasIntersection(String glob1, String glob2) {\n    if (null == glob1 || null == glob2) {\n        return false;\n    }\n\n    if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n        int index1 = glob1.indexOf(\"*\");\n        int index2 = glob2.indexOf(\"*\");\n\n        String s11 = glob1.substring(0, index1);\n        String s12 = glob1.substring(index1 + 1, glob1.length());\n\n        String s21 = glob2.substring(0, index2);\n        String s22 = glob2.substring(index2 + 1, glob2.length());\n\n        if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n        if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n        return true;\n    } else if (glob1.contains(\"*\")) {\n        return isMatchGlobPattern(glob1, glob2);\n    } else if (glob2.contains(\"*\")) {\n        return isMatchGlobPattern(glob2, glob1);\n    } else {\n        return glob1.equals(glob2);\n    }\n}",
                "name": "hasIntersection",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "glob1"
                    },
                    {
                        "type": "String",
                        "name": "glob2"
                    }
                ],
                "body": "{\n    if (null == glob1 || null == glob2) {\n        return false;\n    }\n\n    if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n        int index1 = glob1.indexOf(\"*\");\n        int index2 = glob2.indexOf(\"*\");\n\n        String s11 = glob1.substring(0, index1);\n        String s12 = glob1.substring(index1 + 1, glob1.length());\n\n        String s21 = glob2.substring(0, index2);\n        String s22 = glob2.substring(index2 + 1, glob2.length());\n\n        if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n        if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n        return true;\n    } else if (glob1.contains(\"*\")) {\n        return isMatchGlobPattern(glob1, glob2);\n    } else if (glob2.contains(\"*\")) {\n        return isMatchGlobPattern(glob2, glob1);\n    } else {\n        return glob1.equals(glob2);\n    }\n}",
                "start_point": {
                    "row": 187,
                    "column": 4
                },
                "end_point": {
                    "row": 212,
                    "column": 5
                }
            },
            {
                "definition": "public static Map<String, String> parseQuery(String keyPrefix, String query) {\n    if (query == null)\n        return new HashMap<String, String>();\n    if (keyPrefix == null)\n        keyPrefix = \"\";\n\n    Matcher matcher = QUERY_PATTERN.matcher(query);\n    Map<String, String> routeQuery = new HashMap<String, String>();\n    String key = null;\n    while (matcher.find()) { // Match one by one\n        String separator = matcher.group(1);\n        String content = matcher.group(2);\n        if (separator == null || separator.length() == 0\n                || \"&\".equals(separator)) {\n            if (key != null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            key = content;\n        } else if (\"=\".equals(separator)) {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            routeQuery.put(keyPrefix + key, content);\n            key = null;\n        } else {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n        }\n    }\n    /*if (key != null)\n    throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n            + \"\\\", The error in the end char: \" + key);*/\n    return routeQuery;\n}",
                "name": "parseQuery",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "keyPrefix"
                    },
                    {
                        "type": "String",
                        "name": "query"
                    }
                ],
                "body": "{\n    if (query == null)\n        return new HashMap<String, String>();\n    if (keyPrefix == null)\n        keyPrefix = \"\";\n\n    Matcher matcher = QUERY_PATTERN.matcher(query);\n    Map<String, String> routeQuery = new HashMap<String, String>();\n    String key = null;\n    while (matcher.find()) { // Match one by one\n        String separator = matcher.group(1);\n        String content = matcher.group(2);\n        if (separator == null || separator.length() == 0\n                || \"&\".equals(separator)) {\n            if (key != null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            key = content;\n        } else if (\"=\".equals(separator)) {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            routeQuery.put(keyPrefix + key, content);\n            key = null;\n        } else {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n        }\n    }\n    /*if (key != null)\n    throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n            + \"\\\", The error in the end char: \" + key);*/\n    return routeQuery;\n}",
                "start_point": {
                    "row": 223,
                    "column": 4
                },
                "end_point": {
                    "row": 263,
                    "column": 5
                }
            },
            {
                "definition": "public static Map<String, String> parseQuery(String query) {\n    return parseQuery(\"\", query);\n}",
                "name": "parseQuery",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "query"
                    }
                ],
                "body": "{\n    return parseQuery(\"\", query);\n}",
                "start_point": {
                    "row": 265,
                    "column": 4
                },
                "end_point": {
                    "row": 267,
                    "column": 5
                }
            },
            {
                "definition": "public static String replaceParameter(String query, String key, String value) {\n    if (query == null || query.length() == 0) {\n        return key + \"=\" + value;\n    }\n    if (query.indexOf(key + \"=\") == -1) {\n        return query + \"&\" + key + \"=\" + value;\n    }\n    Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n    if (pattern == null) {\n        pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n    }\n    Matcher matcher = pattern.matcher(query);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) {\n        matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "name": "replaceParameter",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "query"
                    },
                    {
                        "type": "String",
                        "name": "key"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (query == null || query.length() == 0) {\n        return key + \"=\" + value;\n    }\n    if (query.indexOf(key + \"=\") == -1) {\n        return query + \"&\" + key + \"=\" + value;\n    }\n    Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n    if (pattern == null) {\n        pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n    }\n    Matcher matcher = pattern.matcher(query);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) {\n        matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "start_point": {
                    "row": 272,
                    "column": 4
                },
                "end_point": {
                    "row": 290,
                    "column": 5
                }
            },
            {
                "definition": "public static String appendParamToUri(String uri, String name, String value) {\n    if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n    if (uri.indexOf('?') != -1) {\n        uri += \"&\" + name + \"=\" + value;\n    } else {\n        uri += \"?\" + name + \"=\" + value;\n    }\n    return uri;\n}",
                "name": "appendParamToUri",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "uri"
                    },
                    {
                        "type": "String",
                        "name": "name"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n    if (uri.indexOf('?') != -1) {\n        uri += \"&\" + name + \"=\" + value;\n    } else {\n        uri += \"?\" + name + \"=\" + value;\n    }\n    return uri;\n}",
                "start_point": {
                    "row": 292,
                    "column": 4
                },
                "end_point": {
                    "row": 300,
                    "column": 5
                }
            },
            {
                "definition": "public static String appendParamsToUri(String uri, Map<String, String> params) {\n    StringBuilder buf = new StringBuilder(uri);\n    boolean first = (uri.indexOf('?') < 0);\n    for (Map.Entry<String, String> entry : params.entrySet()) {\n        String key = entry.getKey();\n        String value = entry.getValue();\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n            continue;\n        if (first) {\n            buf.append(\"?\");\n            first = false;\n        } else {\n            buf.append(\"&\");\n        }\n        buf.append(key);\n        buf.append(\"=\");\n        buf.append(value);\n    }\n    return buf.toString();\n}",
                "name": "appendParamsToUri",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "uri"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "params"
                    }
                ],
                "body": "{\n    StringBuilder buf = new StringBuilder(uri);\n    boolean first = (uri.indexOf('?') < 0);\n    for (Map.Entry<String, String> entry : params.entrySet()) {\n        String key = entry.getKey();\n        String value = entry.getValue();\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n            continue;\n        if (first) {\n            buf.append(\"?\");\n            first = false;\n        } else {\n            buf.append(\"&\");\n        }\n        buf.append(key);\n        buf.append(\"=\");\n        buf.append(value);\n    }\n    return buf.toString();\n}",
                "start_point": {
                    "row": 302,
                    "column": 4
                },
                "end_point": {
                    "row": 321,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean matchEndStarPattern(String value, String pattern) {\n    if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n    String perfix = pattern.substring(0, pattern.length() - 1);\n    return value.startsWith(perfix);\n}",
                "name": "matchEndStarPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "value"
                    },
                    {
                        "type": "String",
                        "name": "pattern"
                    }
                ],
                "body": "{\n    if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n    String perfix = pattern.substring(0, pattern.length() - 1);\n    return value.startsWith(perfix);\n}",
                "start_point": {
                    "row": 323,
                    "column": 4
                },
                "end_point": {
                    "row": 327,
                    "column": 5
                }
            }
        ]
    }
]