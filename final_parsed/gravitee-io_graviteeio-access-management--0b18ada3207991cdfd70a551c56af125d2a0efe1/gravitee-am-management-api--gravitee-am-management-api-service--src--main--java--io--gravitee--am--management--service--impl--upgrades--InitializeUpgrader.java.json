[
    {
        "repo_name": "gravitee-io_graviteeio-access-management",
        "commit": "0b18ada3207991cdfd70a551c56af125d2a0efe1",
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/InitializeUpgrader.java",
        "definition": "@Component\npublic class InitializeUpgrader implements Upgrader, Ordered {\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        domainService.findById(ADMIN_DOMAIN)\n                .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n                .flatMap(adminDomain -> {\n                    logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                    if (!adminDomain.isMaster()) {\n                        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                        return domainService.setMasterDomain(adminDomain.getId(), true);\n                    }\n                    return Single.just(adminDomain);\n                })\n                .flatMap(adminDomain -> {\n                    // New since AM v2\n                    // Move admin client identity providers to admin domain and remove the admin client\n                    return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                            .map(client -> Optional.of(client))\n                            .defaultIfEmpty(Optional.empty())\n                            .flatMapSingle(optionalClient -> {\n                                if (optionalClient.isPresent()) {\n                                    Client adminClient = optionalClient.get();\n                                    logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                    UpdateDomain updateDomain = new UpdateDomain();\n                                    updateDomain.setName(adminDomain.getName());\n                                    updateDomain.setPath(adminDomain.getPath());\n                                    updateDomain.setDescription(adminDomain.getDescription());\n                                    updateDomain.setEnabled(adminDomain.isEnabled());\n                                    updateDomain.setIdentities(adminClient.getIdentities());\n                                    updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                    return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                            .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                                }\n                                return Single.just(adminDomain);\n                            });\n\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof DomainNotFoundException) {\n                        return domainNotFoundFallback();\n                    }\n                    return Single.error(new TechnicalManagementException(ex));\n                })\n                .subscribe();\n\n        return true;\n    }\n\n    private Single<Domain> domainNotFoundFallback() {\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        return domainService.create(adminDomain)\n                .flatMap(createdDomain -> {\n                    // Create an inline identity provider\n                    logger.info(\"Create an user-inline provider\");\n                    NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                    adminIdentityProvider.setType(\"inline-am-idp\");\n                    adminIdentityProvider.setName(\"Inline users\");\n                    adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                    return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                            .flatMap(createdIdentityProvider -> {\n                                logger.info(\"Associate user-inline provider to previously created domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(createdDomain.getName());\n                                updateDomain.setPath(createdDomain.getPath());\n                                updateDomain.setDescription(createdDomain.getDescription());\n                                updateDomain.setEnabled(createdDomain.isEnabled());\n                                updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                                updateDomain.setEnabled(true);\n                                return domainService.update(createdDomain.getId(), updateDomain);\n                            });\n                })\n                .flatMap(createdDomain -> {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(createdDomain.getId(), true);\n                });\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "InitializeUpgrader",
        "name": "InitializeUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        domainService.findById(ADMIN_DOMAIN)\n                .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n                .flatMap(adminDomain -> {\n                    logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                    if (!adminDomain.isMaster()) {\n                        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                        return domainService.setMasterDomain(adminDomain.getId(), true);\n                    }\n                    return Single.just(adminDomain);\n                })\n                .flatMap(adminDomain -> {\n                    // New since AM v2\n                    // Move admin client identity providers to admin domain and remove the admin client\n                    return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                            .map(client -> Optional.of(client))\n                            .defaultIfEmpty(Optional.empty())\n                            .flatMapSingle(optionalClient -> {\n                                if (optionalClient.isPresent()) {\n                                    Client adminClient = optionalClient.get();\n                                    logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                    UpdateDomain updateDomain = new UpdateDomain();\n                                    updateDomain.setName(adminDomain.getName());\n                                    updateDomain.setPath(adminDomain.getPath());\n                                    updateDomain.setDescription(adminDomain.getDescription());\n                                    updateDomain.setEnabled(adminDomain.isEnabled());\n                                    updateDomain.setIdentities(adminClient.getIdentities());\n                                    updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                    return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                            .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                                }\n                                return Single.just(adminDomain);\n                            });\n\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof DomainNotFoundException) {\n                        return domainNotFoundFallback();\n                    }\n                    return Single.error(new TechnicalManagementException(ex));\n                })\n                .subscribe();\n\n        return true;\n    }\n\n    private Single<Domain> domainNotFoundFallback() {\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        return domainService.create(adminDomain)\n                .flatMap(createdDomain -> {\n                    // Create an inline identity provider\n                    logger.info(\"Create an user-inline provider\");\n                    NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                    adminIdentityProvider.setType(\"inline-am-idp\");\n                    adminIdentityProvider.setName(\"Inline users\");\n                    adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                    return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                            .flatMap(createdIdentityProvider -> {\n                                logger.info(\"Associate user-inline provider to previously created domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(createdDomain.getName());\n                                updateDomain.setPath(createdDomain.getPath());\n                                updateDomain.setDescription(createdDomain.getDescription());\n                                updateDomain.setEnabled(createdDomain.isEnabled());\n                                updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                                updateDomain.setEnabled(true);\n                                return domainService.update(createdDomain.getId(), updateDomain);\n                            });\n                })\n                .flatMap(createdDomain -> {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(createdDomain.getId(), true);\n                });\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "start_point": {
            "row": 42,
            "column": 0
        },
        "end_point": {
            "row": 147,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    domainService.findById(ADMIN_DOMAIN)\n            .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n            .flatMap(adminDomain -> {\n                logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                if (!adminDomain.isMaster()) {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(adminDomain.getId(), true);\n                }\n                return Single.just(adminDomain);\n            })\n            .flatMap(adminDomain -> {\n                // New since AM v2\n                // Move admin client identity providers to admin domain and remove the admin client\n                return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                        .map(client -> Optional.of(client))\n                        .defaultIfEmpty(Optional.empty())\n                        .flatMapSingle(optionalClient -> {\n                            if (optionalClient.isPresent()) {\n                                Client adminClient = optionalClient.get();\n                                logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(adminDomain.getName());\n                                updateDomain.setPath(adminDomain.getPath());\n                                updateDomain.setDescription(adminDomain.getDescription());\n                                updateDomain.setEnabled(adminDomain.isEnabled());\n                                updateDomain.setIdentities(adminClient.getIdentities());\n                                updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                        .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                            }\n                            return Single.just(adminDomain);\n                        });\n\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof DomainNotFoundException) {\n                    return domainNotFoundFallback();\n                }\n                return Single.error(new TechnicalManagementException(ex));\n            })\n            .subscribe();\n\n    return true;\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    domainService.findById(ADMIN_DOMAIN)\n            .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n            .flatMap(adminDomain -> {\n                logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                if (!adminDomain.isMaster()) {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(adminDomain.getId(), true);\n                }\n                return Single.just(adminDomain);\n            })\n            .flatMap(adminDomain -> {\n                // New since AM v2\n                // Move admin client identity providers to admin domain and remove the admin client\n                return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                        .map(client -> Optional.of(client))\n                        .defaultIfEmpty(Optional.empty())\n                        .flatMapSingle(optionalClient -> {\n                            if (optionalClient.isPresent()) {\n                                Client adminClient = optionalClient.get();\n                                logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(adminDomain.getName());\n                                updateDomain.setPath(adminDomain.getPath());\n                                updateDomain.setDescription(adminDomain.getDescription());\n                                updateDomain.setEnabled(adminDomain.isEnabled());\n                                updateDomain.setIdentities(adminClient.getIdentities());\n                                updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                        .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                            }\n                            return Single.just(adminDomain);\n                        });\n\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof DomainNotFoundException) {\n                    return domainNotFoundFallback();\n                }\n                return Single.error(new TechnicalManagementException(ex));\n            })\n            .subscribe();\n\n    return true;\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 108,
                    "column": 5
                }
            },
            {
                "definition": "private Single<Domain> domainNotFoundFallback() {\n    // Create a new admin domain\n    logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n    NewDomain adminDomain = new NewDomain();\n    adminDomain.setName(\"admin\");\n    adminDomain.setDescription(\"AM Admin domain\");\n    return domainService.create(adminDomain)\n            .flatMap(createdDomain -> {\n                // Create an inline identity provider\n                logger.info(\"Create an user-inline provider\");\n                NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                adminIdentityProvider.setType(\"inline-am-idp\");\n                adminIdentityProvider.setName(\"Inline users\");\n                adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                        .flatMap(createdIdentityProvider -> {\n                            logger.info(\"Associate user-inline provider to previously created domain\");\n                            UpdateDomain updateDomain = new UpdateDomain();\n                            updateDomain.setName(createdDomain.getName());\n                            updateDomain.setPath(createdDomain.getPath());\n                            updateDomain.setDescription(createdDomain.getDescription());\n                            updateDomain.setEnabled(createdDomain.isEnabled());\n                            updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                            updateDomain.setEnabled(true);\n                            return domainService.update(createdDomain.getId(), updateDomain);\n                        });\n            })\n            .flatMap(createdDomain -> {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                return domainService.setMasterDomain(createdDomain.getId(), true);\n            });\n}",
                "name": "domainNotFoundFallback",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // Create a new admin domain\n    logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n    NewDomain adminDomain = new NewDomain();\n    adminDomain.setName(\"admin\");\n    adminDomain.setDescription(\"AM Admin domain\");\n    return domainService.create(adminDomain)\n            .flatMap(createdDomain -> {\n                // Create an inline identity provider\n                logger.info(\"Create an user-inline provider\");\n                NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                adminIdentityProvider.setType(\"inline-am-idp\");\n                adminIdentityProvider.setName(\"Inline users\");\n                adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                        .flatMap(createdIdentityProvider -> {\n                            logger.info(\"Associate user-inline provider to previously created domain\");\n                            UpdateDomain updateDomain = new UpdateDomain();\n                            updateDomain.setName(createdDomain.getName());\n                            updateDomain.setPath(createdDomain.getPath());\n                            updateDomain.setDescription(createdDomain.getDescription());\n                            updateDomain.setEnabled(createdDomain.isEnabled());\n                            updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                            updateDomain.setEnabled(true);\n                            return domainService.update(createdDomain.getId(), updateDomain);\n                        });\n            })\n            .flatMap(createdDomain -> {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                return domainService.setMasterDomain(createdDomain.getId(), true);\n            });\n}",
                "start_point": {
                    "row": 110,
                    "column": 4
                },
                "end_point": {
                    "row": 141,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "start_point": {
                    "row": 143,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            }
        ]
    }
]