[
    {
        "repo_name": "HotelsDotCom_data-highway",
        "commit": "7f175375b3c193309094dd8308b77af61d40e57e",
        "rev_path": "monitoring/kafka-offset-metrics/src/main/java/com/hotels/road/kafka/offset/metrics/KafkaOffsetMetrics.java",
        "definition": "@Component\n@RequiredArgsConstructor\n@Slf4j\nclass KafkaOffsetMetrics {\n  private final AdminClient adminClient;\n  private final ScheduledReporter reporter;\n\n  @Scheduled(initialDelayString = \"${metricRate:60000}\", fixedRateString = \"${metricRate:60000}\")\n  void sendOffsets() {\n    log.info(\"Sending offsets\");\n    // We're calling listAllGroupsFlattened as opposed to listAllConsumerGroupsFlattened because we're not\n    // consuming data with the KafkaConsumer in hive-agent (it doesn't subscribe/poll), so when it commits the\n    // protocolType is null when it would otherwise be 'consumer'.\n    @SuppressWarnings(\"rawtypes\")\n    SortedMap<String, Gauge> gauges = asJavaCollection(adminClient.listAllGroupsFlattened())\n        .stream()\n        .map(GroupOverview::groupId)\n        .flatMap(groupId -> {\n          log.info(\"Found groupId: {}\", groupId);\n          return mapAsJavaMap(adminClient.listGroupOffsets(groupId)).entrySet().stream().map(\n              entry -> createMetric(groupId, entry));\n        })\n        .collect(toMap(Entry::getKey, Entry::getValue, (a, b) -> a, () -> new TreeMap<>()));\n\n    reporter.report(gauges, emptySortedMap(), emptySortedMap(), emptySortedMap(), emptySortedMap());\n    log.info(\"Done\");\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  private Entry<String, Gauge> createMetric(String groupId, Entry<TopicPartition, Object> entry) {\n    return Maps.immutableEntry(metricName(groupId, entry.getKey()), (Gauge) () -> entry.getValue());\n  }\n\n  private String metricName(String groupId, TopicPartition topicPartition) {\n    return MetricRegistry.name(\"group\", clean(groupId), \"topic\", clean(topicPartition.topic()), \"partition\",\n        Integer.toString(topicPartition.partition()), \"offset\");\n  }\n\n  private String clean(String name) {\n    return name.replaceAll(\"\\\\.\", \"_\");\n  }\n\n}",
        "package": "package com.hotels.road.kafka.offset.metrics;",
        "tree_path": "KafkaOffsetMetrics",
        "name": "KafkaOffsetMetrics",
        "modifiers": "@Component\n@RequiredArgsConstructor\n@Slf4j",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n  private final AdminClient adminClient;\n  private final ScheduledReporter reporter;\n\n  @Scheduled(initialDelayString = \"${metricRate:60000}\", fixedRateString = \"${metricRate:60000}\")\n  void sendOffsets() {\n    log.info(\"Sending offsets\");\n    // We're calling listAllGroupsFlattened as opposed to listAllConsumerGroupsFlattened because we're not\n    // consuming data with the KafkaConsumer in hive-agent (it doesn't subscribe/poll), so when it commits the\n    // protocolType is null when it would otherwise be 'consumer'.\n    @SuppressWarnings(\"rawtypes\")\n    SortedMap<String, Gauge> gauges = asJavaCollection(adminClient.listAllGroupsFlattened())\n        .stream()\n        .map(GroupOverview::groupId)\n        .flatMap(groupId -> {\n          log.info(\"Found groupId: {}\", groupId);\n          return mapAsJavaMap(adminClient.listGroupOffsets(groupId)).entrySet().stream().map(\n              entry -> createMetric(groupId, entry));\n        })\n        .collect(toMap(Entry::getKey, Entry::getValue, (a, b) -> a, () -> new TreeMap<>()));\n\n    reporter.report(gauges, emptySortedMap(), emptySortedMap(), emptySortedMap(), emptySortedMap());\n    log.info(\"Done\");\n  }\n\n  @SuppressWarnings(\"rawtypes\")\n  private Entry<String, Gauge> createMetric(String groupId, Entry<TopicPartition, Object> entry) {\n    return Maps.immutableEntry(metricName(groupId, entry.getKey()), (Gauge) () -> entry.getValue());\n  }\n\n  private String metricName(String groupId, TopicPartition topicPartition) {\n    return MetricRegistry.name(\"group\", clean(groupId), \"topic\", clean(topicPartition.topic()), \"partition\",\n        Integer.toString(topicPartition.partition()), \"offset\");\n  }\n\n  private String clean(String name) {\n    return name.replaceAll(\"\\\\.\", \"_\");\n  }\n\n}",
        "start_point": {
            "row": 41,
            "column": 0
        },
        "end_point": {
            "row": 83,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Scheduled(initialDelayString = \"${metricRate:60000}\", fixedRateString = \"${metricRate:60000}\")\nvoid sendOffsets() {\n  log.info(\"Sending offsets\");\n  // We're calling listAllGroupsFlattened as opposed to listAllConsumerGroupsFlattened because we're not\n  // consuming data with the KafkaConsumer in hive-agent (it doesn't subscribe/poll), so when it commits the\n  // protocolType is null when it would otherwise be 'consumer'.\n  @SuppressWarnings(\"rawtypes\")\n  SortedMap<String, Gauge> gauges = asJavaCollection(adminClient.listAllGroupsFlattened())\n      .stream()\n      .map(GroupOverview::groupId)\n      .flatMap(groupId -> {\n        log.info(\"Found groupId: {}\", groupId);\n        return mapAsJavaMap(adminClient.listGroupOffsets(groupId)).entrySet().stream().map(\n            entry -> createMetric(groupId, entry));\n      })\n      .collect(toMap(Entry::getKey, Entry::getValue, (a, b) -> a, () -> new TreeMap<>()));\n\n  reporter.report(gauges, emptySortedMap(), emptySortedMap(), emptySortedMap(), emptySortedMap());\n  log.info(\"Done\");\n}",
                "name": "sendOffsets",
                "modifiers": "@Scheduled(initialDelayString = \"${metricRate:60000}\", fixedRateString = \"${metricRate:60000}\")",
                "return_type": null,
                "parameters": [],
                "body": "{\n  log.info(\"Sending offsets\");\n  // We're calling listAllGroupsFlattened as opposed to listAllConsumerGroupsFlattened because we're not\n  // consuming data with the KafkaConsumer in hive-agent (it doesn't subscribe/poll), so when it commits the\n  // protocolType is null when it would otherwise be 'consumer'.\n  @SuppressWarnings(\"rawtypes\")\n  SortedMap<String, Gauge> gauges = asJavaCollection(adminClient.listAllGroupsFlattened())\n      .stream()\n      .map(GroupOverview::groupId)\n      .flatMap(groupId -> {\n        log.info(\"Found groupId: {}\", groupId);\n        return mapAsJavaMap(adminClient.listGroupOffsets(groupId)).entrySet().stream().map(\n            entry -> createMetric(groupId, entry));\n      })\n      .collect(toMap(Entry::getKey, Entry::getValue, (a, b) -> a, () -> new TreeMap<>()));\n\n  reporter.report(gauges, emptySortedMap(), emptySortedMap(), emptySortedMap(), emptySortedMap());\n  log.info(\"Done\");\n}",
                "start_point": {
                    "row": 48,
                    "column": 2
                },
                "end_point": {
                    "row": 67,
                    "column": 3
                }
            },
            {
                "definition": "@SuppressWarnings(\"rawtypes\")\nprivate Entry<String, Gauge> createMetric(String groupId, Entry<TopicPartition, Object> entry) {\n  return Maps.immutableEntry(metricName(groupId, entry.getKey()), (Gauge) () -> entry.getValue());\n}",
                "name": "createMetric",
                "modifiers": "@SuppressWarnings(\"rawtypes\")\n  private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "groupId"
                    },
                    {
                        "type": "Entry<TopicPartition, Object>",
                        "name": "entry"
                    }
                ],
                "body": "{\n  return Maps.immutableEntry(metricName(groupId, entry.getKey()), (Gauge) () -> entry.getValue());\n}",
                "start_point": {
                    "row": 69,
                    "column": 2
                },
                "end_point": {
                    "row": 72,
                    "column": 3
                }
            },
            {
                "definition": "private String metricName(String groupId, TopicPartition topicPartition) {\n  return MetricRegistry.name(\"group\", clean(groupId), \"topic\", clean(topicPartition.topic()), \"partition\",\n      Integer.toString(topicPartition.partition()), \"offset\");\n}",
                "name": "metricName",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "groupId"
                    },
                    {
                        "type": "TopicPartition",
                        "name": "topicPartition"
                    }
                ],
                "body": "{\n  return MetricRegistry.name(\"group\", clean(groupId), \"topic\", clean(topicPartition.topic()), \"partition\",\n      Integer.toString(topicPartition.partition()), \"offset\");\n}",
                "start_point": {
                    "row": 74,
                    "column": 2
                },
                "end_point": {
                    "row": 77,
                    "column": 3
                }
            },
            {
                "definition": "private String clean(String name) {\n  return name.replaceAll(\"\\\\.\", \"_\");\n}",
                "name": "clean",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n  return name.replaceAll(\"\\\\.\", \"_\");\n}",
                "start_point": {
                    "row": 79,
                    "column": 2
                },
                "end_point": {
                    "row": 81,
                    "column": 3
                }
            }
        ]
    }
]