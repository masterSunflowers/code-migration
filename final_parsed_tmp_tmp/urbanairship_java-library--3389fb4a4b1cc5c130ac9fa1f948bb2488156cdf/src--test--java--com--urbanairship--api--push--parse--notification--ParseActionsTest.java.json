[
    {
        "repo_name": "urbanairship_java-library",
        "commit": "3389fb4a4b1cc5c130ac9fa1f948bb2488156cdf",
        "rev_path": "src/test/java/com/urbanairship/api/push/parse/notification/ParseActionsTest.java",
        "definition": "public class ParseActionsTest {\n\n    private ObjectMapper mapper;\n\n    @Before\n    public void setUp() {\n        mapper = PushObjectMapper.getInstance();\n    }\n\n    @Test\n    public void testAddTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    private <A extends Action> Optional<A> getAction(Actions actions, ActionType type, Class<A> klass) {\n        for (Action a : actions.allActions()) {\n            if (a.getActionType() == type && a.getClass() == klass) {\n                return Optional.of((A) a);\n            }\n        }\n\n        return Optional.absent();\n\n    }\n\n    @Test\n    public void testRemoveTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    @Test\n    public void testAddTag() throws Exception {\n        String tag = \"foo\";\n\n        AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testRemoveTag() throws Exception {\n        String tag = \"foo\";\n\n        RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testOpenExternal() throws Exception {\n        URI url = URI.create(\"http://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testOpenExternalHTTPS() throws IOException {\n        URI url = URI.create(\"https://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testBadOpenExternalWrongScheme() throws IOException {\n        URI u = URI.create(\"ftp://foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            String content = mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build());\n            mapper.readValue(content, Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalAbsolutePathNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"/foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testOpenLandingPage() throws Exception {\n\n        {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            assertNotNull(\"Could not round-trip open landing action.\", actions);\n            Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n            assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n            LandingPageContent actual = optOpen.get().getValue();\n            assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n            assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n            assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n        }\n\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            fail(\"Invalid Base64 content should have raised an exception.\");\n        } catch (APIParsingException ex) {\n            assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n        }\n    }\n\n    private void openLandingPageContentType(String contentTypeHeader, boolean good) throws Exception {\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"content\")\n                    .setContentType(contentTypeHeader)\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            if (!good) {\n                fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n            }\n        } catch (APIParsingException ex) {\n            if (good) {\n                fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n            } else {\n                assertNotNull(ex);\n            }\n        }\n    }\n\n    @Test\n    public void testOpenLandingPageContentTypeValidation() throws Exception {\n        ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n                \"text/html\",\n                \"Text/HTML\",\n                \"Text/HTML; charset=utf-8\",\n                \"Text/HTML ; charset=iso8859-1; something=else\",\n                \"application/x-rtf\",\n                \"image/jpeg\"\n        );\n\n        ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n                \"text/ html\",\n                \"Text/H TML\",\n                \"Text/XHTML; charset=utf-8\",\n                \"Text/FooHTML; charset=iso8859-1;;;;\",\n                \"application/x-treme\",\n                \"imagine/jpeg\",\n                \"undefined\",\n                \"halp\",\n                \"\"\n        );\n\n        for (String contentTypeHeader : validContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, true);\n        }\n\n        for (String contentTypeHeader : invalidContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, false);\n        }\n    }\n\n    private void openLandingPageBody(String body, LandingPageContent.Encoding encoding) throws Exception {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(body)\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(encoding))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n    }\n\n    @Test\n    public void testSmallBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = BaseEncoding.base64().encode(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testSmallTextBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = new String(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testAppDefined() throws Exception {\n        String appDefined = \"{\\n\" +\n                \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n                \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n                \"            }\\n\";\n        ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n        AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip app_defined action\", actions);\n        Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n        assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n        ObjectNode result = optAppDefined.get().getValue();\n\n        Iterator<String> fieldNames = expected.getFieldNames();\n        while (fieldNames.hasNext()) {\n            String fieldName = fieldNames.next();\n            assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                    result.path(fieldName).isMissingNode());\n            assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                    expected.path(fieldName), result.path(fieldName));\n        }\n\n        Iterator<String> resultFields = result.getFieldNames();\n        while (resultFields.hasNext()) {\n            String fieldName = resultFields.next();\n            assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                    expected.path(fieldName).isMissingNode());\n        }\n\n    }\n\n    @Test\n    public void testDeepLinkActionSerialization() throws Exception {\n        DeepLinkAction a = new DeepLinkAction(\"test\");\n        assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n    }\n\n    @Test\n    public void testShare() throws Exception {\n        String shareText = \"This is a share.\";\n\n        ShareAction shareAction = new ShareAction(shareText);\n\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip share action\", actions);\n        Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n        assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n        String shareData = optShareAction.get().getValue();\n        assertEquals(shareText, shareData);\n    }\n\n    @Test\n    public void testNonemptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n        mapper.readValue(json, Actions.class);\n    }\n\n    @Test\n    public void testEmptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n        try {\n            mapper.readValue(json, Actions.class);\n        } catch (APIParsingException exc) {\n            assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n        }\n    }\n}",
        "package": "package com.urbanairship.api.push.parse.notification;",
        "tree_path": "ParseActionsTest",
        "name": "ParseActionsTest",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private ObjectMapper mapper;\n\n    @Before\n    public void setUp() {\n        mapper = PushObjectMapper.getInstance();\n    }\n\n    @Test\n    public void testAddTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    private <A extends Action> Optional<A> getAction(Actions actions, ActionType type, Class<A> klass) {\n        for (Action a : actions.allActions()) {\n            if (a.getActionType() == type && a.getClass() == klass) {\n                return Optional.of((A) a);\n            }\n        }\n\n        return Optional.absent();\n\n    }\n\n    @Test\n    public void testRemoveTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    @Test\n    public void testAddTag() throws Exception {\n        String tag = \"foo\";\n\n        AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testRemoveTag() throws Exception {\n        String tag = \"foo\";\n\n        RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testOpenExternal() throws Exception {\n        URI url = URI.create(\"http://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testOpenExternalHTTPS() throws IOException {\n        URI url = URI.create(\"https://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testBadOpenExternalWrongScheme() throws IOException {\n        URI u = URI.create(\"ftp://foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            String content = mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build());\n            mapper.readValue(content, Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalAbsolutePathNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"/foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testOpenLandingPage() throws Exception {\n\n        {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            assertNotNull(\"Could not round-trip open landing action.\", actions);\n            Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n            assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n            LandingPageContent actual = optOpen.get().getValue();\n            assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n            assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n            assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n        }\n\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            fail(\"Invalid Base64 content should have raised an exception.\");\n        } catch (APIParsingException ex) {\n            assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n        }\n    }\n\n    private void openLandingPageContentType(String contentTypeHeader, boolean good) throws Exception {\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"content\")\n                    .setContentType(contentTypeHeader)\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            if (!good) {\n                fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n            }\n        } catch (APIParsingException ex) {\n            if (good) {\n                fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n            } else {\n                assertNotNull(ex);\n            }\n        }\n    }\n\n    @Test\n    public void testOpenLandingPageContentTypeValidation() throws Exception {\n        ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n                \"text/html\",\n                \"Text/HTML\",\n                \"Text/HTML; charset=utf-8\",\n                \"Text/HTML ; charset=iso8859-1; something=else\",\n                \"application/x-rtf\",\n                \"image/jpeg\"\n        );\n\n        ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n                \"text/ html\",\n                \"Text/H TML\",\n                \"Text/XHTML; charset=utf-8\",\n                \"Text/FooHTML; charset=iso8859-1;;;;\",\n                \"application/x-treme\",\n                \"imagine/jpeg\",\n                \"undefined\",\n                \"halp\",\n                \"\"\n        );\n\n        for (String contentTypeHeader : validContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, true);\n        }\n\n        for (String contentTypeHeader : invalidContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, false);\n        }\n    }\n\n    private void openLandingPageBody(String body, LandingPageContent.Encoding encoding) throws Exception {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(body)\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(encoding))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n    }\n\n    @Test\n    public void testSmallBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = BaseEncoding.base64().encode(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testSmallTextBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = new String(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testAppDefined() throws Exception {\n        String appDefined = \"{\\n\" +\n                \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n                \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n                \"            }\\n\";\n        ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n        AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip app_defined action\", actions);\n        Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n        assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n        ObjectNode result = optAppDefined.get().getValue();\n\n        Iterator<String> fieldNames = expected.getFieldNames();\n        while (fieldNames.hasNext()) {\n            String fieldName = fieldNames.next();\n            assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                    result.path(fieldName).isMissingNode());\n            assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                    expected.path(fieldName), result.path(fieldName));\n        }\n\n        Iterator<String> resultFields = result.getFieldNames();\n        while (resultFields.hasNext()) {\n            String fieldName = resultFields.next();\n            assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                    expected.path(fieldName).isMissingNode());\n        }\n\n    }\n\n    @Test\n    public void testDeepLinkActionSerialization() throws Exception {\n        DeepLinkAction a = new DeepLinkAction(\"test\");\n        assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n    }\n\n    @Test\n    public void testShare() throws Exception {\n        String shareText = \"This is a share.\";\n\n        ShareAction shareAction = new ShareAction(shareText);\n\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip share action\", actions);\n        Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n        assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n        String shareData = optShareAction.get().getValue();\n        assertEquals(shareText, shareData);\n    }\n\n    @Test\n    public void testNonemptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n        mapper.readValue(json, Actions.class);\n    }\n\n    @Test\n    public void testEmptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n        try {\n            mapper.readValue(json, Actions.class);\n        } catch (APIParsingException exc) {\n            assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n        }\n    }\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 437,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Before\npublic void setUp() {\n    mapper = PushObjectMapper.getInstance();\n}",
                "name": "setUp",
                "modifiers": "@Before\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    mapper = PushObjectMapper.getInstance();\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 45,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testAddTags() throws Exception {\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "name": "testAddTags",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "private <A extends Action> Optional<A> getAction(Actions actions, ActionType type, Class<A> klass) {\n    for (Action a : actions.allActions()) {\n        if (a.getActionType() == type && a.getClass() == klass) {\n            return Optional.of((A) a);\n        }\n    }\n\n    return Optional.absent();\n\n}",
                "name": "getAction",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Actions",
                        "name": "actions"
                    },
                    {
                        "type": "ActionType",
                        "name": "type"
                    },
                    {
                        "type": "Class<A>",
                        "name": "klass"
                    }
                ],
                "body": "{\n    for (Action a : actions.allActions()) {\n        if (a.getActionType() == type && a.getClass() == klass) {\n            return Optional.of((A) a);\n        }\n    }\n\n    return Optional.absent();\n\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testRemoveTags() throws Exception {\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "name": "testRemoveTags",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testAddTag() throws Exception {\n    String tag = \"foo\";\n\n    AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "name": "testAddTag",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String tag = \"foo\";\n\n    AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 122,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testRemoveTag() throws Exception {\n    String tag = \"foo\";\n\n    RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "name": "testRemoveTag",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String tag = \"foo\";\n\n    RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "start_point": {
                    "row": 124,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testOpenExternal() throws Exception {\n    URI url = URI.create(\"http://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "name": "testOpenExternal",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI url = URI.create(\"http://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 152,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testOpenExternalHTTPS() throws IOException {\n    URI url = URI.create(\"https://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "name": "testOpenExternalHTTPS",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI url = URI.create(\"https://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "start_point": {
                    "row": 154,
                    "column": 4
                },
                "end_point": {
                    "row": 166,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testBadOpenExternalWrongScheme() throws IOException {\n    URI u = URI.create(\"ftp://foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        String content = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        mapper.readValue(content, Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "name": "testBadOpenExternalWrongScheme",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI u = URI.create(\"ftp://foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        String content = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        mapper.readValue(content, Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 181,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testBadOpenExternalAbsolutePathNoScheme() throws java.io.IOException {\n    URI u = URI.create(\"/foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "name": "testBadOpenExternalAbsolutePathNoScheme",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI u = URI.create(\"/foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 183,
                    "column": 4
                },
                "end_point": {
                    "row": 195,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testBadOpenExternalNoScheme() throws java.io.IOException {\n    URI u = URI.create(\"foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "name": "testBadOpenExternalNoScheme",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI u = URI.create(\"foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 197,
                    "column": 4
                },
                "end_point": {
                    "row": 209,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testOpenLandingPage() throws Exception {\n\n    {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        assertNotNull(\"Could not round-trip open landing action.\", actions);\n        Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n        assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n        LandingPageContent actual = optOpen.get().getValue();\n        assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n        assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n        assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n    }\n\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        fail(\"Invalid Base64 content should have raised an exception.\");\n    } catch (APIParsingException ex) {\n        assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n    }\n}",
                "name": "testOpenLandingPage",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n\n    {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        assertNotNull(\"Could not round-trip open landing action.\", actions);\n        Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n        assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n        LandingPageContent actual = optOpen.get().getValue();\n        assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n        assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n        assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n    }\n\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        fail(\"Invalid Base64 content should have raised an exception.\");\n    } catch (APIParsingException ex) {\n        assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n    }\n}",
                "start_point": {
                    "row": 211,
                    "column": 4
                },
                "end_point": {
                    "row": 247,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "private void openLandingPageContentType(String contentTypeHeader, boolean good) throws Exception {\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"content\")\n                .setContentType(contentTypeHeader)\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        if (!good) {\n            fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n        }\n    } catch (APIParsingException ex) {\n        if (good) {\n            fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n        } else {\n            assertNotNull(ex);\n        }\n    }\n}",
                "name": "openLandingPageContentType",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "contentTypeHeader"
                    },
                    {
                        "type": "boolean",
                        "name": "good"
                    }
                ],
                "body": "{\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"content\")\n                .setContentType(contentTypeHeader)\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        if (!good) {\n            fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n        }\n    } catch (APIParsingException ex) {\n        if (good) {\n            fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n        } else {\n            assertNotNull(ex);\n        }\n    }\n}",
                "start_point": {
                    "row": 249,
                    "column": 4
                },
                "end_point": {
                    "row": 270,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testOpenLandingPageContentTypeValidation() throws Exception {\n    ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n            \"text/html\",\n            \"Text/HTML\",\n            \"Text/HTML; charset=utf-8\",\n            \"Text/HTML ; charset=iso8859-1; something=else\",\n            \"application/x-rtf\",\n            \"image/jpeg\"\n    );\n\n    ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n            \"text/ html\",\n            \"Text/H TML\",\n            \"Text/XHTML; charset=utf-8\",\n            \"Text/FooHTML; charset=iso8859-1;;;;\",\n            \"application/x-treme\",\n            \"imagine/jpeg\",\n            \"undefined\",\n            \"halp\",\n            \"\"\n    );\n\n    for (String contentTypeHeader : validContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, true);\n    }\n\n    for (String contentTypeHeader : invalidContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, false);\n    }\n}",
                "name": "testOpenLandingPageContentTypeValidation",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n            \"text/html\",\n            \"Text/HTML\",\n            \"Text/HTML; charset=utf-8\",\n            \"Text/HTML ; charset=iso8859-1; something=else\",\n            \"application/x-rtf\",\n            \"image/jpeg\"\n    );\n\n    ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n            \"text/ html\",\n            \"Text/H TML\",\n            \"Text/XHTML; charset=utf-8\",\n            \"Text/FooHTML; charset=iso8859-1;;;;\",\n            \"application/x-treme\",\n            \"imagine/jpeg\",\n            \"undefined\",\n            \"halp\",\n            \"\"\n    );\n\n    for (String contentTypeHeader : validContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, true);\n    }\n\n    for (String contentTypeHeader : invalidContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, false);\n    }\n}",
                "start_point": {
                    "row": 272,
                    "column": 4
                },
                "end_point": {
                    "row": 302,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "private void openLandingPageBody(String body, LandingPageContent.Encoding encoding) throws Exception {\n    LandingPageContent expected = LandingPageContent.newBuilder()\n            .setBody(body)\n            .setContentType(\"text/html\")\n            .setEncoding(Optional.of(encoding))\n            .build();\n    OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n    mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(reference)\n            .build()), Actions.class);\n}",
                "name": "openLandingPageBody",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "body"
                    },
                    {
                        "type": "LandingPageContent.Encoding",
                        "name": "encoding"
                    }
                ],
                "body": "{\n    LandingPageContent expected = LandingPageContent.newBuilder()\n            .setBody(body)\n            .setContentType(\"text/html\")\n            .setEncoding(Optional.of(encoding))\n            .build();\n    OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n    mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(reference)\n            .build()), Actions.class);\n}",
                "start_point": {
                    "row": 304,
                    "column": 4
                },
                "end_point": {
                    "row": 314,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testSmallBinaryBody() throws Exception {\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "name": "testSmallBinaryBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "start_point": {
                    "row": 316,
                    "column": 4
                },
                "end_point": {
                    "row": 322,
                    "column": 5
                },
                "method_mode": "Modified"
            },
            {
                "definition": "@Test\npublic void testLargeBinaryBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = BaseEncoding.base64().encode(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "name": "testLargeBinaryBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = BaseEncoding.base64().encode(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "start_point": {
                    "row": 324,
                    "column": 4
                },
                "end_point": {
                    "row": 331,
                    "column": 5
                },
                "method_mode": "Modified"
            },
            {
                "definition": "@Test(expected = APIParsingException.class)\npublic void testTooLargeBinaryBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "name": "testTooLargeBinaryBody",
                "modifiers": "@Test(expected = APIParsingException.class)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = BaseEncoding.base64().encode(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "start_point": {
                    "row": 333,
                    "column": 4
                },
                "end_point": {
                    "row": 339,
                    "column": 5
                },
                "method_mode": "Modified"
            },
            {
                "definition": "@Test\npublic void testSmallTextBody() throws Exception {\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "name": "testSmallTextBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "start_point": {
                    "row": 341,
                    "column": 4
                },
                "end_point": {
                    "row": 347,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testLargeTextBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = new String(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "name": "testLargeTextBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = new String(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "start_point": {
                    "row": 349,
                    "column": 4
                },
                "end_point": {
                    "row": 356,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test(expected = APIParsingException.class)\npublic void testTooLargeTextBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "name": "testTooLargeTextBody",
                "modifiers": "@Test(expected = APIParsingException.class)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "start_point": {
                    "row": 358,
                    "column": 4
                },
                "end_point": {
                    "row": 364,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testAppDefined() throws Exception {\n    String appDefined = \"{\\n\" +\n            \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n            \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n            \"            }\\n\";\n    ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n    AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip app_defined action\", actions);\n    Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n    assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n    ObjectNode result = optAppDefined.get().getValue();\n\n    Iterator<String> fieldNames = expected.getFieldNames();\n    while (fieldNames.hasNext()) {\n        String fieldName = fieldNames.next();\n        assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                result.path(fieldName).isMissingNode());\n        assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                expected.path(fieldName), result.path(fieldName));\n    }\n\n    Iterator<String> resultFields = result.getFieldNames();\n    while (resultFields.hasNext()) {\n        String fieldName = resultFields.next();\n        assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                expected.path(fieldName).isMissingNode());\n    }\n\n}",
                "name": "testAppDefined",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String appDefined = \"{\\n\" +\n            \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n            \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n            \"            }\\n\";\n    ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n    AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip app_defined action\", actions);\n    Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n    assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n    ObjectNode result = optAppDefined.get().getValue();\n\n    Iterator<String> fieldNames = expected.getFieldNames();\n    while (fieldNames.hasNext()) {\n        String fieldName = fieldNames.next();\n        assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                result.path(fieldName).isMissingNode());\n        assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                expected.path(fieldName), result.path(fieldName));\n    }\n\n    Iterator<String> resultFields = result.getFieldNames();\n    while (resultFields.hasNext()) {\n        String fieldName = resultFields.next();\n        assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                expected.path(fieldName).isMissingNode());\n    }\n\n}",
                "start_point": {
                    "row": 366,
                    "column": 4
                },
                "end_point": {
                    "row": 399,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testDeepLinkActionSerialization() throws Exception {\n    DeepLinkAction a = new DeepLinkAction(\"test\");\n    assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n}",
                "name": "testDeepLinkActionSerialization",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    DeepLinkAction a = new DeepLinkAction(\"test\");\n    assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n}",
                "start_point": {
                    "row": 401,
                    "column": 4
                },
                "end_point": {
                    "row": 405,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testShare() throws Exception {\n    String shareText = \"This is a share.\";\n\n    ShareAction shareAction = new ShareAction(shareText);\n\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip share action\", actions);\n    Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n    assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n    String shareData = optShareAction.get().getValue();\n    assertEquals(shareText, shareData);\n}",
                "name": "testShare",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String shareText = \"This is a share.\";\n\n    ShareAction shareAction = new ShareAction(shareText);\n\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip share action\", actions);\n    Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n    assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n    String shareData = optShareAction.get().getValue();\n    assertEquals(shareText, shareData);\n}",
                "start_point": {
                    "row": 407,
                    "column": 4
                },
                "end_point": {
                    "row": 420,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testNonemptyShare() throws Exception {\n    String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n    mapper.readValue(json, Actions.class);\n}",
                "name": "testNonemptyShare",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n    mapper.readValue(json, Actions.class);\n}",
                "start_point": {
                    "row": 422,
                    "column": 4
                },
                "end_point": {
                    "row": 426,
                    "column": 5
                },
                "method_mode": "Unchanged"
            },
            {
                "definition": "@Test\npublic void testEmptyShare() throws Exception {\n    String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n    try {\n        mapper.readValue(json, Actions.class);\n    } catch (APIParsingException exc) {\n        assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n    }\n}",
                "name": "testEmptyShare",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n    try {\n        mapper.readValue(json, Actions.class);\n    } catch (APIParsingException exc) {\n        assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n    }\n}",
                "start_point": {
                    "row": 428,
                    "column": 4
                },
                "end_point": {
                    "row": 436,
                    "column": 5
                },
                "method_mode": "Unchanged"
            }
        ],
        "class_mode": "Modified"
    }
]