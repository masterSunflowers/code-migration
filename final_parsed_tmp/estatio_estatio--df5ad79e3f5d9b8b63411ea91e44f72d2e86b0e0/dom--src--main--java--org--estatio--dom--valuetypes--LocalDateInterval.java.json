[
    {
        "rev_path": "dom/src/main/java/org/estatio/dom/valuetypes/LocalDateInterval.java",
        "definition": "public final class LocalDateInterval {\n\n    private Long startInstant;\n    private Long endInstant;\n    private static final IntervalEnding PERSISTENT_ENDING = IntervalEnding.INCLUDING_END_DATE;\n\n    public enum IntervalEnding {\n        INCLUDING_END_DATE, EXCLUDING_END_DATE\n    }\n\n    public static LocalDateInterval excluding(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public static LocalDateInterval including(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n    }\n\n    public LocalDateInterval(final LocalDate startDate, final LocalDate endDate, final IntervalEnding ending) {\n        startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n        endInstant = endDate == null\n                ? null\n                : ending == IntervalEnding.EXCLUDING_END_DATE\n                        ? endDate.toInterval().getStartMillis()\n                        : endDate.toInterval().getEndMillis();\n    }\n\n    public LocalDateInterval() {\n    }\n\n    public LocalDateInterval(final Interval interval) {\n        if (interval != null) {\n            startInstant = interval.getStartMillis();\n            endInstant = interval.getEndMillis();\n        }\n    }\n\n    public Interval asInterval() {\n        return new Interval(\n                startInstant == null ? 0 : startInstant,\n                endInstant == null ? Long.MAX_VALUE : endInstant);\n    }\n\n    public LocalDate startDate() {\n        if (startInstant == null) {\n            return null;\n        }\n        return new LocalDate(startInstant);\n    }\n\n    public LocalDate endDate() {\n        return endDate(PERSISTENT_ENDING);\n    }\n\n    public LocalDate endDate(final IntervalEnding ending) {\n        if (endInstant == null) {\n            return null;\n        }\n        LocalDate date = new LocalDate(endInstant);\n        return adjustDate(date, ending);\n    }\n\n    public LocalDate endDateExcluding() {\n        return endDate(IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public LocalDate endDateFromStartDate() {\n        return adjustDate(startDate(), PERSISTENT_ENDING);\n    }\n\n    private LocalDate adjustDate(final LocalDate date, final IntervalEnding ending) {\n        return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param localDateInterval\n     * @return\n     */\n    public boolean contains(final LocalDateInterval localDateInterval) {\n        return asInterval().contains(localDateInterval.asInterval());\n    }\n\n    /**\n     * Does this date contain the specified time interval.\n     * \n     * @param date\n     * @return\n     */\n    public boolean contains(final LocalDate date) {\n        if (endDate() == null) {\n            if (startDate() == null) {\n                return true;\n            }\n            if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n                return true;\n            }\n            return false;\n        }\n        return asInterval().contains(date.toInterval());\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param interval\n     * @return\n     */\n    public boolean overlaps(final LocalDateInterval interval) {\n        return asInterval().overlaps(interval.asInterval());\n    }\n\n    /**\n     * Gets the overlap between this interval and another interval.\n     * \n     * @param otherInterval\n     * @return\n     */\n    public LocalDateInterval overlap(final LocalDateInterval otherInterval) {\n        if (otherInterval == null || otherInterval.isInfinite()) {\n            return this;\n        }\n        final Interval thisAsInterval = asInterval();\n        final Interval otherAsInterval = otherInterval.asInterval();\n        Interval overlap = thisAsInterval.overlap(otherAsInterval);\n        if (overlap == null) {\n            return new LocalDateInterval();\n        }\n        return new LocalDateInterval(overlap);\n    }\n\n    /**\n     * Does this interval is within the specified interval\n     * \n     * @param interval\n     * @return\n     */\n    public boolean within(final LocalDateInterval interval) {\n        return interval.asInterval().contains(asInterval());\n    }\n\n    /**\n     * The duration in days\n     * \n     * @return\n     */\n    public int days() {\n        if (isInfinite()){\n            return 0;\n        }\n        Period p = new Period(asInterval(), PeriodType.days());\n        return p.getDays();\n    }\n\n    private boolean isInfinite() {\n        return startInstant == null && endInstant == null;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder =\n                new StringBuilder(\n                        startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                        endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n        return builder.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        // TODO: use Isis' ObjectContracts?\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LocalDateInterval)) {\n            return false;\n        }\n        LocalDateInterval rhs = (LocalDateInterval) obj;\n        return new EqualsBuilder().\n                append(startInstant, rhs.startInstant).\n                append(endInstant, rhs.endInstant).\n                isEquals();\n    }\n}",
        "package": "package org.estatio.dom.valuetypes;",
        "tree_path": "LocalDateInterval",
        "name": "LocalDateInterval",
        "modifiers": "public final",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private Long startInstant;\n    private Long endInstant;\n    private static final IntervalEnding PERSISTENT_ENDING = IntervalEnding.INCLUDING_END_DATE;\n\n    public enum IntervalEnding {\n        INCLUDING_END_DATE, EXCLUDING_END_DATE\n    }\n\n    public static LocalDateInterval excluding(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public static LocalDateInterval including(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n    }\n\n    public LocalDateInterval(final LocalDate startDate, final LocalDate endDate, final IntervalEnding ending) {\n        startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n        endInstant = endDate == null\n                ? null\n                : ending == IntervalEnding.EXCLUDING_END_DATE\n                        ? endDate.toInterval().getStartMillis()\n                        : endDate.toInterval().getEndMillis();\n    }\n\n    public LocalDateInterval() {\n    }\n\n    public LocalDateInterval(final Interval interval) {\n        if (interval != null) {\n            startInstant = interval.getStartMillis();\n            endInstant = interval.getEndMillis();\n        }\n    }\n\n    public Interval asInterval() {\n        return new Interval(\n                startInstant == null ? 0 : startInstant,\n                endInstant == null ? Long.MAX_VALUE : endInstant);\n    }\n\n    public LocalDate startDate() {\n        if (startInstant == null) {\n            return null;\n        }\n        return new LocalDate(startInstant);\n    }\n\n    public LocalDate endDate() {\n        return endDate(PERSISTENT_ENDING);\n    }\n\n    public LocalDate endDate(final IntervalEnding ending) {\n        if (endInstant == null) {\n            return null;\n        }\n        LocalDate date = new LocalDate(endInstant);\n        return adjustDate(date, ending);\n    }\n\n    public LocalDate endDateExcluding() {\n        return endDate(IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public LocalDate endDateFromStartDate() {\n        return adjustDate(startDate(), PERSISTENT_ENDING);\n    }\n\n    private LocalDate adjustDate(final LocalDate date, final IntervalEnding ending) {\n        return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param localDateInterval\n     * @return\n     */\n    public boolean contains(final LocalDateInterval localDateInterval) {\n        return asInterval().contains(localDateInterval.asInterval());\n    }\n\n    /**\n     * Does this date contain the specified time interval.\n     * \n     * @param date\n     * @return\n     */\n    public boolean contains(final LocalDate date) {\n        if (endDate() == null) {\n            if (startDate() == null) {\n                return true;\n            }\n            if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n                return true;\n            }\n            return false;\n        }\n        return asInterval().contains(date.toInterval());\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param interval\n     * @return\n     */\n    public boolean overlaps(final LocalDateInterval interval) {\n        return asInterval().overlaps(interval.asInterval());\n    }\n\n    /**\n     * Gets the overlap between this interval and another interval.\n     * \n     * @param otherInterval\n     * @return\n     */\n    public LocalDateInterval overlap(final LocalDateInterval otherInterval) {\n        if (otherInterval == null || otherInterval.isInfinite()) {\n            return this;\n        }\n        final Interval thisAsInterval = asInterval();\n        final Interval otherAsInterval = otherInterval.asInterval();\n        Interval overlap = thisAsInterval.overlap(otherAsInterval);\n        if (overlap == null) {\n            return new LocalDateInterval();\n        }\n        return new LocalDateInterval(overlap);\n    }\n\n    /**\n     * Does this interval is within the specified interval\n     * \n     * @param interval\n     * @return\n     */\n    public boolean within(final LocalDateInterval interval) {\n        return interval.asInterval().contains(asInterval());\n    }\n\n    /**\n     * The duration in days\n     * \n     * @return\n     */\n    public int days() {\n        if (isInfinite()){\n            return 0;\n        }\n        Period p = new Period(asInterval(), PeriodType.days());\n        return p.getDays();\n    }\n\n    private boolean isInfinite() {\n        return startInstant == null && endInstant == null;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder =\n                new StringBuilder(\n                        startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                        endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n        return builder.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        // TODO: use Isis' ObjectContracts?\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LocalDateInterval)) {\n            return false;\n        }\n        LocalDateInterval rhs = (LocalDateInterval) obj;\n        return new EqualsBuilder().\n                append(startInstant, rhs.startInstant).\n                append(endInstant, rhs.endInstant).\n                isEquals();\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 213,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public static LocalDateInterval excluding(final LocalDate startDate, final LocalDate endDate) {\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n}",
                "name": "excluding",
                "modifiers": "public static",
                "return_type": "LocalDateInterval",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 38,
                    "column": 5
                }
            },
            {
                "definition": "public static LocalDateInterval including(final LocalDate startDate, final LocalDate endDate) {\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n}",
                "name": "including",
                "modifiers": "public static",
                "return_type": "LocalDateInterval",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n}",
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 42,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval(final LocalDate startDate, final LocalDate endDate, final IntervalEnding ending) {\n    startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n    endInstant = endDate == null\n            ? null\n            : ending == IntervalEnding.EXCLUDING_END_DATE\n                    ? endDate.toInterval().getStartMillis()\n                    : endDate.toInterval().getEndMillis();\n}",
                "name": "LocalDateInterval",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "IntervalEnding"
                    }
                ],
                "body": "{\n    startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n    endInstant = endDate == null\n            ? null\n            : ending == IntervalEnding.EXCLUDING_END_DATE\n                    ? endDate.toInterval().getStartMillis()\n                    : endDate.toInterval().getEndMillis();\n}",
                "constructor": true,
                "start_point": {
                    "row": 44,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval() {\n}",
                "name": "LocalDateInterval",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval(final Interval interval) {\n    if (interval != null) {\n        startInstant = interval.getStartMillis();\n        endInstant = interval.getEndMillis();\n    }\n}",
                "name": "LocalDateInterval",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "final",
                        "name": "Interval"
                    }
                ],
                "body": "{\n    if (interval != null) {\n        startInstant = interval.getStartMillis();\n        endInstant = interval.getEndMillis();\n    }\n}",
                "constructor": true,
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "public Interval asInterval() {\n    return new Interval(\n            startInstant == null ? 0 : startInstant,\n            endInstant == null ? Long.MAX_VALUE : endInstant);\n}",
                "name": "asInterval",
                "modifiers": "public",
                "return_type": "Interval",
                "parameters": [],
                "body": "{\n    return new Interval(\n            startInstant == null ? 0 : startInstant,\n            endInstant == null ? Long.MAX_VALUE : endInstant);\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 67,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate startDate() {\n    if (startInstant == null) {\n        return null;\n    }\n    return new LocalDate(startInstant);\n}",
                "name": "startDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    if (startInstant == null) {\n        return null;\n    }\n    return new LocalDate(startInstant);\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDate() {\n    return endDate(PERSISTENT_ENDING);\n}",
                "name": "endDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return endDate(PERSISTENT_ENDING);\n}",
                "start_point": {
                    "row": 76,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDate(final IntervalEnding ending) {\n    if (endInstant == null) {\n        return null;\n    }\n    LocalDate date = new LocalDate(endInstant);\n    return adjustDate(date, ending);\n}",
                "name": "endDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [
                    {
                        "type": "final",
                        "name": "IntervalEnding"
                    }
                ],
                "body": "{\n    if (endInstant == null) {\n        return null;\n    }\n    LocalDate date = new LocalDate(endInstant);\n    return adjustDate(date, ending);\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 86,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDateExcluding() {\n    return endDate(IntervalEnding.EXCLUDING_END_DATE);\n}",
                "name": "endDateExcluding",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return endDate(IntervalEnding.EXCLUDING_END_DATE);\n}",
                "start_point": {
                    "row": 88,
                    "column": 4
                },
                "end_point": {
                    "row": 90,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDateFromStartDate() {\n    return adjustDate(startDate(), PERSISTENT_ENDING);\n}",
                "name": "endDateFromStartDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return adjustDate(startDate(), PERSISTENT_ENDING);\n}",
                "start_point": {
                    "row": 92,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "private LocalDate adjustDate(final LocalDate date, final IntervalEnding ending) {\n    return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n}",
                "name": "adjustDate",
                "modifiers": "private",
                "return_type": "LocalDate",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "IntervalEnding"
                    }
                ],
                "body": "{\n    return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            },
            {
                "definition": "public boolean contains(final LocalDateInterval localDateInterval) {\n    return asInterval().contains(localDateInterval.asInterval());\n}",
                "name": "contains",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    return asInterval().contains(localDateInterval.asInterval());\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "public boolean contains(final LocalDate date) {\n    if (endDate() == null) {\n        if (startDate() == null) {\n            return true;\n        }\n        if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n            return true;\n        }\n        return false;\n    }\n    return asInterval().contains(date.toInterval());\n}",
                "name": "contains",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    if (endDate() == null) {\n        if (startDate() == null) {\n            return true;\n        }\n        if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n            return true;\n        }\n        return false;\n    }\n    return asInterval().contains(date.toInterval());\n}",
                "start_point": {
                    "row": 117,
                    "column": 4
                },
                "end_point": {
                    "row": 128,
                    "column": 5
                }
            },
            {
                "definition": "public boolean overlaps(final LocalDateInterval interval) {\n    return asInterval().overlaps(interval.asInterval());\n}",
                "name": "overlaps",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    return asInterval().overlaps(interval.asInterval());\n}",
                "start_point": {
                    "row": 136,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval overlap(final LocalDateInterval otherInterval) {\n    if (otherInterval == null || otherInterval.isInfinite()) {\n        return this;\n    }\n    final Interval thisAsInterval = asInterval();\n    final Interval otherAsInterval = otherInterval.asInterval();\n    Interval overlap = thisAsInterval.overlap(otherAsInterval);\n    if (overlap == null) {\n        return new LocalDateInterval();\n    }\n    return new LocalDateInterval(overlap);\n}",
                "name": "overlap",
                "modifiers": "public",
                "return_type": "LocalDateInterval",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    if (otherInterval == null || otherInterval.isInfinite()) {\n        return this;\n    }\n    final Interval thisAsInterval = asInterval();\n    final Interval otherAsInterval = otherInterval.asInterval();\n    Interval overlap = thisAsInterval.overlap(otherAsInterval);\n    if (overlap == null) {\n        return new LocalDateInterval();\n    }\n    return new LocalDateInterval(overlap);\n}",
                "start_point": {
                    "row": 146,
                    "column": 4
                },
                "end_point": {
                    "row": 157,
                    "column": 5
                }
            },
            {
                "definition": "public boolean within(final LocalDateInterval interval) {\n    return interval.asInterval().contains(asInterval());\n}",
                "name": "within",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    return interval.asInterval().contains(asInterval());\n}",
                "start_point": {
                    "row": 165,
                    "column": 4
                },
                "end_point": {
                    "row": 167,
                    "column": 5
                }
            },
            {
                "definition": "public int days() {\n    if (isInfinite()){\n        return 0;\n    }\n    Period p = new Period(asInterval(), PeriodType.days());\n    return p.getDays();\n}",
                "name": "days",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    if (isInfinite()){\n        return 0;\n    }\n    Period p = new Period(asInterval(), PeriodType.days());\n    return p.getDays();\n}",
                "start_point": {
                    "row": 174,
                    "column": 4
                },
                "end_point": {
                    "row": 180,
                    "column": 5
                }
            },
            {
                "definition": "private boolean isInfinite() {\n    return startInstant == null && endInstant == null;\n}",
                "name": "isInfinite",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return startInstant == null && endInstant == null;\n}",
                "start_point": {
                    "row": 182,
                    "column": 4
                },
                "end_point": {
                    "row": 184,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    StringBuilder builder =\n            new StringBuilder(\n                    startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                    endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n    return builder.toString();\n}",
                "name": "toString",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    StringBuilder builder =\n            new StringBuilder(\n                    startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                    endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n    return builder.toString();\n}",
                "start_point": {
                    "row": 186,
                    "column": 4
                },
                "end_point": {
                    "row": 193,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(final Object obj) {\n    // TODO: use Isis' ObjectContracts?\n    if (obj == null) {\n        return false;\n    }\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof LocalDateInterval)) {\n        return false;\n    }\n    LocalDateInterval rhs = (LocalDateInterval) obj;\n    return new EqualsBuilder().\n            append(startInstant, rhs.startInstant).\n            append(endInstant, rhs.endInstant).\n            isEquals();\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Object"
                    }
                ],
                "body": "{\n    // TODO: use Isis' ObjectContracts?\n    if (obj == null) {\n        return false;\n    }\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof LocalDateInterval)) {\n        return false;\n    }\n    LocalDateInterval rhs = (LocalDateInterval) obj;\n    return new EqualsBuilder().\n            append(startInstant, rhs.startInstant).\n            append(endInstant, rhs.endInstant).\n            isEquals();\n}",
                "start_point": {
                    "row": 195,
                    "column": 4
                },
                "end_point": {
                    "row": 212,
                    "column": 5
                }
            }
        ],
        "class_mode": "Unchanged"
    }
]