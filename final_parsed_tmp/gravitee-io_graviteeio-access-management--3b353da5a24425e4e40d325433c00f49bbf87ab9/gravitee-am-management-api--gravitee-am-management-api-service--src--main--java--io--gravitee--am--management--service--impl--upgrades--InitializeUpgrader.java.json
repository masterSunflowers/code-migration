[
    {
        "repo_name": "gravitee-io_graviteeio-access-management",
        "commit": "3b353da5a24425e4e40d325433c00f49bbf87ab9",
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/InitializeUpgrader.java",
        "definition": "@Component\npublic class InitializeUpgrader implements Upgrader, Ordered {\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n    private final static String ADMIN_CLIENT_SECRET = \"admin-secret\";\n    private final static String DEFAULT_SCOPE = \"openid\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        try {\n            // TODO async call\n            Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n            // update master flag\n            // TODO: keep history in database to avoid this call\n            if (!adminDomain.isMaster()) {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                // TODO async call\n                domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n            }\n            logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n        } catch (DomainNotFoundException dnfe) {\n            //TODO: Use configuration to get admin values\n            // Create a new admin domain\n            logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n            NewDomain adminDomain = new NewDomain();\n            adminDomain.setName(\"admin\");\n            adminDomain.setDescription(\"AM Admin domain\");\n            // TODO async call\n            Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n            // Create default scope\n            NewScope scope = new NewScope();\n            scope.setKey(DEFAULT_SCOPE);\n            scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n            scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n            // TODO async call\n            Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n            // Create a new admin client\n            logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n            NewClient adminClient = new NewClient();\n            adminClient.setClientId(ADMIN_CLIENT_ID);\n            adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n            // TODO async call\n            Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n            // Create an inline identity provider\n            logger.info(\"Create an user-inline provider\");\n            NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n            adminIdentityProvider.setType(\"inline-am-idp\");\n            adminIdentityProvider.setName(\"Inline users\");\n            adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n            // TODO async call\n            IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n            // Associate the identity provider to the client and enabled it\n            logger.info(\"Associate user-inline provider to previously created client\");\n            UpdateClient updateClient = new UpdateClient();\n            updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n            updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n            updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n            updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n            updateClient.setAutoApproveScopes(updateClient.getScopes());\n            updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n            updateClient.setEnabled(true);\n            // TODO async call\n            clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n            // Enabled the domain\n            logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n            UpdateDomain updateDomain = new UpdateDomain();\n            updateDomain.setName(createdDomain.getName());\n            updateDomain.setDescription(createdDomain.getDescription());\n            updateDomain.setEnabled(true);\n            updateDomain.setPath(createdDomain.getPath());\n            // TODO async call\n            domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n            // Set master flag\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n        }\n\n        return true;\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "InitializeUpgrader",
        "name": "InitializeUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n    private final static String ADMIN_CLIENT_SECRET = \"admin-secret\";\n    private final static String DEFAULT_SCOPE = \"openid\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        try {\n            // TODO async call\n            Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n            // update master flag\n            // TODO: keep history in database to avoid this call\n            if (!adminDomain.isMaster()) {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                // TODO async call\n                domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n            }\n            logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n        } catch (DomainNotFoundException dnfe) {\n            //TODO: Use configuration to get admin values\n            // Create a new admin domain\n            logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n            NewDomain adminDomain = new NewDomain();\n            adminDomain.setName(\"admin\");\n            adminDomain.setDescription(\"AM Admin domain\");\n            // TODO async call\n            Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n            // Create default scope\n            NewScope scope = new NewScope();\n            scope.setKey(DEFAULT_SCOPE);\n            scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n            scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n            // TODO async call\n            Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n            // Create a new admin client\n            logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n            NewClient adminClient = new NewClient();\n            adminClient.setClientId(ADMIN_CLIENT_ID);\n            adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n            // TODO async call\n            Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n            // Create an inline identity provider\n            logger.info(\"Create an user-inline provider\");\n            NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n            adminIdentityProvider.setType(\"inline-am-idp\");\n            adminIdentityProvider.setName(\"Inline users\");\n            adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n            // TODO async call\n            IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n            // Associate the identity provider to the client and enabled it\n            logger.info(\"Associate user-inline provider to previously created client\");\n            UpdateClient updateClient = new UpdateClient();\n            updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n            updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n            updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n            updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n            updateClient.setAutoApproveScopes(updateClient.getScopes());\n            updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n            updateClient.setEnabled(true);\n            // TODO async call\n            clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n            // Enabled the domain\n            logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n            UpdateDomain updateDomain = new UpdateDomain();\n            updateDomain.setName(createdDomain.getName());\n            updateDomain.setDescription(createdDomain.getDescription());\n            updateDomain.setEnabled(true);\n            updateDomain.setPath(createdDomain.getPath());\n            // TODO async call\n            domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n            // Set master flag\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n        }\n\n        return true;\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "start_point": {
            "row": 40,
            "column": 0
        },
        "end_point": {
            "row": 152,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    try {\n        // TODO async call\n        Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n        // update master flag\n        // TODO: keep history in database to avoid this call\n        if (!adminDomain.isMaster()) {\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n        }\n        logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n    } catch (DomainNotFoundException dnfe) {\n        //TODO: Use configuration to get admin values\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        // TODO async call\n        Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n        // Create default scope\n        NewScope scope = new NewScope();\n        scope.setKey(DEFAULT_SCOPE);\n        scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n        scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n        // TODO async call\n        Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n        // Create a new admin client\n        logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n        NewClient adminClient = new NewClient();\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n        adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n        // TODO async call\n        Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n        // Create an inline identity provider\n        logger.info(\"Create an user-inline provider\");\n        NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n        adminIdentityProvider.setType(\"inline-am-idp\");\n        adminIdentityProvider.setName(\"Inline users\");\n        adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n        // TODO async call\n        IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n        // Associate the identity provider to the client and enabled it\n        logger.info(\"Associate user-inline provider to previously created client\");\n        UpdateClient updateClient = new UpdateClient();\n        updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n        updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n        updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n        updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n        updateClient.setAutoApproveScopes(updateClient.getScopes());\n        updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n        updateClient.setEnabled(true);\n        // TODO async call\n        clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n        // Enabled the domain\n        logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n        UpdateDomain updateDomain = new UpdateDomain();\n        updateDomain.setName(createdDomain.getName());\n        updateDomain.setDescription(createdDomain.getDescription());\n        updateDomain.setEnabled(true);\n        updateDomain.setPath(createdDomain.getPath());\n        // TODO async call\n        domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n        // Set master flag\n        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n        // TODO async call\n        domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n    }\n\n    return true;\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    try {\n        // TODO async call\n        Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n        // update master flag\n        // TODO: keep history in database to avoid this call\n        if (!adminDomain.isMaster()) {\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n        }\n        logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n    } catch (DomainNotFoundException dnfe) {\n        //TODO: Use configuration to get admin values\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        // TODO async call\n        Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n        // Create default scope\n        NewScope scope = new NewScope();\n        scope.setKey(DEFAULT_SCOPE);\n        scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n        scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n        // TODO async call\n        Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n        // Create a new admin client\n        logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n        NewClient adminClient = new NewClient();\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n        adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n        // TODO async call\n        Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n        // Create an inline identity provider\n        logger.info(\"Create an user-inline provider\");\n        NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n        adminIdentityProvider.setType(\"inline-am-idp\");\n        adminIdentityProvider.setName(\"Inline users\");\n        adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n        // TODO async call\n        IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n        // Associate the identity provider to the client and enabled it\n        logger.info(\"Associate user-inline provider to previously created client\");\n        UpdateClient updateClient = new UpdateClient();\n        updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n        updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n        updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n        updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n        updateClient.setAutoApproveScopes(updateClient.getScopes());\n        updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n        updateClient.setEnabled(true);\n        // TODO async call\n        clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n        // Enabled the domain\n        logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n        UpdateDomain updateDomain = new UpdateDomain();\n        updateDomain.setName(createdDomain.getName());\n        updateDomain.setDescription(createdDomain.getDescription());\n        updateDomain.setEnabled(true);\n        updateDomain.setPath(createdDomain.getPath());\n        // TODO async call\n        domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n        // Set master flag\n        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n        // TODO async call\n        domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n    }\n\n    return true;\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 151,
                    "column": 5
                }
            }
        ],
        "class_mode": "Modified"
    }
]