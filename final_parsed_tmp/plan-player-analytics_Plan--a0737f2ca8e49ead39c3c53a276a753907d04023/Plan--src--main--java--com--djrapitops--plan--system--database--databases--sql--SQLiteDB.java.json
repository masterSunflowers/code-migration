[
    {
        "rev_path": "Plan/src/main/java/com/djrapitops/plan/system/database/databases/sql/SQLiteDB.java",
        "definition": "public class SQLiteDB extends SQLDB {\n\n    private final File databaseFile;\n    private final String dbName;\n    private Connection connection;\n    private ITask connectionPingTask;\n\n    /**\n     * Class Constructor.\n     */\n    public SQLiteDB() {\n        this(\"database\");\n    }\n\n    public SQLiteDB(String dbName) {\n        this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n    }\n\n    public SQLiteDB(File databaseFile) {\n        dbName = databaseFile.getName();\n        this.databaseFile = databaseFile;\n    }\n\n    /**\n     * Setups the {@link BasicDataSource}\n     */\n    @Override\n    public void setupDataSource() throws DBInitException {\n        try {\n            connection = getNewConnection(databaseFile);\n        } catch (SQLException e) {\n            throw new DBInitException(e);\n        }\n        startConnectionPingTask();\n    }\n\n    public Connection getNewConnection(File dbFile) throws SQLException {\n        try {\n            Class.forName(\"org.sqlite.JDBC\");\n        } catch (ClassNotFoundException e) {\n            Log.toLog(this.getClass(), e);\n            return null; // Should never happen.\n        }\n\n        String dbFilePath = dbFile.getAbsolutePath();\n\n        Connection newConnection = getConnectionFor(dbFilePath);\n        Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n        newConnection.setAutoCommit(false);\n        return newConnection;\n    }\n\n    private Connection getConnectionFor(String dbFilePath) throws SQLException {\n        try {\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n        } catch (SQLException ignored) {\n            Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n        }\n    }\n\n    private void startConnectionPingTask() {\n        stopConnectionPingTask();\n        try {\n            // Maintains Connection.\n            connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n                @Override\n                public void run() {\n                    Statement statement = null;\n                    ResultSet resultSet = null;\n                    try {\n                        if (connection != null && !connection.isClosed()) {\n                            statement = connection.createStatement();\n                            resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                        }\n                    } catch (SQLException e) {\n                        Log.debug(\"Something went wrong during Ping task.\");\n                        try {\n                            connection = getNewConnection(databaseFile);\n                        } catch (SQLException e1) {\n                            Log.toLog(this.getClass(), e1);\n                            Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                            this.cancel();\n                        }\n                    } finally {\n                        MiscUtils.close(statement, resultSet);\n                    }\n                }\n            }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n        } catch (Exception ignored) {\n        }\n    }\n\n    private void stopConnectionPingTask() {\n        if (connectionPingTask != null) {\n            try {\n                connectionPingTask.cancel();\n            } catch (Exception ignored) {\n            }\n        }\n    }\n\n    /**\n     * @return the name of the Database\n     */\n    @Override\n    public String getName() {\n        return \"SQLite\";\n    }\n\n    @Override\n    public Connection getConnection() throws SQLException {\n        if (connection == null) {\n            connection = getNewConnection(databaseFile);\n        }\n        return connection;\n    }\n\n    @Override\n    public void close() {\n        stopConnectionPingTask();\n        if (connection != null) {\n            Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n            MiscUtils.close(connection);\n        }\n        super.close();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        SQLiteDB sqLiteDB = (SQLiteDB) o;\n        return Objects.equals(dbName, sqLiteDB.dbName);\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(super.hashCode(), dbName);\n    }\n}",
        "package": "package com.djrapitops.plan.system.database.databases.sql;",
        "tree_path": "SQLiteDB",
        "name": "SQLiteDB",
        "modifiers": "public",
        "superclass": "extends SQLDB",
        "super_interfaces": null,
        "body": "{\n\n    private final File databaseFile;\n    private final String dbName;\n    private Connection connection;\n    private ITask connectionPingTask;\n\n    /**\n     * Class Constructor.\n     */\n    public SQLiteDB() {\n        this(\"database\");\n    }\n\n    public SQLiteDB(String dbName) {\n        this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n    }\n\n    public SQLiteDB(File databaseFile) {\n        dbName = databaseFile.getName();\n        this.databaseFile = databaseFile;\n    }\n\n    /**\n     * Setups the {@link BasicDataSource}\n     */\n    @Override\n    public void setupDataSource() throws DBInitException {\n        try {\n            connection = getNewConnection(databaseFile);\n        } catch (SQLException e) {\n            throw new DBInitException(e);\n        }\n        startConnectionPingTask();\n    }\n\n    public Connection getNewConnection(File dbFile) throws SQLException {\n        try {\n            Class.forName(\"org.sqlite.JDBC\");\n        } catch (ClassNotFoundException e) {\n            Log.toLog(this.getClass(), e);\n            return null; // Should never happen.\n        }\n\n        String dbFilePath = dbFile.getAbsolutePath();\n\n        Connection newConnection = getConnectionFor(dbFilePath);\n        Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n        newConnection.setAutoCommit(false);\n        return newConnection;\n    }\n\n    private Connection getConnectionFor(String dbFilePath) throws SQLException {\n        try {\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n        } catch (SQLException ignored) {\n            Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n        }\n    }\n\n    private void startConnectionPingTask() {\n        stopConnectionPingTask();\n        try {\n            // Maintains Connection.\n            connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n                @Override\n                public void run() {\n                    Statement statement = null;\n                    ResultSet resultSet = null;\n                    try {\n                        if (connection != null && !connection.isClosed()) {\n                            statement = connection.createStatement();\n                            resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                        }\n                    } catch (SQLException e) {\n                        Log.debug(\"Something went wrong during Ping task.\");\n                        try {\n                            connection = getNewConnection(databaseFile);\n                        } catch (SQLException e1) {\n                            Log.toLog(this.getClass(), e1);\n                            Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                            this.cancel();\n                        }\n                    } finally {\n                        MiscUtils.close(statement, resultSet);\n                    }\n                }\n            }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n        } catch (Exception ignored) {\n        }\n    }\n\n    private void stopConnectionPingTask() {\n        if (connectionPingTask != null) {\n            try {\n                connectionPingTask.cancel();\n            } catch (Exception ignored) {\n            }\n        }\n    }\n\n    /**\n     * @return the name of the Database\n     */\n    @Override\n    public String getName() {\n        return \"SQLite\";\n    }\n\n    @Override\n    public Connection getConnection() throws SQLException {\n        if (connection == null) {\n            connection = getNewConnection(databaseFile);\n        }\n        return connection;\n    }\n\n    @Override\n    public void close() {\n        stopConnectionPingTask();\n        if (connection != null) {\n            Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n            MiscUtils.close(connection);\n        }\n        super.close();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        SQLiteDB sqLiteDB = (SQLiteDB) o;\n        return Objects.equals(dbName, sqLiteDB.dbName);\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(super.hashCode(), dbName);\n    }\n}",
        "start_point": {
            "row": 18,
            "column": 0
        },
        "end_point": {
            "row": 160,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public SQLiteDB() {\n    this(\"database\");\n}",
                "name": "SQLiteDB",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    this(\"database\");\n}",
                "constructor": true,
                "start_point": {
                    "row": 28,
                    "column": 4
                },
                "end_point": {
                    "row": 30,
                    "column": 5
                }
            },
            {
                "definition": "public SQLiteDB(String dbName) {\n    this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n}",
                "name": "SQLiteDB",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "dbName"
                    }
                ],
                "body": "{\n    this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n}",
                "constructor": true,
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 34,
                    "column": 5
                }
            },
            {
                "definition": "public SQLiteDB(File databaseFile) {\n    dbName = databaseFile.getName();\n    this.databaseFile = databaseFile;\n}",
                "name": "SQLiteDB",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "File",
                        "name": "databaseFile"
                    }
                ],
                "body": "{\n    dbName = databaseFile.getName();\n    this.databaseFile = databaseFile;\n}",
                "constructor": true,
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 39,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setupDataSource() throws DBInitException {\n    try {\n        connection = getNewConnection(databaseFile);\n    } catch (SQLException e) {\n        throw new DBInitException(e);\n    }\n    startConnectionPingTask();\n}",
                "name": "setupDataSource",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    try {\n        connection = getNewConnection(databaseFile);\n    } catch (SQLException e) {\n        throw new DBInitException(e);\n    }\n    startConnectionPingTask();\n}",
                "start_point": {
                    "row": 44,
                    "column": 4
                },
                "end_point": {
                    "row": 52,
                    "column": 5
                }
            },
            {
                "definition": "public Connection getNewConnection(File dbFile) throws SQLException {\n    try {\n        Class.forName(\"org.sqlite.JDBC\");\n    } catch (ClassNotFoundException e) {\n        Log.toLog(this.getClass(), e);\n        return null; // Should never happen.\n    }\n\n    String dbFilePath = dbFile.getAbsolutePath();\n\n    Connection newConnection = getConnectionFor(dbFilePath);\n    Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n    newConnection.setAutoCommit(false);\n    return newConnection;\n}",
                "name": "getNewConnection",
                "modifiers": "public",
                "return_type": "Connection",
                "parameters": [
                    {
                        "type": "File",
                        "name": "dbFile"
                    }
                ],
                "body": "{\n    try {\n        Class.forName(\"org.sqlite.JDBC\");\n    } catch (ClassNotFoundException e) {\n        Log.toLog(this.getClass(), e);\n        return null; // Should never happen.\n    }\n\n    String dbFilePath = dbFile.getAbsolutePath();\n\n    Connection newConnection = getConnectionFor(dbFilePath);\n    Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n    newConnection.setAutoCommit(false);\n    return newConnection;\n}",
                "start_point": {
                    "row": 54,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "private Connection getConnectionFor(String dbFilePath) throws SQLException {\n    try {\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n    } catch (SQLException ignored) {\n        Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n    }\n}",
                "name": "getConnectionFor",
                "modifiers": "private",
                "return_type": "Connection",
                "parameters": [
                    {
                        "type": "String",
                        "name": "dbFilePath"
                    }
                ],
                "body": "{\n    try {\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n    } catch (SQLException ignored) {\n        Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n    }\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 77,
                    "column": 5
                }
            },
            {
                "definition": "private void startConnectionPingTask() {\n    stopConnectionPingTask();\n    try {\n        // Maintains Connection.\n        connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n            @Override\n            public void run() {\n                Statement statement = null;\n                ResultSet resultSet = null;\n                try {\n                    if (connection != null && !connection.isClosed()) {\n                        statement = connection.createStatement();\n                        resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                    }\n                } catch (SQLException e) {\n                    Log.debug(\"Something went wrong during Ping task.\");\n                    try {\n                        connection = getNewConnection(databaseFile);\n                    } catch (SQLException e1) {\n                        Log.toLog(this.getClass(), e1);\n                        Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                        this.cancel();\n                    }\n                } finally {\n                    MiscUtils.close(statement, resultSet);\n                }\n            }\n        }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n    } catch (Exception ignored) {\n    }\n}",
                "name": "startConnectionPingTask",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    stopConnectionPingTask();\n    try {\n        // Maintains Connection.\n        connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n            @Override\n            public void run() {\n                Statement statement = null;\n                ResultSet resultSet = null;\n                try {\n                    if (connection != null && !connection.isClosed()) {\n                        statement = connection.createStatement();\n                        resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                    }\n                } catch (SQLException e) {\n                    Log.debug(\"Something went wrong during Ping task.\");\n                    try {\n                        connection = getNewConnection(databaseFile);\n                    } catch (SQLException e1) {\n                        Log.toLog(this.getClass(), e1);\n                        Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                        this.cancel();\n                    }\n                } finally {\n                    MiscUtils.close(statement, resultSet);\n                }\n            }\n        }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n    } catch (Exception ignored) {\n    }\n}",
                "start_point": {
                    "row": 79,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "private void stopConnectionPingTask() {\n    if (connectionPingTask != null) {\n        try {\n            connectionPingTask.cancel();\n        } catch (Exception ignored) {\n        }\n    }\n}",
                "name": "stopConnectionPingTask",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    if (connectionPingTask != null) {\n        try {\n            connectionPingTask.cancel();\n        } catch (Exception ignored) {\n        }\n    }\n}",
                "start_point": {
                    "row": 111,
                    "column": 4
                },
                "end_point": {
                    "row": 118,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String getName() {\n    return \"SQLite\";\n}",
                "name": "getName",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"SQLite\";\n}",
                "start_point": {
                    "row": 123,
                    "column": 4
                },
                "end_point": {
                    "row": 126,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Connection getConnection() throws SQLException {\n    if (connection == null) {\n        connection = getNewConnection(databaseFile);\n    }\n    return connection;\n}",
                "name": "getConnection",
                "modifiers": "@Override\n    public",
                "return_type": "Connection",
                "parameters": [],
                "body": "{\n    if (connection == null) {\n        connection = getNewConnection(databaseFile);\n    }\n    return connection;\n}",
                "start_point": {
                    "row": 128,
                    "column": 4
                },
                "end_point": {
                    "row": 134,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void close() {\n    stopConnectionPingTask();\n    if (connection != null) {\n        Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n        MiscUtils.close(connection);\n    }\n    super.close();\n}",
                "name": "close",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    stopConnectionPingTask();\n    if (connection != null) {\n        Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n        MiscUtils.close(connection);\n    }\n    super.close();\n}",
                "start_point": {
                    "row": 136,
                    "column": 4
                },
                "end_point": {
                    "row": 144,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    SQLiteDB sqLiteDB = (SQLiteDB) o;\n    return Objects.equals(dbName, sqLiteDB.dbName);\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    SQLiteDB sqLiteDB = (SQLiteDB) o;\n    return Objects.equals(dbName, sqLiteDB.dbName);\n}",
                "start_point": {
                    "row": 146,
                    "column": 4
                },
                "end_point": {
                    "row": 153,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n\n    return Objects.hash(super.hashCode(), dbName);\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n\n    return Objects.hash(super.hashCode(), dbName);\n}",
                "start_point": {
                    "row": 155,
                    "column": 4
                },
                "end_point": {
                    "row": 159,
                    "column": 5
                }
            }
        ],
        "class_mode": "Modified"
    }
]