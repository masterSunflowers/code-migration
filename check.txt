'package fr.inria.edelweiss.engine.core;\r\n\r\nimport java.io.IOException;\r\nimport java.util.List;\r\n\r\nimport org.apache.log4j.Logger;\r\n\r\n//import fr.inria.acacia.corese.event.Event;\r\n//import fr.inria.acacia.corese.event.EventManager;\r\n//import fr.inria.acacia.corese.event.RuleEvent;\r\nimport fr.inria.acacia.corese.triple.api.ElementClause;\r\nimport fr.inria.edelweiss.engine.model.api.Bind;\r\nimport fr.inria.edelweiss.engine.model.api.Clause;\r\nimport fr.inria.edelweiss.engine.model.api.ExpFilter;\r\nimport fr.inria.edelweiss.engine.model.api.LBind;\r\nimport fr.inria.edelweiss.engine.model.api.Query;\r\nimport fr.inria.edelweiss.engine.model.api.Rule;\r\nimport fr.inria.edelweiss.engine.model.api.RuleBase;\r\nimport fr.inria.edelweiss.engine.model.core.LBindImpl;\r\nimport fr.inria.edelweiss.engine.tool.api.EventsTreatment;\r\n\r\npublic class Backward {\r\n\tprivate static Logger logger = Logger.getLogger(Backward.class);\r\n\r\n\t\t/**\r\n\t     * ruleBase: { construct {?a grandFather ?c} where {?a father ?b . ?b father ?c} }\r\n\t     * eventBase: {John father Mark. Mark father Pierre}\r\n\t     */\r\n\t\r\n\t\t//the base of rules\r\n\t    private RuleBase ruleBase;\r\n\t   // private EventManager manager;\r\n\t    private EventsTreatment sparql;\r\n\t    \r\n\r\n\t    private Stack stack;\r\n\t    \r\n\t    private boolean \r\n\t    \t// sparql query for level = 0, i.e. for initial clause\r\n\t    \t// we may skip sparql query for initial clause in some case\r\n\t    \t// e.g. when clause is only defined by a proof\r\n\t    \thasQuery = true,\r\n\t    \thasEvent = false, \r\n\t    \ttrace = !true, \r\n\t    \tdebug = !true;\r\n\t    \r\n\t    int count = 0, loop;\r\n\t   \r\n\t    public Backward(RuleBase ruleBase, EventsTreatment proc) {\r\n\t\t\tthis.ruleBase = ruleBase;\r\n\t\t\tsparql = proc;\r\n\t\t\tstack = new Stack();\r\n\t\t}\r\n\t    \r\n//\t    void setEventManager(EventManager em){\r\n//\t    \tmanager = em;\r\n//\t\t\thasEvent = manager.handle(Event.RULE);\r\n//\t    }\r\n\t\r\n\t\tpublic LBind prove(Query query, Bind bind){\r\n\t\t\tdebug = query.getASTQuery().isDebug();\r\n\t\t\tif (debug){\r\n\t\t\t\tSystem.out.println("** RuleBase: " );\r\n\t\t\t\tfor (Rule rr : ruleBase){\r\n\t\t\t\t\tSystem.out.println(rr);\r\n\t\t\t\t}\r\n\t\t\t\tSystem.out.println("** end" );\r\n\t\t\t}\r\n\t\t\treturn prove(query, query.getClauses(), bind, 0, 0);\r\n\t\t}\r\n\t\t\r\n\t\tint getLoop(){\r\n\t\t\treturn loop;\r\n\t\t}\r\n\t\t\r\n\t\t/**\r\n\t\t * Query is the AST of the clauses to prove\r\n\t\t * clauses is the list of clause to prove\r\n\t\t * bind is the current partial variable binding\r\n\t\t * n is the index of current clause in the clauses list\r\n\t\t * level is the recursive level of backward rule calls\r\n\t\t * level = 0 means the initial clause to prove \r\n\t\t * \r\n\t\t *  TODO: \r\n\t\t *  compile filters only once for all bindings\r\n\t\t *  when filter fails there is no event\r\n\t\t *\r\n\t\t */\r\n\t\tpublic LBind prove(Query query, List<Clause> clauses, \r\n\t\t\t\tBind bind, int n, int level){\r\n\t\t\tLBind lb;\r\n\t\t\tloop++;\r\n\t\t\tif (level > count){\r\n\t\t\t\tcount = level;\r\n\t\t\t\t//System.out.println(level);\r\n\t\t\t}\r\n\r\n\t\t\tif (n == clauses.size()){\r\n\t\t\t\t// never happens\r\n\t\t\t\tlb = new  LBindImpl();\r\n\t\t\t\tlb.add(bind);\r\n\t\t\t\treturn lb;\r\n\t\t\t}\r\n\r\n\t\t\tif (query.isSparql()){\r\n\t\t\t\t// this is a pure SPARQL query, no backward here:\r\n\r\n//\t\t\t\tif (hasEvent){ \r\n//\t\t\t\t\t// ASTQuery is the Abstract Syntax Tree of the query\r\n//\t\t\t\t\tRuleEvent e = \r\n//\t\t\t\t\t\tRuleEvent.create(Event.RULE_SPARQL, level, n, query.getASTQuery());\r\n//\t\t\t\t\tmanager.send(e);\t\t\r\n//\t\t\t\t}\r\n\r\n\t\t\t\tlb = sparql.searchTriples(query, clauses, bind);\r\n\r\n\t\t\t\treturn lb;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif (query.getFilters().size() > 0 ){\r\n\t\t\t\t// test filters that would need only current bind and no clause\r\n\r\n\t\t\t\tif (! checkFilters(query, null, bind, level, n)){\r\n\t\t\t\t\t// a filter is not valid : fail right now\r\n\t\t\t\t\treturn new LBindImpl();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\r\n\t\t\t//Iteration of the clauses of the query\r\n\t\t\tClause clause = clauses.get(n);\r\n\t\t\t\r\n\r\n//\t\t\tif (hasEvent){ \r\n//\t\t\t\t// announce current clause\r\n//\t\t\t\tRuleEvent e = \r\n//\t\t\t\t\tRuleEvent.create(Event.RULE_PROVE, level, n, clause.getTriple());\r\n//\t\t\t\tmanager.send(e);\t\t\r\n//\t\t\t}\r\n\r\n\t\t\t\r\n\t\t\t// search  triples matching the clause in the RDF store \r\n\t\t\t// and check appropriate filters\r\n\r\n\t\t\tLBind lbQuery = sparql.searchTriples(query, clause, bind);\r\n\t\t\t\r\n\t\t\tif (debug){\r\n\t\t\t\tSystem.out.println("sparql: "+ clause + " level: " + level);\r\n\t\t\t\tSystem.out.println("bind: " + bind);\r\n\t\t\t\tSystem.out.println("result: " + lbQuery);\r\n\t\t\t\tSystem.out.println("__");\r\n\t\t\t}\r\n\t\t\t\r\n//\t\t\tif (hasEvent){ \r\n//\t\t\t\t// we try to prove current clause by querying the graph\r\n//\t\t\t\tRuleEvent e = \r\n//\t\t\t\t\tRuleEvent.create(Event.RULE_SPARQL, level, n, clause.getTriple());\r\n//\t\t\t\te.addObject(lbQuery);\r\n//\t\t\t\tmanager.send(e);\t\t\r\n//\t\t\t}\r\n\t\t\t\r\n\t\t\tLBind lbProve;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\tif (clause.isGround()){\r\n\t\t\t\t// e.g. clause = xxx rdf:type owl:TransitiveProperty\r\n\t\t\t\t// no backward for this clause, search only in RDF store\r\n\t\t\t\tlbProve = lbQuery;\r\n\t\t\t\tlbQuery = new LBindImpl();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// prove clause using the backward algorithm\r\n\t\t\t\t\tlbProve = backward(clause, bind, level, n);\r\n\t\t\t}\r\n\r\n\t\t\t// now we check filters that concern current clause in backward\r\n\t\t\tif (query.getFilters().size() > 0 ){\r\n\r\n\t\t\t\tfor (Bind bProve : lbProve){\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (checkFilters(query, clause, bProve, level, n)){\r\n\t\t\t\t\t\tlbQuery = lbQuery.union(bProve);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlb = lbQuery;\r\n\t\t\t}\r\n\t\t\telse {\t\t\t\t\t\t\t\t\r\n\t\t\t\t//union of the two lists of binds above, SPARQL and backward\r\n\t\t\t\tlb = lbQuery.union(lbProve);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (debug){\r\n\t\t\t\tSystem.out.println("union: sparql: " + lbQuery);\r\n\t\t\t\tSystem.out.println("union: prove: " + lbProve);\r\n\t\t\t\tSystem.out.println("union: " + lb);\r\n\t\t\t}\r\n\r\n\r\n//\t\t\tif (hasEvent){ \r\n//\t\t\t\t// we have tried to prove current clause\r\n//\t\t\t\tRuleEvent e = \r\n//\t\t\t\t\tRuleEvent.create(Event.RULE_PROVED, level, n, clause.getTriple());\r\n//\t\t\t\t// current bindings\r\n//\t\t\t\te.addObject(lb);\r\n//\t\t\t\tmanager.send(e);\t\t\r\n//\t\t\t}\r\n\r\n\t\t\tn++;\r\n\r\n\t\t\tif (n < clauses.size()){\r\n\t\t\t\t// yet another clause\r\n\r\n\t\t\t\tLBind lbRec = new LBindImpl();\r\n\r\n\t\t\t\tfor (Bind b : lb){\r\n\t\t\t\t\t// for each binding, \r\n\t\t\t\t\t// call the function prove with the rest of the query  \r\n\t\t\t\t\tLBind lbRecProve = prove (query, clauses, b, n, level);\r\n\r\n\t\t\t\t\tlbRec = lbRec.union(lbRecProve);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//recover the lasts bindings\r\n\t\t\t\tlb = lbRec;\r\n\t\t\t}\r\n\r\n\r\n\t\t\treturn lb;\r\n\t\t}\t\r\n\r\n\t\t\r\n\t\tboolean checkFilters(Query query, Clause clause, Bind bind, int level, int n){\r\n\t\t\tfor (ExpFilter filter: query.getFilters()){\r\n\r\n\t\t\t\tif (filter.isCorresponding(clause, bind)){\r\n\t\t\t\t\t// filter share variables with clause: evaluate it\r\n\t\t\t\t\tif (! sparql.test(query, filter, bind, level, n)){\r\n\t\t\t\t\t\treturn false;\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t\r\n\t\t\r\n\t\tboolean isPropertyVariable(Clause clause, Bind bind){\r\n\t\t\tElementClause property = clause.get(Clause.PROPERTY);\r\n\t\t\tif (property.isVariable() &&\r\n\t\t\t\t\t! bind.hasVariable(property.getName())){\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\telse return false;\r\n\t\t}\r\n\r\n\r\n        /**\r\n         * clause: John grandFather ?y\r\n         * bind: {}\r\n         * case rule = construct {?a grandFather ?c} where {?a father ?b . ?b father ?c} \r\n         * rule.match(clause,bind) -> true \r\n         * bind.get(rule.getHead(), clause) -> {?a = John}\r\n         * lb1.rename(rule.getHead(), clause) : rename ?c into ?y in the list of binds lb1 \r\n         */\r\n\r\n        public LBind backward(Clause clause, Bind bind, int level, int n){\r\n        \t\r\n            LBind lb1 = null, lb = new LBindImpl();\r\n            \r\n            //iteration of the base of rules\r\n            for (Rule rule : ruleBase){\r\n           \t\r\n            \t// draft to prevent loop \r\n            \tif (stack.contains(rule, clause, bind)){\r\n            \t\tcontinue;\r\n            \t}\r\n            \t\r\n\r\n            \t// get  clauses of  rule matching the clause of the query\r\n            \tList<Clause> list = rule.match(clause, bind);\r\n\r\n            \tfor (Clause clauseRule : list){\r\n            \t\t\r\n                \t// rule match the clause,  considering the bind\r\n            \t\t\r\n//            \t\tif (hasEvent){\r\n//                \t\tRuleEvent e = \r\n//                \t\t\tRuleEvent.create(Event.RULE_BACK, level, n, clause.getTriple());\r\n//                \t\te.addObject(rule.getRuleInstance());\r\n//                \t\te.addObject(bind);\r\n//                \t\tmanager.send(e);\r\n//                \t}\r\n                \t           \t\t           \t\t\r\n                \t// call the method prove with the premises of the rule \r\n                \t// if clause variables are bound\r\n            \t\t// generate a new bind were bindings are attached to the\r\n            \t\t// rule clause variables \r\n            \t\t// (rename clause variables into rule variables)\r\n            \t\t\r\n            \t\t//if (debug) System.out.println("back unify");\r\n            \t\t\r\n            \t\tBind unified =  bind.unify(clauseRule, clause);\r\n            \t\t\r\n            \t\tif (debug){\r\n//            \t\t\tSystem.out.println("back unify: " + clauseRule);\r\n//            \t\t\tSystem.out.println("back unify: " + clause);\r\n//            \t\t\tSystem.out.println("back unify: " + unified);\r\n            \t\t}\r\n\r\n            \t\tif (unified != null){\r\n                   \t\tstack.push(rule, clause, clauseRule, bind);\r\n\r\n                   \t\tif (debug){\r\n                   \t\t\t//System.out.println(level + ": " + rule.getID() + " " + clauseRule.getTriple() + " " + clause + " " + unified);\r\n                   \t\t\tSystem.out.println("prove: " + clause );\r\n                   \t\t\tSystem.out.println("with:  " + clauseRule.getTriple() + " " + unified);\r\n                   \t\t\tSystem.out.println(stack);\r\n                   \t\t\twatch();\r\n                   \t\t}\r\n                   \t \r\n            \t\t\tlb1 = prove(rule.getBody(), rule.getBody().getClauses(), \r\n            \t\t\t\t\tunified, 0, level+1);\r\n\r\n            \t\t\tstack.pop();\r\n\r\n            \t\t\t/*\t\r\n            \t\t\t *\tresult : list of binds renaming the variables of the binds to the variables of the clause\r\n            \t\t\t *\tcorresponding to these variables in the rule\'s conclusion, for example : rename ?c into ?y\t\r\n            \t\t\t *\t\t\t\r\n            \t\t\t * TODO: \r\n            \t\t\t * clause = ?x R ?x ; clauseRule = ?y R ?z\r\n            \t\t\t * check that ?y = ?z in the bind\r\n            \t\t\t * \r\n            \t\t\t */\r\n            \t\t\t\r\n            \t\t\tif (debug){\r\n                   \t\t\tSystem.out.println("back result: " + lb1);\r\n            \t\t\t}\r\n            \t\t\t\r\n            \t\t\tlb = lb.union(lb1.rename(clauseRule, clause, bind));\r\n            \t\t\t\r\n            \t\t\tif (debug){\r\n                   \t\t\tSystem.out.println(clauseRule);\r\n                 \t\t\tSystem.out.println(clause);\r\n                \t\t\tSystem.out.println("back union: " + lb);\r\n            \t\t\t}\r\n            \t\t\t\r\n            \t\t}\r\n                  \r\n                }\r\n            }\r\n            return lb;\r\n        }\r\n        \r\n        void watch(){\r\n        \ttry {\r\n\t\t\t\tSystem.in.read();\r\n\t\t\t} catch (IOException e) {\r\n\t\t\t\t// TODO Auto-generated catch block\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n        }\r\n      \r\n}\r\n\r\n'
====================================================================================================
'package fr.inria.edelweiss.engine.core;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.apache.log4j.Logger;\n\n//import fr.inria.acacia.corese.event.Event;\n//import fr.inria.acacia.corese.event.EventManager;\n//import fr.inria.acacia.corese.event.RuleEvent;\nimport fr.inria.acacia.corese.triple.api.ElementClause;\nimport fr.inria.edelweiss.engine.model.api.Bind;\nimport fr.inria.edelweiss.engine.model.api.Clause;\nimport fr.inria.edelweiss.engine.model.api.ExpFilter;\nimport fr.inria.edelweiss.engine.model.api.LBind;\nimport fr.inria.edelweiss.engine.model.api.Query;\nimport fr.inria.edelweiss.engine.model.api.Rule;\nimport fr.inria.edelweiss.engine.model.api.RuleBase;\nimport fr.inria.edelweiss.engine.model.core.LBindImpl;\nimport fr.inria.edelweiss.engine.tool.api.EventsTreatment;\n\npublic class Backward {\n\tprivate static Logger logger = Logger.getLogger(Backward.class);\n\n\t\t/**\n\t     * ruleBase: { construct {?a grandFather ?c} where {?a father ?b . ?b father ?c} }\n\t     * eventBase: {John father Mark. Mark father Pierre}\n\t     */\n\t\n\t\t//the base of rules\n\t    private RuleBase ruleBase;\n\t   // private EventManager manager;\n\t    private EventsTreatment sparql;\n\t    \n\n\t    private Stack stack;\n\t    \n\t    private boolean \n\t    \t// sparql query for level = 0, i.e. for initial clause\n\t    \t// we may skip sparql query for initial clause in some case\n\t    \t// e.g. when clause is only defined by a proof\n\t    \thasQuery = true,\n\t    \thasEvent = false, \n\t    \ttrace = !true, \n\t    \tdebug = !true;\n\t    \n\t    int count = 0, loop;\n\t   \n\t    public Backward(RuleBase ruleBase, EventsTreatment proc) {\n\t\t\tthis.ruleBase = ruleBase;\n\t\t\tsparql = proc;\n\t\t\tstack = new Stack();\n\t\t}\n\t    \n//\t    void setEventManager(EventManager em){\n//\t    \tmanager = em;\n//\t\t\thasEvent = manager.handle(Event.RULE);\n//\t    }\n\t\n\t\tpublic LBind prove(Query query, Bind bind){\n\t\t\tdebug = query.getASTQuery().isDebug();\n\t\t\tif (debug){\n\t\t\t\tSystem.out.println("** RuleBase: " );\n\t\t\t\tfor (Rule rr : ruleBase){\n\t\t\t\t\tSystem.out.println(rr);\n\t\t\t\t}\n\t\t\t\tSystem.out.println("** end" );\n\t\t\t}\n\t\t\treturn prove(query, query.getClauses(), bind, 0, 0);\n\t\t}\n\t\t\n\t\tint getLoop(){\n\t\t\treturn loop;\n\t\t}\n\t\t\n\t\t/**\n\t\t * Query is the AST of the clauses to prove\n\t\t * clauses is the list of clause to prove\n\t\t * bind is the current partial variable binding\n\t\t * n is the index of current clause in the clauses list\n\t\t * level is the recursive level of backward rule calls\n\t\t * level = 0 means the initial clause to prove \n\t\t * \n\t\t *  TODO: \n\t\t *  compile filters only once for all bindings\n\t\t *  when filter fails there is no event\n\t\t *\n\t\t */\n\t\tpublic LBind prove(Query query, List<Clause> clauses, \n\t\t\t\tBind bind, int n, int level){\n\t\t\tLBind lb;\n\t\t\tloop++;\n\t\t\tif (level > count){\n\t\t\t\tcount = level;\n\t\t\t\t//System.out.println(level);\n\t\t\t}\n\n\t\t\tif (n == clauses.size()){\n\t\t\t\t// never happens\n\t\t\t\tlb = new  LBindImpl();\n\t\t\t\tlb.add(bind);\n\t\t\t\treturn lb;\n\t\t\t}\n\n\t\t\tif (query.isSparql()){\n\t\t\t\t// this is a pure SPARQL query, no backward here:\n\n//\t\t\t\tif (hasEvent){ \n//\t\t\t\t\t// ASTQuery is the Abstract Syntax Tree of the query\n//\t\t\t\t\tRuleEvent e = \n//\t\t\t\t\t\tRuleEvent.create(Event.RULE_SPARQL, level, n, query.getASTQuery());\n//\t\t\t\t\tmanager.send(e);\t\t\n//\t\t\t\t}\n\n\t\t\t\tlb = sparql.searchTriples(query, clauses, bind);\n\n\t\t\t\treturn lb;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif (query.getFilters().size() > 0 ){\n\t\t\t\t// test filters that would need only current bind and no clause\n\n\t\t\t\tif (! checkFilters(query, null, bind, level, n)){\n\t\t\t\t\t// a filter is not valid : fail right now\n\t\t\t\t\treturn new LBindImpl();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\n\t\t\t//Iteration of the clauses of the query\n\t\t\tClause clause = clauses.get(n);\n\t\t\t\n\n//\t\t\tif (hasEvent){ \n//\t\t\t\t// announce current clause\n//\t\t\t\tRuleEvent e = \n//\t\t\t\t\tRuleEvent.create(Event.RULE_PROVE, level, n, clause.getTriple());\n//\t\t\t\tmanager.send(e);\t\t\n//\t\t\t}\n\n\t\t\t\n\t\t\t// search  triples matching the clause in the RDF store \n\t\t\t// and check appropriate filters\n\n\t\t\tLBind lbQuery = sparql.searchTriples(query, clause, bind);\n\t\t\t\n\t\t\tif (debug){\n\t\t\t\tSystem.out.println("sparql: "+ clause + " level: " + level);\n\t\t\t\tSystem.out.println("bind: " + bind);\n\t\t\t\tSystem.out.println("result: " + lbQuery);\n\t\t\t\tSystem.out.println("__");\n\t\t\t}\n\t\t\t\n//\t\t\tif (hasEvent){ \n//\t\t\t\t// we try to prove current clause by querying the graph\n//\t\t\t\tRuleEvent e = \n//\t\t\t\t\tRuleEvent.create(Event.RULE_SPARQL, level, n, clause.getTriple());\n//\t\t\t\te.addObject(lbQuery);\n//\t\t\t\tmanager.send(e);\t\t\n//\t\t\t}\n\t\t\t\n\t\t\tLBind lbProve;\n\t\t\t\t\t\t\t\t\t\n\t\t\tif (clause.isGround()){\n\t\t\t\t// e.g. clause = xxx rdf:type owl:TransitiveProperty\n\t\t\t\t// no backward for this clause, search only in RDF store\n\t\t\t\tlbProve = lbQuery;\n\t\t\t\tlbQuery = new LBindImpl();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prove clause using the backward algorithm\n\t\t\t\t\tlbProve = backward(clause, bind, level, n);\n\t\t\t}\n\n\t\t\t// now we check filters that concern current clause in backward\n\t\t\tif (query.getFilters().size() > 0 ){\n\n\t\t\t\tfor (Bind bProve : lbProve){\t\n\t\t\t\t\t\n\t\t\t\t\tif (checkFilters(query, clause, bProve, level, n)){\n\t\t\t\t\t\tlbQuery = lbQuery.union(bProve);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlb = lbQuery;\n\t\t\t}\n\t\t\telse {\t\t\t\t\t\t\t\t\n\t\t\t\t//union of the two lists of binds above, SPARQL and backward\n\t\t\t\tlb = lbQuery.union(lbProve);\n\t\t\t}\n\t\t\t\n\t\t\tif (debug){\n\t\t\t\tSystem.out.println("union: sparql: " + lbQuery);\n\t\t\t\tSystem.out.println("union: prove: " + lbProve);\n\t\t\t\tSystem.out.println("union: " + lb);\n\t\t\t}\n\n\n//\t\t\tif (hasEvent){ \n//\t\t\t\t// we have tried to prove current clause\n//\t\t\t\tRuleEvent e = \n//\t\t\t\t\tRuleEvent.create(Event.RULE_PROVED, level, n, clause.getTriple());\n//\t\t\t\t// current bindings\n//\t\t\t\te.addObject(lb);\n//\t\t\t\tmanager.send(e);\t\t\n//\t\t\t}\n\n\t\t\tn++;\n\n\t\t\tif (n < clauses.size()){\n\t\t\t\t// yet another clause\n\n\t\t\t\tLBind lbRec = new LBindImpl();\n\n\t\t\t\tfor (Bind b : lb){\n\t\t\t\t\t// for each binding, \n\t\t\t\t\t// call the function prove with the rest of the query  \n\t\t\t\t\tLBind lbRecProve = prove (query, clauses, b, n, level);\n\n\t\t\t\t\tlbRec = lbRec.union(lbRecProve);\n\t\t\t\t}\n\n\t\t\t\t//recover the lasts bindings\n\t\t\t\tlb = lbRec;\n\t\t\t}\n\n\n\t\t\treturn lb;\n\t\t}\t\n\n\t\t\n\t\tboolean checkFilters(Query query, Clause clause, Bind bind, int level, int n){\n\t\t\tfor (ExpFilter filter: query.getFilters()){\n\n\t\t\t\tif (filter.isCorresponding(clause, bind)){\n\t\t\t\t\t// filter share variables with clause: evaluate it\n\t\t\t\t\tif (! sparql.test(query, filter, bind, level, n)){\n\t\t\t\t\t\treturn false;\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t\n\t\t\n\t\tboolean isPropertyVariable(Clause clause, Bind bind){\n\t\t\tElementClause property = clause.get(Clause.PROPERTY);\n\t\t\tif (property.isVariable() &&\n\t\t\t\t\t! bind.hasVariable(property.getName())){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse return false;\n\t\t}\n\n\n        /**\n         * clause: John grandFather ?y\n         * bind: {}\n         * case rule = construct {?a grandFather ?c} where {?a father ?b . ?b father ?c} \n         * rule.match(clause,bind) -> true \n         * bind.get(rule.getHead(), clause) -> {?a = John}\n         * lb1.rename(rule.getHead(), clause) : rename ?c into ?y in the list of binds lb1 \n         */\n\n        public LBind backward(Clause clause, Bind bind, int level, int n){\n        \t\n            LBind lb1 = null, lb = new LBindImpl();\n            \n            //iteration of the base of rules\n            for (Rule rule : ruleBase){\n           \t\n            \t// draft to prevent loop \n            \tif (stack.contains(rule, clause, bind)){\n            \t\tcontinue;\n            \t}\n            \t\n\n            \t// get  clauses of  rule matching the clause of the query\n            \tList<Clause> list = rule.match(clause, bind);\n\n            \tfor (Clause clauseRule : list){\n            \t\t\n                \t// rule match the clause,  considering the bind\n            \t\t\n//            \t\tif (hasEvent){\n//                \t\tRuleEvent e = \n//                \t\t\tRuleEvent.create(Event.RULE_BACK, level, n, clause.getTriple());\n//                \t\te.addObject(rule.getRuleInstance());\n//                \t\te.addObject(bind);\n//                \t\tmanager.send(e);\n//                \t}\n                \t           \t\t           \t\t\n                \t// call the method prove with the premises of the rule \n                \t// if clause variables are bound\n            \t\t// generate a new bind were bindings are attached to the\n            \t\t// rule clause variables \n            \t\t// (rename clause variables into rule variables)\n            \t\t\n            \t\t//if (debug) System.out.println("back unify");\n            \t\t\n            \t\tBind unified =  bind.unify(clauseRule, clause);\n            \t\t\n            \t\tif (debug){\n//            \t\t\tSystem.out.println("back unify: " + clauseRule);\n//            \t\t\tSystem.out.println("back unify: " + clause);\n//            \t\t\tSystem.out.println("back unify: " + unified);\n            \t\t}\n\n            \t\tif (unified != null){\n                   \t\tstack.push(rule, clause, clauseRule, bind);\n\n                   \t\tif (debug){\n                   \t\t\t//System.out.println(level + ": " + rule.getID() + " " + clauseRule.getTriple() + " " + clause + " " + unified);\n                   \t\t\tSystem.out.println("prove: " + clause );\n                   \t\t\tSystem.out.println("with:  " + clauseRule.getTriple() + " " + unified);\n                   \t\t\tSystem.out.println(stack);\n                   \t\t\twatch();\n                   \t\t}\n                   \t \n            \t\t\tlb1 = prove(rule.getBody(), rule.getBody().getClauses(), \n            \t\t\t\t\tunified, 0, level+1);\n\n            \t\t\tstack.pop();\n\n            \t\t\t/*\t\n            \t\t\t *\tresult : list of binds renaming the variables of the binds to the variables of the clause\n            \t\t\t *\tcorresponding to these variables in the rule\'s conclusion, for example : rename ?c into ?y\t\n            \t\t\t *\t\t\t\n            \t\t\t * TODO: \n            \t\t\t * clause = ?x R ?x ; clauseRule = ?y R ?z\n            \t\t\t * check that ?y = ?z in the bind\n            \t\t\t * \n            \t\t\t */\n            \t\t\t\n            \t\t\tif (debug){\n                   \t\t\tSystem.out.println("back result: " + lb1);\n            \t\t\t}\n            \t\t\t\n            \t\t\tlb = lb.union(lb1.rename(clauseRule, clause, bind));\n            \t\t\t\n            \t\t\tif (debug){\n                   \t\t\tSystem.out.println(clauseRule);\n                 \t\t\tSystem.out.println(clause);\n                \t\t\tSystem.out.println("back union: " + lb);\n            \t\t\t}\n            \t\t\t\n            \t\t}\n                  \n                }\n            }\n            return lb;\n        }\n        \n        void watch(){\n        \ttry {\n\t\t\t\tSystem.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n        }\n      \n}\n\n'