[
    {
        "rev_path": "Plan/src/main/java/com/djrapitops/plan/system/database/databases/sql/MySQLDB.java",
        "definition": "public class MySQLDB extends SQLDB {\n\n    protected DataSource dataSource;\n\n    public MySQLDB() {\n    }\n\n    /**\n     * Setups the {@link HikariDataSource}\n     */\n    @Override\n    public void setupDataSource() throws DBInitException {\n        HikariConfig config = new HikariConfig();\n\n        String host = Settings.DB_HOST.toString();\n        String port = Integer.toString(Settings.DB_PORT.getNumber());\n        String database = Settings.DB_DATABASE.toString();\n        String launchOptions = Settings.DB_LAUNCH_OPTIONS.toString();\n        if (launchOptions.isEmpty() || !launchOptions.startsWith(\"?\") || launchOptions.endsWith(\"&\")) {\n            Log.error(\"Launch Options were faulty, using default (?rewriteBatchedStatements=true&useSSL=false)\");\n            launchOptions = \"?rewriteBatchedStatements=true&useSSL=false\";\n        }\n        config.setJdbcUrl(\"jdbc:mysql://\" + host + \":\" + port + \"/\" + database + launchOptions);\n\n        String username = Settings.DB_USER.toString();\n        String password = Settings.DB_PASS.toString();\n\n        config.setUsername(username);\n        config.setPassword(password);\n\n        config.setPoolName(\"Plan Connection Pool\");\n        config.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\n        config.setAutoCommit(true);\n        config.setReadOnly(false);\n        config.setMaximumPoolSize(8);\n\n        this.dataSource = new HikariDataSource(config);\n    }\n\n    /**\n     * @return the name of the Database\n     */\n    @Override\n    public String getName() {\n        return \"MySQL\";\n    }\n\n    @Override\n    public Connection getConnection() throws SQLException {\n        return dataSource.getConnection();\n    }\n\n    @Override\n    public void close() {\n        if (dataSource instanceof HikariDataSource) {\n            ((HikariDataSource) dataSource).close();\n        }\n        super.close();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        MySQLDB mySQLDB = (MySQLDB) o;\n        return Objects.equals(dataSource, mySQLDB.dataSource);\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(super.hashCode(), dataSource);\n    }\n}",
        "package": "package com.djrapitops.plan.system.database.databases.sql;",
        "tree_path": "MySQLDB",
        "name": "MySQLDB",
        "modifiers": "public",
        "superclass": "extends SQLDB",
        "super_interfaces": null,
        "body": "{\n\n    protected DataSource dataSource;\n\n    public MySQLDB() {\n    }\n\n    /**\n     * Setups the {@link HikariDataSource}\n     */\n    @Override\n    public void setupDataSource() throws DBInitException {\n        HikariConfig config = new HikariConfig();\n\n        String host = Settings.DB_HOST.toString();\n        String port = Integer.toString(Settings.DB_PORT.getNumber());\n        String database = Settings.DB_DATABASE.toString();\n        String launchOptions = Settings.DB_LAUNCH_OPTIONS.toString();\n        if (launchOptions.isEmpty() || !launchOptions.startsWith(\"?\") || launchOptions.endsWith(\"&\")) {\n            Log.error(\"Launch Options were faulty, using default (?rewriteBatchedStatements=true&useSSL=false)\");\n            launchOptions = \"?rewriteBatchedStatements=true&useSSL=false\";\n        }\n        config.setJdbcUrl(\"jdbc:mysql://\" + host + \":\" + port + \"/\" + database + launchOptions);\n\n        String username = Settings.DB_USER.toString();\n        String password = Settings.DB_PASS.toString();\n\n        config.setUsername(username);\n        config.setPassword(password);\n\n        config.setPoolName(\"Plan Connection Pool\");\n        config.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\n        config.setAutoCommit(true);\n        config.setReadOnly(false);\n        config.setMaximumPoolSize(8);\n\n        this.dataSource = new HikariDataSource(config);\n    }\n\n    /**\n     * @return the name of the Database\n     */\n    @Override\n    public String getName() {\n        return \"MySQL\";\n    }\n\n    @Override\n    public Connection getConnection() throws SQLException {\n        return dataSource.getConnection();\n    }\n\n    @Override\n    public void close() {\n        if (dataSource instanceof HikariDataSource) {\n            ((HikariDataSource) dataSource).close();\n        }\n        super.close();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        MySQLDB mySQLDB = (MySQLDB) o;\n        return Objects.equals(dataSource, mySQLDB.dataSource);\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(super.hashCode(), dataSource);\n    }\n}",
        "start_point": {
            "row": 16,
            "column": 0
        },
        "end_point": {
            "row": 91,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public MySQLDB() {\n}",
                "name": "MySQLDB",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 20,
                    "column": 4
                },
                "end_point": {
                    "row": 21,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setupDataSource() throws DBInitException {\n    HikariConfig config = new HikariConfig();\n\n    String host = Settings.DB_HOST.toString();\n    String port = Integer.toString(Settings.DB_PORT.getNumber());\n    String database = Settings.DB_DATABASE.toString();\n    String launchOptions = Settings.DB_LAUNCH_OPTIONS.toString();\n    if (launchOptions.isEmpty() || !launchOptions.startsWith(\"?\") || launchOptions.endsWith(\"&\")) {\n        Log.error(\"Launch Options were faulty, using default (?rewriteBatchedStatements=true&useSSL=false)\");\n        launchOptions = \"?rewriteBatchedStatements=true&useSSL=false\";\n    }\n    config.setJdbcUrl(\"jdbc:mysql://\" + host + \":\" + port + \"/\" + database + launchOptions);\n\n    String username = Settings.DB_USER.toString();\n    String password = Settings.DB_PASS.toString();\n\n    config.setUsername(username);\n    config.setPassword(password);\n\n    config.setPoolName(\"Plan Connection Pool\");\n    config.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\n    config.setAutoCommit(true);\n    config.setReadOnly(false);\n    config.setMaximumPoolSize(8);\n\n    this.dataSource = new HikariDataSource(config);\n}",
                "name": "setupDataSource",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    HikariConfig config = new HikariConfig();\n\n    String host = Settings.DB_HOST.toString();\n    String port = Integer.toString(Settings.DB_PORT.getNumber());\n    String database = Settings.DB_DATABASE.toString();\n    String launchOptions = Settings.DB_LAUNCH_OPTIONS.toString();\n    if (launchOptions.isEmpty() || !launchOptions.startsWith(\"?\") || launchOptions.endsWith(\"&\")) {\n        Log.error(\"Launch Options were faulty, using default (?rewriteBatchedStatements=true&useSSL=false)\");\n        launchOptions = \"?rewriteBatchedStatements=true&useSSL=false\";\n    }\n    config.setJdbcUrl(\"jdbc:mysql://\" + host + \":\" + port + \"/\" + database + launchOptions);\n\n    String username = Settings.DB_USER.toString();\n    String password = Settings.DB_PASS.toString();\n\n    config.setUsername(username);\n    config.setPassword(password);\n\n    config.setPoolName(\"Plan Connection Pool\");\n    config.setDriverClassName(\"com.mysql.jdbc.Driver\");\n\n    config.setAutoCommit(true);\n    config.setReadOnly(false);\n    config.setMaximumPoolSize(8);\n\n    this.dataSource = new HikariDataSource(config);\n}",
                "start_point": {
                    "row": 26,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String getName() {\n    return \"MySQL\";\n}",
                "name": "getName",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"MySQL\";\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 62,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Connection getConnection() throws SQLException {\n    return dataSource.getConnection();\n}",
                "name": "getConnection",
                "modifiers": "@Override\n    public",
                "return_type": "Connection",
                "parameters": [],
                "body": "{\n    return dataSource.getConnection();\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 67,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void close() {\n    if (dataSource instanceof HikariDataSource) {\n        ((HikariDataSource) dataSource).close();\n    }\n    super.close();\n}",
                "name": "close",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    if (dataSource instanceof HikariDataSource) {\n        ((HikariDataSource) dataSource).close();\n    }\n    super.close();\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    MySQLDB mySQLDB = (MySQLDB) o;\n    return Objects.equals(dataSource, mySQLDB.dataSource);\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    MySQLDB mySQLDB = (MySQLDB) o;\n    return Objects.equals(dataSource, mySQLDB.dataSource);\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n\n    return Objects.hash(super.hashCode(), dataSource);\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n\n    return Objects.hash(super.hashCode(), dataSource);\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 90,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "Plan/src/main/java/com/djrapitops/plan/system/database/databases/sql/SQLDB.java",
        "definition": "public abstract class SQLDB extends Database {\n\n    private final UsersTable usersTable;\n    private final UserInfoTable userInfoTable;\n    private final KillsTable killsTable;\n    private final NicknamesTable nicknamesTable;\n    private final SessionsTable sessionsTable;\n    private final GeoInfoTable geoInfoTable;\n    private final CommandUseTable commandUseTable;\n    private final TPSTable tpsTable;\n    private final VersionTable versionTable;\n    private final SecurityTable securityTable;\n    private final WorldTable worldTable;\n    private final WorldTimesTable worldTimesTable;\n    private final ServerTable serverTable;\n    private final TransferTable transferTable;\n    private final PingTable pingTable;\n\n    private final SQLBackupOps backupOps;\n    private final SQLCheckOps checkOps;\n    private final SQLFetchOps fetchOps;\n    private final SQLRemoveOps removeOps;\n    private final SQLSearchOps searchOps;\n    private final SQLCountOps countOps;\n    private final SQLSaveOps saveOps;\n    private final SQLTransferOps transferOps;\n\n    private final boolean usingMySQL;\n    private ITask dbCleanTask;\n\n    public SQLDB() {\n        usingMySQL = getName().equals(\"MySQL\");\n\n        versionTable = new VersionTable(this);\n        serverTable = new ServerTable(this);\n        securityTable = new SecurityTable(this);\n\n        commandUseTable = new CommandUseTable(this);\n        tpsTable = new TPSTable(this);\n\n        usersTable = new UsersTable(this);\n        userInfoTable = new UserInfoTable(this);\n        geoInfoTable = new GeoInfoTable(this);\n        nicknamesTable = new NicknamesTable(this);\n        sessionsTable = new SessionsTable(this);\n        killsTable = new KillsTable(this);\n        worldTable = new WorldTable(this);\n        worldTimesTable = new WorldTimesTable(this);\n        transferTable = new TransferTable(this);\n        pingTable = new PingTable(this);\n\n        backupOps = new SQLBackupOps(this);\n        checkOps = new SQLCheckOps(this);\n        fetchOps = new SQLFetchOps(this);\n        removeOps = new SQLRemoveOps(this);\n        countOps = new SQLCountOps(this);\n        searchOps = new SQLSearchOps(this);\n        saveOps = new SQLSaveOps(this);\n        transferOps = new SQLTransferOps(this);\n    }\n\n    /**\n     * Initializes the Database.\n     * <p>\n     * All tables exist in the database after call to this.\n     * Updates Schema to latest version.\n     * Converts Unsaved Bukkit player files to database data.\n     * Cleans the database.\n     *\n     * @throws DBInitException if Database fails to initiate.\n     */\n    @Override\n    public void init() throws DBInitException {\n        open = true;\n        setupDataSource();\n        setupDatabase();\n    }\n\n    @Override\n    public void scheduleClean(long secondsDelay) {\n        dbCleanTask = RunnableFactory.createNew(\"DB Clean Task\", new AbsRunnable() {\n            @Override\n            public void run() {\n                try {\n                    if (isOpen()) {\n                        clean();\n                    }\n                } catch (DBOpException e) {\n                    Log.toLog(this.getClass(), e);\n                    cancel();\n                }\n            }\n        }).runTaskTimerAsynchronously(TimeAmount.SECOND.ticks() * secondsDelay, TimeAmount.MINUTE.ticks() * 5L);\n    }\n\n    /**\n     * Ensures connection functions correctly and all tables exist.\n     * <p>\n     * Updates to latest schema.\n     *\n     * @throws DBInitException if something goes wrong.\n     */\n    public void setupDatabase() throws DBInitException {\n        try {\n            boolean newDatabase = versionTable.isNewDatabase();\n\n            versionTable.createTable();\n            createTables();\n\n            if (newDatabase) {\n                Log.info(\"New Database created.\");\n                versionTable.setVersion(19);\n            }\n\n            int version = versionTable.getVersion();\n\n            final SQLDB db = this;\n            if (version < 10) {\n                RunnableFactory.createNew(\"DB v8 -> v10 Task\", new AbsRunnable() {\n                    @Override\n                    public void run() {\n                        try {\n                            new Version8TransferTable(db).alterTablesToV10();\n                        } catch (DBInitException | DBOpException e) {\n                            Log.toLog(this.getClass(), e);\n                        }\n                    }\n                }).runTaskLaterAsynchronously(TimeAmount.SECOND.ticks() * 5L);\n            }\n            if (version < 11) {\n                serverTable.alterTableV11();\n                versionTable.setVersion(11);\n            }\n            if (version < 12) {\n                geoInfoTable.alterTableV12();\n                versionTable.setVersion(12);\n            }\n            if (version < 13) {\n                geoInfoTable.alterTableV13();\n                versionTable.setVersion(13);\n            }\n            if (version < 14) {\n                transferTable.alterTableV14();\n                versionTable.setVersion(14);\n            }\n            if (version < 15) {\n                sessionsTable.alterTableV15();\n                versionTable.setVersion(15);\n            }\n            if (version < 16) {\n                killsTable.alterTableV16();\n                worldTimesTable.alterTableV16();\n                versionTable.setVersion(16);\n            }\n            if (version < 17) {\n                geoInfoTable.alterTableV17();\n                versionTable.setVersion(17);\n            }\n            if (version < 18) {\n                geoInfoTable.alterTableV18();\n                // version set in the runnable in above method\n            }\n            if (version < 19) {\n                nicknamesTable.alterTableV19();\n            }\n        } catch (DBOpException e) {\n            throw new DBInitException(\"Failed to set-up Database\", e);\n        }\n    }\n\n    /**\n     * Creates the tables that contain data.\n     * <p>\n     * Updates table columns to latest schema.\n     */\n    private void createTables() throws DBInitException {\n        for (Table table : getAllTables()) {\n            table.createTable();\n        }\n    }\n\n    /**\n     * Get all tables in a create order.\n     *\n     * @return Table array.\n     */\n    public Table[] getAllTables() {\n        return new Table[]{\n                serverTable, usersTable, userInfoTable, geoInfoTable,\n                nicknamesTable, sessionsTable, killsTable, pingTable,\n                commandUseTable, tpsTable, worldTable,\n                worldTimesTable, securityTable, transferTable\n        };\n    }\n\n    /**\n     * Get all tables for removal of data.\n     *\n     * @return Tables in the order the data should be removed in.\n     */\n    public Table[] getAllTablesInRemoveOrder() {\n        return new Table[]{\n                transferTable, geoInfoTable, nicknamesTable, killsTable,\n                worldTimesTable, sessionsTable, worldTable, pingTable,\n                userInfoTable, usersTable, commandUseTable,\n                tpsTable, securityTable, serverTable\n        };\n    }\n\n    public abstract void setupDataSource() throws DBInitException;\n\n    @Override\n    public void close() {\n        open = false;\n        if (dbCleanTask != null) {\n            dbCleanTask.cancel();\n        }\n    }\n\n    public int getVersion() {\n        return versionTable.getVersion();\n    }\n\n    public void setVersion(int version) {\n        versionTable.setVersion(version);\n    }\n\n    private void clean() {\n        tpsTable.clean();\n        transferTable.clean();\n        geoInfoTable.clean();\n        pingTable.clean();\n\n        long now = System.currentTimeMillis();\n        long keepActiveAfter = now - TimeAmount.DAY.ms() * Settings.KEEP_INACTIVE_PLAYERS_DAYS.getNumber();\n\n        List<UUID> inactivePlayers = sessionsTable.getLastSeenForAllPlayers().entrySet().stream()\n                .filter(entry -> entry.getValue() < keepActiveAfter)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n        for (UUID uuid : inactivePlayers) {\n            removeOps.player(uuid);\n        }\n        int removed = inactivePlayers.size();\n        if (removed > 0) {\n            Log.info(\"Removed data of \" + removed + \" players.\");\n        }\n    }\n\n    public abstract Connection getConnection() throws SQLException;\n\n    /**\n     * Commits changes to the .db file when using SQLite Database.\n     * <p>\n     * MySQL has Auto Commit enabled.\n     */\n    public void commit(Connection connection) {\n        try {\n            if (!usingMySQL) {\n                connection.commit();\n            }\n        } catch (SQLException e) {\n            if (!e.getMessage().contains(\"cannot commit\")) {\n                Log.toLog(this.getClass(), e);\n            }\n        } finally {\n            returnToPool(connection);\n        }\n    }\n\n    public void returnToPool(Connection connection) {\n        try {\n            if (usingMySQL && connection != null) {\n                connection.close();\n            }\n        } catch (SQLException e) {\n            Log.toLog(this.getClass(), e);\n        }\n    }\n\n    /**\n     * Reverts transaction when using SQLite Database.\n     * <p>\n     * MySQL has Auto Commit enabled.\n     */\n    public void rollback(Connection connection) throws SQLException {\n        try {\n            if (!usingMySQL) {\n                connection.rollback();\n            }\n        } finally {\n            returnToPool(connection);\n        }\n    }\n\n    public boolean execute(ExecStatement statement) {\n        Connection connection = null;\n        try {\n            connection = getConnection();\n            try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n                return statement.execute(preparedStatement);\n            }\n        } catch (SQLException e) {\n            throw DBOpException.forCause(statement.getSql(), e);\n        } finally {\n            commit(connection);\n        }\n    }\n\n    public void executeBatch(ExecStatement statement) {\n        Connection connection = null;\n        try {\n            connection = getConnection();\n            try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n                statement.executeBatch(preparedStatement);\n            }\n        } catch (SQLException e) {\n            throw DBOpException.forCause(statement.getSql(), e);\n        } finally {\n            commit(connection);\n        }\n    }\n\n    public <T> T query(QueryStatement<T> statement) {\n        Connection connection = null;\n        try {\n            connection = getConnection();\n            try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n                return statement.executeQuery(preparedStatement);\n            }\n        } catch (SQLException e) {\n            throw DBOpException.forCause(statement.getSql(), e);\n        } finally {\n            returnToPool(connection);\n        }\n    }\n\n    public UsersTable getUsersTable() {\n        return usersTable;\n    }\n\n    public SessionsTable getSessionsTable() {\n        return sessionsTable;\n    }\n\n    public KillsTable getKillsTable() {\n        return killsTable;\n    }\n\n    public GeoInfoTable getGeoInfoTable() {\n        return geoInfoTable;\n    }\n\n    public NicknamesTable getNicknamesTable() {\n        return nicknamesTable;\n    }\n\n    public CommandUseTable getCommandUseTable() {\n        return commandUseTable;\n    }\n\n    public TPSTable getTpsTable() {\n        return tpsTable;\n    }\n\n    public SecurityTable getSecurityTable() {\n        return securityTable;\n    }\n\n    public WorldTable getWorldTable() {\n        return worldTable;\n    }\n\n    public WorldTimesTable getWorldTimesTable() {\n        return worldTimesTable;\n    }\n\n    public ServerTable getServerTable() {\n        return serverTable;\n    }\n\n    public UserInfoTable getUserInfoTable() {\n        return userInfoTable;\n    }\n\n    public TransferTable getTransferTable() {\n        return transferTable;\n    }\n\n    public PingTable getPingTable() {\n        return pingTable;\n    }\n\n    public boolean isUsingMySQL() {\n        return usingMySQL;\n    }\n\n    @Override\n    public BackupOperations backup() {\n        return backupOps;\n    }\n\n    @Override\n    public CheckOperations check() {\n        return checkOps;\n    }\n\n    @Override\n    public FetchOperations fetch() {\n        return fetchOps;\n    }\n\n    @Override\n    public RemoveOperations remove() {\n        return removeOps;\n    }\n\n    @Override\n    public SearchOperations search() {\n        return searchOps;\n    }\n\n    @Override\n    public CountOperations count() {\n        return countOps;\n    }\n\n    @Override\n    public SaveOperations save() {\n        return saveOps;\n    }\n\n    @Override\n    public TransferOperations transfer() {\n        return transferOps;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SQLDB sqldb = (SQLDB) o;\n        return usingMySQL == sqldb.usingMySQL && getName().equals(sqldb.getName());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(usingMySQL, getName());\n    }\n}",
        "package": "package com.djrapitops.plan.system.database.databases.sql;",
        "tree_path": "SQLDB",
        "name": "SQLDB",
        "modifiers": "public abstract",
        "superclass": "extends Database",
        "super_interfaces": null,
        "body": "{\n\n    private final UsersTable usersTable;\n    private final UserInfoTable userInfoTable;\n    private final KillsTable killsTable;\n    private final NicknamesTable nicknamesTable;\n    private final SessionsTable sessionsTable;\n    private final GeoInfoTable geoInfoTable;\n    private final CommandUseTable commandUseTable;\n    private final TPSTable tpsTable;\n    private final VersionTable versionTable;\n    private final SecurityTable securityTable;\n    private final WorldTable worldTable;\n    private final WorldTimesTable worldTimesTable;\n    private final ServerTable serverTable;\n    private final TransferTable transferTable;\n    private final PingTable pingTable;\n\n    private final SQLBackupOps backupOps;\n    private final SQLCheckOps checkOps;\n    private final SQLFetchOps fetchOps;\n    private final SQLRemoveOps removeOps;\n    private final SQLSearchOps searchOps;\n    private final SQLCountOps countOps;\n    private final SQLSaveOps saveOps;\n    private final SQLTransferOps transferOps;\n\n    private final boolean usingMySQL;\n    private ITask dbCleanTask;\n\n    public SQLDB() {\n        usingMySQL = getName().equals(\"MySQL\");\n\n        versionTable = new VersionTable(this);\n        serverTable = new ServerTable(this);\n        securityTable = new SecurityTable(this);\n\n        commandUseTable = new CommandUseTable(this);\n        tpsTable = new TPSTable(this);\n\n        usersTable = new UsersTable(this);\n        userInfoTable = new UserInfoTable(this);\n        geoInfoTable = new GeoInfoTable(this);\n        nicknamesTable = new NicknamesTable(this);\n        sessionsTable = new SessionsTable(this);\n        killsTable = new KillsTable(this);\n        worldTable = new WorldTable(this);\n        worldTimesTable = new WorldTimesTable(this);\n        transferTable = new TransferTable(this);\n        pingTable = new PingTable(this);\n\n        backupOps = new SQLBackupOps(this);\n        checkOps = new SQLCheckOps(this);\n        fetchOps = new SQLFetchOps(this);\n        removeOps = new SQLRemoveOps(this);\n        countOps = new SQLCountOps(this);\n        searchOps = new SQLSearchOps(this);\n        saveOps = new SQLSaveOps(this);\n        transferOps = new SQLTransferOps(this);\n    }\n\n    /**\n     * Initializes the Database.\n     * <p>\n     * All tables exist in the database after call to this.\n     * Updates Schema to latest version.\n     * Converts Unsaved Bukkit player files to database data.\n     * Cleans the database.\n     *\n     * @throws DBInitException if Database fails to initiate.\n     */\n    @Override\n    public void init() throws DBInitException {\n        open = true;\n        setupDataSource();\n        setupDatabase();\n    }\n\n    @Override\n    public void scheduleClean(long secondsDelay) {\n        dbCleanTask = RunnableFactory.createNew(\"DB Clean Task\", new AbsRunnable() {\n            @Override\n            public void run() {\n                try {\n                    if (isOpen()) {\n                        clean();\n                    }\n                } catch (DBOpException e) {\n                    Log.toLog(this.getClass(), e);\n                    cancel();\n                }\n            }\n        }).runTaskTimerAsynchronously(TimeAmount.SECOND.ticks() * secondsDelay, TimeAmount.MINUTE.ticks() * 5L);\n    }\n\n    /**\n     * Ensures connection functions correctly and all tables exist.\n     * <p>\n     * Updates to latest schema.\n     *\n     * @throws DBInitException if something goes wrong.\n     */\n    public void setupDatabase() throws DBInitException {\n        try {\n            boolean newDatabase = versionTable.isNewDatabase();\n\n            versionTable.createTable();\n            createTables();\n\n            if (newDatabase) {\n                Log.info(\"New Database created.\");\n                versionTable.setVersion(19);\n            }\n\n            int version = versionTable.getVersion();\n\n            final SQLDB db = this;\n            if (version < 10) {\n                RunnableFactory.createNew(\"DB v8 -> v10 Task\", new AbsRunnable() {\n                    @Override\n                    public void run() {\n                        try {\n                            new Version8TransferTable(db).alterTablesToV10();\n                        } catch (DBInitException | DBOpException e) {\n                            Log.toLog(this.getClass(), e);\n                        }\n                    }\n                }).runTaskLaterAsynchronously(TimeAmount.SECOND.ticks() * 5L);\n            }\n            if (version < 11) {\n                serverTable.alterTableV11();\n                versionTable.setVersion(11);\n            }\n            if (version < 12) {\n                geoInfoTable.alterTableV12();\n                versionTable.setVersion(12);\n            }\n            if (version < 13) {\n                geoInfoTable.alterTableV13();\n                versionTable.setVersion(13);\n            }\n            if (version < 14) {\n                transferTable.alterTableV14();\n                versionTable.setVersion(14);\n            }\n            if (version < 15) {\n                sessionsTable.alterTableV15();\n                versionTable.setVersion(15);\n            }\n            if (version < 16) {\n                killsTable.alterTableV16();\n                worldTimesTable.alterTableV16();\n                versionTable.setVersion(16);\n            }\n            if (version < 17) {\n                geoInfoTable.alterTableV17();\n                versionTable.setVersion(17);\n            }\n            if (version < 18) {\n                geoInfoTable.alterTableV18();\n                // version set in the runnable in above method\n            }\n            if (version < 19) {\n                nicknamesTable.alterTableV19();\n            }\n        } catch (DBOpException e) {\n            throw new DBInitException(\"Failed to set-up Database\", e);\n        }\n    }\n\n    /**\n     * Creates the tables that contain data.\n     * <p>\n     * Updates table columns to latest schema.\n     */\n    private void createTables() throws DBInitException {\n        for (Table table : getAllTables()) {\n            table.createTable();\n        }\n    }\n\n    /**\n     * Get all tables in a create order.\n     *\n     * @return Table array.\n     */\n    public Table[] getAllTables() {\n        return new Table[]{\n                serverTable, usersTable, userInfoTable, geoInfoTable,\n                nicknamesTable, sessionsTable, killsTable, pingTable,\n                commandUseTable, tpsTable, worldTable,\n                worldTimesTable, securityTable, transferTable\n        };\n    }\n\n    /**\n     * Get all tables for removal of data.\n     *\n     * @return Tables in the order the data should be removed in.\n     */\n    public Table[] getAllTablesInRemoveOrder() {\n        return new Table[]{\n                transferTable, geoInfoTable, nicknamesTable, killsTable,\n                worldTimesTable, sessionsTable, worldTable, pingTable,\n                userInfoTable, usersTable, commandUseTable,\n                tpsTable, securityTable, serverTable\n        };\n    }\n\n    public abstract void setupDataSource() throws DBInitException;\n\n    @Override\n    public void close() {\n        open = false;\n        if (dbCleanTask != null) {\n            dbCleanTask.cancel();\n        }\n    }\n\n    public int getVersion() {\n        return versionTable.getVersion();\n    }\n\n    public void setVersion(int version) {\n        versionTable.setVersion(version);\n    }\n\n    private void clean() {\n        tpsTable.clean();\n        transferTable.clean();\n        geoInfoTable.clean();\n        pingTable.clean();\n\n        long now = System.currentTimeMillis();\n        long keepActiveAfter = now - TimeAmount.DAY.ms() * Settings.KEEP_INACTIVE_PLAYERS_DAYS.getNumber();\n\n        List<UUID> inactivePlayers = sessionsTable.getLastSeenForAllPlayers().entrySet().stream()\n                .filter(entry -> entry.getValue() < keepActiveAfter)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toList());\n        for (UUID uuid : inactivePlayers) {\n            removeOps.player(uuid);\n        }\n        int removed = inactivePlayers.size();\n        if (removed > 0) {\n            Log.info(\"Removed data of \" + removed + \" players.\");\n        }\n    }\n\n    public abstract Connection getConnection() throws SQLException;\n\n    /**\n     * Commits changes to the .db file when using SQLite Database.\n     * <p>\n     * MySQL has Auto Commit enabled.\n     */\n    public void commit(Connection connection) {\n        try {\n            if (!usingMySQL) {\n                connection.commit();\n            }\n        } catch (SQLException e) {\n            if (!e.getMessage().contains(\"cannot commit\")) {\n                Log.toLog(this.getClass(), e);\n            }\n        } finally {\n            returnToPool(connection);\n        }\n    }\n\n    public void returnToPool(Connection connection) {\n        try {\n            if (usingMySQL && connection != null) {\n                connection.close();\n            }\n        } catch (SQLException e) {\n            Log.toLog(this.getClass(), e);\n        }\n    }\n\n    /**\n     * Reverts transaction when using SQLite Database.\n     * <p>\n     * MySQL has Auto Commit enabled.\n     */\n    public void rollback(Connection connection) throws SQLException {\n        try {\n            if (!usingMySQL) {\n                connection.rollback();\n            }\n        } finally {\n            returnToPool(connection);\n        }\n    }\n\n    public boolean execute(ExecStatement statement) {\n        Connection connection = null;\n        try {\n            connection = getConnection();\n            try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n                return statement.execute(preparedStatement);\n            }\n        } catch (SQLException e) {\n            throw DBOpException.forCause(statement.getSql(), e);\n        } finally {\n            commit(connection);\n        }\n    }\n\n    public void executeBatch(ExecStatement statement) {\n        Connection connection = null;\n        try {\n            connection = getConnection();\n            try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n                statement.executeBatch(preparedStatement);\n            }\n        } catch (SQLException e) {\n            throw DBOpException.forCause(statement.getSql(), e);\n        } finally {\n            commit(connection);\n        }\n    }\n\n    public <T> T query(QueryStatement<T> statement) {\n        Connection connection = null;\n        try {\n            connection = getConnection();\n            try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n                return statement.executeQuery(preparedStatement);\n            }\n        } catch (SQLException e) {\n            throw DBOpException.forCause(statement.getSql(), e);\n        } finally {\n            returnToPool(connection);\n        }\n    }\n\n    public UsersTable getUsersTable() {\n        return usersTable;\n    }\n\n    public SessionsTable getSessionsTable() {\n        return sessionsTable;\n    }\n\n    public KillsTable getKillsTable() {\n        return killsTable;\n    }\n\n    public GeoInfoTable getGeoInfoTable() {\n        return geoInfoTable;\n    }\n\n    public NicknamesTable getNicknamesTable() {\n        return nicknamesTable;\n    }\n\n    public CommandUseTable getCommandUseTable() {\n        return commandUseTable;\n    }\n\n    public TPSTable getTpsTable() {\n        return tpsTable;\n    }\n\n    public SecurityTable getSecurityTable() {\n        return securityTable;\n    }\n\n    public WorldTable getWorldTable() {\n        return worldTable;\n    }\n\n    public WorldTimesTable getWorldTimesTable() {\n        return worldTimesTable;\n    }\n\n    public ServerTable getServerTable() {\n        return serverTable;\n    }\n\n    public UserInfoTable getUserInfoTable() {\n        return userInfoTable;\n    }\n\n    public TransferTable getTransferTable() {\n        return transferTable;\n    }\n\n    public PingTable getPingTable() {\n        return pingTable;\n    }\n\n    public boolean isUsingMySQL() {\n        return usingMySQL;\n    }\n\n    @Override\n    public BackupOperations backup() {\n        return backupOps;\n    }\n\n    @Override\n    public CheckOperations check() {\n        return checkOps;\n    }\n\n    @Override\n    public FetchOperations fetch() {\n        return fetchOps;\n    }\n\n    @Override\n    public RemoveOperations remove() {\n        return removeOps;\n    }\n\n    @Override\n    public SearchOperations search() {\n        return searchOps;\n    }\n\n    @Override\n    public CountOperations count() {\n        return countOps;\n    }\n\n    @Override\n    public SaveOperations save() {\n        return saveOps;\n    }\n\n    @Override\n    public TransferOperations transfer() {\n        return transferOps;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        SQLDB sqldb = (SQLDB) o;\n        return usingMySQL == sqldb.usingMySQL && getName().equals(sqldb.getName());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(usingMySQL, getName());\n    }\n}",
        "start_point": {
            "row": 33,
            "column": 0
        },
        "end_point": {
            "row": 482,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public SQLDB() {\n    usingMySQL = getName().equals(\"MySQL\");\n\n    versionTable = new VersionTable(this);\n    serverTable = new ServerTable(this);\n    securityTable = new SecurityTable(this);\n\n    commandUseTable = new CommandUseTable(this);\n    tpsTable = new TPSTable(this);\n\n    usersTable = new UsersTable(this);\n    userInfoTable = new UserInfoTable(this);\n    geoInfoTable = new GeoInfoTable(this);\n    nicknamesTable = new NicknamesTable(this);\n    sessionsTable = new SessionsTable(this);\n    killsTable = new KillsTable(this);\n    worldTable = new WorldTable(this);\n    worldTimesTable = new WorldTimesTable(this);\n    transferTable = new TransferTable(this);\n    pingTable = new PingTable(this);\n\n    backupOps = new SQLBackupOps(this);\n    checkOps = new SQLCheckOps(this);\n    fetchOps = new SQLFetchOps(this);\n    removeOps = new SQLRemoveOps(this);\n    countOps = new SQLCountOps(this);\n    searchOps = new SQLSearchOps(this);\n    saveOps = new SQLSaveOps(this);\n    transferOps = new SQLTransferOps(this);\n}",
                "name": "SQLDB",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    usingMySQL = getName().equals(\"MySQL\");\n\n    versionTable = new VersionTable(this);\n    serverTable = new ServerTable(this);\n    securityTable = new SecurityTable(this);\n\n    commandUseTable = new CommandUseTable(this);\n    tpsTable = new TPSTable(this);\n\n    usersTable = new UsersTable(this);\n    userInfoTable = new UserInfoTable(this);\n    geoInfoTable = new GeoInfoTable(this);\n    nicknamesTable = new NicknamesTable(this);\n    sessionsTable = new SessionsTable(this);\n    killsTable = new KillsTable(this);\n    worldTable = new WorldTable(this);\n    worldTimesTable = new WorldTimesTable(this);\n    transferTable = new TransferTable(this);\n    pingTable = new PingTable(this);\n\n    backupOps = new SQLBackupOps(this);\n    checkOps = new SQLCheckOps(this);\n    fetchOps = new SQLFetchOps(this);\n    removeOps = new SQLRemoveOps(this);\n    countOps = new SQLCountOps(this);\n    searchOps = new SQLSearchOps(this);\n    saveOps = new SQLSaveOps(this);\n    transferOps = new SQLTransferOps(this);\n}",
                "constructor": true,
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 92,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void init() throws DBInitException {\n    open = true;\n    setupDataSource();\n    setupDatabase();\n}",
                "name": "init",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    open = true;\n    setupDataSource();\n    setupDatabase();\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void scheduleClean(long secondsDelay) {\n    dbCleanTask = RunnableFactory.createNew(\"DB Clean Task\", new AbsRunnable() {\n        @Override\n        public void run() {\n            try {\n                if (isOpen()) {\n                    clean();\n                }\n            } catch (DBOpException e) {\n                Log.toLog(this.getClass(), e);\n                cancel();\n            }\n        }\n    }).runTaskTimerAsynchronously(TimeAmount.SECOND.ticks() * secondsDelay, TimeAmount.MINUTE.ticks() * 5L);\n}",
                "name": "scheduleClean",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "long",
                        "name": "secondsDelay"
                    }
                ],
                "body": "{\n    dbCleanTask = RunnableFactory.createNew(\"DB Clean Task\", new AbsRunnable() {\n        @Override\n        public void run() {\n            try {\n                if (isOpen()) {\n                    clean();\n                }\n            } catch (DBOpException e) {\n                Log.toLog(this.getClass(), e);\n                cancel();\n            }\n        }\n    }).runTaskTimerAsynchronously(TimeAmount.SECOND.ticks() * secondsDelay, TimeAmount.MINUTE.ticks() * 5L);\n}",
                "start_point": {
                    "row": 111,
                    "column": 4
                },
                "end_point": {
                    "row": 126,
                    "column": 5
                }
            },
            {
                "definition": "public void setupDatabase() throws DBInitException {\n    try {\n        boolean newDatabase = versionTable.isNewDatabase();\n\n        versionTable.createTable();\n        createTables();\n\n        if (newDatabase) {\n            Log.info(\"New Database created.\");\n            versionTable.setVersion(19);\n        }\n\n        int version = versionTable.getVersion();\n\n        final SQLDB db = this;\n        if (version < 10) {\n            RunnableFactory.createNew(\"DB v8 -> v10 Task\", new AbsRunnable() {\n                @Override\n                public void run() {\n                    try {\n                        new Version8TransferTable(db).alterTablesToV10();\n                    } catch (DBInitException | DBOpException e) {\n                        Log.toLog(this.getClass(), e);\n                    }\n                }\n            }).runTaskLaterAsynchronously(TimeAmount.SECOND.ticks() * 5L);\n        }\n        if (version < 11) {\n            serverTable.alterTableV11();\n            versionTable.setVersion(11);\n        }\n        if (version < 12) {\n            geoInfoTable.alterTableV12();\n            versionTable.setVersion(12);\n        }\n        if (version < 13) {\n            geoInfoTable.alterTableV13();\n            versionTable.setVersion(13);\n        }\n        if (version < 14) {\n            transferTable.alterTableV14();\n            versionTable.setVersion(14);\n        }\n        if (version < 15) {\n            sessionsTable.alterTableV15();\n            versionTable.setVersion(15);\n        }\n        if (version < 16) {\n            killsTable.alterTableV16();\n            worldTimesTable.alterTableV16();\n            versionTable.setVersion(16);\n        }\n        if (version < 17) {\n            geoInfoTable.alterTableV17();\n            versionTable.setVersion(17);\n        }\n        if (version < 18) {\n            geoInfoTable.alterTableV18();\n            // version set in the runnable in above method\n        }\n        if (version < 19) {\n            nicknamesTable.alterTableV19();\n        }\n    } catch (DBOpException e) {\n        throw new DBInitException(\"Failed to set-up Database\", e);\n    }\n}",
                "name": "setupDatabase",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    try {\n        boolean newDatabase = versionTable.isNewDatabase();\n\n        versionTable.createTable();\n        createTables();\n\n        if (newDatabase) {\n            Log.info(\"New Database created.\");\n            versionTable.setVersion(19);\n        }\n\n        int version = versionTable.getVersion();\n\n        final SQLDB db = this;\n        if (version < 10) {\n            RunnableFactory.createNew(\"DB v8 -> v10 Task\", new AbsRunnable() {\n                @Override\n                public void run() {\n                    try {\n                        new Version8TransferTable(db).alterTablesToV10();\n                    } catch (DBInitException | DBOpException e) {\n                        Log.toLog(this.getClass(), e);\n                    }\n                }\n            }).runTaskLaterAsynchronously(TimeAmount.SECOND.ticks() * 5L);\n        }\n        if (version < 11) {\n            serverTable.alterTableV11();\n            versionTable.setVersion(11);\n        }\n        if (version < 12) {\n            geoInfoTable.alterTableV12();\n            versionTable.setVersion(12);\n        }\n        if (version < 13) {\n            geoInfoTable.alterTableV13();\n            versionTable.setVersion(13);\n        }\n        if (version < 14) {\n            transferTable.alterTableV14();\n            versionTable.setVersion(14);\n        }\n        if (version < 15) {\n            sessionsTable.alterTableV15();\n            versionTable.setVersion(15);\n        }\n        if (version < 16) {\n            killsTable.alterTableV16();\n            worldTimesTable.alterTableV16();\n            versionTable.setVersion(16);\n        }\n        if (version < 17) {\n            geoInfoTable.alterTableV17();\n            versionTable.setVersion(17);\n        }\n        if (version < 18) {\n            geoInfoTable.alterTableV18();\n            // version set in the runnable in above method\n        }\n        if (version < 19) {\n            nicknamesTable.alterTableV19();\n        }\n    } catch (DBOpException e) {\n        throw new DBInitException(\"Failed to set-up Database\", e);\n    }\n}",
                "start_point": {
                    "row": 135,
                    "column": 4
                },
                "end_point": {
                    "row": 201,
                    "column": 5
                }
            },
            {
                "definition": "private void createTables() throws DBInitException {\n    for (Table table : getAllTables()) {\n        table.createTable();\n    }\n}",
                "name": "createTables",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    for (Table table : getAllTables()) {\n        table.createTable();\n    }\n}",
                "start_point": {
                    "row": 208,
                    "column": 4
                },
                "end_point": {
                    "row": 212,
                    "column": 5
                }
            },
            {
                "definition": "public Table[] getAllTables() {\n    return new Table[]{\n            serverTable, usersTable, userInfoTable, geoInfoTable,\n            nicknamesTable, sessionsTable, killsTable, pingTable,\n            commandUseTable, tpsTable, worldTable,\n            worldTimesTable, securityTable, transferTable\n    };\n}",
                "name": "getAllTables",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return new Table[]{\n            serverTable, usersTable, userInfoTable, geoInfoTable,\n            nicknamesTable, sessionsTable, killsTable, pingTable,\n            commandUseTable, tpsTable, worldTable,\n            worldTimesTable, securityTable, transferTable\n    };\n}",
                "start_point": {
                    "row": 219,
                    "column": 4
                },
                "end_point": {
                    "row": 226,
                    "column": 5
                }
            },
            {
                "definition": "public Table[] getAllTablesInRemoveOrder() {\n    return new Table[]{\n            transferTable, geoInfoTable, nicknamesTable, killsTable,\n            worldTimesTable, sessionsTable, worldTable, pingTable,\n            userInfoTable, usersTable, commandUseTable,\n            tpsTable, securityTable, serverTable\n    };\n}",
                "name": "getAllTablesInRemoveOrder",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return new Table[]{\n            transferTable, geoInfoTable, nicknamesTable, killsTable,\n            worldTimesTable, sessionsTable, worldTable, pingTable,\n            userInfoTable, usersTable, commandUseTable,\n            tpsTable, securityTable, serverTable\n    };\n}",
                "start_point": {
                    "row": 233,
                    "column": 4
                },
                "end_point": {
                    "row": 240,
                    "column": 5
                }
            },
            {
                "definition": "public abstract void setupDataSource() throws DBInitException;",
                "name": "setupDataSource",
                "modifiers": "public abstract",
                "return_type": null,
                "parameters": [],
                "body": null,
                "start_point": {
                    "row": 242,
                    "column": 4
                },
                "end_point": {
                    "row": 242,
                    "column": 66
                }
            },
            {
                "definition": "@Override\npublic void close() {\n    open = false;\n    if (dbCleanTask != null) {\n        dbCleanTask.cancel();\n    }\n}",
                "name": "close",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    open = false;\n    if (dbCleanTask != null) {\n        dbCleanTask.cancel();\n    }\n}",
                "start_point": {
                    "row": 244,
                    "column": 4
                },
                "end_point": {
                    "row": 250,
                    "column": 5
                }
            },
            {
                "definition": "public int getVersion() {\n    return versionTable.getVersion();\n}",
                "name": "getVersion",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return versionTable.getVersion();\n}",
                "start_point": {
                    "row": 252,
                    "column": 4
                },
                "end_point": {
                    "row": 254,
                    "column": 5
                }
            },
            {
                "definition": "public void setVersion(int version) {\n    versionTable.setVersion(version);\n}",
                "name": "setVersion",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "int",
                        "name": "version"
                    }
                ],
                "body": "{\n    versionTable.setVersion(version);\n}",
                "start_point": {
                    "row": 256,
                    "column": 4
                },
                "end_point": {
                    "row": 258,
                    "column": 5
                }
            },
            {
                "definition": "private void clean() {\n    tpsTable.clean();\n    transferTable.clean();\n    geoInfoTable.clean();\n    pingTable.clean();\n\n    long now = System.currentTimeMillis();\n    long keepActiveAfter = now - TimeAmount.DAY.ms() * Settings.KEEP_INACTIVE_PLAYERS_DAYS.getNumber();\n\n    List<UUID> inactivePlayers = sessionsTable.getLastSeenForAllPlayers().entrySet().stream()\n            .filter(entry -> entry.getValue() < keepActiveAfter)\n            .map(Map.Entry::getKey)\n            .collect(Collectors.toList());\n    for (UUID uuid : inactivePlayers) {\n        removeOps.player(uuid);\n    }\n    int removed = inactivePlayers.size();\n    if (removed > 0) {\n        Log.info(\"Removed data of \" + removed + \" players.\");\n    }\n}",
                "name": "clean",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    tpsTable.clean();\n    transferTable.clean();\n    geoInfoTable.clean();\n    pingTable.clean();\n\n    long now = System.currentTimeMillis();\n    long keepActiveAfter = now - TimeAmount.DAY.ms() * Settings.KEEP_INACTIVE_PLAYERS_DAYS.getNumber();\n\n    List<UUID> inactivePlayers = sessionsTable.getLastSeenForAllPlayers().entrySet().stream()\n            .filter(entry -> entry.getValue() < keepActiveAfter)\n            .map(Map.Entry::getKey)\n            .collect(Collectors.toList());\n    for (UUID uuid : inactivePlayers) {\n        removeOps.player(uuid);\n    }\n    int removed = inactivePlayers.size();\n    if (removed > 0) {\n        Log.info(\"Removed data of \" + removed + \" players.\");\n    }\n}",
                "start_point": {
                    "row": 260,
                    "column": 4
                },
                "end_point": {
                    "row": 280,
                    "column": 5
                }
            },
            {
                "definition": "public abstract Connection getConnection() throws SQLException;",
                "name": "getConnection",
                "modifiers": "public abstract",
                "return_type": "Connection",
                "parameters": [],
                "body": null,
                "start_point": {
                    "row": 282,
                    "column": 4
                },
                "end_point": {
                    "row": 282,
                    "column": 67
                }
            },
            {
                "definition": "public void commit(Connection connection) {\n    try {\n        if (!usingMySQL) {\n            connection.commit();\n        }\n    } catch (SQLException e) {\n        if (!e.getMessage().contains(\"cannot commit\")) {\n            Log.toLog(this.getClass(), e);\n        }\n    } finally {\n        returnToPool(connection);\n    }\n}",
                "name": "commit",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Connection",
                        "name": "connection"
                    }
                ],
                "body": "{\n    try {\n        if (!usingMySQL) {\n            connection.commit();\n        }\n    } catch (SQLException e) {\n        if (!e.getMessage().contains(\"cannot commit\")) {\n            Log.toLog(this.getClass(), e);\n        }\n    } finally {\n        returnToPool(connection);\n    }\n}",
                "start_point": {
                    "row": 289,
                    "column": 4
                },
                "end_point": {
                    "row": 301,
                    "column": 5
                }
            },
            {
                "definition": "public void returnToPool(Connection connection) {\n    try {\n        if (usingMySQL && connection != null) {\n            connection.close();\n        }\n    } catch (SQLException e) {\n        Log.toLog(this.getClass(), e);\n    }\n}",
                "name": "returnToPool",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Connection",
                        "name": "connection"
                    }
                ],
                "body": "{\n    try {\n        if (usingMySQL && connection != null) {\n            connection.close();\n        }\n    } catch (SQLException e) {\n        Log.toLog(this.getClass(), e);\n    }\n}",
                "start_point": {
                    "row": 303,
                    "column": 4
                },
                "end_point": {
                    "row": 311,
                    "column": 5
                }
            },
            {
                "definition": "public void rollback(Connection connection) throws SQLException {\n    try {\n        if (!usingMySQL) {\n            connection.rollback();\n        }\n    } finally {\n        returnToPool(connection);\n    }\n}",
                "name": "rollback",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Connection",
                        "name": "connection"
                    }
                ],
                "body": "{\n    try {\n        if (!usingMySQL) {\n            connection.rollback();\n        }\n    } finally {\n        returnToPool(connection);\n    }\n}",
                "start_point": {
                    "row": 318,
                    "column": 4
                },
                "end_point": {
                    "row": 326,
                    "column": 5
                }
            },
            {
                "definition": "public boolean execute(ExecStatement statement) {\n    Connection connection = null;\n    try {\n        connection = getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n            return statement.execute(preparedStatement);\n        }\n    } catch (SQLException e) {\n        throw DBOpException.forCause(statement.getSql(), e);\n    } finally {\n        commit(connection);\n    }\n}",
                "name": "execute",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ExecStatement",
                        "name": "statement"
                    }
                ],
                "body": "{\n    Connection connection = null;\n    try {\n        connection = getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n            return statement.execute(preparedStatement);\n        }\n    } catch (SQLException e) {\n        throw DBOpException.forCause(statement.getSql(), e);\n    } finally {\n        commit(connection);\n    }\n}",
                "start_point": {
                    "row": 328,
                    "column": 4
                },
                "end_point": {
                    "row": 340,
                    "column": 5
                }
            },
            {
                "definition": "public void executeBatch(ExecStatement statement) {\n    Connection connection = null;\n    try {\n        connection = getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n            statement.executeBatch(preparedStatement);\n        }\n    } catch (SQLException e) {\n        throw DBOpException.forCause(statement.getSql(), e);\n    } finally {\n        commit(connection);\n    }\n}",
                "name": "executeBatch",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ExecStatement",
                        "name": "statement"
                    }
                ],
                "body": "{\n    Connection connection = null;\n    try {\n        connection = getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n            statement.executeBatch(preparedStatement);\n        }\n    } catch (SQLException e) {\n        throw DBOpException.forCause(statement.getSql(), e);\n    } finally {\n        commit(connection);\n    }\n}",
                "start_point": {
                    "row": 342,
                    "column": 4
                },
                "end_point": {
                    "row": 354,
                    "column": 5
                }
            },
            {
                "definition": "public <T> T query(QueryStatement<T> statement) {\n    Connection connection = null;\n    try {\n        connection = getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n            return statement.executeQuery(preparedStatement);\n        }\n    } catch (SQLException e) {\n        throw DBOpException.forCause(statement.getSql(), e);\n    } finally {\n        returnToPool(connection);\n    }\n}",
                "name": "query",
                "modifiers": "public",
                "return_type": "T",
                "parameters": [
                    {
                        "type": "QueryStatement<T>",
                        "name": "statement"
                    }
                ],
                "body": "{\n    Connection connection = null;\n    try {\n        connection = getConnection();\n        try (PreparedStatement preparedStatement = connection.prepareStatement(statement.getSql())) {\n            return statement.executeQuery(preparedStatement);\n        }\n    } catch (SQLException e) {\n        throw DBOpException.forCause(statement.getSql(), e);\n    } finally {\n        returnToPool(connection);\n    }\n}",
                "start_point": {
                    "row": 356,
                    "column": 4
                },
                "end_point": {
                    "row": 368,
                    "column": 5
                }
            },
            {
                "definition": "public UsersTable getUsersTable() {\n    return usersTable;\n}",
                "name": "getUsersTable",
                "modifiers": "public",
                "return_type": "UsersTable",
                "parameters": [],
                "body": "{\n    return usersTable;\n}",
                "start_point": {
                    "row": 370,
                    "column": 4
                },
                "end_point": {
                    "row": 372,
                    "column": 5
                }
            },
            {
                "definition": "public SessionsTable getSessionsTable() {\n    return sessionsTable;\n}",
                "name": "getSessionsTable",
                "modifiers": "public",
                "return_type": "SessionsTable",
                "parameters": [],
                "body": "{\n    return sessionsTable;\n}",
                "start_point": {
                    "row": 374,
                    "column": 4
                },
                "end_point": {
                    "row": 376,
                    "column": 5
                }
            },
            {
                "definition": "public KillsTable getKillsTable() {\n    return killsTable;\n}",
                "name": "getKillsTable",
                "modifiers": "public",
                "return_type": "KillsTable",
                "parameters": [],
                "body": "{\n    return killsTable;\n}",
                "start_point": {
                    "row": 378,
                    "column": 4
                },
                "end_point": {
                    "row": 380,
                    "column": 5
                }
            },
            {
                "definition": "public GeoInfoTable getGeoInfoTable() {\n    return geoInfoTable;\n}",
                "name": "getGeoInfoTable",
                "modifiers": "public",
                "return_type": "GeoInfoTable",
                "parameters": [],
                "body": "{\n    return geoInfoTable;\n}",
                "start_point": {
                    "row": 382,
                    "column": 4
                },
                "end_point": {
                    "row": 384,
                    "column": 5
                }
            },
            {
                "definition": "public NicknamesTable getNicknamesTable() {\n    return nicknamesTable;\n}",
                "name": "getNicknamesTable",
                "modifiers": "public",
                "return_type": "NicknamesTable",
                "parameters": [],
                "body": "{\n    return nicknamesTable;\n}",
                "start_point": {
                    "row": 386,
                    "column": 4
                },
                "end_point": {
                    "row": 388,
                    "column": 5
                }
            },
            {
                "definition": "public CommandUseTable getCommandUseTable() {\n    return commandUseTable;\n}",
                "name": "getCommandUseTable",
                "modifiers": "public",
                "return_type": "CommandUseTable",
                "parameters": [],
                "body": "{\n    return commandUseTable;\n}",
                "start_point": {
                    "row": 390,
                    "column": 4
                },
                "end_point": {
                    "row": 392,
                    "column": 5
                }
            },
            {
                "definition": "public TPSTable getTpsTable() {\n    return tpsTable;\n}",
                "name": "getTpsTable",
                "modifiers": "public",
                "return_type": "TPSTable",
                "parameters": [],
                "body": "{\n    return tpsTable;\n}",
                "start_point": {
                    "row": 394,
                    "column": 4
                },
                "end_point": {
                    "row": 396,
                    "column": 5
                }
            },
            {
                "definition": "public SecurityTable getSecurityTable() {\n    return securityTable;\n}",
                "name": "getSecurityTable",
                "modifiers": "public",
                "return_type": "SecurityTable",
                "parameters": [],
                "body": "{\n    return securityTable;\n}",
                "start_point": {
                    "row": 398,
                    "column": 4
                },
                "end_point": {
                    "row": 400,
                    "column": 5
                }
            },
            {
                "definition": "public WorldTable getWorldTable() {\n    return worldTable;\n}",
                "name": "getWorldTable",
                "modifiers": "public",
                "return_type": "WorldTable",
                "parameters": [],
                "body": "{\n    return worldTable;\n}",
                "start_point": {
                    "row": 402,
                    "column": 4
                },
                "end_point": {
                    "row": 404,
                    "column": 5
                }
            },
            {
                "definition": "public WorldTimesTable getWorldTimesTable() {\n    return worldTimesTable;\n}",
                "name": "getWorldTimesTable",
                "modifiers": "public",
                "return_type": "WorldTimesTable",
                "parameters": [],
                "body": "{\n    return worldTimesTable;\n}",
                "start_point": {
                    "row": 406,
                    "column": 4
                },
                "end_point": {
                    "row": 408,
                    "column": 5
                }
            },
            {
                "definition": "public ServerTable getServerTable() {\n    return serverTable;\n}",
                "name": "getServerTable",
                "modifiers": "public",
                "return_type": "ServerTable",
                "parameters": [],
                "body": "{\n    return serverTable;\n}",
                "start_point": {
                    "row": 410,
                    "column": 4
                },
                "end_point": {
                    "row": 412,
                    "column": 5
                }
            },
            {
                "definition": "public UserInfoTable getUserInfoTable() {\n    return userInfoTable;\n}",
                "name": "getUserInfoTable",
                "modifiers": "public",
                "return_type": "UserInfoTable",
                "parameters": [],
                "body": "{\n    return userInfoTable;\n}",
                "start_point": {
                    "row": 414,
                    "column": 4
                },
                "end_point": {
                    "row": 416,
                    "column": 5
                }
            },
            {
                "definition": "public TransferTable getTransferTable() {\n    return transferTable;\n}",
                "name": "getTransferTable",
                "modifiers": "public",
                "return_type": "TransferTable",
                "parameters": [],
                "body": "{\n    return transferTable;\n}",
                "start_point": {
                    "row": 418,
                    "column": 4
                },
                "end_point": {
                    "row": 420,
                    "column": 5
                }
            },
            {
                "definition": "public PingTable getPingTable() {\n    return pingTable;\n}",
                "name": "getPingTable",
                "modifiers": "public",
                "return_type": "PingTable",
                "parameters": [],
                "body": "{\n    return pingTable;\n}",
                "start_point": {
                    "row": 422,
                    "column": 4
                },
                "end_point": {
                    "row": 424,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isUsingMySQL() {\n    return usingMySQL;\n}",
                "name": "isUsingMySQL",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return usingMySQL;\n}",
                "start_point": {
                    "row": 426,
                    "column": 4
                },
                "end_point": {
                    "row": 428,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic BackupOperations backup() {\n    return backupOps;\n}",
                "name": "backup",
                "modifiers": "@Override\n    public",
                "return_type": "BackupOperations",
                "parameters": [],
                "body": "{\n    return backupOps;\n}",
                "start_point": {
                    "row": 430,
                    "column": 4
                },
                "end_point": {
                    "row": 433,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic CheckOperations check() {\n    return checkOps;\n}",
                "name": "check",
                "modifiers": "@Override\n    public",
                "return_type": "CheckOperations",
                "parameters": [],
                "body": "{\n    return checkOps;\n}",
                "start_point": {
                    "row": 435,
                    "column": 4
                },
                "end_point": {
                    "row": 438,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic FetchOperations fetch() {\n    return fetchOps;\n}",
                "name": "fetch",
                "modifiers": "@Override\n    public",
                "return_type": "FetchOperations",
                "parameters": [],
                "body": "{\n    return fetchOps;\n}",
                "start_point": {
                    "row": 440,
                    "column": 4
                },
                "end_point": {
                    "row": 443,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic RemoveOperations remove() {\n    return removeOps;\n}",
                "name": "remove",
                "modifiers": "@Override\n    public",
                "return_type": "RemoveOperations",
                "parameters": [],
                "body": "{\n    return removeOps;\n}",
                "start_point": {
                    "row": 445,
                    "column": 4
                },
                "end_point": {
                    "row": 448,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic SearchOperations search() {\n    return searchOps;\n}",
                "name": "search",
                "modifiers": "@Override\n    public",
                "return_type": "SearchOperations",
                "parameters": [],
                "body": "{\n    return searchOps;\n}",
                "start_point": {
                    "row": 450,
                    "column": 4
                },
                "end_point": {
                    "row": 453,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic CountOperations count() {\n    return countOps;\n}",
                "name": "count",
                "modifiers": "@Override\n    public",
                "return_type": "CountOperations",
                "parameters": [],
                "body": "{\n    return countOps;\n}",
                "start_point": {
                    "row": 455,
                    "column": 4
                },
                "end_point": {
                    "row": 458,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic SaveOperations save() {\n    return saveOps;\n}",
                "name": "save",
                "modifiers": "@Override\n    public",
                "return_type": "SaveOperations",
                "parameters": [],
                "body": "{\n    return saveOps;\n}",
                "start_point": {
                    "row": 460,
                    "column": 4
                },
                "end_point": {
                    "row": 463,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic TransferOperations transfer() {\n    return transferOps;\n}",
                "name": "transfer",
                "modifiers": "@Override\n    public",
                "return_type": "TransferOperations",
                "parameters": [],
                "body": "{\n    return transferOps;\n}",
                "start_point": {
                    "row": 465,
                    "column": 4
                },
                "end_point": {
                    "row": 468,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    SQLDB sqldb = (SQLDB) o;\n    return usingMySQL == sqldb.usingMySQL && getName().equals(sqldb.getName());\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    SQLDB sqldb = (SQLDB) o;\n    return usingMySQL == sqldb.usingMySQL && getName().equals(sqldb.getName());\n}",
                "start_point": {
                    "row": 470,
                    "column": 4
                },
                "end_point": {
                    "row": 476,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    return Objects.hash(usingMySQL, getName());\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Objects.hash(usingMySQL, getName());\n}",
                "start_point": {
                    "row": 478,
                    "column": 4
                },
                "end_point": {
                    "row": 481,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "Plan/src/main/java/com/djrapitops/plan/system/database/databases/sql/SQLiteDB.java",
        "definition": "public class SQLiteDB extends SQLDB {\n\n    private final File databaseFile;\n    private final String dbName;\n    private Connection connection;\n    private ITask connectionPingTask;\n\n    /**\n     * Class Constructor.\n     */\n    public SQLiteDB() {\n        this(\"database\");\n    }\n\n    public SQLiteDB(String dbName) {\n        this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n    }\n\n    public SQLiteDB(File databaseFile) {\n        dbName = databaseFile.getName();\n        this.databaseFile = databaseFile;\n    }\n\n    @Override\n    public void setupDataSource() throws DBInitException {\n        try {\n            connection = getNewConnection(databaseFile);\n        } catch (SQLException e) {\n            throw new DBInitException(e);\n        }\n        startConnectionPingTask();\n    }\n\n    public Connection getNewConnection(File dbFile) throws SQLException {\n        try {\n            Class.forName(\"org.sqlite.JDBC\");\n        } catch (ClassNotFoundException e) {\n            Log.toLog(this.getClass(), e);\n            return null; // Should never happen.\n        }\n\n        String dbFilePath = dbFile.getAbsolutePath();\n\n        Connection newConnection = getConnectionFor(dbFilePath);\n        Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n        newConnection.setAutoCommit(false);\n        return newConnection;\n    }\n\n    private Connection getConnectionFor(String dbFilePath) throws SQLException {\n        try {\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n        } catch (SQLException ignored) {\n            Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n        }\n    }\n\n    private void startConnectionPingTask() {\n        stopConnectionPingTask();\n        try {\n            // Maintains Connection.\n            connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n                @Override\n                public void run() {\n                    Statement statement = null;\n                    ResultSet resultSet = null;\n                    try {\n                        if (connection != null && !connection.isClosed()) {\n                            statement = connection.createStatement();\n                            resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                        }\n                    } catch (SQLException e) {\n                        Log.debug(\"Something went wrong during Ping task.\");\n                        try {\n                            connection = getNewConnection(databaseFile);\n                        } catch (SQLException e1) {\n                            Log.toLog(this.getClass(), e1);\n                            Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                            this.cancel();\n                        }\n                    } finally {\n                        MiscUtils.close(statement, resultSet);\n                    }\n                }\n            }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n        } catch (Exception ignored) {\n        }\n    }\n\n    private void stopConnectionPingTask() {\n        if (connectionPingTask != null) {\n            try {\n                connectionPingTask.cancel();\n            } catch (Exception ignored) {\n            }\n        }\n    }\n\n    /**\n     * @return the name of the Database\n     */\n    @Override\n    public String getName() {\n        return \"SQLite\";\n    }\n\n    @Override\n    public Connection getConnection() throws SQLException {\n        if (connection == null) {\n            connection = getNewConnection(databaseFile);\n        }\n        return connection;\n    }\n\n    @Override\n    public void close() {\n        stopConnectionPingTask();\n        if (connection != null) {\n            Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n            MiscUtils.close(connection);\n        }\n        super.close();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        SQLiteDB sqLiteDB = (SQLiteDB) o;\n        return Objects.equals(dbName, sqLiteDB.dbName);\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(super.hashCode(), dbName);\n    }\n}",
        "package": "package com.djrapitops.plan.system.database.databases.sql;",
        "tree_path": "SQLiteDB",
        "name": "SQLiteDB",
        "modifiers": "public",
        "superclass": "extends SQLDB",
        "super_interfaces": null,
        "body": "{\n\n    private final File databaseFile;\n    private final String dbName;\n    private Connection connection;\n    private ITask connectionPingTask;\n\n    /**\n     * Class Constructor.\n     */\n    public SQLiteDB() {\n        this(\"database\");\n    }\n\n    public SQLiteDB(String dbName) {\n        this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n    }\n\n    public SQLiteDB(File databaseFile) {\n        dbName = databaseFile.getName();\n        this.databaseFile = databaseFile;\n    }\n\n    @Override\n    public void setupDataSource() throws DBInitException {\n        try {\n            connection = getNewConnection(databaseFile);\n        } catch (SQLException e) {\n            throw new DBInitException(e);\n        }\n        startConnectionPingTask();\n    }\n\n    public Connection getNewConnection(File dbFile) throws SQLException {\n        try {\n            Class.forName(\"org.sqlite.JDBC\");\n        } catch (ClassNotFoundException e) {\n            Log.toLog(this.getClass(), e);\n            return null; // Should never happen.\n        }\n\n        String dbFilePath = dbFile.getAbsolutePath();\n\n        Connection newConnection = getConnectionFor(dbFilePath);\n        Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n        newConnection.setAutoCommit(false);\n        return newConnection;\n    }\n\n    private Connection getConnectionFor(String dbFilePath) throws SQLException {\n        try {\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n        } catch (SQLException ignored) {\n            Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n            return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n        }\n    }\n\n    private void startConnectionPingTask() {\n        stopConnectionPingTask();\n        try {\n            // Maintains Connection.\n            connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n                @Override\n                public void run() {\n                    Statement statement = null;\n                    ResultSet resultSet = null;\n                    try {\n                        if (connection != null && !connection.isClosed()) {\n                            statement = connection.createStatement();\n                            resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                        }\n                    } catch (SQLException e) {\n                        Log.debug(\"Something went wrong during Ping task.\");\n                        try {\n                            connection = getNewConnection(databaseFile);\n                        } catch (SQLException e1) {\n                            Log.toLog(this.getClass(), e1);\n                            Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                            this.cancel();\n                        }\n                    } finally {\n                        MiscUtils.close(statement, resultSet);\n                    }\n                }\n            }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n        } catch (Exception ignored) {\n        }\n    }\n\n    private void stopConnectionPingTask() {\n        if (connectionPingTask != null) {\n            try {\n                connectionPingTask.cancel();\n            } catch (Exception ignored) {\n            }\n        }\n    }\n\n    /**\n     * @return the name of the Database\n     */\n    @Override\n    public String getName() {\n        return \"SQLite\";\n    }\n\n    @Override\n    public Connection getConnection() throws SQLException {\n        if (connection == null) {\n            connection = getNewConnection(databaseFile);\n        }\n        return connection;\n    }\n\n    @Override\n    public void close() {\n        stopConnectionPingTask();\n        if (connection != null) {\n            Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n            MiscUtils.close(connection);\n        }\n        super.close();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n        SQLiteDB sqLiteDB = (SQLiteDB) o;\n        return Objects.equals(dbName, sqLiteDB.dbName);\n    }\n\n    @Override\n    public int hashCode() {\n\n        return Objects.hash(super.hashCode(), dbName);\n    }\n}",
        "start_point": {
            "row": 17,
            "column": 0
        },
        "end_point": {
            "row": 156,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public SQLiteDB() {\n    this(\"database\");\n}",
                "name": "SQLiteDB",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    this(\"database\");\n}",
                "constructor": true,
                "start_point": {
                    "row": 27,
                    "column": 4
                },
                "end_point": {
                    "row": 29,
                    "column": 5
                }
            },
            {
                "definition": "public SQLiteDB(String dbName) {\n    this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n}",
                "name": "SQLiteDB",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "dbName"
                    }
                ],
                "body": "{\n    this(new File(PlanPlugin.getInstance().getDataFolder(), dbName + \".db\"));\n}",
                "constructor": true,
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 33,
                    "column": 5
                }
            },
            {
                "definition": "public SQLiteDB(File databaseFile) {\n    dbName = databaseFile.getName();\n    this.databaseFile = databaseFile;\n}",
                "name": "SQLiteDB",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "File",
                        "name": "databaseFile"
                    }
                ],
                "body": "{\n    dbName = databaseFile.getName();\n    this.databaseFile = databaseFile;\n}",
                "constructor": true,
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 38,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setupDataSource() throws DBInitException {\n    try {\n        connection = getNewConnection(databaseFile);\n    } catch (SQLException e) {\n        throw new DBInitException(e);\n    }\n    startConnectionPingTask();\n}",
                "name": "setupDataSource",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    try {\n        connection = getNewConnection(databaseFile);\n    } catch (SQLException e) {\n        throw new DBInitException(e);\n    }\n    startConnectionPingTask();\n}",
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 48,
                    "column": 5
                }
            },
            {
                "definition": "public Connection getNewConnection(File dbFile) throws SQLException {\n    try {\n        Class.forName(\"org.sqlite.JDBC\");\n    } catch (ClassNotFoundException e) {\n        Log.toLog(this.getClass(), e);\n        return null; // Should never happen.\n    }\n\n    String dbFilePath = dbFile.getAbsolutePath();\n\n    Connection newConnection = getConnectionFor(dbFilePath);\n    Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n    newConnection.setAutoCommit(false);\n    return newConnection;\n}",
                "name": "getNewConnection",
                "modifiers": "public",
                "return_type": "Connection",
                "parameters": [
                    {
                        "type": "File",
                        "name": "dbFile"
                    }
                ],
                "body": "{\n    try {\n        Class.forName(\"org.sqlite.JDBC\");\n    } catch (ClassNotFoundException e) {\n        Log.toLog(this.getClass(), e);\n        return null; // Should never happen.\n    }\n\n    String dbFilePath = dbFile.getAbsolutePath();\n\n    Connection newConnection = getConnectionFor(dbFilePath);\n    Log.debug(\"SQLite \" + dbName + \": Opened a new Connection\");\n    newConnection.setAutoCommit(false);\n    return newConnection;\n}",
                "start_point": {
                    "row": 50,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            },
            {
                "definition": "private Connection getConnectionFor(String dbFilePath) throws SQLException {\n    try {\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n    } catch (SQLException ignored) {\n        Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n    }\n}",
                "name": "getConnectionFor",
                "modifiers": "private",
                "return_type": "Connection",
                "parameters": [
                    {
                        "type": "String",
                        "name": "dbFilePath"
                    }
                ],
                "body": "{\n    try {\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath + \"?journal_mode=WAL\");\n    } catch (SQLException ignored) {\n        Log.info(\"SQLite WAL mode not supported on this server version, using default. This may or may not affect performance.\");\n        return DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n    }\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "private void startConnectionPingTask() {\n    stopConnectionPingTask();\n    try {\n        // Maintains Connection.\n        connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n            @Override\n            public void run() {\n                Statement statement = null;\n                ResultSet resultSet = null;\n                try {\n                    if (connection != null && !connection.isClosed()) {\n                        statement = connection.createStatement();\n                        resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                    }\n                } catch (SQLException e) {\n                    Log.debug(\"Something went wrong during Ping task.\");\n                    try {\n                        connection = getNewConnection(databaseFile);\n                    } catch (SQLException e1) {\n                        Log.toLog(this.getClass(), e1);\n                        Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                        this.cancel();\n                    }\n                } finally {\n                    MiscUtils.close(statement, resultSet);\n                }\n            }\n        }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n    } catch (Exception ignored) {\n    }\n}",
                "name": "startConnectionPingTask",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    stopConnectionPingTask();\n    try {\n        // Maintains Connection.\n        connectionPingTask = RunnableFactory.createNew(new AbsRunnable(\"DBConnectionPingTask \" + getName()) {\n            @Override\n            public void run() {\n                Statement statement = null;\n                ResultSet resultSet = null;\n                try {\n                    if (connection != null && !connection.isClosed()) {\n                        statement = connection.createStatement();\n                        resultSet = statement.executeQuery(\"/* ping */ SELECT 1\");\n                    }\n                } catch (SQLException e) {\n                    Log.debug(\"Something went wrong during Ping task.\");\n                    try {\n                        connection = getNewConnection(databaseFile);\n                    } catch (SQLException e1) {\n                        Log.toLog(this.getClass(), e1);\n                        Log.error(\"SQLite connection maintaining task had to be closed due to exception.\");\n                        this.cancel();\n                    }\n                } finally {\n                    MiscUtils.close(statement, resultSet);\n                }\n            }\n        }).runTaskTimerAsynchronously(60L * 20L, 60L * 20L);\n    } catch (Exception ignored) {\n    }\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "private void stopConnectionPingTask() {\n    if (connectionPingTask != null) {\n        try {\n            connectionPingTask.cancel();\n        } catch (Exception ignored) {\n        }\n    }\n}",
                "name": "stopConnectionPingTask",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    if (connectionPingTask != null) {\n        try {\n            connectionPingTask.cancel();\n        } catch (Exception ignored) {\n        }\n    }\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 114,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String getName() {\n    return \"SQLite\";\n}",
                "name": "getName",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"SQLite\";\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 122,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Connection getConnection() throws SQLException {\n    if (connection == null) {\n        connection = getNewConnection(databaseFile);\n    }\n    return connection;\n}",
                "name": "getConnection",
                "modifiers": "@Override\n    public",
                "return_type": "Connection",
                "parameters": [],
                "body": "{\n    if (connection == null) {\n        connection = getNewConnection(databaseFile);\n    }\n    return connection;\n}",
                "start_point": {
                    "row": 124,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void close() {\n    stopConnectionPingTask();\n    if (connection != null) {\n        Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n        MiscUtils.close(connection);\n    }\n    super.close();\n}",
                "name": "close",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    stopConnectionPingTask();\n    if (connection != null) {\n        Log.debug(\"SQLite \" + dbName + \": Closed Connection\");\n        MiscUtils.close(connection);\n    }\n    super.close();\n}",
                "start_point": {
                    "row": 132,
                    "column": 4
                },
                "end_point": {
                    "row": 140,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    SQLiteDB sqLiteDB = (SQLiteDB) o;\n    return Objects.equals(dbName, sqLiteDB.dbName);\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    SQLiteDB sqLiteDB = (SQLiteDB) o;\n    return Objects.equals(dbName, sqLiteDB.dbName);\n}",
                "start_point": {
                    "row": 142,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n\n    return Objects.hash(super.hashCode(), dbName);\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n\n    return Objects.hash(super.hashCode(), dbName);\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 155,
                    "column": 5
                }
            }
        ]
    }
]