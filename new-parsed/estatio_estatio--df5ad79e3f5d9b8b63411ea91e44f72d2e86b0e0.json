[
    {
        "rev_path": "dom/src/main/java/org/estatio/api/Api.java",
        "definition": "@Named(\"Migration\")\npublic class Api extends AbstractFactoryAndRepository {\n\n    @Override\n    public String getId() {\n        return \"api\";\n    }\n\n    public String iconName() {\n        return \"Api\";\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putCountry(\n            @Named(\"code\") String code,\n            @Named(\"alpha2Code\") String alpha2Code,\n            @Named(\"name\") String name) {\n        Country country = countries.findCountry(code);\n        if (country == null) {\n            country = countries.createCountry(code, alpha2Code, name);\n        }\n    }\n\n    private Country fetchCountry(String countryCode) {\n        return fetchCountry(countryCode, true);\n    }\n\n    private Country fetchCountry(String countryCode, boolean exception) {\n        Country country = countries.findCountry(countryCode);\n        if (country == null && exception) {\n            throw new ApplicationException(String.format(\"Country with code %1$s not found\", countryCode));\n        }\n        return country;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putState(\n            @Named(\"code\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"countryCode\") String countryCode) {\n        Country country = fetchCountry(countryCode);\n        State state = states.findState(countryCode);\n        if (state == null) {\n            state = states.newState(reference, name, country);\n        }\n        state.setName(name);\n        state.setCountry(country);\n    }\n\n    private State fetchState(String stateCode, boolean exception) {\n        State country = states.findState(stateCode);\n        if (country == null && exception) {\n            throw new ApplicationException(String.format(\"State with code %1$s not found\", stateCode));\n        }\n        return country;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseType(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name) {\n        leaseTypes.findOrCreate(reference, name);\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putCharge(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"description\") String description,\n            @Named(\"taxReference\") String taxReference,\n            @Named(\"chargeGroupReference\") String chargeGroupReference) {\n        Tax tax = fetchTaxIfAny(taxReference);\n        ChargeGroup chargeGroup = fetchOrCreateChargeGroup(chargeGroupReference);\n        charges.newCharge(reference, name, description, tax, chargeGroup);\n    }\n\n    private Charge fetchCharge(String chargeReference) {\n        Charge charge = charges.findCharge(chargeReference);\n        if (charge == null) {\n            throw new ApplicationException(String.format(\"Charge with reference %s not found.\", chargeReference));\n        }\n        return charge;\n    }\n\n    private ChargeGroup fetchOrCreateChargeGroup(String chargeGroupReference) {\n        ChargeGroup chargeGroup = chargeGroups.findChargeGroup(chargeGroupReference);\n        if (chargeGroup == null) {\n            chargeGroup = chargeGroups.createChargeGroup(chargeGroupReference, null);\n        }\n        return chargeGroup;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putTax(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"percentage\") BigDecimal percentage,\n            @Named(\"startDate\") LocalDate startDate) {\n        Tax tax = fetchTaxIfAny(reference);\n        if (tax == null) {\n            tax = taxes.newTax(reference, name);\n            tax.setName(name);\n        }\n        tax.newRate(startDate, percentage);\n    }\n\n    private Tax fetchTaxIfAny(String reference) {\n        return taxes.findTaxByReference(reference);\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPerson(\n            @Named(\"reference\") String reference,\n            @Named(\"initials\") @Optional String initials,\n            @Named(\"firstName\") String firstName,\n            @Named(\"lastName\") String lastName) {\n        Person person = (Person) parties.findPartyByReference(reference);\n        if (person == null) {\n            person = persons.newPerson(reference, initials, firstName, lastName);\n        }\n        person.setFirstName(firstName);\n        person.setLastName(lastName);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putOrganisation(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"vatCode\") @Optional String vatCode,\n            @Named(\"fiscalCode\") @Optional String fiscalCode) {\n        Organisation org = (Organisation) parties.findPartyByReference(reference);\n        if (org == null) {\n            org = organisations.newOrganisation(reference, name);\n            org.setFiscalCode(fiscalCode);\n            org.setVatCode(vatCode);\n        }\n        org.setName(name);\n    }\n\n    private Party fetchParty(String partyReference) {\n        Party party = parties.findPartyByReference(partyReference);\n        if (party == null) {\n            throw new ApplicationException(String.format(\"Party with reference %s not found.\", partyReference));\n        }\n        return party;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putProperty(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"countryCode\") String countryCode,\n            @Named(\"city\") String city,\n            @Named(\"type\") String type,\n            @Named(\"acquireDate\") @Optional LocalDate acquireDate,\n            @Named(\"disposalDate\") @Optional LocalDate disposalDate,\n            @Named(\"openingDate\") @Optional LocalDate openingDate,\n            @Named(\"ownerReference\") @Optional String ownerReference,\n            @Named(\"numeratorFormat\") @Optional String numeratorFormat\n            ) {\n        Party owner = fetchParty(ownerReference);\n        Property property = fetchProperty(reference, true);\n        property.setName(name);\n        property.setCountry(fetchCountry(countryCode));\n        property.setCity(city);\n        property.setType(PropertyType.valueOf(type));\n        property.setAcquireDate(acquireDate);\n        property.setDisposalDate(disposalDate);\n        property.setOpeningDate(openingDate);\n        property.addRoleIfDoesNotExist(owner, FixedAssetRoleType.PROPERTY_OWNER, null, null);\n        if (numeratorFormat != null)\n            invoices.createInvoiceNumberNumerator(property, numeratorFormat, BigInteger.ZERO);\n    }\n\n    private Property fetchProperty(String reference, boolean createIfNotFond) {\n        Property property = properties.findPropertyByReference(reference);\n        if (property == null) {\n            if (!createIfNotFond)\n                throw new ApplicationException(String.format(\"Property with reference %s not found.\", reference));\n            property = properties.newProperty(reference, null, PropertyType.MIXED, null, null, null);\n        }\n        return property;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putUnit(\n            @Named(\"reference\") String reference,\n            @Named(\"propertyReference\") String propertyReference,\n            @Named(\"ownerReference\") @Optional String ownerReference,\n            @Named(\"name\") String name, @Named(\"type\") String type,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"area\") @Optional BigDecimal area,\n            @Named(\"salesArea\") @Optional BigDecimal salesArea,\n            @Named(\"storageArea\") @Optional BigDecimal storageArea,\n            @Named(\"mezzanineArea\") @Optional BigDecimal mezzanineArea,\n            @Named(\"dehorsArea\") @Optional BigDecimal dehorsArea,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"city\") @Optional String city,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") @Optional String countryCode) {\n        Property property = fetchProperty(propertyReference, false);\n        Unit unit = units.findUnitByReference(reference);\n        if (unit == null) {\n            unit = property.newUnit(reference, name, UnitType.BOUTIQUE);\n        }\n        // set attributes\n        unit.setName(name);\n        unit.setType(UnitType.valueOf(type));\n        unit.changeDates(startDate, endDate);\n        unit.setArea(area);\n        unit.setSalesArea(salesArea);\n        unit.setStorageArea(storageArea);\n        unit.setMezzanineArea(mezzanineArea);\n        unit.setDehorsArea(dehorsArea);\n        CommunicationChannel cc = communicationChannelContributions.findCommunicationChannelForType(unit, CommunicationChannelType.POSTAL_ADDRESS);\n        if (cc == null) {\n            communicationChannelContributions.newPostal(unit, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, null, postalCode, city);\n        }\n    }\n\n    private Unit fetchUnit(String unitReference) {\n        if (unitReference != null) {\n            Unit unit = units.findUnitByReference(unitReference);\n            if (unit == null) {\n                throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n            }\n            return unit;\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPropertyPostalAddress(\n            @Named(\"propertyReference\") String propertyReference,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"address2\") @Optional String address2,\n            @Named(\"city\") String city,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") String countryCode) {\n        final Property property = properties.findPropertyByReference(propertyReference);\n        if (property == null) {\n            throw new ApplicationException(String.format(\"Property with reference %s not found.\", propertyReference));\n        }\n        final CommunicationChannel comm = communicationChannelContributions.findCommunicationChannelForType(property, null);\n        if (comm == null) {\n            communicationChannelContributions.newPostal(property, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, address2, postalCode, city);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPartyCommunicationChannels(\n            @Named(\"partyReference\") String partyReference,\n            @Named(\"reference\") @Optional String reference,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"address2\") @Optional String address2,\n            @Named(\"city\") @Optional String city,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") @Optional String countryCode,\n            @Named(\"phoneNumber\") @Optional String phoneNumber,\n            @Named(\"faxNumber\") @Optional String faxNumber,\n            @Named(\"emailAddress\") @Optional String emailAddress\n            ) {\n        Party party = fetchParty(partyReference);\n        if (party == null)\n            throw new ApplicationException(String.format(\"Party with reference [%s] not found\", partyReference));\n\n        // Address\n        if (address1 != null) {\n            Country country = fetchCountry(countryCode);\n            PostalAddress comm = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, country);\n            if (comm == null) {\n                comm = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, states.findState(stateCode), countries.findCountry(countryCode));\n                comm.setReference(reference);\n            }\n        }\n        // Phone\n        if (phoneNumber != null) {\n            CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, phoneNumber);\n            if (comm == null) {\n                comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.PHONE_NUMBER, phoneNumber);\n                comm.setReference(reference);\n            }\n        }\n        // Fax\n        if (faxNumber != null) {\n            CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, faxNumber);\n            if (comm == null) {\n                comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.FAX_NUMBER, faxNumber);\n                comm.setReference(reference);\n            }\n        }\n        // Email\n        if (emailAddress != null) {\n            CommunicationChannel comm = emailAddresses.findByEmailAddress(party, emailAddress);\n            if (comm == null) {\n                comm = communicationChannels.newEmail(party, CommunicationChannelType.EMAIL_ADDRESS, emailAddress);\n                comm.setReference(reference);\n            }\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPropertyActor(\n            @Named(\"propertyReference\") String propertyReference,\n            @Named(\"partyReference\") String partyReference,\n            @Named(\"type\") String typeStr,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate) {\n        final Property property = fetchProperty(propertyReference, false);\n        final Party party = fetchParty(partyReference);\n        final FixedAssetRoleType type = FixedAssetRoleType.valueOf(typeStr);\n        property.addRoleIfDoesNotExist(party, type, startDate, endDate);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLease(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"landlordReference\") String landlordReference,\n            @Named(\"type\") String type,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"terminationDate\") @Optional LocalDate terminationDate,\n            @Named(\"propertyReference\") @Optional String propertyReference\n            ) {\n        Party tenant = fetchParty(tenantReference);\n        Party landlord = fetchParty(landlordReference);\n        Lease lease = leases.findLeaseByReference(reference);\n        LeaseType leaseType = leaseTypes.findOrCreate(type, null);\n        if (lease == null) {\n            lease = leases.newLease(reference, name, leaseType, startDate, null, endDate, landlord, tenant);\n        }\n        lease.setTerminationDate(terminationDate);\n    }\n\n    private Lease fetchLease(String leaseReference) {\n        Lease lease;\n        lease = leases.findLeaseByReference(leaseReference);\n        if (lease == null) {\n            throw new ApplicationException(String.format(\"Lease with reference %s not found.\", leaseReference));\n        }\n        return lease;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseLink(@Named(\"leaseReference\") String leaseReference, @Named(\"previousLeaseReference\") String previousLeaseReference) {\n        Lease lease = fetchLease(leaseReference);\n        Lease previousLease = fetchLease(previousLeaseReference);\n        lease.modifyPrevious(previousLease);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putOccupancy(\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"tenancyStartDate\") @Optional LocalDate tenancyStartDate,\n            @Named(\"tenancyEndDate\") @Optional LocalDate tenancyEndDate,\n            @Named(\"size\") @Optional String size,\n            @Named(\"brand\") @Optional String brand,\n            @Named(\"sector\") @Optional String sector,\n            @Named(\"activity\") @Optional String activity,\n            @Named(\"reportTurnover\") @Optional String reportTurnover,\n            @Named(\"reportRent\") @Optional String reportRent,\n            @Named(\"reportOCR\") @Optional String reportOCR) {\n        Lease lease = fetchLease(leaseReference);\n        UnitForLease unit = (UnitForLease) units.findUnitByReference(unitReference);\n        if (unitReference != null && unit == null) {\n            throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n        }\n        Occupancy occupancy = occupancies.findByLeaseAndUnitAndStartDate(lease, unit, startDate);\n        if (occupancy == null) {\n            occupancy = lease.occupy(unit, startDate);\n        }\n\n        occupancy.setEndDate(endDate);\n        occupancy.setUnitSizeName(size);\n        occupancy.setBrandName(brand != null ? brand.replaceAll(\"\\\\p{C}\", \"\").trim() : null);\n        occupancy.setSectorName(sector);\n        occupancy.setActivityName(activity);\n        occupancy.setReportTurnover(reportTurnover != null ? OccupancyReportingType.valueOf(reportTurnover) : OccupancyReportingType.NO);\n        occupancy.setReportRent(reportRent != null ? OccupancyReportingType.valueOf(reportRent) : OccupancyReportingType.NO);\n        occupancy.setReportOCR(reportOCR != null ? OccupancyReportingType.valueOf(reportOCR) : OccupancyReportingType.NO);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseItem(\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"type\") @Optional String leaseItemTypeName,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"chargeReference\") @Optional String chargeReference,\n            @Named(\"nextDueDate\") @Optional LocalDate nextDueDate,\n            @Named(\"invoicingFrequency\") @Optional String invoicingFrequency,\n            @Named(\"paymentMethod\") @Optional String paymentMethod,\n            @Named(\"status\") @Optional String status) {\n        Lease lease = fetchLease(leaseReference);\n\n        @SuppressWarnings(\"unused\")\n        Unit unit = fetchUnit(unitReference);\n\n        LeaseItemType itemType = fetchLeaseItemType(leaseItemTypeName);\n        Charge charge = fetchCharge(chargeReference);\n        //\n        LeaseItem item = lease.findItem(itemType, startDate, sequence);\n        if (item == null) {\n            item = lease.newItem(itemType, charge, InvoicingFrequency.valueOf(invoicingFrequency), PaymentMethod.valueOf(paymentMethod), startDate);\n        }\n        final LeaseItemStatus leaseItemStatus = LeaseItemStatus.valueOfElse(status, LeaseItemStatus.APPROVED);\n        item.setStatus(leaseItemStatus);\n        item.setEndDate(endDate);\n        item.setSequence(sequence);\n    }\n\n    private LeaseItemType fetchLeaseItemType(String type) {\n        LeaseItemType itemType = LeaseItemType.valueOf(type);\n        if (itemType == null) {\n            throw new ApplicationException(String.format(\"Type with reference %s not found.\", type));\n        }\n        return itemType;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeasePostalAddress(\n            @Named(\"partyReference\") String partyReference,\n            @Named(\"agreementRoleType\") String agreementRoleType,\n            @Named(\"leaseReference\") @Optional String leaseReference,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"address2\") @Optional String address2,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"city\") @Optional String city,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") @Optional String countryCode,\n            @Named(\"isInvoiceAddress\") @Optional BigInteger isInvoiceAddress\n            ) {\n        if (address1 != null && partyReference != null && leaseReference != null) {\n            Lease lease = fetchLease(leaseReference);\n            Party party = fetchParty(partyReference);\n            AgreementRoleCommunicationChannelType agreementRoleCommunicationChannelType = agreementRoleCommunicationChannelTypes.findByTitle(isInvoiceAddress.compareTo(BigInteger.ZERO) == 0 ? LeaseConstants.ARCCT_INVOICE_ADDRESS : LeaseConstants.ARCCT_ADMINISTRATION_ADDRESS);\n            if (agreementRoleCommunicationChannelType == null)\n                throw new ApplicationException(String.format(\"AgreementRoleCommunicationChannelType not found.\"));\n            PostalAddress address = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, fetchCountry(countryCode));\n            if (address == null) {\n                address = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, fetchState(stateCode, false), fetchCountry(countryCode, false));\n            }\n            AgreementRoleType art = agreementRoleTypes.findByTitle(StringUtils.capitalize(agreementRoleType.toLowerCase()));\n            if (art == null)\n                throw new ApplicationException(String.format(\"AgreementRoleType %s not found.\", agreementRoleType));\n            AgreementRole role = lease.findRole(party, art, clockService.now());\n            if (role == null)\n                throw new ApplicationException(String.format(\"Role for %s, %s not found.\", partyReference, agreementRoleType));\n            role.addCommunicationChannel(agreementRoleCommunicationChannelType, address);\n        }\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseTermForIndexableRent(\n            // start generic fields\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"itemSequence\") BigInteger itemSequence,\n            @Named(\"itemType\") String itemType,\n            @Named(\"itemStartDate\") LocalDate itemStartDate,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"status\") @Optional String statusStr,\n            // end generic fields\n            @Named(\"reviewDate\") @Optional LocalDate reviewDate,\n            @Named(\"effectiveDate\") @Optional LocalDate effectiveDate,\n            @Named(\"baseValue\") @Optional BigDecimal baseValue,\n            @Named(\"indexedValue\") @Optional BigDecimal indexedValue,\n            @Named(\"settledValue\") @Optional BigDecimal settledValue,\n            @Named(\"levellingValue\") @Optional BigDecimal levellingValue,\n            @Named(\"levellingPercentage\") @Optional BigDecimal levellingPercentage,\n            @Named(\"indexReference\") @Optional String indexReference,\n            @Named(\"indexationFrequency\") @Optional String indexationFrequency,\n            @Named(\"indexationPercentage\") @Optional BigDecimal indexationPercentage,\n            @Named(\"baseIndexReference\") @Optional String baseIndexReference,\n            @Named(\"baseIndexStartDate\") @Optional LocalDate baseIndexStartDate,\n            @Named(\"baseIndexEndDate\") @Optional LocalDate baseIndexEndDate,\n            @Named(\"baseIndexValue\") @Optional BigDecimal baseIndexValue,\n            @Named(\"nextIndexReference\") @Optional String nextIndexReference,\n            @Named(\"nextIndexStartDate\") @Optional LocalDate nextIndexStartDate,\n            @Named(\"nextIndexEndDate\") @Optional LocalDate nextIndexEndDate,\n            @Named(\"nextIndexValue\") @Optional BigDecimal nextIndexValue) {\n        LeaseTermForIndexableRent term = (LeaseTermForIndexableRent) putLeaseTerm(\n                leaseReference,\n                unitReference,\n                itemSequence,\n                itemType,\n                itemStartDate,\n                startDate,\n                endDate,\n                sequence,\n                statusStr);\n        if (term != null) {\n            Index index = indices.findIndex(indexReference);\n            LeaseTermFrequency indexationFreq = LeaseTermFrequency.valueOf(indexationFrequency);\n            term.setIndex(index);\n            term.setFrequency(indexationFreq);\n            term.setEffectiveDate(effectiveDate);\n            term.setBaseValue(baseValue);\n            term.setIndexedValue(indexedValue);\n            term.setSettledValue(settledValue);\n            term.setBaseIndexStartDate(baseIndexStartDate);\n            term.setBaseIndexValue(baseIndexValue);\n            term.setNextIndexStartDate(nextIndexStartDate);\n            term.setNextIndexValue(nextIndexValue);\n            term.setIndexationPercentage(indexationPercentage);\n            term.setLevellingPercentage(levellingPercentage);\n        }\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseTermForTurnoverRent(\n            // start generic fields\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"itemSequence\") BigInteger itemSequence,\n            @Named(\"itemType\") String itemType,\n            @Named(\"itemStartDate\") LocalDate itemStartDate,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"status\") @Optional String status,\n            // end generic fields\n            @Named(\"turnoverRentRule\") @Optional String turnoverRentRule,\n            @Named(\"budgetedTurnover\") @Optional BigDecimal budgetedTurnover,\n            @Named(\"auditedTurnover\") @Optional BigDecimal auditedTurnover,\n            @Named(\"turnoverRentValue\") @Optional BigDecimal turnoverRentValue) {\n        LeaseTermForTurnoverRent term = (LeaseTermForTurnoverRent) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n        if (term != null) {\n            term.setTurnoverRentValue(turnoverRentValue);\n            term.setBudgetedTurnover(budgetedTurnover);\n            term.setAuditedTurnover(auditedTurnover);\n            term.setTurnoverRentRule(turnoverRentRule);\n        }\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseTermForServiceCharge(\n            // start generic fields\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"itemSequence\") BigInteger itemSequence,\n            @Named(\"itemType\") String itemType,\n            @Named(\"itemStartDate\") LocalDate itemStartDate,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"status\") @Optional String status,\n            // end generic fields\n            @Named(\"auditedValue\") @Optional BigDecimal auditedValue,\n            @Named(\"budgetedValue\") @Optional BigDecimal budgetedValue) {\n        LeaseTermForServiceCharge term = (LeaseTermForServiceCharge) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n        if (term != null) {\n            term.setAuditedValue(auditedValue);\n            term.setBudgetedValue(budgetedValue);\n        }\n    }\n\n    private LeaseTerm putLeaseTerm(\n            final String leaseReference,\n            final String unitReference,\n            final BigInteger itemSequence,\n            final String itemType,\n            final LocalDate itemStartDate,\n            final LocalDate startDate,\n            final LocalDate endDate,\n            final BigInteger sequence,\n            final String statusStr) {\n        Lease lease = leases.findLeaseByReference(leaseReference);\n        if (lease == null) {\n            throw new ApplicationException(String.format(\"Leaseitem with reference %1$s not found.\", leaseReference));\n        }\n        Unit unit;\n        if (unitReference != null) {\n            unit = units.findUnitByReference(unitReference);\n            if (unitReference != null && unit == null) {\n                throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n            }\n        }\n        LeaseItemType leaseItemType = fetchLeaseItemType(itemType);\n        LeaseItem item = lease.findItem(leaseItemType, itemStartDate, itemSequence);\n        if (item == null) {\n            throw new ApplicationException(String.format(\"LeaseItem with reference %1$s, %2$s, %3$s, %4$s not found.\", leaseReference, leaseItemType.toString(), itemStartDate.toString(), itemSequence.toString()));\n        }\n        // check if the date is within range of lease\n        if (lease.getTerminationDate() == null || lease.getTerminationDate().compareTo(startDate) >= 0) {\n            LeaseTerm term = item.findTermWithSequence(sequence);\n            if (term == null) {\n                if (sequence.equals(BigInteger.ONE)) {\n                    term = item.newTerm(startDate);\n                } else {\n                    LeaseTerm previousTerm = item.findTermWithSequence(sequence.subtract(BigInteger.ONE));\n                    term = previousTerm.createNext(startDate);\n                }\n                term.setSequence(sequence);\n            }\n            term.setStatus(org.estatio.dom.lease.LeaseTermStatus.valueOf(statusStr));\n            // will be overwritten if there is a next term\n            term.setEndDate(lease.getTerminationDate());\n            return term;\n        }\n        return null;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putBankAccount(\n            // start generic fields\n            @Named(\"reference\") @Optional String reference,\n            @Named(\"name\") @Optional String name,\n            @Named(\"bankAccountType\") @Optional String bankAccountType,\n            @Named(\"ownerReference\") String ownerReference,\n            @Named(\"iban\") @Optional String iban,\n            @Named(\"countryCode\") @Optional String countryCode,\n            @Named(\"nationalCheckCode\") @Optional String nationalCheckCode,\n            @Named(\"nationalBankCode\") @Optional String nationalBankCode,\n            @Named(\"branchCode\") @Optional String branchCode,\n            @Named(\"accountNumber\") @Optional String accountNumber\n            ) {\n        BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(reference);\n        Party owner = parties.findPartyByReference(ownerReference);\n        if (owner == null)\n            return;\n        if (bankAccount == null) {\n            bankAccount = financialAccounts.newBankAccount(owner, iban);\n        }\n        bankAccount.setReference(reference);\n        bankAccount.setAccountNumber(accountNumber);\n        bankAccount.setBranchCode(branchCode);\n        bankAccount.setName(name);\n        bankAccount.setCountry(fetchCountry(countryCode, false));\n        bankAccount.setNationalBankCode(nationalBankCode);\n        bankAccount.setNationalCheckCode(nationalCheckCode);\n        bankAccount.setBankAccountType(BankAccountType.valueOf(bankAccountType));\n        bankAccount.verifyIban();\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putBankMandate(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") @Optional String name,\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"debtorReference\") String debtorReference,\n            @Named(\"creditorReference\") String creditorReference,\n            @Named(\"bankAccountReference\") String bankAccountReference,\n            @Named(\"startDate\") LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate) {\n        BankMandate bankMandate = (BankMandate) agreements.findAgreementByReference(reference);\n        BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(bankAccountReference);\n        if (bankAccount == null)\n            throw new ApplicationException(String.format(\"BankAccount with reference %1$s not found\", bankAccountReference));\n        if (bankMandate == null) {\n            Party debtor = fetchParty(debtorReference);\n            Party creditor = fetchParty(creditorReference);\n            Lease lease = fetchLease(leaseReference);\n            bankMandate = bankMandates.newBankMandate(reference, name, startDate, endDate, debtor, creditor, bankAccount);\n            lease.paidBy(bankMandate);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putBreakOption(\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"breakType\") String breakTypeStr,\n            @Named(\"breakExcerciseType\") String breakExcerciseTypeStr,\n            @Named(\"breakDate\") LocalDate breakDate,\n            @Named(\"notificationDate\") LocalDate notificationDate,\n            @Named(\"notificationPeriod\") @Optional String notificationPeriodStr,\n            @Named(\"description\") @Optional String description\n            ) {\n        Lease lease = fetchLease(leaseReference);\n        BreakType breakType = BreakType.valueOf(breakTypeStr);\n        BreakExerciseType breakExerciseType = BreakExerciseType.valueOf(breakExcerciseTypeStr);\n        if (notificationDate != null) {\n            Period period = new Period(notificationDate, breakDate);\n            notificationPeriodStr = JodaPeriodUtils.asSimpleString(period);\n        }\n        if (lease.validateNewBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description) == null) {\n            lease.newBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    private Agreements agreements;\n\n    public void injectAgreements(Agreements agreements) {\n        this.agreements = agreements;\n    }\n\n    private BankMandates bankMandates;\n\n    public void injectBankMandates(BankMandates bankMandates) {\n        this.bankMandates = bankMandates;\n    }\n\n    private ClockService clockService;\n\n    public void setClockService(ClockService clockService) {\n        this.clockService = clockService;\n    }\n\n    private Countries countries;\n\n    public void injectCountries(final Countries countries) {\n        this.countries = countries;\n    }\n\n    private States states;\n\n    public void injectStates(final States states) {\n        this.states = states;\n    }\n\n    private Units<Unit> units;\n\n    public void injectUnits(final Units<Unit> units) {\n        this.units = units;\n    }\n\n    private Properties properties;\n\n    public void injectProperties(final Properties properties) {\n        this.properties = properties;\n    }\n\n    private Parties parties;\n\n    public void injectParties(final Parties parties) {\n        this.parties = parties;\n    }\n\n    private Organisations organisations;\n\n    public void injectOrganisations(final Organisations organisations) {\n        this.organisations = organisations;\n    }\n\n    private Persons persons;\n\n    public void injectOrganisations(final Persons persons) {\n        this.persons = persons;\n    }\n\n    private CommunicationChannelContributions communicationChannelContributions;\n\n    public void injectCommunicationChannelContributedActions(final CommunicationChannelContributions communicationChannelContributedActions) {\n        this.communicationChannelContributions = communicationChannelContributedActions;\n    }\n\n    private CommunicationChannels communicationChannels;\n\n    public void injectCommunicationChannels(final CommunicationChannels communicationChannels) {\n        this.communicationChannels = communicationChannels;\n    }\n\n    private PostalAddresses postalAddresses;\n\n    public void injectPostalAddresses(PostalAddresses postalAddresses) {\n        this.postalAddresses = postalAddresses;\n    }\n\n    private EmailAddresses emailAddresses;\n\n    public void injectEmailAddresses(EmailAddresses emailAddresses) {\n        this.emailAddresses = emailAddresses;\n    }\n\n    private PhoneOrFaxNumbers phoneOrFaxNumbers;\n\n    public void setPhoneOrFaxNumbers(PhoneOrFaxNumbers phoneOrFaxNumbers) {\n        this.phoneOrFaxNumbers = phoneOrFaxNumbers;\n    }\n\n    private Leases leases;\n\n    public void injectLeaseRepository(final Leases leases) {\n        this.leases = leases;\n    }\n\n    private AgreementRoleTypes agreementRoleTypes;\n\n    public void injectAgreementRoleTypes(AgreementRoleTypes agreementRoleTypes) {\n        this.agreementRoleTypes = agreementRoleTypes;\n    }\n\n    private Occupancies occupancies;\n\n    public void injectLeaseUnits(final Occupancies leaseUnits) {\n        this.occupancies = leaseUnits;\n    }\n\n    private Taxes taxes;\n\n    public void injectTaxes(final Taxes taxes) {\n        this.taxes = taxes;\n    }\n\n    private Charges charges;\n\n    public void injectCharges(final Charges charges) {\n        this.charges = charges;\n    }\n\n    private ChargeGroups chargeGroups;\n\n    public void injectChargeGroups(final ChargeGroups chargeGroups) {\n        this.chargeGroups = chargeGroups;\n    }\n\n    private Indices indices;\n\n    public void injectIndices(final Indices indices) {\n        this.indices = indices;\n    }\n\n    private FinancialAccounts financialAccounts;\n\n    public void injectFinancialAccounts(FinancialAccounts financialAccounts) {\n        this.financialAccounts = financialAccounts;\n    }\n\n    private Invoices invoices;\n\n    public void injectInvoices(Invoices invoices) {\n        this.invoices = invoices;\n    }\n\n    private AgreementRoleCommunicationChannelTypes agreementRoleCommunicationChannelTypes;\n\n    public void injectAgreementRoleCommunicationChannelTypes(AgreementRoleCommunicationChannelTypes agreementRoleCommunicationChannelTypes) {\n        this.agreementRoleCommunicationChannelTypes = agreementRoleCommunicationChannelTypes;\n    }\n\n    private LeaseTypes leaseTypes;\n\n    public void injectLeaseTypes(LeaseTypes leaseTypes) {\n        this.leaseTypes = leaseTypes;\n    }\n\n}",
        "package": "package org.estatio.api;",
        "tree_path": "Api",
        "name": "Api",
        "modifiers": "@Named(\"Migration\")\npublic",
        "superclass": "extends AbstractFactoryAndRepository",
        "super_interfaces": null,
        "body": "{\n\n    @Override\n    public String getId() {\n        return \"api\";\n    }\n\n    public String iconName() {\n        return \"Api\";\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putCountry(\n            @Named(\"code\") String code,\n            @Named(\"alpha2Code\") String alpha2Code,\n            @Named(\"name\") String name) {\n        Country country = countries.findCountry(code);\n        if (country == null) {\n            country = countries.createCountry(code, alpha2Code, name);\n        }\n    }\n\n    private Country fetchCountry(String countryCode) {\n        return fetchCountry(countryCode, true);\n    }\n\n    private Country fetchCountry(String countryCode, boolean exception) {\n        Country country = countries.findCountry(countryCode);\n        if (country == null && exception) {\n            throw new ApplicationException(String.format(\"Country with code %1$s not found\", countryCode));\n        }\n        return country;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putState(\n            @Named(\"code\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"countryCode\") String countryCode) {\n        Country country = fetchCountry(countryCode);\n        State state = states.findState(countryCode);\n        if (state == null) {\n            state = states.newState(reference, name, country);\n        }\n        state.setName(name);\n        state.setCountry(country);\n    }\n\n    private State fetchState(String stateCode, boolean exception) {\n        State country = states.findState(stateCode);\n        if (country == null && exception) {\n            throw new ApplicationException(String.format(\"State with code %1$s not found\", stateCode));\n        }\n        return country;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseType(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name) {\n        leaseTypes.findOrCreate(reference, name);\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putCharge(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"description\") String description,\n            @Named(\"taxReference\") String taxReference,\n            @Named(\"chargeGroupReference\") String chargeGroupReference) {\n        Tax tax = fetchTaxIfAny(taxReference);\n        ChargeGroup chargeGroup = fetchOrCreateChargeGroup(chargeGroupReference);\n        charges.newCharge(reference, name, description, tax, chargeGroup);\n    }\n\n    private Charge fetchCharge(String chargeReference) {\n        Charge charge = charges.findCharge(chargeReference);\n        if (charge == null) {\n            throw new ApplicationException(String.format(\"Charge with reference %s not found.\", chargeReference));\n        }\n        return charge;\n    }\n\n    private ChargeGroup fetchOrCreateChargeGroup(String chargeGroupReference) {\n        ChargeGroup chargeGroup = chargeGroups.findChargeGroup(chargeGroupReference);\n        if (chargeGroup == null) {\n            chargeGroup = chargeGroups.createChargeGroup(chargeGroupReference, null);\n        }\n        return chargeGroup;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putTax(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"percentage\") BigDecimal percentage,\n            @Named(\"startDate\") LocalDate startDate) {\n        Tax tax = fetchTaxIfAny(reference);\n        if (tax == null) {\n            tax = taxes.newTax(reference, name);\n            tax.setName(name);\n        }\n        tax.newRate(startDate, percentage);\n    }\n\n    private Tax fetchTaxIfAny(String reference) {\n        return taxes.findTaxByReference(reference);\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPerson(\n            @Named(\"reference\") String reference,\n            @Named(\"initials\") @Optional String initials,\n            @Named(\"firstName\") String firstName,\n            @Named(\"lastName\") String lastName) {\n        Person person = (Person) parties.findPartyByReference(reference);\n        if (person == null) {\n            person = persons.newPerson(reference, initials, firstName, lastName);\n        }\n        person.setFirstName(firstName);\n        person.setLastName(lastName);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putOrganisation(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"vatCode\") @Optional String vatCode,\n            @Named(\"fiscalCode\") @Optional String fiscalCode) {\n        Organisation org = (Organisation) parties.findPartyByReference(reference);\n        if (org == null) {\n            org = organisations.newOrganisation(reference, name);\n            org.setFiscalCode(fiscalCode);\n            org.setVatCode(vatCode);\n        }\n        org.setName(name);\n    }\n\n    private Party fetchParty(String partyReference) {\n        Party party = parties.findPartyByReference(partyReference);\n        if (party == null) {\n            throw new ApplicationException(String.format(\"Party with reference %s not found.\", partyReference));\n        }\n        return party;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putProperty(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"countryCode\") String countryCode,\n            @Named(\"city\") String city,\n            @Named(\"type\") String type,\n            @Named(\"acquireDate\") @Optional LocalDate acquireDate,\n            @Named(\"disposalDate\") @Optional LocalDate disposalDate,\n            @Named(\"openingDate\") @Optional LocalDate openingDate,\n            @Named(\"ownerReference\") @Optional String ownerReference,\n            @Named(\"numeratorFormat\") @Optional String numeratorFormat\n            ) {\n        Party owner = fetchParty(ownerReference);\n        Property property = fetchProperty(reference, true);\n        property.setName(name);\n        property.setCountry(fetchCountry(countryCode));\n        property.setCity(city);\n        property.setType(PropertyType.valueOf(type));\n        property.setAcquireDate(acquireDate);\n        property.setDisposalDate(disposalDate);\n        property.setOpeningDate(openingDate);\n        property.addRoleIfDoesNotExist(owner, FixedAssetRoleType.PROPERTY_OWNER, null, null);\n        if (numeratorFormat != null)\n            invoices.createInvoiceNumberNumerator(property, numeratorFormat, BigInteger.ZERO);\n    }\n\n    private Property fetchProperty(String reference, boolean createIfNotFond) {\n        Property property = properties.findPropertyByReference(reference);\n        if (property == null) {\n            if (!createIfNotFond)\n                throw new ApplicationException(String.format(\"Property with reference %s not found.\", reference));\n            property = properties.newProperty(reference, null, PropertyType.MIXED, null, null, null);\n        }\n        return property;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putUnit(\n            @Named(\"reference\") String reference,\n            @Named(\"propertyReference\") String propertyReference,\n            @Named(\"ownerReference\") @Optional String ownerReference,\n            @Named(\"name\") String name, @Named(\"type\") String type,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"area\") @Optional BigDecimal area,\n            @Named(\"salesArea\") @Optional BigDecimal salesArea,\n            @Named(\"storageArea\") @Optional BigDecimal storageArea,\n            @Named(\"mezzanineArea\") @Optional BigDecimal mezzanineArea,\n            @Named(\"dehorsArea\") @Optional BigDecimal dehorsArea,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"city\") @Optional String city,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") @Optional String countryCode) {\n        Property property = fetchProperty(propertyReference, false);\n        Unit unit = units.findUnitByReference(reference);\n        if (unit == null) {\n            unit = property.newUnit(reference, name, UnitType.BOUTIQUE);\n        }\n        // set attributes\n        unit.setName(name);\n        unit.setType(UnitType.valueOf(type));\n        unit.changeDates(startDate, endDate);\n        unit.setArea(area);\n        unit.setSalesArea(salesArea);\n        unit.setStorageArea(storageArea);\n        unit.setMezzanineArea(mezzanineArea);\n        unit.setDehorsArea(dehorsArea);\n        CommunicationChannel cc = communicationChannelContributions.findCommunicationChannelForType(unit, CommunicationChannelType.POSTAL_ADDRESS);\n        if (cc == null) {\n            communicationChannelContributions.newPostal(unit, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, null, postalCode, city);\n        }\n    }\n\n    private Unit fetchUnit(String unitReference) {\n        if (unitReference != null) {\n            Unit unit = units.findUnitByReference(unitReference);\n            if (unit == null) {\n                throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n            }\n            return unit;\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPropertyPostalAddress(\n            @Named(\"propertyReference\") String propertyReference,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"address2\") @Optional String address2,\n            @Named(\"city\") String city,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") String countryCode) {\n        final Property property = properties.findPropertyByReference(propertyReference);\n        if (property == null) {\n            throw new ApplicationException(String.format(\"Property with reference %s not found.\", propertyReference));\n        }\n        final CommunicationChannel comm = communicationChannelContributions.findCommunicationChannelForType(property, null);\n        if (comm == null) {\n            communicationChannelContributions.newPostal(property, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, address2, postalCode, city);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPartyCommunicationChannels(\n            @Named(\"partyReference\") String partyReference,\n            @Named(\"reference\") @Optional String reference,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"address2\") @Optional String address2,\n            @Named(\"city\") @Optional String city,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") @Optional String countryCode,\n            @Named(\"phoneNumber\") @Optional String phoneNumber,\n            @Named(\"faxNumber\") @Optional String faxNumber,\n            @Named(\"emailAddress\") @Optional String emailAddress\n            ) {\n        Party party = fetchParty(partyReference);\n        if (party == null)\n            throw new ApplicationException(String.format(\"Party with reference [%s] not found\", partyReference));\n\n        // Address\n        if (address1 != null) {\n            Country country = fetchCountry(countryCode);\n            PostalAddress comm = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, country);\n            if (comm == null) {\n                comm = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, states.findState(stateCode), countries.findCountry(countryCode));\n                comm.setReference(reference);\n            }\n        }\n        // Phone\n        if (phoneNumber != null) {\n            CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, phoneNumber);\n            if (comm == null) {\n                comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.PHONE_NUMBER, phoneNumber);\n                comm.setReference(reference);\n            }\n        }\n        // Fax\n        if (faxNumber != null) {\n            CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, faxNumber);\n            if (comm == null) {\n                comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.FAX_NUMBER, faxNumber);\n                comm.setReference(reference);\n            }\n        }\n        // Email\n        if (emailAddress != null) {\n            CommunicationChannel comm = emailAddresses.findByEmailAddress(party, emailAddress);\n            if (comm == null) {\n                comm = communicationChannels.newEmail(party, CommunicationChannelType.EMAIL_ADDRESS, emailAddress);\n                comm.setReference(reference);\n            }\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putPropertyActor(\n            @Named(\"propertyReference\") String propertyReference,\n            @Named(\"partyReference\") String partyReference,\n            @Named(\"type\") String typeStr,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate) {\n        final Property property = fetchProperty(propertyReference, false);\n        final Party party = fetchParty(partyReference);\n        final FixedAssetRoleType type = FixedAssetRoleType.valueOf(typeStr);\n        property.addRoleIfDoesNotExist(party, type, startDate, endDate);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLease(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") String name,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"landlordReference\") String landlordReference,\n            @Named(\"type\") String type,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"terminationDate\") @Optional LocalDate terminationDate,\n            @Named(\"propertyReference\") @Optional String propertyReference\n            ) {\n        Party tenant = fetchParty(tenantReference);\n        Party landlord = fetchParty(landlordReference);\n        Lease lease = leases.findLeaseByReference(reference);\n        LeaseType leaseType = leaseTypes.findOrCreate(type, null);\n        if (lease == null) {\n            lease = leases.newLease(reference, name, leaseType, startDate, null, endDate, landlord, tenant);\n        }\n        lease.setTerminationDate(terminationDate);\n    }\n\n    private Lease fetchLease(String leaseReference) {\n        Lease lease;\n        lease = leases.findLeaseByReference(leaseReference);\n        if (lease == null) {\n            throw new ApplicationException(String.format(\"Lease with reference %s not found.\", leaseReference));\n        }\n        return lease;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseLink(@Named(\"leaseReference\") String leaseReference, @Named(\"previousLeaseReference\") String previousLeaseReference) {\n        Lease lease = fetchLease(leaseReference);\n        Lease previousLease = fetchLease(previousLeaseReference);\n        lease.modifyPrevious(previousLease);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putOccupancy(\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"tenancyStartDate\") @Optional LocalDate tenancyStartDate,\n            @Named(\"tenancyEndDate\") @Optional LocalDate tenancyEndDate,\n            @Named(\"size\") @Optional String size,\n            @Named(\"brand\") @Optional String brand,\n            @Named(\"sector\") @Optional String sector,\n            @Named(\"activity\") @Optional String activity,\n            @Named(\"reportTurnover\") @Optional String reportTurnover,\n            @Named(\"reportRent\") @Optional String reportRent,\n            @Named(\"reportOCR\") @Optional String reportOCR) {\n        Lease lease = fetchLease(leaseReference);\n        UnitForLease unit = (UnitForLease) units.findUnitByReference(unitReference);\n        if (unitReference != null && unit == null) {\n            throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n        }\n        Occupancy occupancy = occupancies.findByLeaseAndUnitAndStartDate(lease, unit, startDate);\n        if (occupancy == null) {\n            occupancy = lease.occupy(unit, startDate);\n        }\n\n        occupancy.setEndDate(endDate);\n        occupancy.setUnitSizeName(size);\n        occupancy.setBrandName(brand != null ? brand.replaceAll(\"\\\\p{C}\", \"\").trim() : null);\n        occupancy.setSectorName(sector);\n        occupancy.setActivityName(activity);\n        occupancy.setReportTurnover(reportTurnover != null ? OccupancyReportingType.valueOf(reportTurnover) : OccupancyReportingType.NO);\n        occupancy.setReportRent(reportRent != null ? OccupancyReportingType.valueOf(reportRent) : OccupancyReportingType.NO);\n        occupancy.setReportOCR(reportOCR != null ? OccupancyReportingType.valueOf(reportOCR) : OccupancyReportingType.NO);\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseItem(\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"type\") @Optional String leaseItemTypeName,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"chargeReference\") @Optional String chargeReference,\n            @Named(\"nextDueDate\") @Optional LocalDate nextDueDate,\n            @Named(\"invoicingFrequency\") @Optional String invoicingFrequency,\n            @Named(\"paymentMethod\") @Optional String paymentMethod,\n            @Named(\"status\") @Optional String status) {\n        Lease lease = fetchLease(leaseReference);\n\n        @SuppressWarnings(\"unused\")\n        Unit unit = fetchUnit(unitReference);\n\n        LeaseItemType itemType = fetchLeaseItemType(leaseItemTypeName);\n        Charge charge = fetchCharge(chargeReference);\n        //\n        LeaseItem item = lease.findItem(itemType, startDate, sequence);\n        if (item == null) {\n            item = lease.newItem(itemType, charge, InvoicingFrequency.valueOf(invoicingFrequency), PaymentMethod.valueOf(paymentMethod), startDate);\n        }\n        final LeaseItemStatus leaseItemStatus = LeaseItemStatus.valueOfElse(status, LeaseItemStatus.APPROVED);\n        item.setStatus(leaseItemStatus);\n        item.setEndDate(endDate);\n        item.setSequence(sequence);\n    }\n\n    private LeaseItemType fetchLeaseItemType(String type) {\n        LeaseItemType itemType = LeaseItemType.valueOf(type);\n        if (itemType == null) {\n            throw new ApplicationException(String.format(\"Type with reference %s not found.\", type));\n        }\n        return itemType;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeasePostalAddress(\n            @Named(\"partyReference\") String partyReference,\n            @Named(\"agreementRoleType\") String agreementRoleType,\n            @Named(\"leaseReference\") @Optional String leaseReference,\n            @Named(\"address1\") @Optional String address1,\n            @Named(\"address2\") @Optional String address2,\n            @Named(\"postalCode\") @Optional String postalCode,\n            @Named(\"city\") @Optional String city,\n            @Named(\"stateCode\") @Optional String stateCode,\n            @Named(\"countryCode\") @Optional String countryCode,\n            @Named(\"isInvoiceAddress\") @Optional BigInteger isInvoiceAddress\n            ) {\n        if (address1 != null && partyReference != null && leaseReference != null) {\n            Lease lease = fetchLease(leaseReference);\n            Party party = fetchParty(partyReference);\n            AgreementRoleCommunicationChannelType agreementRoleCommunicationChannelType = agreementRoleCommunicationChannelTypes.findByTitle(isInvoiceAddress.compareTo(BigInteger.ZERO) == 0 ? LeaseConstants.ARCCT_INVOICE_ADDRESS : LeaseConstants.ARCCT_ADMINISTRATION_ADDRESS);\n            if (agreementRoleCommunicationChannelType == null)\n                throw new ApplicationException(String.format(\"AgreementRoleCommunicationChannelType not found.\"));\n            PostalAddress address = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, fetchCountry(countryCode));\n            if (address == null) {\n                address = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, fetchState(stateCode, false), fetchCountry(countryCode, false));\n            }\n            AgreementRoleType art = agreementRoleTypes.findByTitle(StringUtils.capitalize(agreementRoleType.toLowerCase()));\n            if (art == null)\n                throw new ApplicationException(String.format(\"AgreementRoleType %s not found.\", agreementRoleType));\n            AgreementRole role = lease.findRole(party, art, clockService.now());\n            if (role == null)\n                throw new ApplicationException(String.format(\"Role for %s, %s not found.\", partyReference, agreementRoleType));\n            role.addCommunicationChannel(agreementRoleCommunicationChannelType, address);\n        }\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseTermForIndexableRent(\n            // start generic fields\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"itemSequence\") BigInteger itemSequence,\n            @Named(\"itemType\") String itemType,\n            @Named(\"itemStartDate\") LocalDate itemStartDate,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"status\") @Optional String statusStr,\n            // end generic fields\n            @Named(\"reviewDate\") @Optional LocalDate reviewDate,\n            @Named(\"effectiveDate\") @Optional LocalDate effectiveDate,\n            @Named(\"baseValue\") @Optional BigDecimal baseValue,\n            @Named(\"indexedValue\") @Optional BigDecimal indexedValue,\n            @Named(\"settledValue\") @Optional BigDecimal settledValue,\n            @Named(\"levellingValue\") @Optional BigDecimal levellingValue,\n            @Named(\"levellingPercentage\") @Optional BigDecimal levellingPercentage,\n            @Named(\"indexReference\") @Optional String indexReference,\n            @Named(\"indexationFrequency\") @Optional String indexationFrequency,\n            @Named(\"indexationPercentage\") @Optional BigDecimal indexationPercentage,\n            @Named(\"baseIndexReference\") @Optional String baseIndexReference,\n            @Named(\"baseIndexStartDate\") @Optional LocalDate baseIndexStartDate,\n            @Named(\"baseIndexEndDate\") @Optional LocalDate baseIndexEndDate,\n            @Named(\"baseIndexValue\") @Optional BigDecimal baseIndexValue,\n            @Named(\"nextIndexReference\") @Optional String nextIndexReference,\n            @Named(\"nextIndexStartDate\") @Optional LocalDate nextIndexStartDate,\n            @Named(\"nextIndexEndDate\") @Optional LocalDate nextIndexEndDate,\n            @Named(\"nextIndexValue\") @Optional BigDecimal nextIndexValue) {\n        LeaseTermForIndexableRent term = (LeaseTermForIndexableRent) putLeaseTerm(\n                leaseReference,\n                unitReference,\n                itemSequence,\n                itemType,\n                itemStartDate,\n                startDate,\n                endDate,\n                sequence,\n                statusStr);\n        if (term != null) {\n            Index index = indices.findIndex(indexReference);\n            LeaseTermFrequency indexationFreq = LeaseTermFrequency.valueOf(indexationFrequency);\n            term.setIndex(index);\n            term.setFrequency(indexationFreq);\n            term.setEffectiveDate(effectiveDate);\n            term.setBaseValue(baseValue);\n            term.setIndexedValue(indexedValue);\n            term.setSettledValue(settledValue);\n            term.setBaseIndexStartDate(baseIndexStartDate);\n            term.setBaseIndexValue(baseIndexValue);\n            term.setNextIndexStartDate(nextIndexStartDate);\n            term.setNextIndexValue(nextIndexValue);\n            term.setIndexationPercentage(indexationPercentage);\n            term.setLevellingPercentage(levellingPercentage);\n        }\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseTermForTurnoverRent(\n            // start generic fields\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"itemSequence\") BigInteger itemSequence,\n            @Named(\"itemType\") String itemType,\n            @Named(\"itemStartDate\") LocalDate itemStartDate,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"status\") @Optional String status,\n            // end generic fields\n            @Named(\"turnoverRentRule\") @Optional String turnoverRentRule,\n            @Named(\"budgetedTurnover\") @Optional BigDecimal budgetedTurnover,\n            @Named(\"auditedTurnover\") @Optional BigDecimal auditedTurnover,\n            @Named(\"turnoverRentValue\") @Optional BigDecimal turnoverRentValue) {\n        LeaseTermForTurnoverRent term = (LeaseTermForTurnoverRent) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n        if (term != null) {\n            term.setTurnoverRentValue(turnoverRentValue);\n            term.setBudgetedTurnover(budgetedTurnover);\n            term.setAuditedTurnover(auditedTurnover);\n            term.setTurnoverRentRule(turnoverRentRule);\n        }\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putLeaseTermForServiceCharge(\n            // start generic fields\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"tenantReference\") String tenantReference,\n            @Named(\"unitReference\") @Optional String unitReference,\n            @Named(\"itemSequence\") BigInteger itemSequence,\n            @Named(\"itemType\") String itemType,\n            @Named(\"itemStartDate\") LocalDate itemStartDate,\n            @Named(\"sequence\") BigInteger sequence,\n            @Named(\"startDate\") @Optional LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate,\n            @Named(\"status\") @Optional String status,\n            // end generic fields\n            @Named(\"auditedValue\") @Optional BigDecimal auditedValue,\n            @Named(\"budgetedValue\") @Optional BigDecimal budgetedValue) {\n        LeaseTermForServiceCharge term = (LeaseTermForServiceCharge) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n        if (term != null) {\n            term.setAuditedValue(auditedValue);\n            term.setBudgetedValue(budgetedValue);\n        }\n    }\n\n    private LeaseTerm putLeaseTerm(\n            final String leaseReference,\n            final String unitReference,\n            final BigInteger itemSequence,\n            final String itemType,\n            final LocalDate itemStartDate,\n            final LocalDate startDate,\n            final LocalDate endDate,\n            final BigInteger sequence,\n            final String statusStr) {\n        Lease lease = leases.findLeaseByReference(leaseReference);\n        if (lease == null) {\n            throw new ApplicationException(String.format(\"Leaseitem with reference %1$s not found.\", leaseReference));\n        }\n        Unit unit;\n        if (unitReference != null) {\n            unit = units.findUnitByReference(unitReference);\n            if (unitReference != null && unit == null) {\n                throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n            }\n        }\n        LeaseItemType leaseItemType = fetchLeaseItemType(itemType);\n        LeaseItem item = lease.findItem(leaseItemType, itemStartDate, itemSequence);\n        if (item == null) {\n            throw new ApplicationException(String.format(\"LeaseItem with reference %1$s, %2$s, %3$s, %4$s not found.\", leaseReference, leaseItemType.toString(), itemStartDate.toString(), itemSequence.toString()));\n        }\n        // check if the date is within range of lease\n        if (lease.getTerminationDate() == null || lease.getTerminationDate().compareTo(startDate) >= 0) {\n            LeaseTerm term = item.findTermWithSequence(sequence);\n            if (term == null) {\n                if (sequence.equals(BigInteger.ONE)) {\n                    term = item.newTerm(startDate);\n                } else {\n                    LeaseTerm previousTerm = item.findTermWithSequence(sequence.subtract(BigInteger.ONE));\n                    term = previousTerm.createNext(startDate);\n                }\n                term.setSequence(sequence);\n            }\n            term.setStatus(org.estatio.dom.lease.LeaseTermStatus.valueOf(statusStr));\n            // will be overwritten if there is a next term\n            term.setEndDate(lease.getTerminationDate());\n            return term;\n        }\n        return null;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putBankAccount(\n            // start generic fields\n            @Named(\"reference\") @Optional String reference,\n            @Named(\"name\") @Optional String name,\n            @Named(\"bankAccountType\") @Optional String bankAccountType,\n            @Named(\"ownerReference\") String ownerReference,\n            @Named(\"iban\") @Optional String iban,\n            @Named(\"countryCode\") @Optional String countryCode,\n            @Named(\"nationalCheckCode\") @Optional String nationalCheckCode,\n            @Named(\"nationalBankCode\") @Optional String nationalBankCode,\n            @Named(\"branchCode\") @Optional String branchCode,\n            @Named(\"accountNumber\") @Optional String accountNumber\n            ) {\n        BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(reference);\n        Party owner = parties.findPartyByReference(ownerReference);\n        if (owner == null)\n            return;\n        if (bankAccount == null) {\n            bankAccount = financialAccounts.newBankAccount(owner, iban);\n        }\n        bankAccount.setReference(reference);\n        bankAccount.setAccountNumber(accountNumber);\n        bankAccount.setBranchCode(branchCode);\n        bankAccount.setName(name);\n        bankAccount.setCountry(fetchCountry(countryCode, false));\n        bankAccount.setNationalBankCode(nationalBankCode);\n        bankAccount.setNationalCheckCode(nationalCheckCode);\n        bankAccount.setBankAccountType(BankAccountType.valueOf(bankAccountType));\n        bankAccount.verifyIban();\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putBankMandate(\n            @Named(\"reference\") String reference,\n            @Named(\"name\") @Optional String name,\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"debtorReference\") String debtorReference,\n            @Named(\"creditorReference\") String creditorReference,\n            @Named(\"bankAccountReference\") String bankAccountReference,\n            @Named(\"startDate\") LocalDate startDate,\n            @Named(\"endDate\") @Optional LocalDate endDate) {\n        BankMandate bankMandate = (BankMandate) agreements.findAgreementByReference(reference);\n        BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(bankAccountReference);\n        if (bankAccount == null)\n            throw new ApplicationException(String.format(\"BankAccount with reference %1$s not found\", bankAccountReference));\n        if (bankMandate == null) {\n            Party debtor = fetchParty(debtorReference);\n            Party creditor = fetchParty(creditorReference);\n            Lease lease = fetchLease(leaseReference);\n            bankMandate = bankMandates.newBankMandate(reference, name, startDate, endDate, debtor, creditor, bankAccount);\n            lease.paidBy(bankMandate);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    public void putBreakOption(\n            @Named(\"leaseReference\") String leaseReference,\n            @Named(\"breakType\") String breakTypeStr,\n            @Named(\"breakExcerciseType\") String breakExcerciseTypeStr,\n            @Named(\"breakDate\") LocalDate breakDate,\n            @Named(\"notificationDate\") LocalDate notificationDate,\n            @Named(\"notificationPeriod\") @Optional String notificationPeriodStr,\n            @Named(\"description\") @Optional String description\n            ) {\n        Lease lease = fetchLease(leaseReference);\n        BreakType breakType = BreakType.valueOf(breakTypeStr);\n        BreakExerciseType breakExerciseType = BreakExerciseType.valueOf(breakExcerciseTypeStr);\n        if (notificationDate != null) {\n            Period period = new Period(notificationDate, breakDate);\n            notificationPeriodStr = JodaPeriodUtils.asSimpleString(period);\n        }\n        if (lease.validateNewBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description) == null) {\n            lease.newBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    private Agreements agreements;\n\n    public void injectAgreements(Agreements agreements) {\n        this.agreements = agreements;\n    }\n\n    private BankMandates bankMandates;\n\n    public void injectBankMandates(BankMandates bankMandates) {\n        this.bankMandates = bankMandates;\n    }\n\n    private ClockService clockService;\n\n    public void setClockService(ClockService clockService) {\n        this.clockService = clockService;\n    }\n\n    private Countries countries;\n\n    public void injectCountries(final Countries countries) {\n        this.countries = countries;\n    }\n\n    private States states;\n\n    public void injectStates(final States states) {\n        this.states = states;\n    }\n\n    private Units<Unit> units;\n\n    public void injectUnits(final Units<Unit> units) {\n        this.units = units;\n    }\n\n    private Properties properties;\n\n    public void injectProperties(final Properties properties) {\n        this.properties = properties;\n    }\n\n    private Parties parties;\n\n    public void injectParties(final Parties parties) {\n        this.parties = parties;\n    }\n\n    private Organisations organisations;\n\n    public void injectOrganisations(final Organisations organisations) {\n        this.organisations = organisations;\n    }\n\n    private Persons persons;\n\n    public void injectOrganisations(final Persons persons) {\n        this.persons = persons;\n    }\n\n    private CommunicationChannelContributions communicationChannelContributions;\n\n    public void injectCommunicationChannelContributedActions(final CommunicationChannelContributions communicationChannelContributedActions) {\n        this.communicationChannelContributions = communicationChannelContributedActions;\n    }\n\n    private CommunicationChannels communicationChannels;\n\n    public void injectCommunicationChannels(final CommunicationChannels communicationChannels) {\n        this.communicationChannels = communicationChannels;\n    }\n\n    private PostalAddresses postalAddresses;\n\n    public void injectPostalAddresses(PostalAddresses postalAddresses) {\n        this.postalAddresses = postalAddresses;\n    }\n\n    private EmailAddresses emailAddresses;\n\n    public void injectEmailAddresses(EmailAddresses emailAddresses) {\n        this.emailAddresses = emailAddresses;\n    }\n\n    private PhoneOrFaxNumbers phoneOrFaxNumbers;\n\n    public void setPhoneOrFaxNumbers(PhoneOrFaxNumbers phoneOrFaxNumbers) {\n        this.phoneOrFaxNumbers = phoneOrFaxNumbers;\n    }\n\n    private Leases leases;\n\n    public void injectLeaseRepository(final Leases leases) {\n        this.leases = leases;\n    }\n\n    private AgreementRoleTypes agreementRoleTypes;\n\n    public void injectAgreementRoleTypes(AgreementRoleTypes agreementRoleTypes) {\n        this.agreementRoleTypes = agreementRoleTypes;\n    }\n\n    private Occupancies occupancies;\n\n    public void injectLeaseUnits(final Occupancies leaseUnits) {\n        this.occupancies = leaseUnits;\n    }\n\n    private Taxes taxes;\n\n    public void injectTaxes(final Taxes taxes) {\n        this.taxes = taxes;\n    }\n\n    private Charges charges;\n\n    public void injectCharges(final Charges charges) {\n        this.charges = charges;\n    }\n\n    private ChargeGroups chargeGroups;\n\n    public void injectChargeGroups(final ChargeGroups chargeGroups) {\n        this.chargeGroups = chargeGroups;\n    }\n\n    private Indices indices;\n\n    public void injectIndices(final Indices indices) {\n        this.indices = indices;\n    }\n\n    private FinancialAccounts financialAccounts;\n\n    public void injectFinancialAccounts(FinancialAccounts financialAccounts) {\n        this.financialAccounts = financialAccounts;\n    }\n\n    private Invoices invoices;\n\n    public void injectInvoices(Invoices invoices) {\n        this.invoices = invoices;\n    }\n\n    private AgreementRoleCommunicationChannelTypes agreementRoleCommunicationChannelTypes;\n\n    public void injectAgreementRoleCommunicationChannelTypes(AgreementRoleCommunicationChannelTypes agreementRoleCommunicationChannelTypes) {\n        this.agreementRoleCommunicationChannelTypes = agreementRoleCommunicationChannelTypes;\n    }\n\n    private LeaseTypes leaseTypes;\n\n    public void injectLeaseTypes(LeaseTypes leaseTypes) {\n        this.leaseTypes = leaseTypes;\n    }\n\n}",
        "start_point": {
            "row": 101,
            "column": 0
        },
        "end_point": {
            "row": 980,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic String getId() {\n    return \"api\";\n}",
                "name": "getId",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"api\";\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "public String iconName() {\n    return \"Api\";\n}",
                "name": "iconName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"Api\";\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putCountry(\n        @Named(\"code\") String code,\n        @Named(\"alpha2Code\") String alpha2Code,\n        @Named(\"name\") String name) {\n    Country country = countries.findCountry(code);\n    if (country == null) {\n        country = countries.createCountry(code, alpha2Code, name);\n    }\n}",
                "name": "putCountry",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"code\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"alpha2Code\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    }
                ],
                "body": "{\n    Country country = countries.findCountry(code);\n    if (country == null) {\n        country = countries.createCountry(code, alpha2Code, name);\n    }\n}",
                "start_point": {
                    "row": 115,
                    "column": 4
                },
                "end_point": {
                    "row": 124,
                    "column": 5
                }
            },
            {
                "definition": "private Country fetchCountry(String countryCode) {\n    return fetchCountry(countryCode, true);\n}",
                "name": "fetchCountry",
                "modifiers": "private",
                "return_type": "Country",
                "parameters": [
                    {
                        "type": "String",
                        "name": "countryCode"
                    }
                ],
                "body": "{\n    return fetchCountry(countryCode, true);\n}",
                "start_point": {
                    "row": 126,
                    "column": 4
                },
                "end_point": {
                    "row": 128,
                    "column": 5
                }
            },
            {
                "definition": "private Country fetchCountry(String countryCode, boolean exception) {\n    Country country = countries.findCountry(countryCode);\n    if (country == null && exception) {\n        throw new ApplicationException(String.format(\"Country with code %1$s not found\", countryCode));\n    }\n    return country;\n}",
                "name": "fetchCountry",
                "modifiers": "private",
                "return_type": "Country",
                "parameters": [
                    {
                        "type": "String",
                        "name": "countryCode"
                    },
                    {
                        "type": "boolean",
                        "name": "exception"
                    }
                ],
                "body": "{\n    Country country = countries.findCountry(countryCode);\n    if (country == null && exception) {\n        throw new ApplicationException(String.format(\"Country with code %1$s not found\", countryCode));\n    }\n    return country;\n}",
                "start_point": {
                    "row": 130,
                    "column": 4
                },
                "end_point": {
                    "row": 136,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putState(\n        @Named(\"code\") String reference,\n        @Named(\"name\") String name,\n        @Named(\"countryCode\") String countryCode) {\n    Country country = fetchCountry(countryCode);\n    State state = states.findState(countryCode);\n    if (state == null) {\n        state = states.newState(reference, name, country);\n    }\n    state.setName(name);\n    state.setCountry(country);\n}",
                "name": "putState",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"code\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"countryCode\")",
                        "name": "String"
                    }
                ],
                "body": "{\n    Country country = fetchCountry(countryCode);\n    State state = states.findState(countryCode);\n    if (state == null) {\n        state = states.newState(reference, name, country);\n    }\n    state.setName(name);\n    state.setCountry(country);\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 152,
                    "column": 5
                }
            },
            {
                "definition": "private State fetchState(String stateCode, boolean exception) {\n    State country = states.findState(stateCode);\n    if (country == null && exception) {\n        throw new ApplicationException(String.format(\"State with code %1$s not found\", stateCode));\n    }\n    return country;\n}",
                "name": "fetchState",
                "modifiers": "private",
                "return_type": "State",
                "parameters": [
                    {
                        "type": "String",
                        "name": "stateCode"
                    },
                    {
                        "type": "boolean",
                        "name": "exception"
                    }
                ],
                "body": "{\n    State country = states.findState(stateCode);\n    if (country == null && exception) {\n        throw new ApplicationException(String.format(\"State with code %1$s not found\", stateCode));\n    }\n    return country;\n}",
                "start_point": {
                    "row": 154,
                    "column": 4
                },
                "end_point": {
                    "row": 160,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLeaseType(\n        @Named(\"reference\") String reference,\n        @Named(\"name\") String name) {\n    leaseTypes.findOrCreate(reference, name);\n}",
                "name": "putLeaseType",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    }
                ],
                "body": "{\n    leaseTypes.findOrCreate(reference, name);\n}",
                "start_point": {
                    "row": 164,
                    "column": 4
                },
                "end_point": {
                    "row": 169,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putCharge(\n        @Named(\"reference\") String reference,\n        @Named(\"name\") String name,\n        @Named(\"description\") String description,\n        @Named(\"taxReference\") String taxReference,\n        @Named(\"chargeGroupReference\") String chargeGroupReference) {\n    Tax tax = fetchTaxIfAny(taxReference);\n    ChargeGroup chargeGroup = fetchOrCreateChargeGroup(chargeGroupReference);\n    charges.newCharge(reference, name, description, tax, chargeGroup);\n}",
                "name": "putCharge",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"description\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"taxReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"chargeGroupReference\")",
                        "name": "String"
                    }
                ],
                "body": "{\n    Tax tax = fetchTaxIfAny(taxReference);\n    ChargeGroup chargeGroup = fetchOrCreateChargeGroup(chargeGroupReference);\n    charges.newCharge(reference, name, description, tax, chargeGroup);\n}",
                "start_point": {
                    "row": 173,
                    "column": 4
                },
                "end_point": {
                    "row": 183,
                    "column": 5
                }
            },
            {
                "definition": "private Charge fetchCharge(String chargeReference) {\n    Charge charge = charges.findCharge(chargeReference);\n    if (charge == null) {\n        throw new ApplicationException(String.format(\"Charge with reference %s not found.\", chargeReference));\n    }\n    return charge;\n}",
                "name": "fetchCharge",
                "modifiers": "private",
                "return_type": "Charge",
                "parameters": [
                    {
                        "type": "String",
                        "name": "chargeReference"
                    }
                ],
                "body": "{\n    Charge charge = charges.findCharge(chargeReference);\n    if (charge == null) {\n        throw new ApplicationException(String.format(\"Charge with reference %s not found.\", chargeReference));\n    }\n    return charge;\n}",
                "start_point": {
                    "row": 185,
                    "column": 4
                },
                "end_point": {
                    "row": 191,
                    "column": 5
                }
            },
            {
                "definition": "private ChargeGroup fetchOrCreateChargeGroup(String chargeGroupReference) {\n    ChargeGroup chargeGroup = chargeGroups.findChargeGroup(chargeGroupReference);\n    if (chargeGroup == null) {\n        chargeGroup = chargeGroups.createChargeGroup(chargeGroupReference, null);\n    }\n    return chargeGroup;\n}",
                "name": "fetchOrCreateChargeGroup",
                "modifiers": "private",
                "return_type": "ChargeGroup",
                "parameters": [
                    {
                        "type": "String",
                        "name": "chargeGroupReference"
                    }
                ],
                "body": "{\n    ChargeGroup chargeGroup = chargeGroups.findChargeGroup(chargeGroupReference);\n    if (chargeGroup == null) {\n        chargeGroup = chargeGroups.createChargeGroup(chargeGroupReference, null);\n    }\n    return chargeGroup;\n}",
                "start_point": {
                    "row": 193,
                    "column": 4
                },
                "end_point": {
                    "row": 199,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putTax(\n        @Named(\"reference\") String reference,\n        @Named(\"name\") String name,\n        @Named(\"percentage\") BigDecimal percentage,\n        @Named(\"startDate\") LocalDate startDate) {\n    Tax tax = fetchTaxIfAny(reference);\n    if (tax == null) {\n        tax = taxes.newTax(reference, name);\n        tax.setName(name);\n    }\n    tax.newRate(startDate, percentage);\n}",
                "name": "putTax",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"percentage\")",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"startDate\")",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    Tax tax = fetchTaxIfAny(reference);\n    if (tax == null) {\n        tax = taxes.newTax(reference, name);\n        tax.setName(name);\n    }\n    tax.newRate(startDate, percentage);\n}",
                "start_point": {
                    "row": 203,
                    "column": 4
                },
                "end_point": {
                    "row": 215,
                    "column": 5
                }
            },
            {
                "definition": "private Tax fetchTaxIfAny(String reference) {\n    return taxes.findTaxByReference(reference);\n}",
                "name": "fetchTaxIfAny",
                "modifiers": "private",
                "return_type": "Tax",
                "parameters": [
                    {
                        "type": "String",
                        "name": "reference"
                    }
                ],
                "body": "{\n    return taxes.findTaxByReference(reference);\n}",
                "start_point": {
                    "row": 217,
                    "column": 4
                },
                "end_point": {
                    "row": 219,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putPerson(\n        @Named(\"reference\") String reference,\n        @Named(\"initials\") @Optional String initials,\n        @Named(\"firstName\") String firstName,\n        @Named(\"lastName\") String lastName) {\n    Person person = (Person) parties.findPartyByReference(reference);\n    if (person == null) {\n        person = persons.newPerson(reference, initials, firstName, lastName);\n    }\n    person.setFirstName(firstName);\n    person.setLastName(lastName);\n}",
                "name": "putPerson",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"initials\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"firstName\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"lastName\")",
                        "name": "String"
                    }
                ],
                "body": "{\n    Person person = (Person) parties.findPartyByReference(reference);\n    if (person == null) {\n        person = persons.newPerson(reference, initials, firstName, lastName);\n    }\n    person.setFirstName(firstName);\n    person.setLastName(lastName);\n}",
                "start_point": {
                    "row": 223,
                    "column": 4
                },
                "end_point": {
                    "row": 235,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putOrganisation(\n        @Named(\"reference\") String reference,\n        @Named(\"name\") String name,\n        @Named(\"vatCode\") @Optional String vatCode,\n        @Named(\"fiscalCode\") @Optional String fiscalCode) {\n    Organisation org = (Organisation) parties.findPartyByReference(reference);\n    if (org == null) {\n        org = organisations.newOrganisation(reference, name);\n        org.setFiscalCode(fiscalCode);\n        org.setVatCode(vatCode);\n    }\n    org.setName(name);\n}",
                "name": "putOrganisation",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"vatCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"fiscalCode\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Organisation org = (Organisation) parties.findPartyByReference(reference);\n    if (org == null) {\n        org = organisations.newOrganisation(reference, name);\n        org.setFiscalCode(fiscalCode);\n        org.setVatCode(vatCode);\n    }\n    org.setName(name);\n}",
                "start_point": {
                    "row": 237,
                    "column": 4
                },
                "end_point": {
                    "row": 250,
                    "column": 5
                }
            },
            {
                "definition": "private Party fetchParty(String partyReference) {\n    Party party = parties.findPartyByReference(partyReference);\n    if (party == null) {\n        throw new ApplicationException(String.format(\"Party with reference %s not found.\", partyReference));\n    }\n    return party;\n}",
                "name": "fetchParty",
                "modifiers": "private",
                "return_type": "Party",
                "parameters": [
                    {
                        "type": "String",
                        "name": "partyReference"
                    }
                ],
                "body": "{\n    Party party = parties.findPartyByReference(partyReference);\n    if (party == null) {\n        throw new ApplicationException(String.format(\"Party with reference %s not found.\", partyReference));\n    }\n    return party;\n}",
                "start_point": {
                    "row": 252,
                    "column": 4
                },
                "end_point": {
                    "row": 258,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putProperty(\n        @Named(\"reference\") String reference,\n        @Named(\"name\") String name,\n        @Named(\"countryCode\") String countryCode,\n        @Named(\"city\") String city,\n        @Named(\"type\") String type,\n        @Named(\"acquireDate\") @Optional LocalDate acquireDate,\n        @Named(\"disposalDate\") @Optional LocalDate disposalDate,\n        @Named(\"openingDate\") @Optional LocalDate openingDate,\n        @Named(\"ownerReference\") @Optional String ownerReference,\n        @Named(\"numeratorFormat\") @Optional String numeratorFormat\n        ) {\n    Party owner = fetchParty(ownerReference);\n    Property property = fetchProperty(reference, true);\n    property.setName(name);\n    property.setCountry(fetchCountry(countryCode));\n    property.setCity(city);\n    property.setType(PropertyType.valueOf(type));\n    property.setAcquireDate(acquireDate);\n    property.setDisposalDate(disposalDate);\n    property.setOpeningDate(openingDate);\n    property.addRoleIfDoesNotExist(owner, FixedAssetRoleType.PROPERTY_OWNER, null, null);\n    if (numeratorFormat != null)\n        invoices.createInvoiceNumberNumerator(property, numeratorFormat, BigInteger.ZERO);\n}",
                "name": "putProperty",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"countryCode\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"city\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"type\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"acquireDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"disposalDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"openingDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"ownerReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"numeratorFormat\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Party owner = fetchParty(ownerReference);\n    Property property = fetchProperty(reference, true);\n    property.setName(name);\n    property.setCountry(fetchCountry(countryCode));\n    property.setCity(city);\n    property.setType(PropertyType.valueOf(type));\n    property.setAcquireDate(acquireDate);\n    property.setDisposalDate(disposalDate);\n    property.setOpeningDate(openingDate);\n    property.addRoleIfDoesNotExist(owner, FixedAssetRoleType.PROPERTY_OWNER, null, null);\n    if (numeratorFormat != null)\n        invoices.createInvoiceNumberNumerator(property, numeratorFormat, BigInteger.ZERO);\n}",
                "start_point": {
                    "row": 262,
                    "column": 4
                },
                "end_point": {
                    "row": 287,
                    "column": 5
                }
            },
            {
                "definition": "private Property fetchProperty(String reference, boolean createIfNotFond) {\n    Property property = properties.findPropertyByReference(reference);\n    if (property == null) {\n        if (!createIfNotFond)\n            throw new ApplicationException(String.format(\"Property with reference %s not found.\", reference));\n        property = properties.newProperty(reference, null, PropertyType.MIXED, null, null, null);\n    }\n    return property;\n}",
                "name": "fetchProperty",
                "modifiers": "private",
                "return_type": "Property",
                "parameters": [
                    {
                        "type": "String",
                        "name": "reference"
                    },
                    {
                        "type": "boolean",
                        "name": "createIfNotFond"
                    }
                ],
                "body": "{\n    Property property = properties.findPropertyByReference(reference);\n    if (property == null) {\n        if (!createIfNotFond)\n            throw new ApplicationException(String.format(\"Property with reference %s not found.\", reference));\n        property = properties.newProperty(reference, null, PropertyType.MIXED, null, null, null);\n    }\n    return property;\n}",
                "start_point": {
                    "row": 289,
                    "column": 4
                },
                "end_point": {
                    "row": 297,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putUnit(\n        @Named(\"reference\") String reference,\n        @Named(\"propertyReference\") String propertyReference,\n        @Named(\"ownerReference\") @Optional String ownerReference,\n        @Named(\"name\") String name, @Named(\"type\") String type,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate,\n        @Named(\"area\") @Optional BigDecimal area,\n        @Named(\"salesArea\") @Optional BigDecimal salesArea,\n        @Named(\"storageArea\") @Optional BigDecimal storageArea,\n        @Named(\"mezzanineArea\") @Optional BigDecimal mezzanineArea,\n        @Named(\"dehorsArea\") @Optional BigDecimal dehorsArea,\n        @Named(\"address1\") @Optional String address1,\n        @Named(\"city\") @Optional String city,\n        @Named(\"postalCode\") @Optional String postalCode,\n        @Named(\"stateCode\") @Optional String stateCode,\n        @Named(\"countryCode\") @Optional String countryCode) {\n    Property property = fetchProperty(propertyReference, false);\n    Unit unit = units.findUnitByReference(reference);\n    if (unit == null) {\n        unit = property.newUnit(reference, name, UnitType.BOUTIQUE);\n    }\n    // set attributes\n    unit.setName(name);\n    unit.setType(UnitType.valueOf(type));\n    unit.changeDates(startDate, endDate);\n    unit.setArea(area);\n    unit.setSalesArea(salesArea);\n    unit.setStorageArea(storageArea);\n    unit.setMezzanineArea(mezzanineArea);\n    unit.setDehorsArea(dehorsArea);\n    CommunicationChannel cc = communicationChannelContributions.findCommunicationChannelForType(unit, CommunicationChannelType.POSTAL_ADDRESS);\n    if (cc == null) {\n        communicationChannelContributions.newPostal(unit, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, null, postalCode, city);\n    }\n}",
                "name": "putUnit",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"propertyReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"ownerReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"type\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"area\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"salesArea\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"storageArea\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"mezzanineArea\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"dehorsArea\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"address1\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"city\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"postalCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"stateCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"countryCode\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Property property = fetchProperty(propertyReference, false);\n    Unit unit = units.findUnitByReference(reference);\n    if (unit == null) {\n        unit = property.newUnit(reference, name, UnitType.BOUTIQUE);\n    }\n    // set attributes\n    unit.setName(name);\n    unit.setType(UnitType.valueOf(type));\n    unit.changeDates(startDate, endDate);\n    unit.setArea(area);\n    unit.setSalesArea(salesArea);\n    unit.setStorageArea(storageArea);\n    unit.setMezzanineArea(mezzanineArea);\n    unit.setDehorsArea(dehorsArea);\n    CommunicationChannel cc = communicationChannelContributions.findCommunicationChannelForType(unit, CommunicationChannelType.POSTAL_ADDRESS);\n    if (cc == null) {\n        communicationChannelContributions.newPostal(unit, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, null, postalCode, city);\n    }\n}",
                "start_point": {
                    "row": 301,
                    "column": 4
                },
                "end_point": {
                    "row": 337,
                    "column": 5
                }
            },
            {
                "definition": "private Unit fetchUnit(String unitReference) {\n    if (unitReference != null) {\n        Unit unit = units.findUnitByReference(unitReference);\n        if (unit == null) {\n            throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n        }\n        return unit;\n    }\n    return null;\n}",
                "name": "fetchUnit",
                "modifiers": "private",
                "return_type": "Unit",
                "parameters": [
                    {
                        "type": "String",
                        "name": "unitReference"
                    }
                ],
                "body": "{\n    if (unitReference != null) {\n        Unit unit = units.findUnitByReference(unitReference);\n        if (unit == null) {\n            throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n        }\n        return unit;\n    }\n    return null;\n}",
                "start_point": {
                    "row": 339,
                    "column": 4
                },
                "end_point": {
                    "row": 348,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putPropertyPostalAddress(\n        @Named(\"propertyReference\") String propertyReference,\n        @Named(\"address1\") @Optional String address1,\n        @Named(\"address2\") @Optional String address2,\n        @Named(\"city\") String city,\n        @Named(\"postalCode\") @Optional String postalCode,\n        @Named(\"stateCode\") @Optional String stateCode,\n        @Named(\"countryCode\") String countryCode) {\n    final Property property = properties.findPropertyByReference(propertyReference);\n    if (property == null) {\n        throw new ApplicationException(String.format(\"Property with reference %s not found.\", propertyReference));\n    }\n    final CommunicationChannel comm = communicationChannelContributions.findCommunicationChannelForType(property, null);\n    if (comm == null) {\n        communicationChannelContributions.newPostal(property, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, address2, postalCode, city);\n    }\n}",
                "name": "putPropertyPostalAddress",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"propertyReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"address1\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"address2\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"city\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"postalCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"stateCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"countryCode\")",
                        "name": "String"
                    }
                ],
                "body": "{\n    final Property property = properties.findPropertyByReference(propertyReference);\n    if (property == null) {\n        throw new ApplicationException(String.format(\"Property with reference %s not found.\", propertyReference));\n    }\n    final CommunicationChannel comm = communicationChannelContributions.findCommunicationChannelForType(property, null);\n    if (comm == null) {\n        communicationChannelContributions.newPostal(property, CommunicationChannelType.POSTAL_ADDRESS, countries.findCountry(countryCode), states.findState(stateCode), address1, address2, postalCode, city);\n    }\n}",
                "start_point": {
                    "row": 352,
                    "column": 4
                },
                "end_point": {
                    "row": 369,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putPartyCommunicationChannels(\n        @Named(\"partyReference\") String partyReference,\n        @Named(\"reference\") @Optional String reference,\n        @Named(\"address1\") @Optional String address1,\n        @Named(\"address2\") @Optional String address2,\n        @Named(\"city\") @Optional String city,\n        @Named(\"postalCode\") @Optional String postalCode,\n        @Named(\"stateCode\") @Optional String stateCode,\n        @Named(\"countryCode\") @Optional String countryCode,\n        @Named(\"phoneNumber\") @Optional String phoneNumber,\n        @Named(\"faxNumber\") @Optional String faxNumber,\n        @Named(\"emailAddress\") @Optional String emailAddress\n        ) {\n    Party party = fetchParty(partyReference);\n    if (party == null)\n        throw new ApplicationException(String.format(\"Party with reference [%s] not found\", partyReference));\n\n    // Address\n    if (address1 != null) {\n        Country country = fetchCountry(countryCode);\n        PostalAddress comm = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, country);\n        if (comm == null) {\n            comm = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, states.findState(stateCode), countries.findCountry(countryCode));\n            comm.setReference(reference);\n        }\n    }\n    // Phone\n    if (phoneNumber != null) {\n        CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, phoneNumber);\n        if (comm == null) {\n            comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.PHONE_NUMBER, phoneNumber);\n            comm.setReference(reference);\n        }\n    }\n    // Fax\n    if (faxNumber != null) {\n        CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, faxNumber);\n        if (comm == null) {\n            comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.FAX_NUMBER, faxNumber);\n            comm.setReference(reference);\n        }\n    }\n    // Email\n    if (emailAddress != null) {\n        CommunicationChannel comm = emailAddresses.findByEmailAddress(party, emailAddress);\n        if (comm == null) {\n            comm = communicationChannels.newEmail(party, CommunicationChannelType.EMAIL_ADDRESS, emailAddress);\n            comm.setReference(reference);\n        }\n    }\n}",
                "name": "putPartyCommunicationChannels",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"partyReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"reference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"address1\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"address2\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"city\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"postalCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"stateCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"countryCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"phoneNumber\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"faxNumber\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"emailAddress\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Party party = fetchParty(partyReference);\n    if (party == null)\n        throw new ApplicationException(String.format(\"Party with reference [%s] not found\", partyReference));\n\n    // Address\n    if (address1 != null) {\n        Country country = fetchCountry(countryCode);\n        PostalAddress comm = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, country);\n        if (comm == null) {\n            comm = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, states.findState(stateCode), countries.findCountry(countryCode));\n            comm.setReference(reference);\n        }\n    }\n    // Phone\n    if (phoneNumber != null) {\n        CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, phoneNumber);\n        if (comm == null) {\n            comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.PHONE_NUMBER, phoneNumber);\n            comm.setReference(reference);\n        }\n    }\n    // Fax\n    if (faxNumber != null) {\n        CommunicationChannel comm = phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, faxNumber);\n        if (comm == null) {\n            comm = communicationChannels.newPhoneOrFax(party, CommunicationChannelType.FAX_NUMBER, faxNumber);\n            comm.setReference(reference);\n        }\n    }\n    // Email\n    if (emailAddress != null) {\n        CommunicationChannel comm = emailAddresses.findByEmailAddress(party, emailAddress);\n        if (comm == null) {\n            comm = communicationChannels.newEmail(party, CommunicationChannelType.EMAIL_ADDRESS, emailAddress);\n            comm.setReference(reference);\n        }\n    }\n}",
                "start_point": {
                    "row": 373,
                    "column": 4
                },
                "end_point": {
                    "row": 424,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putPropertyActor(\n        @Named(\"propertyReference\") String propertyReference,\n        @Named(\"partyReference\") String partyReference,\n        @Named(\"type\") String typeStr,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate) {\n    final Property property = fetchProperty(propertyReference, false);\n    final Party party = fetchParty(partyReference);\n    final FixedAssetRoleType type = FixedAssetRoleType.valueOf(typeStr);\n    property.addRoleIfDoesNotExist(party, type, startDate, endDate);\n}",
                "name": "putPropertyActor",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"propertyReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"partyReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"type\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    final Property property = fetchProperty(propertyReference, false);\n    final Party party = fetchParty(partyReference);\n    final FixedAssetRoleType type = FixedAssetRoleType.valueOf(typeStr);\n    property.addRoleIfDoesNotExist(party, type, startDate, endDate);\n}",
                "start_point": {
                    "row": 428,
                    "column": 4
                },
                "end_point": {
                    "row": 439,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLease(\n        @Named(\"reference\") String reference,\n        @Named(\"name\") String name,\n        @Named(\"tenantReference\") String tenantReference,\n        @Named(\"landlordReference\") String landlordReference,\n        @Named(\"type\") String type,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate,\n        @Named(\"terminationDate\") @Optional LocalDate terminationDate,\n        @Named(\"propertyReference\") @Optional String propertyReference\n        ) {\n    Party tenant = fetchParty(tenantReference);\n    Party landlord = fetchParty(landlordReference);\n    Lease lease = leases.findLeaseByReference(reference);\n    LeaseType leaseType = leaseTypes.findOrCreate(type, null);\n    if (lease == null) {\n        lease = leases.newLease(reference, name, leaseType, startDate, null, endDate, landlord, tenant);\n    }\n    lease.setTerminationDate(terminationDate);\n}",
                "name": "putLease",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"tenantReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"landlordReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"type\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"terminationDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"propertyReference\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Party tenant = fetchParty(tenantReference);\n    Party landlord = fetchParty(landlordReference);\n    Lease lease = leases.findLeaseByReference(reference);\n    LeaseType leaseType = leaseTypes.findOrCreate(type, null);\n    if (lease == null) {\n        lease = leases.newLease(reference, name, leaseType, startDate, null, endDate, landlord, tenant);\n    }\n    lease.setTerminationDate(terminationDate);\n}",
                "start_point": {
                    "row": 441,
                    "column": 4
                },
                "end_point": {
                    "row": 461,
                    "column": 5
                }
            },
            {
                "definition": "private Lease fetchLease(String leaseReference) {\n    Lease lease;\n    lease = leases.findLeaseByReference(leaseReference);\n    if (lease == null) {\n        throw new ApplicationException(String.format(\"Lease with reference %s not found.\", leaseReference));\n    }\n    return lease;\n}",
                "name": "fetchLease",
                "modifiers": "private",
                "return_type": "Lease",
                "parameters": [
                    {
                        "type": "String",
                        "name": "leaseReference"
                    }
                ],
                "body": "{\n    Lease lease;\n    lease = leases.findLeaseByReference(leaseReference);\n    if (lease == null) {\n        throw new ApplicationException(String.format(\"Lease with reference %s not found.\", leaseReference));\n    }\n    return lease;\n}",
                "start_point": {
                    "row": 463,
                    "column": 4
                },
                "end_point": {
                    "row": 470,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLeaseLink(@Named(\"leaseReference\") String leaseReference, @Named(\"previousLeaseReference\") String previousLeaseReference) {\n    Lease lease = fetchLease(leaseReference);\n    Lease previousLease = fetchLease(previousLeaseReference);\n    lease.modifyPrevious(previousLease);\n}",
                "name": "putLeaseLink",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"previousLeaseReference\")",
                        "name": "String"
                    }
                ],
                "body": "{\n    Lease lease = fetchLease(leaseReference);\n    Lease previousLease = fetchLease(previousLeaseReference);\n    lease.modifyPrevious(previousLease);\n}",
                "start_point": {
                    "row": 472,
                    "column": 4
                },
                "end_point": {
                    "row": 477,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putOccupancy(\n        @Named(\"leaseReference\") String leaseReference,\n        @Named(\"unitReference\") @Optional String unitReference,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate,\n        @Named(\"tenancyStartDate\") @Optional LocalDate tenancyStartDate,\n        @Named(\"tenancyEndDate\") @Optional LocalDate tenancyEndDate,\n        @Named(\"size\") @Optional String size,\n        @Named(\"brand\") @Optional String brand,\n        @Named(\"sector\") @Optional String sector,\n        @Named(\"activity\") @Optional String activity,\n        @Named(\"reportTurnover\") @Optional String reportTurnover,\n        @Named(\"reportRent\") @Optional String reportRent,\n        @Named(\"reportOCR\") @Optional String reportOCR) {\n    Lease lease = fetchLease(leaseReference);\n    UnitForLease unit = (UnitForLease) units.findUnitByReference(unitReference);\n    if (unitReference != null && unit == null) {\n        throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n    }\n    Occupancy occupancy = occupancies.findByLeaseAndUnitAndStartDate(lease, unit, startDate);\n    if (occupancy == null) {\n        occupancy = lease.occupy(unit, startDate);\n    }\n\n    occupancy.setEndDate(endDate);\n    occupancy.setUnitSizeName(size);\n    occupancy.setBrandName(brand != null ? brand.replaceAll(\"\\\\p{C}\", \"\").trim() : null);\n    occupancy.setSectorName(sector);\n    occupancy.setActivityName(activity);\n    occupancy.setReportTurnover(reportTurnover != null ? OccupancyReportingType.valueOf(reportTurnover) : OccupancyReportingType.NO);\n    occupancy.setReportRent(reportRent != null ? OccupancyReportingType.valueOf(reportRent) : OccupancyReportingType.NO);\n    occupancy.setReportOCR(reportOCR != null ? OccupancyReportingType.valueOf(reportOCR) : OccupancyReportingType.NO);\n}",
                "name": "putOccupancy",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"unitReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"tenancyStartDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"tenancyEndDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"size\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"brand\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"sector\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"activity\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"reportTurnover\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"reportRent\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"reportOCR\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Lease lease = fetchLease(leaseReference);\n    UnitForLease unit = (UnitForLease) units.findUnitByReference(unitReference);\n    if (unitReference != null && unit == null) {\n        throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n    }\n    Occupancy occupancy = occupancies.findByLeaseAndUnitAndStartDate(lease, unit, startDate);\n    if (occupancy == null) {\n        occupancy = lease.occupy(unit, startDate);\n    }\n\n    occupancy.setEndDate(endDate);\n    occupancy.setUnitSizeName(size);\n    occupancy.setBrandName(brand != null ? brand.replaceAll(\"\\\\p{C}\", \"\").trim() : null);\n    occupancy.setSectorName(sector);\n    occupancy.setActivityName(activity);\n    occupancy.setReportTurnover(reportTurnover != null ? OccupancyReportingType.valueOf(reportTurnover) : OccupancyReportingType.NO);\n    occupancy.setReportRent(reportRent != null ? OccupancyReportingType.valueOf(reportRent) : OccupancyReportingType.NO);\n    occupancy.setReportOCR(reportOCR != null ? OccupancyReportingType.valueOf(reportOCR) : OccupancyReportingType.NO);\n}",
                "start_point": {
                    "row": 479,
                    "column": 4
                },
                "end_point": {
                    "row": 512,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLeaseItem(\n        @Named(\"leaseReference\") String leaseReference,\n        @Named(\"tenantReference\") String tenantReference,\n        @Named(\"unitReference\") @Optional String unitReference,\n        @Named(\"type\") @Optional String leaseItemTypeName,\n        @Named(\"sequence\") BigInteger sequence,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate,\n        @Named(\"chargeReference\") @Optional String chargeReference,\n        @Named(\"nextDueDate\") @Optional LocalDate nextDueDate,\n        @Named(\"invoicingFrequency\") @Optional String invoicingFrequency,\n        @Named(\"paymentMethod\") @Optional String paymentMethod,\n        @Named(\"status\") @Optional String status) {\n    Lease lease = fetchLease(leaseReference);\n\n    @SuppressWarnings(\"unused\")\n    Unit unit = fetchUnit(unitReference);\n\n    LeaseItemType itemType = fetchLeaseItemType(leaseItemTypeName);\n    Charge charge = fetchCharge(chargeReference);\n    //\n    LeaseItem item = lease.findItem(itemType, startDate, sequence);\n    if (item == null) {\n        item = lease.newItem(itemType, charge, InvoicingFrequency.valueOf(invoicingFrequency), PaymentMethod.valueOf(paymentMethod), startDate);\n    }\n    final LeaseItemStatus leaseItemStatus = LeaseItemStatus.valueOfElse(status, LeaseItemStatus.APPROVED);\n    item.setStatus(leaseItemStatus);\n    item.setEndDate(endDate);\n    item.setSequence(sequence);\n}",
                "name": "putLeaseItem",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"tenantReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"unitReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"type\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"sequence\")",
                        "name": "BigInteger"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"chargeReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"nextDueDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"invoicingFrequency\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"paymentMethod\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"status\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Lease lease = fetchLease(leaseReference);\n\n    @SuppressWarnings(\"unused\")\n    Unit unit = fetchUnit(unitReference);\n\n    LeaseItemType itemType = fetchLeaseItemType(leaseItemTypeName);\n    Charge charge = fetchCharge(chargeReference);\n    //\n    LeaseItem item = lease.findItem(itemType, startDate, sequence);\n    if (item == null) {\n        item = lease.newItem(itemType, charge, InvoicingFrequency.valueOf(invoicingFrequency), PaymentMethod.valueOf(paymentMethod), startDate);\n    }\n    final LeaseItemStatus leaseItemStatus = LeaseItemStatus.valueOfElse(status, LeaseItemStatus.APPROVED);\n    item.setStatus(leaseItemStatus);\n    item.setEndDate(endDate);\n    item.setSequence(sequence);\n}",
                "start_point": {
                    "row": 514,
                    "column": 4
                },
                "end_point": {
                    "row": 544,
                    "column": 5
                }
            },
            {
                "definition": "private LeaseItemType fetchLeaseItemType(String type) {\n    LeaseItemType itemType = LeaseItemType.valueOf(type);\n    if (itemType == null) {\n        throw new ApplicationException(String.format(\"Type with reference %s not found.\", type));\n    }\n    return itemType;\n}",
                "name": "fetchLeaseItemType",
                "modifiers": "private",
                "return_type": "LeaseItemType",
                "parameters": [
                    {
                        "type": "String",
                        "name": "type"
                    }
                ],
                "body": "{\n    LeaseItemType itemType = LeaseItemType.valueOf(type);\n    if (itemType == null) {\n        throw new ApplicationException(String.format(\"Type with reference %s not found.\", type));\n    }\n    return itemType;\n}",
                "start_point": {
                    "row": 546,
                    "column": 4
                },
                "end_point": {
                    "row": 552,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLeasePostalAddress(\n        @Named(\"partyReference\") String partyReference,\n        @Named(\"agreementRoleType\") String agreementRoleType,\n        @Named(\"leaseReference\") @Optional String leaseReference,\n        @Named(\"address1\") @Optional String address1,\n        @Named(\"address2\") @Optional String address2,\n        @Named(\"postalCode\") @Optional String postalCode,\n        @Named(\"city\") @Optional String city,\n        @Named(\"stateCode\") @Optional String stateCode,\n        @Named(\"countryCode\") @Optional String countryCode,\n        @Named(\"isInvoiceAddress\") @Optional BigInteger isInvoiceAddress\n        ) {\n    if (address1 != null && partyReference != null && leaseReference != null) {\n        Lease lease = fetchLease(leaseReference);\n        Party party = fetchParty(partyReference);\n        AgreementRoleCommunicationChannelType agreementRoleCommunicationChannelType = agreementRoleCommunicationChannelTypes.findByTitle(isInvoiceAddress.compareTo(BigInteger.ZERO) == 0 ? LeaseConstants.ARCCT_INVOICE_ADDRESS : LeaseConstants.ARCCT_ADMINISTRATION_ADDRESS);\n        if (agreementRoleCommunicationChannelType == null)\n            throw new ApplicationException(String.format(\"AgreementRoleCommunicationChannelType not found.\"));\n        PostalAddress address = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, fetchCountry(countryCode));\n        if (address == null) {\n            address = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, fetchState(stateCode, false), fetchCountry(countryCode, false));\n        }\n        AgreementRoleType art = agreementRoleTypes.findByTitle(StringUtils.capitalize(agreementRoleType.toLowerCase()));\n        if (art == null)\n            throw new ApplicationException(String.format(\"AgreementRoleType %s not found.\", agreementRoleType));\n        AgreementRole role = lease.findRole(party, art, clockService.now());\n        if (role == null)\n            throw new ApplicationException(String.format(\"Role for %s, %s not found.\", partyReference, agreementRoleType));\n        role.addCommunicationChannel(agreementRoleCommunicationChannelType, address);\n    }\n}",
                "name": "putLeasePostalAddress",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"partyReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"agreementRoleType\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"leaseReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"address1\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"address2\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"postalCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"city\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"stateCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"countryCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"isInvoiceAddress\") @Optional",
                        "name": "BigInteger"
                    }
                ],
                "body": "{\n    if (address1 != null && partyReference != null && leaseReference != null) {\n        Lease lease = fetchLease(leaseReference);\n        Party party = fetchParty(partyReference);\n        AgreementRoleCommunicationChannelType agreementRoleCommunicationChannelType = agreementRoleCommunicationChannelTypes.findByTitle(isInvoiceAddress.compareTo(BigInteger.ZERO) == 0 ? LeaseConstants.ARCCT_INVOICE_ADDRESS : LeaseConstants.ARCCT_ADMINISTRATION_ADDRESS);\n        if (agreementRoleCommunicationChannelType == null)\n            throw new ApplicationException(String.format(\"AgreementRoleCommunicationChannelType not found.\"));\n        PostalAddress address = (PostalAddress) postalAddresses.findByAddress(party, address1, postalCode, city, fetchCountry(countryCode));\n        if (address == null) {\n            address = communicationChannels.newPostal(party, CommunicationChannelType.POSTAL_ADDRESS, address1, address2, postalCode, city, fetchState(stateCode, false), fetchCountry(countryCode, false));\n        }\n        AgreementRoleType art = agreementRoleTypes.findByTitle(StringUtils.capitalize(agreementRoleType.toLowerCase()));\n        if (art == null)\n            throw new ApplicationException(String.format(\"AgreementRoleType %s not found.\", agreementRoleType));\n        AgreementRole role = lease.findRole(party, art, clockService.now());\n        if (role == null)\n            throw new ApplicationException(String.format(\"Role for %s, %s not found.\", partyReference, agreementRoleType));\n        role.addCommunicationChannel(agreementRoleCommunicationChannelType, address);\n    }\n}",
                "start_point": {
                    "row": 554,
                    "column": 4
                },
                "end_point": {
                    "row": 585,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLeaseTermForIndexableRent(\n        // start generic fields\n        @Named(\"leaseReference\") String leaseReference,\n        @Named(\"tenantReference\") String tenantReference,\n        @Named(\"unitReference\") @Optional String unitReference,\n        @Named(\"itemSequence\") BigInteger itemSequence,\n        @Named(\"itemType\") String itemType,\n        @Named(\"itemStartDate\") LocalDate itemStartDate,\n        @Named(\"sequence\") BigInteger sequence,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate,\n        @Named(\"status\") @Optional String statusStr,\n        // end generic fields\n        @Named(\"reviewDate\") @Optional LocalDate reviewDate,\n        @Named(\"effectiveDate\") @Optional LocalDate effectiveDate,\n        @Named(\"baseValue\") @Optional BigDecimal baseValue,\n        @Named(\"indexedValue\") @Optional BigDecimal indexedValue,\n        @Named(\"settledValue\") @Optional BigDecimal settledValue,\n        @Named(\"levellingValue\") @Optional BigDecimal levellingValue,\n        @Named(\"levellingPercentage\") @Optional BigDecimal levellingPercentage,\n        @Named(\"indexReference\") @Optional String indexReference,\n        @Named(\"indexationFrequency\") @Optional String indexationFrequency,\n        @Named(\"indexationPercentage\") @Optional BigDecimal indexationPercentage,\n        @Named(\"baseIndexReference\") @Optional String baseIndexReference,\n        @Named(\"baseIndexStartDate\") @Optional LocalDate baseIndexStartDate,\n        @Named(\"baseIndexEndDate\") @Optional LocalDate baseIndexEndDate,\n        @Named(\"baseIndexValue\") @Optional BigDecimal baseIndexValue,\n        @Named(\"nextIndexReference\") @Optional String nextIndexReference,\n        @Named(\"nextIndexStartDate\") @Optional LocalDate nextIndexStartDate,\n        @Named(\"nextIndexEndDate\") @Optional LocalDate nextIndexEndDate,\n        @Named(\"nextIndexValue\") @Optional BigDecimal nextIndexValue) {\n    LeaseTermForIndexableRent term = (LeaseTermForIndexableRent) putLeaseTerm(\n            leaseReference,\n            unitReference,\n            itemSequence,\n            itemType,\n            itemStartDate,\n            startDate,\n            endDate,\n            sequence,\n            statusStr);\n    if (term != null) {\n        Index index = indices.findIndex(indexReference);\n        LeaseTermFrequency indexationFreq = LeaseTermFrequency.valueOf(indexationFrequency);\n        term.setIndex(index);\n        term.setFrequency(indexationFreq);\n        term.setEffectiveDate(effectiveDate);\n        term.setBaseValue(baseValue);\n        term.setIndexedValue(indexedValue);\n        term.setSettledValue(settledValue);\n        term.setBaseIndexStartDate(baseIndexStartDate);\n        term.setBaseIndexValue(baseIndexValue);\n        term.setNextIndexStartDate(nextIndexStartDate);\n        term.setNextIndexValue(nextIndexValue);\n        term.setIndexationPercentage(indexationPercentage);\n        term.setLevellingPercentage(levellingPercentage);\n    }\n}",
                "name": "putLeaseTermForIndexableRent",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"tenantReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"unitReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"itemSequence\")",
                        "name": "BigInteger"
                    },
                    {
                        "type": "@Named(\"itemType\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"itemStartDate\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"sequence\")",
                        "name": "BigInteger"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"status\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"reviewDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"effectiveDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"baseValue\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"indexedValue\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"settledValue\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"levellingValue\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"levellingPercentage\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"indexReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"indexationFrequency\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"indexationPercentage\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"baseIndexReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"baseIndexStartDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"baseIndexEndDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"baseIndexValue\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"nextIndexReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"nextIndexStartDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"nextIndexEndDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"nextIndexValue\") @Optional",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    LeaseTermForIndexableRent term = (LeaseTermForIndexableRent) putLeaseTerm(\n            leaseReference,\n            unitReference,\n            itemSequence,\n            itemType,\n            itemStartDate,\n            startDate,\n            endDate,\n            sequence,\n            statusStr);\n    if (term != null) {\n        Index index = indices.findIndex(indexReference);\n        LeaseTermFrequency indexationFreq = LeaseTermFrequency.valueOf(indexationFrequency);\n        term.setIndex(index);\n        term.setFrequency(indexationFreq);\n        term.setEffectiveDate(effectiveDate);\n        term.setBaseValue(baseValue);\n        term.setIndexedValue(indexedValue);\n        term.setSettledValue(settledValue);\n        term.setBaseIndexStartDate(baseIndexStartDate);\n        term.setBaseIndexValue(baseIndexValue);\n        term.setNextIndexStartDate(nextIndexStartDate);\n        term.setNextIndexValue(nextIndexValue);\n        term.setIndexationPercentage(indexationPercentage);\n        term.setLevellingPercentage(levellingPercentage);\n    }\n}",
                "start_point": {
                    "row": 587,
                    "column": 4
                },
                "end_point": {
                    "row": 645,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLeaseTermForTurnoverRent(\n        // start generic fields\n        @Named(\"leaseReference\") String leaseReference,\n        @Named(\"tenantReference\") String tenantReference,\n        @Named(\"unitReference\") @Optional String unitReference,\n        @Named(\"itemSequence\") BigInteger itemSequence,\n        @Named(\"itemType\") String itemType,\n        @Named(\"itemStartDate\") LocalDate itemStartDate,\n        @Named(\"sequence\") BigInteger sequence,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate,\n        @Named(\"status\") @Optional String status,\n        // end generic fields\n        @Named(\"turnoverRentRule\") @Optional String turnoverRentRule,\n        @Named(\"budgetedTurnover\") @Optional BigDecimal budgetedTurnover,\n        @Named(\"auditedTurnover\") @Optional BigDecimal auditedTurnover,\n        @Named(\"turnoverRentValue\") @Optional BigDecimal turnoverRentValue) {\n    LeaseTermForTurnoverRent term = (LeaseTermForTurnoverRent) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n    if (term != null) {\n        term.setTurnoverRentValue(turnoverRentValue);\n        term.setBudgetedTurnover(budgetedTurnover);\n        term.setAuditedTurnover(auditedTurnover);\n        term.setTurnoverRentRule(turnoverRentRule);\n    }\n}",
                "name": "putLeaseTermForTurnoverRent",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"tenantReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"unitReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"itemSequence\")",
                        "name": "BigInteger"
                    },
                    {
                        "type": "@Named(\"itemType\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"itemStartDate\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"sequence\")",
                        "name": "BigInteger"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"status\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"turnoverRentRule\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"budgetedTurnover\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"auditedTurnover\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"turnoverRentValue\") @Optional",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    LeaseTermForTurnoverRent term = (LeaseTermForTurnoverRent) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n    if (term != null) {\n        term.setTurnoverRentValue(turnoverRentValue);\n        term.setBudgetedTurnover(budgetedTurnover);\n        term.setAuditedTurnover(auditedTurnover);\n        term.setTurnoverRentRule(turnoverRentRule);\n    }\n}",
                "start_point": {
                    "row": 647,
                    "column": 4
                },
                "end_point": {
                    "row": 672,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putLeaseTermForServiceCharge(\n        // start generic fields\n        @Named(\"leaseReference\") String leaseReference,\n        @Named(\"tenantReference\") String tenantReference,\n        @Named(\"unitReference\") @Optional String unitReference,\n        @Named(\"itemSequence\") BigInteger itemSequence,\n        @Named(\"itemType\") String itemType,\n        @Named(\"itemStartDate\") LocalDate itemStartDate,\n        @Named(\"sequence\") BigInteger sequence,\n        @Named(\"startDate\") @Optional LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate,\n        @Named(\"status\") @Optional String status,\n        // end generic fields\n        @Named(\"auditedValue\") @Optional BigDecimal auditedValue,\n        @Named(\"budgetedValue\") @Optional BigDecimal budgetedValue) {\n    LeaseTermForServiceCharge term = (LeaseTermForServiceCharge) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n    if (term != null) {\n        term.setAuditedValue(auditedValue);\n        term.setBudgetedValue(budgetedValue);\n    }\n}",
                "name": "putLeaseTermForServiceCharge",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"tenantReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"unitReference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"itemSequence\")",
                        "name": "BigInteger"
                    },
                    {
                        "type": "@Named(\"itemType\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"itemStartDate\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"sequence\")",
                        "name": "BigInteger"
                    },
                    {
                        "type": "@Named(\"startDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"status\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"auditedValue\") @Optional",
                        "name": "BigDecimal"
                    },
                    {
                        "type": "@Named(\"budgetedValue\") @Optional",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    LeaseTermForServiceCharge term = (LeaseTermForServiceCharge) putLeaseTerm(leaseReference, unitReference, itemSequence, itemType, itemStartDate, startDate, endDate, sequence, status);\n    if (term != null) {\n        term.setAuditedValue(auditedValue);\n        term.setBudgetedValue(budgetedValue);\n    }\n}",
                "start_point": {
                    "row": 674,
                    "column": 4
                },
                "end_point": {
                    "row": 695,
                    "column": 5
                }
            },
            {
                "definition": "private LeaseTerm putLeaseTerm(\n        final String leaseReference,\n        final String unitReference,\n        final BigInteger itemSequence,\n        final String itemType,\n        final LocalDate itemStartDate,\n        final LocalDate startDate,\n        final LocalDate endDate,\n        final BigInteger sequence,\n        final String statusStr) {\n    Lease lease = leases.findLeaseByReference(leaseReference);\n    if (lease == null) {\n        throw new ApplicationException(String.format(\"Leaseitem with reference %1$s not found.\", leaseReference));\n    }\n    Unit unit;\n    if (unitReference != null) {\n        unit = units.findUnitByReference(unitReference);\n        if (unitReference != null && unit == null) {\n            throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n        }\n    }\n    LeaseItemType leaseItemType = fetchLeaseItemType(itemType);\n    LeaseItem item = lease.findItem(leaseItemType, itemStartDate, itemSequence);\n    if (item == null) {\n        throw new ApplicationException(String.format(\"LeaseItem with reference %1$s, %2$s, %3$s, %4$s not found.\", leaseReference, leaseItemType.toString(), itemStartDate.toString(), itemSequence.toString()));\n    }\n    // check if the date is within range of lease\n    if (lease.getTerminationDate() == null || lease.getTerminationDate().compareTo(startDate) >= 0) {\n        LeaseTerm term = item.findTermWithSequence(sequence);\n        if (term == null) {\n            if (sequence.equals(BigInteger.ONE)) {\n                term = item.newTerm(startDate);\n            } else {\n                LeaseTerm previousTerm = item.findTermWithSequence(sequence.subtract(BigInteger.ONE));\n                term = previousTerm.createNext(startDate);\n            }\n            term.setSequence(sequence);\n        }\n        term.setStatus(org.estatio.dom.lease.LeaseTermStatus.valueOf(statusStr));\n        // will be overwritten if there is a next term\n        term.setEndDate(lease.getTerminationDate());\n        return term;\n    }\n    return null;\n}",
                "name": "putLeaseTerm",
                "modifiers": "private",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "BigInteger"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "BigInteger"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    Lease lease = leases.findLeaseByReference(leaseReference);\n    if (lease == null) {\n        throw new ApplicationException(String.format(\"Leaseitem with reference %1$s not found.\", leaseReference));\n    }\n    Unit unit;\n    if (unitReference != null) {\n        unit = units.findUnitByReference(unitReference);\n        if (unitReference != null && unit == null) {\n            throw new ApplicationException(String.format(\"Unit with reference %s not found.\", unitReference));\n        }\n    }\n    LeaseItemType leaseItemType = fetchLeaseItemType(itemType);\n    LeaseItem item = lease.findItem(leaseItemType, itemStartDate, itemSequence);\n    if (item == null) {\n        throw new ApplicationException(String.format(\"LeaseItem with reference %1$s, %2$s, %3$s, %4$s not found.\", leaseReference, leaseItemType.toString(), itemStartDate.toString(), itemSequence.toString()));\n    }\n    // check if the date is within range of lease\n    if (lease.getTerminationDate() == null || lease.getTerminationDate().compareTo(startDate) >= 0) {\n        LeaseTerm term = item.findTermWithSequence(sequence);\n        if (term == null) {\n            if (sequence.equals(BigInteger.ONE)) {\n                term = item.newTerm(startDate);\n            } else {\n                LeaseTerm previousTerm = item.findTermWithSequence(sequence.subtract(BigInteger.ONE));\n                term = previousTerm.createNext(startDate);\n            }\n            term.setSequence(sequence);\n        }\n        term.setStatus(org.estatio.dom.lease.LeaseTermStatus.valueOf(statusStr));\n        // will be overwritten if there is a next term\n        term.setEndDate(lease.getTerminationDate());\n        return term;\n    }\n    return null;\n}",
                "start_point": {
                    "row": 697,
                    "column": 4
                },
                "end_point": {
                    "row": 741,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putBankAccount(\n        // start generic fields\n        @Named(\"reference\") @Optional String reference,\n        @Named(\"name\") @Optional String name,\n        @Named(\"bankAccountType\") @Optional String bankAccountType,\n        @Named(\"ownerReference\") String ownerReference,\n        @Named(\"iban\") @Optional String iban,\n        @Named(\"countryCode\") @Optional String countryCode,\n        @Named(\"nationalCheckCode\") @Optional String nationalCheckCode,\n        @Named(\"nationalBankCode\") @Optional String nationalBankCode,\n        @Named(\"branchCode\") @Optional String branchCode,\n        @Named(\"accountNumber\") @Optional String accountNumber\n        ) {\n    BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(reference);\n    Party owner = parties.findPartyByReference(ownerReference);\n    if (owner == null)\n        return;\n    if (bankAccount == null) {\n        bankAccount = financialAccounts.newBankAccount(owner, iban);\n    }\n    bankAccount.setReference(reference);\n    bankAccount.setAccountNumber(accountNumber);\n    bankAccount.setBranchCode(branchCode);\n    bankAccount.setName(name);\n    bankAccount.setCountry(fetchCountry(countryCode, false));\n    bankAccount.setNationalBankCode(nationalBankCode);\n    bankAccount.setNationalCheckCode(nationalCheckCode);\n    bankAccount.setBankAccountType(BankAccountType.valueOf(bankAccountType));\n    bankAccount.verifyIban();\n}",
                "name": "putBankAccount",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"bankAccountType\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"ownerReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"iban\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"countryCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"nationalCheckCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"nationalBankCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"branchCode\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"accountNumber\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(reference);\n    Party owner = parties.findPartyByReference(ownerReference);\n    if (owner == null)\n        return;\n    if (bankAccount == null) {\n        bankAccount = financialAccounts.newBankAccount(owner, iban);\n    }\n    bankAccount.setReference(reference);\n    bankAccount.setAccountNumber(accountNumber);\n    bankAccount.setBranchCode(branchCode);\n    bankAccount.setName(name);\n    bankAccount.setCountry(fetchCountry(countryCode, false));\n    bankAccount.setNationalBankCode(nationalBankCode);\n    bankAccount.setNationalCheckCode(nationalCheckCode);\n    bankAccount.setBankAccountType(BankAccountType.valueOf(bankAccountType));\n    bankAccount.verifyIban();\n}",
                "start_point": {
                    "row": 743,
                    "column": 4
                },
                "end_point": {
                    "row": 773,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putBankMandate(\n        @Named(\"reference\") String reference,\n        @Named(\"name\") @Optional String name,\n        @Named(\"leaseReference\") String leaseReference,\n        @Named(\"debtorReference\") String debtorReference,\n        @Named(\"creditorReference\") String creditorReference,\n        @Named(\"bankAccountReference\") String bankAccountReference,\n        @Named(\"startDate\") LocalDate startDate,\n        @Named(\"endDate\") @Optional LocalDate endDate) {\n    BankMandate bankMandate = (BankMandate) agreements.findAgreementByReference(reference);\n    BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(bankAccountReference);\n    if (bankAccount == null)\n        throw new ApplicationException(String.format(\"BankAccount with reference %1$s not found\", bankAccountReference));\n    if (bankMandate == null) {\n        Party debtor = fetchParty(debtorReference);\n        Party creditor = fetchParty(creditorReference);\n        Lease lease = fetchLease(leaseReference);\n        bankMandate = bankMandates.newBankMandate(reference, name, startDate, endDate, debtor, creditor, bankAccount);\n        lease.paidBy(bankMandate);\n    }\n}",
                "name": "putBankMandate",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"reference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"name\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"debtorReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"creditorReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"bankAccountReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"startDate\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"endDate\") @Optional",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    BankMandate bankMandate = (BankMandate) agreements.findAgreementByReference(reference);\n    BankAccount bankAccount = (BankAccount) financialAccounts.findAccountByReference(bankAccountReference);\n    if (bankAccount == null)\n        throw new ApplicationException(String.format(\"BankAccount with reference %1$s not found\", bankAccountReference));\n    if (bankMandate == null) {\n        Party debtor = fetchParty(debtorReference);\n        Party creditor = fetchParty(creditorReference);\n        Lease lease = fetchLease(leaseReference);\n        bankMandate = bankMandates.newBankMandate(reference, name, startDate, endDate, debtor, creditor, bankAccount);\n        lease.paidBy(bankMandate);\n    }\n}",
                "start_point": {
                    "row": 775,
                    "column": 4
                },
                "end_point": {
                    "row": 796,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\npublic void putBreakOption(\n        @Named(\"leaseReference\") String leaseReference,\n        @Named(\"breakType\") String breakTypeStr,\n        @Named(\"breakExcerciseType\") String breakExcerciseTypeStr,\n        @Named(\"breakDate\") LocalDate breakDate,\n        @Named(\"notificationDate\") LocalDate notificationDate,\n        @Named(\"notificationPeriod\") @Optional String notificationPeriodStr,\n        @Named(\"description\") @Optional String description\n        ) {\n    Lease lease = fetchLease(leaseReference);\n    BreakType breakType = BreakType.valueOf(breakTypeStr);\n    BreakExerciseType breakExerciseType = BreakExerciseType.valueOf(breakExcerciseTypeStr);\n    if (notificationDate != null) {\n        Period period = new Period(notificationDate, breakDate);\n        notificationPeriodStr = JodaPeriodUtils.asSimpleString(period);\n    }\n    if (lease.validateNewBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description) == null) {\n        lease.newBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description);\n    }\n}",
                "name": "putBreakOption",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Named(\"leaseReference\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"breakType\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"breakExcerciseType\")",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"breakDate\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"notificationDate\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "@Named(\"notificationPeriod\") @Optional",
                        "name": "String"
                    },
                    {
                        "type": "@Named(\"description\") @Optional",
                        "name": "String"
                    }
                ],
                "body": "{\n    Lease lease = fetchLease(leaseReference);\n    BreakType breakType = BreakType.valueOf(breakTypeStr);\n    BreakExerciseType breakExerciseType = BreakExerciseType.valueOf(breakExcerciseTypeStr);\n    if (notificationDate != null) {\n        Period period = new Period(notificationDate, breakDate);\n        notificationPeriodStr = JodaPeriodUtils.asSimpleString(period);\n    }\n    if (lease.validateNewBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description) == null) {\n        lease.newBreakOption(breakDate, notificationPeriodStr, breakExerciseType, breakType, description);\n    }\n}",
                "start_point": {
                    "row": 800,
                    "column": 4
                },
                "end_point": {
                    "row": 820,
                    "column": 5
                }
            },
            {
                "definition": "public void injectAgreements(Agreements agreements) {\n    this.agreements = agreements;\n}",
                "name": "injectAgreements",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Agreements",
                        "name": "agreements"
                    }
                ],
                "body": "{\n    this.agreements = agreements;\n}",
                "start_point": {
                    "row": 826,
                    "column": 4
                },
                "end_point": {
                    "row": 828,
                    "column": 5
                }
            },
            {
                "definition": "public void injectBankMandates(BankMandates bankMandates) {\n    this.bankMandates = bankMandates;\n}",
                "name": "injectBankMandates",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "BankMandates",
                        "name": "bankMandates"
                    }
                ],
                "body": "{\n    this.bankMandates = bankMandates;\n}",
                "start_point": {
                    "row": 832,
                    "column": 4
                },
                "end_point": {
                    "row": 834,
                    "column": 5
                }
            },
            {
                "definition": "public void setClockService(ClockService clockService) {\n    this.clockService = clockService;\n}",
                "name": "setClockService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ClockService",
                        "name": "clockService"
                    }
                ],
                "body": "{\n    this.clockService = clockService;\n}",
                "start_point": {
                    "row": 838,
                    "column": 4
                },
                "end_point": {
                    "row": 840,
                    "column": 5
                }
            },
            {
                "definition": "public void injectCountries(final Countries countries) {\n    this.countries = countries;\n}",
                "name": "injectCountries",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Countries"
                    }
                ],
                "body": "{\n    this.countries = countries;\n}",
                "start_point": {
                    "row": 844,
                    "column": 4
                },
                "end_point": {
                    "row": 846,
                    "column": 5
                }
            },
            {
                "definition": "public void injectStates(final States states) {\n    this.states = states;\n}",
                "name": "injectStates",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "States"
                    }
                ],
                "body": "{\n    this.states = states;\n}",
                "start_point": {
                    "row": 850,
                    "column": 4
                },
                "end_point": {
                    "row": 852,
                    "column": 5
                }
            },
            {
                "definition": "public void injectUnits(final Units<Unit> units) {\n    this.units = units;\n}",
                "name": "injectUnits",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Units<Unit>"
                    }
                ],
                "body": "{\n    this.units = units;\n}",
                "start_point": {
                    "row": 856,
                    "column": 4
                },
                "end_point": {
                    "row": 858,
                    "column": 5
                }
            },
            {
                "definition": "public void injectProperties(final Properties properties) {\n    this.properties = properties;\n}",
                "name": "injectProperties",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Properties"
                    }
                ],
                "body": "{\n    this.properties = properties;\n}",
                "start_point": {
                    "row": 862,
                    "column": 4
                },
                "end_point": {
                    "row": 864,
                    "column": 5
                }
            },
            {
                "definition": "public void injectParties(final Parties parties) {\n    this.parties = parties;\n}",
                "name": "injectParties",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Parties"
                    }
                ],
                "body": "{\n    this.parties = parties;\n}",
                "start_point": {
                    "row": 868,
                    "column": 4
                },
                "end_point": {
                    "row": 870,
                    "column": 5
                }
            },
            {
                "definition": "public void injectOrganisations(final Organisations organisations) {\n    this.organisations = organisations;\n}",
                "name": "injectOrganisations",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Organisations"
                    }
                ],
                "body": "{\n    this.organisations = organisations;\n}",
                "start_point": {
                    "row": 874,
                    "column": 4
                },
                "end_point": {
                    "row": 876,
                    "column": 5
                }
            },
            {
                "definition": "public void injectOrganisations(final Persons persons) {\n    this.persons = persons;\n}",
                "name": "injectOrganisations",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Persons"
                    }
                ],
                "body": "{\n    this.persons = persons;\n}",
                "start_point": {
                    "row": 880,
                    "column": 4
                },
                "end_point": {
                    "row": 882,
                    "column": 5
                }
            },
            {
                "definition": "public void injectCommunicationChannelContributedActions(final CommunicationChannelContributions communicationChannelContributedActions) {\n    this.communicationChannelContributions = communicationChannelContributedActions;\n}",
                "name": "injectCommunicationChannelContributedActions",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "CommunicationChannelContributions"
                    }
                ],
                "body": "{\n    this.communicationChannelContributions = communicationChannelContributedActions;\n}",
                "start_point": {
                    "row": 886,
                    "column": 4
                },
                "end_point": {
                    "row": 888,
                    "column": 5
                }
            },
            {
                "definition": "public void injectCommunicationChannels(final CommunicationChannels communicationChannels) {\n    this.communicationChannels = communicationChannels;\n}",
                "name": "injectCommunicationChannels",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "CommunicationChannels"
                    }
                ],
                "body": "{\n    this.communicationChannels = communicationChannels;\n}",
                "start_point": {
                    "row": 892,
                    "column": 4
                },
                "end_point": {
                    "row": 894,
                    "column": 5
                }
            },
            {
                "definition": "public void injectPostalAddresses(PostalAddresses postalAddresses) {\n    this.postalAddresses = postalAddresses;\n}",
                "name": "injectPostalAddresses",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "PostalAddresses",
                        "name": "postalAddresses"
                    }
                ],
                "body": "{\n    this.postalAddresses = postalAddresses;\n}",
                "start_point": {
                    "row": 898,
                    "column": 4
                },
                "end_point": {
                    "row": 900,
                    "column": 5
                }
            },
            {
                "definition": "public void injectEmailAddresses(EmailAddresses emailAddresses) {\n    this.emailAddresses = emailAddresses;\n}",
                "name": "injectEmailAddresses",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "EmailAddresses",
                        "name": "emailAddresses"
                    }
                ],
                "body": "{\n    this.emailAddresses = emailAddresses;\n}",
                "start_point": {
                    "row": 904,
                    "column": 4
                },
                "end_point": {
                    "row": 906,
                    "column": 5
                }
            },
            {
                "definition": "public void setPhoneOrFaxNumbers(PhoneOrFaxNumbers phoneOrFaxNumbers) {\n    this.phoneOrFaxNumbers = phoneOrFaxNumbers;\n}",
                "name": "setPhoneOrFaxNumbers",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "PhoneOrFaxNumbers",
                        "name": "phoneOrFaxNumbers"
                    }
                ],
                "body": "{\n    this.phoneOrFaxNumbers = phoneOrFaxNumbers;\n}",
                "start_point": {
                    "row": 910,
                    "column": 4
                },
                "end_point": {
                    "row": 912,
                    "column": 5
                }
            },
            {
                "definition": "public void injectLeaseRepository(final Leases leases) {\n    this.leases = leases;\n}",
                "name": "injectLeaseRepository",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Leases"
                    }
                ],
                "body": "{\n    this.leases = leases;\n}",
                "start_point": {
                    "row": 916,
                    "column": 4
                },
                "end_point": {
                    "row": 918,
                    "column": 5
                }
            },
            {
                "definition": "public void injectAgreementRoleTypes(AgreementRoleTypes agreementRoleTypes) {\n    this.agreementRoleTypes = agreementRoleTypes;\n}",
                "name": "injectAgreementRoleTypes",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AgreementRoleTypes",
                        "name": "agreementRoleTypes"
                    }
                ],
                "body": "{\n    this.agreementRoleTypes = agreementRoleTypes;\n}",
                "start_point": {
                    "row": 922,
                    "column": 4
                },
                "end_point": {
                    "row": 924,
                    "column": 5
                }
            },
            {
                "definition": "public void injectLeaseUnits(final Occupancies leaseUnits) {\n    this.occupancies = leaseUnits;\n}",
                "name": "injectLeaseUnits",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Occupancies"
                    }
                ],
                "body": "{\n    this.occupancies = leaseUnits;\n}",
                "start_point": {
                    "row": 928,
                    "column": 4
                },
                "end_point": {
                    "row": 930,
                    "column": 5
                }
            },
            {
                "definition": "public void injectTaxes(final Taxes taxes) {\n    this.taxes = taxes;\n}",
                "name": "injectTaxes",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Taxes"
                    }
                ],
                "body": "{\n    this.taxes = taxes;\n}",
                "start_point": {
                    "row": 934,
                    "column": 4
                },
                "end_point": {
                    "row": 936,
                    "column": 5
                }
            },
            {
                "definition": "public void injectCharges(final Charges charges) {\n    this.charges = charges;\n}",
                "name": "injectCharges",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Charges"
                    }
                ],
                "body": "{\n    this.charges = charges;\n}",
                "start_point": {
                    "row": 940,
                    "column": 4
                },
                "end_point": {
                    "row": 942,
                    "column": 5
                }
            },
            {
                "definition": "public void injectChargeGroups(final ChargeGroups chargeGroups) {\n    this.chargeGroups = chargeGroups;\n}",
                "name": "injectChargeGroups",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "ChargeGroups"
                    }
                ],
                "body": "{\n    this.chargeGroups = chargeGroups;\n}",
                "start_point": {
                    "row": 946,
                    "column": 4
                },
                "end_point": {
                    "row": 948,
                    "column": 5
                }
            },
            {
                "definition": "public void injectIndices(final Indices indices) {\n    this.indices = indices;\n}",
                "name": "injectIndices",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Indices"
                    }
                ],
                "body": "{\n    this.indices = indices;\n}",
                "start_point": {
                    "row": 952,
                    "column": 4
                },
                "end_point": {
                    "row": 954,
                    "column": 5
                }
            },
            {
                "definition": "public void injectFinancialAccounts(FinancialAccounts financialAccounts) {\n    this.financialAccounts = financialAccounts;\n}",
                "name": "injectFinancialAccounts",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "FinancialAccounts",
                        "name": "financialAccounts"
                    }
                ],
                "body": "{\n    this.financialAccounts = financialAccounts;\n}",
                "start_point": {
                    "row": 958,
                    "column": 4
                },
                "end_point": {
                    "row": 960,
                    "column": 5
                }
            },
            {
                "definition": "public void injectInvoices(Invoices invoices) {\n    this.invoices = invoices;\n}",
                "name": "injectInvoices",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Invoices",
                        "name": "invoices"
                    }
                ],
                "body": "{\n    this.invoices = invoices;\n}",
                "start_point": {
                    "row": 964,
                    "column": 4
                },
                "end_point": {
                    "row": 966,
                    "column": 5
                }
            },
            {
                "definition": "public void injectAgreementRoleCommunicationChannelTypes(AgreementRoleCommunicationChannelTypes agreementRoleCommunicationChannelTypes) {\n    this.agreementRoleCommunicationChannelTypes = agreementRoleCommunicationChannelTypes;\n}",
                "name": "injectAgreementRoleCommunicationChannelTypes",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AgreementRoleCommunicationChannelTypes",
                        "name": "agreementRoleCommunicationChannelTypes"
                    }
                ],
                "body": "{\n    this.agreementRoleCommunicationChannelTypes = agreementRoleCommunicationChannelTypes;\n}",
                "start_point": {
                    "row": 970,
                    "column": 4
                },
                "end_point": {
                    "row": 972,
                    "column": 5
                }
            },
            {
                "definition": "public void injectLeaseTypes(LeaseTypes leaseTypes) {\n    this.leaseTypes = leaseTypes;\n}",
                "name": "injectLeaseTypes",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "LeaseTypes",
                        "name": "leaseTypes"
                    }
                ],
                "body": "{\n    this.leaseTypes = leaseTypes;\n}",
                "start_point": {
                    "row": 976,
                    "column": 4
                },
                "end_point": {
                    "row": 978,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dom/src/main/java/org/estatio/dom/financial/utils/IBANValidator.java",
        "definition": "public final class IBANValidator {\n    \n    private IBANValidator(){}\n\n    private static final int IBAN_LENGTH_MAX = 32;\n\n    private static final int IBAN_LENGTH_MIN = 15;\n\n    private static final int SUFFIX_OFFSET = 4;\n    \n    private static final int A_ASCII = 97;\n    private static final int BASE_TEN = 10;\n\n    public static int checksum(final String iban) {\n        String tmp = (iban.substring(SUFFIX_OFFSET) + iban.substring(0, SUFFIX_OFFSET)).toUpperCase();\n        StringBuffer digits = new StringBuffer();\n        for (int i = 0; i < tmp.length(); i++) {\n            char c = tmp.charAt(i);\n            if (c >= '0' && c <= '9') {\n                digits.append(c);\n            } else if (c >= 'A' && c <= 'Z') {\n                int n = c - 'A' + BASE_TEN;\n                digits.append((char) ('0' + n / BASE_TEN));\n                digits.append((char) ('0' + (n % BASE_TEN)));\n            } else {\n                return -1;\n            }\n        }\n        BigDecimal n = new BigDecimal(digits.toString());\n        return n.remainder(BigDecimal.valueOf(A_ASCII)).intValue();\n    }\n\n    public static String fixChecksum(final String ibanTemplate) {\n        int remainder = checksum(ibanTemplate);\n        String pp = StringUtils.leftPad(String.valueOf(1+A_ASCII - remainder), 2, '0');\n        return ibanTemplate.substring(0, 2) + pp + ibanTemplate.substring(SUFFIX_OFFSET);\n    }\n\n    public static boolean valid(final String iban) {\n        if (iban == null || \n            iban.length() < IBAN_LENGTH_MIN || \n            iban.length() > IBAN_LENGTH_MAX) {\n            return false;\n        }\n\n        final int checksum = checksum(iban);\n        return (checksum == 1);\n    }\n\n}",
        "package": "package org.estatio.dom.financial.utils;",
        "tree_path": "IBANValidator",
        "name": "IBANValidator",
        "modifiers": "public final",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    \n    private IBANValidator(){}\n\n    private static final int IBAN_LENGTH_MAX = 32;\n\n    private static final int IBAN_LENGTH_MIN = 15;\n\n    private static final int SUFFIX_OFFSET = 4;\n    \n    private static final int A_ASCII = 97;\n    private static final int BASE_TEN = 10;\n\n    public static int checksum(final String iban) {\n        String tmp = (iban.substring(SUFFIX_OFFSET) + iban.substring(0, SUFFIX_OFFSET)).toUpperCase();\n        StringBuffer digits = new StringBuffer();\n        for (int i = 0; i < tmp.length(); i++) {\n            char c = tmp.charAt(i);\n            if (c >= '0' && c <= '9') {\n                digits.append(c);\n            } else if (c >= 'A' && c <= 'Z') {\n                int n = c - 'A' + BASE_TEN;\n                digits.append((char) ('0' + n / BASE_TEN));\n                digits.append((char) ('0' + (n % BASE_TEN)));\n            } else {\n                return -1;\n            }\n        }\n        BigDecimal n = new BigDecimal(digits.toString());\n        return n.remainder(BigDecimal.valueOf(A_ASCII)).intValue();\n    }\n\n    public static String fixChecksum(final String ibanTemplate) {\n        int remainder = checksum(ibanTemplate);\n        String pp = StringUtils.leftPad(String.valueOf(1+A_ASCII - remainder), 2, '0');\n        return ibanTemplate.substring(0, 2) + pp + ibanTemplate.substring(SUFFIX_OFFSET);\n    }\n\n    public static boolean valid(final String iban) {\n        if (iban == null || \n            iban.length() < IBAN_LENGTH_MIN || \n            iban.length() > IBAN_LENGTH_MAX) {\n            return false;\n        }\n\n        final int checksum = checksum(iban);\n        return (checksum == 1);\n    }\n\n}",
        "start_point": {
            "row": 24,
            "column": 0
        },
        "end_point": {
            "row": 73,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "private IBANValidator(){}",
                "name": "IBANValidator",
                "modifiers": "private",
                "parameters": [],
                "body": "{}",
                "constructor": true,
                "start_point": {
                    "row": 26,
                    "column": 4
                },
                "end_point": {
                    "row": 26,
                    "column": 29
                }
            },
            {
                "definition": "public static int checksum(final String iban) {\n    String tmp = (iban.substring(SUFFIX_OFFSET) + iban.substring(0, SUFFIX_OFFSET)).toUpperCase();\n    StringBuffer digits = new StringBuffer();\n    for (int i = 0; i < tmp.length(); i++) {\n        char c = tmp.charAt(i);\n        if (c >= '0' && c <= '9') {\n            digits.append(c);\n        } else if (c >= 'A' && c <= 'Z') {\n            int n = c - 'A' + BASE_TEN;\n            digits.append((char) ('0' + n / BASE_TEN));\n            digits.append((char) ('0' + (n % BASE_TEN)));\n        } else {\n            return -1;\n        }\n    }\n    BigDecimal n = new BigDecimal(digits.toString());\n    return n.remainder(BigDecimal.valueOf(A_ASCII)).intValue();\n}",
                "name": "checksum",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    String tmp = (iban.substring(SUFFIX_OFFSET) + iban.substring(0, SUFFIX_OFFSET)).toUpperCase();\n    StringBuffer digits = new StringBuffer();\n    for (int i = 0; i < tmp.length(); i++) {\n        char c = tmp.charAt(i);\n        if (c >= '0' && c <= '9') {\n            digits.append(c);\n        } else if (c >= 'A' && c <= 'Z') {\n            int n = c - 'A' + BASE_TEN;\n            digits.append((char) ('0' + n / BASE_TEN));\n            digits.append((char) ('0' + (n % BASE_TEN)));\n        } else {\n            return -1;\n        }\n    }\n    BigDecimal n = new BigDecimal(digits.toString());\n    return n.remainder(BigDecimal.valueOf(A_ASCII)).intValue();\n}",
                "start_point": {
                    "row": 37,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "public static String fixChecksum(final String ibanTemplate) {\n    int remainder = checksum(ibanTemplate);\n    String pp = StringUtils.leftPad(String.valueOf(1+A_ASCII - remainder), 2, '0');\n    return ibanTemplate.substring(0, 2) + pp + ibanTemplate.substring(SUFFIX_OFFSET);\n}",
                "name": "fixChecksum",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    int remainder = checksum(ibanTemplate);\n    String pp = StringUtils.leftPad(String.valueOf(1+A_ASCII - remainder), 2, '0');\n    return ibanTemplate.substring(0, 2) + pp + ibanTemplate.substring(SUFFIX_OFFSET);\n}",
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 60,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean valid(final String iban) {\n    if (iban == null || \n        iban.length() < IBAN_LENGTH_MIN || \n        iban.length() > IBAN_LENGTH_MAX) {\n        return false;\n    }\n\n    final int checksum = checksum(iban);\n    return (checksum == 1);\n}",
                "name": "valid",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    if (iban == null || \n        iban.length() < IBAN_LENGTH_MIN || \n        iban.length() > IBAN_LENGTH_MAX) {\n        return false;\n    }\n\n    final int checksum = checksum(iban);\n    return (checksum == 1);\n}",
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dom/src/main/java/org/estatio/dom/invoice/Invoice.java",
        "definition": "@javax.jdo.annotations.PersistenceCapable(identityType = IdentityType.DATASTORE)\n@javax.jdo.annotations.DatastoreIdentity(\n        strategy = IdGeneratorStrategy.NATIVE,\n        column = \"id\")\n@javax.jdo.annotations.Version(\n        strategy = VersionStrategy.VERSION_NUMBER,\n        column = \"version\")\n@javax.jdo.annotations.Queries({\n        @javax.jdo.annotations.Query(\n                name = \"findMatchingInvoices\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.invoice.Invoice \"\n                        + \"WHERE source == :source \"\n                        + \"&& seller == :seller \"\n                        + \"&& buyer == :buyer \"\n                        + \"&& paymentMethod == :paymentMethod \"\n                        + \"&& status == :status \"\n                        + \"&& dueDate == :dueDate\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByPropertyAndStatus\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.invoice.Invoice \"\n                        + \"WHERE status == :status \"\n                        + \"&& source.occupancies.contains(o) \"\n                        + \"&& o.unit.property == :property \"\n                        + \"VARIABLES \"\n                        + \"org.estatio.dom.lease.Occupancy o; \"\n                        + \"org.estatio.dom.lease.Lease source\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByPropertyAndDueDateAndStatus\", language = \"JDOQL\",\n                value = \"SELECT FROM org.estatio.dom.invoice.Invoice \" +\n                        \"WHERE status == :status && \" +\n                        \"dueDate == :dueDate && \" +\n                        \"source.occupancies.contains(o) &&\" +\n                        \"o.unit.property == :property \" +\n                        \"VARIABLES org.estatio.dom.lease.Occupancy o; org.estatio.dom.lease.Lease source\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByPropertyAndDueDate\", language = \"JDOQL\",\n                value = \"SELECT FROM org.estatio.dom.invoice.Invoice \" +\n                        \"WHERE dueDate == :dueDate && \" +\n                        \"source.occupancies.contains(o) &&\" +\n                        \"o.unit.property == :property \" +\n                        \"VARIABLES org.estatio.dom.lease.Occupancy o; org.estatio.dom.lease.Lease source\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByStatus\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.invoice.Invoice \"\n                        + \"WHERE status == :status \")\n})\n@Bookmarkable\npublic class Invoice extends EstatioMutableObject<Invoice> {\n\n    public Invoice() {\n        super(\"invoiceNumber\");\n    }\n\n    // //////////////////////////////////////\n\n    public String title() {\n        return String.format(\"*%08d\", Integer.parseInt(getId()));\n    }\n\n    // //////////////////////////////////////\n\n    @Hidden(where=Where.OBJECT_FORMS)\n    public String getNumber() {\n        return ObjectUtils.firstNonNull(\n                getInvoiceNumber(),\n                getCollectionNumber(),\n                title());\n    }\n\n    // //////////////////////////////////////\n\n    private Party buyer;\n\n    @javax.jdo.annotations.Column(name = \"buyerPartyId\", allowsNull = \"false\")\n    @Disabled\n    public Party getBuyer() {\n        return buyer;\n\n    }\n\n    public void setBuyer(final Party buyer) {\n        this.buyer = buyer;\n    }\n\n    // //////////////////////////////////////\n\n    private Party seller;\n\n    @javax.jdo.annotations.Column(name = \"sellerPartyId\", allowsNull = \"false\")\n    @Disabled\n    public Party getSeller() {\n        return seller;\n    }\n\n    public void setSeller(final Party seller) {\n        this.seller = seller;\n    }\n\n    // //////////////////////////////////////\n\n    private String collectionNumber;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n    @Disabled\n    @Hidden(where=Where.PARENTED_TABLES)\n    public String getCollectionNumber() {\n        return collectionNumber;\n    }\n\n    public void setCollectionNumber(final String collectionNumber) {\n        this.collectionNumber = collectionNumber;\n    }\n\n    // //////////////////////////////////////\n\n    private String invoiceNumber;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n    @Disabled\n    @Hidden(where=Where.PARENTED_TABLES)\n    public String getInvoiceNumber() {\n        return invoiceNumber;\n    }\n\n    public void setInvoiceNumber(final String invoiceNumber) {\n        this.invoiceNumber = invoiceNumber;\n    }\n\n    // //////////////////////////////////////\n\n    private InvoiceSource source;\n\n    /**\n     * Polymorphic association to (any implementation of) {@link InvoiceSource}.\n     */\n    @javax.jdo.annotations.Persistent(\n            extensions = {\n                    @Extension(vendorName = \"datanucleus\",\n                            key = \"mapping-strategy\",\n                            value = \"per-implementation\"),\n                    @Extension(vendorName = \"datanucleus\",\n                            key = \"implementation-classes\",\n                            value = \"org.estatio.dom.lease.Lease\") })\n    @javax.jdo.annotations.Columns({\n            @javax.jdo.annotations.Column(name = \"sourceLeaseId\", allowsNull = \"true\")\n    })\n    @Optional\n    // not really, but to be compatible with JDO\n    @Disabled\n    public InvoiceSource getSource() {\n        return source;\n    }\n\n    public void setSource(final InvoiceSource source) {\n        this.source = source;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate invoiceDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Disabled\n    public LocalDate getInvoiceDate() {\n        return invoiceDate;\n    }\n\n    public void setInvoiceDate(final LocalDate invoiceDate) {\n        this.invoiceDate = invoiceDate;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate dueDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\")\n    @Disabled\n    public LocalDate getDueDate() {\n        return dueDate;\n    }\n\n    public void setDueDate(final LocalDate dueDate) {\n        this.dueDate = dueDate;\n    }\n\n    // //////////////////////////////////////\n\n    private InvoiceStatus status;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Disabled\n    public InvoiceStatus getStatus() {\n        return status;\n    }\n\n    public void setStatus(final InvoiceStatus status) {\n        this.status = status;\n    }\n\n    // //////////////////////////////////////\n\n    private Currency currency;\n\n    // REVIEW: invoice generation is not populating this field.\n    @javax.jdo.annotations.Column(name = \"currencyId\", allowsNull = \"true\")\n    @Hidden(where = Where.ALL_TABLES)\n    @Disabled\n    public Currency getCurrency() {\n        return currency;\n    }\n\n    public void setCurrency(final Currency currency) {\n        this.currency = currency;\n    }\n\n    // //////////////////////////////////////\n\n    private PaymentMethod paymentMethod;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n    @Disabled\n    public PaymentMethod getPaymentMethod() {\n        return paymentMethod;\n    }\n\n    public void setPaymentMethod(final PaymentMethod paymentMethod) {\n        this.paymentMethod = paymentMethod;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent(mappedBy = \"invoice\")\n    private SortedSet<InvoiceItem> items = new TreeSet<InvoiceItem>();\n\n    @Disabled\n    @Render(Type.EAGERLY)\n    public SortedSet<InvoiceItem> getItems() {\n        return items;\n    }\n\n    public void setItems(final SortedSet<InvoiceItem> items) {\n        this.items = items;\n    }\n\n    // //////////////////////////////////////\n\n    @Persistent\n    private BigInteger lastItemSequence;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Hidden\n    public BigInteger getLastItemSequence() {\n        return lastItemSequence;\n    }\n\n    public void setLastItemSequence(final BigInteger lastItemSequence) {\n        this.lastItemSequence = lastItemSequence;\n    }\n\n    @Programmatic\n    public BigInteger nextItemSequence() {\n        BigInteger nextItemSequence = getLastItemSequence() == null\n                ? BigInteger.ONE\n                : getLastItemSequence().add(BigInteger.ONE);\n        setLastItemSequence(nextItemSequence);\n        return nextItemSequence;\n    }\n\n    // //////////////////////////////////////\n\n    @NotPersisted\n    public BigDecimal getNetAmount() {\n        BigDecimal total = BigDecimal.ZERO;\n        for (InvoiceItem item : getItems()) {\n            total = total.add(item.getNetAmount());\n        }\n        return total;\n    }\n\n    @NotPersisted\n    public BigDecimal getVatAmount() {\n        BigDecimal total = BigDecimal.ZERO;\n        for (InvoiceItem item : getItems()) {\n            total = total.add(item.getVatAmount());\n        }\n        return total;\n    }\n\n    @NotPersisted\n    public BigDecimal getGrossAmount() {\n        BigDecimal total = BigDecimal.ZERO;\n        for (InvoiceItem item : getItems()) {\n            total = total.add(item.getGrossAmount());\n        }\n        return total;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public Invoice approve() {\n        setStatus(InvoiceStatus.APPROVED);\n        return this;\n    }\n\n    public boolean hideApprove() {\n        return false;\n    }\n\n    public String disableApprove() {\n        return getStatus() != InvoiceStatus.NEW ? \"Can only approve 'new' invoices\" : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public Invoice collect() {\n\n        // bulk action, so need these guards\n        if (hideCollect()) {\n            return this;\n        }\n        if (disableCollect() != null) {\n            return this;\n        }\n\n        final Numerator numerator = invoices.findCollectionNumberNumerator();\n\n        setCollectionNumber(numerator.increment());\n        this.setStatus(InvoiceStatus.COLLECTED);\n\n        informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n        return this;\n    }\n\n    public boolean hideCollect() {\n        // only applies to direct debits\n        return !getPaymentMethod().isDirectDebit();\n    }\n\n    public String disableCollect() {\n        if (getCollectionNumber() != null) {\n            return \"Collection number already assigned\";\n        }\n\n        final Numerator numerator = invoices.findCollectionNumberNumerator();\n        if (numerator == null) {\n            return \"No 'collection number' numerator found for invoice's property\";\n        }\n\n        if (getStatus() != InvoiceStatus.APPROVED) {\n            return \"Must be in status of 'approved'\";\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public Invoice invoiceNow() {\n        return invoiceOn(getClockService().now());\n    }\n\n    public boolean hideInvoiceNow() {\n        return false; // TODO: return true if action is hidden, false if visible\n    }\n\n    public String disableInvoiceNow() {\n        if (getInvoiceNumber() != null) {\n            return \"Invoice number already assigned\";\n        }\n        final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n        if (numerator == null) {\n            return \"No 'invoice number' numerator found for invoice's property\";\n        }\n        // TODO: offload valid next states to the InvoiceStatus enum? Eg\n        // getStatus.isPossible(InvoiceStatus.APPROVED)\n        //\n        if (getStatus() != InvoiceStatus.COLLECTED && getStatus() != InvoiceStatus.APPROVED) {\n            return \"Must be in status of 'collected'\";\n        }\n        return null;\n    }\n\n    @Programmatic\n    public Invoice invoiceOn(final LocalDate invoiceDate) {\n        // bulk action, so need these guards\n        if (disableInvoiceNow() != null) {\n            return this;\n        }\n        final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n        setInvoiceNumber(numerator.increment());\n        setInvoiceDate(invoiceDate);\n        this.setStatus(InvoiceStatus.INVOICED);\n        informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    /**\n     * Derived from the {@link #getSource() invoice source}.\n     */\n    public Property getProperty() {\n        return getSource().getProperty();\n    }\n\n    // //////////////////////////////////////\n\n    @PublishedAction(InvoiceEagerlyRenderedPayloadFactory.class)\n    @Bulk\n    @ActionSemantics(Of.IDEMPOTENT)\n    public Invoice submitToCoda() {\n        collect();\n        return this;\n    }\n\n    public String disableSubmitToCoda() {\n        if (getPaymentMethod().isDirectDebit()) {\n            return getStatus() == InvoiceStatus.COLLECTED ||\n                    getStatus() == InvoiceStatus.INVOICED\n                    ? null\n                    : \"Must be collected or invoiced\";\n        } else {\n            return getStatus() == InvoiceStatus.INVOICED\n                    ? null\n                    : \"Must be invoiced\";\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @Prototype\n    @Bulk\n    public void remove() {\n        for (InvoiceItem item : getItems()) {\n            item.remove();\n        }\n        getContainer().remove(this);\n    }\n\n    // //////////////////////////////////////\n\n    private Invoices invoices;\n\n    public final void injectInvoices(final Invoices invoices) {\n        this.invoices = invoices;\n    }\n}",
        "package": "package org.estatio.dom.invoice;",
        "tree_path": "Invoice",
        "name": "Invoice",
        "modifiers": "@javax.jdo.annotations.PersistenceCapable(identityType = IdentityType.DATASTORE)\n@javax.jdo.annotations.DatastoreIdentity(\n        strategy = IdGeneratorStrategy.NATIVE,\n        column = \"id\")\n@javax.jdo.annotations.Version(\n        strategy = VersionStrategy.VERSION_NUMBER,\n        column = \"version\")\n@javax.jdo.annotations.Queries({\n        @javax.jdo.annotations.Query(\n                name = \"findMatchingInvoices\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.invoice.Invoice \"\n                        + \"WHERE source == :source \"\n                        + \"&& seller == :seller \"\n                        + \"&& buyer == :buyer \"\n                        + \"&& paymentMethod == :paymentMethod \"\n                        + \"&& status == :status \"\n                        + \"&& dueDate == :dueDate\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByPropertyAndStatus\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.invoice.Invoice \"\n                        + \"WHERE status == :status \"\n                        + \"&& source.occupancies.contains(o) \"\n                        + \"&& o.unit.property == :property \"\n                        + \"VARIABLES \"\n                        + \"org.estatio.dom.lease.Occupancy o; \"\n                        + \"org.estatio.dom.lease.Lease source\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByPropertyAndDueDateAndStatus\", language = \"JDOQL\",\n                value = \"SELECT FROM org.estatio.dom.invoice.Invoice \" +\n                        \"WHERE status == :status && \" +\n                        \"dueDate == :dueDate && \" +\n                        \"source.occupancies.contains(o) &&\" +\n                        \"o.unit.property == :property \" +\n                        \"VARIABLES org.estatio.dom.lease.Occupancy o; org.estatio.dom.lease.Lease source\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByPropertyAndDueDate\", language = \"JDOQL\",\n                value = \"SELECT FROM org.estatio.dom.invoice.Invoice \" +\n                        \"WHERE dueDate == :dueDate && \" +\n                        \"source.occupancies.contains(o) &&\" +\n                        \"o.unit.property == :property \" +\n                        \"VARIABLES org.estatio.dom.lease.Occupancy o; org.estatio.dom.lease.Lease source\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByStatus\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.invoice.Invoice \"\n                        + \"WHERE status == :status \")\n})\n@Bookmarkable\npublic",
        "superclass": "extends EstatioMutableObject<Invoice>",
        "super_interfaces": null,
        "body": "{\n\n    public Invoice() {\n        super(\"invoiceNumber\");\n    }\n\n    // //////////////////////////////////////\n\n    public String title() {\n        return String.format(\"*%08d\", Integer.parseInt(getId()));\n    }\n\n    // //////////////////////////////////////\n\n    @Hidden(where=Where.OBJECT_FORMS)\n    public String getNumber() {\n        return ObjectUtils.firstNonNull(\n                getInvoiceNumber(),\n                getCollectionNumber(),\n                title());\n    }\n\n    // //////////////////////////////////////\n\n    private Party buyer;\n\n    @javax.jdo.annotations.Column(name = \"buyerPartyId\", allowsNull = \"false\")\n    @Disabled\n    public Party getBuyer() {\n        return buyer;\n\n    }\n\n    public void setBuyer(final Party buyer) {\n        this.buyer = buyer;\n    }\n\n    // //////////////////////////////////////\n\n    private Party seller;\n\n    @javax.jdo.annotations.Column(name = \"sellerPartyId\", allowsNull = \"false\")\n    @Disabled\n    public Party getSeller() {\n        return seller;\n    }\n\n    public void setSeller(final Party seller) {\n        this.seller = seller;\n    }\n\n    // //////////////////////////////////////\n\n    private String collectionNumber;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n    @Disabled\n    @Hidden(where=Where.PARENTED_TABLES)\n    public String getCollectionNumber() {\n        return collectionNumber;\n    }\n\n    public void setCollectionNumber(final String collectionNumber) {\n        this.collectionNumber = collectionNumber;\n    }\n\n    // //////////////////////////////////////\n\n    private String invoiceNumber;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n    @Disabled\n    @Hidden(where=Where.PARENTED_TABLES)\n    public String getInvoiceNumber() {\n        return invoiceNumber;\n    }\n\n    public void setInvoiceNumber(final String invoiceNumber) {\n        this.invoiceNumber = invoiceNumber;\n    }\n\n    // //////////////////////////////////////\n\n    private InvoiceSource source;\n\n    /**\n     * Polymorphic association to (any implementation of) {@link InvoiceSource}.\n     */\n    @javax.jdo.annotations.Persistent(\n            extensions = {\n                    @Extension(vendorName = \"datanucleus\",\n                            key = \"mapping-strategy\",\n                            value = \"per-implementation\"),\n                    @Extension(vendorName = \"datanucleus\",\n                            key = \"implementation-classes\",\n                            value = \"org.estatio.dom.lease.Lease\") })\n    @javax.jdo.annotations.Columns({\n            @javax.jdo.annotations.Column(name = \"sourceLeaseId\", allowsNull = \"true\")\n    })\n    @Optional\n    // not really, but to be compatible with JDO\n    @Disabled\n    public InvoiceSource getSource() {\n        return source;\n    }\n\n    public void setSource(final InvoiceSource source) {\n        this.source = source;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate invoiceDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Disabled\n    public LocalDate getInvoiceDate() {\n        return invoiceDate;\n    }\n\n    public void setInvoiceDate(final LocalDate invoiceDate) {\n        this.invoiceDate = invoiceDate;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate dueDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\")\n    @Disabled\n    public LocalDate getDueDate() {\n        return dueDate;\n    }\n\n    public void setDueDate(final LocalDate dueDate) {\n        this.dueDate = dueDate;\n    }\n\n    // //////////////////////////////////////\n\n    private InvoiceStatus status;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Disabled\n    public InvoiceStatus getStatus() {\n        return status;\n    }\n\n    public void setStatus(final InvoiceStatus status) {\n        this.status = status;\n    }\n\n    // //////////////////////////////////////\n\n    private Currency currency;\n\n    // REVIEW: invoice generation is not populating this field.\n    @javax.jdo.annotations.Column(name = \"currencyId\", allowsNull = \"true\")\n    @Hidden(where = Where.ALL_TABLES)\n    @Disabled\n    public Currency getCurrency() {\n        return currency;\n    }\n\n    public void setCurrency(final Currency currency) {\n        this.currency = currency;\n    }\n\n    // //////////////////////////////////////\n\n    private PaymentMethod paymentMethod;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n    @Disabled\n    public PaymentMethod getPaymentMethod() {\n        return paymentMethod;\n    }\n\n    public void setPaymentMethod(final PaymentMethod paymentMethod) {\n        this.paymentMethod = paymentMethod;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent(mappedBy = \"invoice\")\n    private SortedSet<InvoiceItem> items = new TreeSet<InvoiceItem>();\n\n    @Disabled\n    @Render(Type.EAGERLY)\n    public SortedSet<InvoiceItem> getItems() {\n        return items;\n    }\n\n    public void setItems(final SortedSet<InvoiceItem> items) {\n        this.items = items;\n    }\n\n    // //////////////////////////////////////\n\n    @Persistent\n    private BigInteger lastItemSequence;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Hidden\n    public BigInteger getLastItemSequence() {\n        return lastItemSequence;\n    }\n\n    public void setLastItemSequence(final BigInteger lastItemSequence) {\n        this.lastItemSequence = lastItemSequence;\n    }\n\n    @Programmatic\n    public BigInteger nextItemSequence() {\n        BigInteger nextItemSequence = getLastItemSequence() == null\n                ? BigInteger.ONE\n                : getLastItemSequence().add(BigInteger.ONE);\n        setLastItemSequence(nextItemSequence);\n        return nextItemSequence;\n    }\n\n    // //////////////////////////////////////\n\n    @NotPersisted\n    public BigDecimal getNetAmount() {\n        BigDecimal total = BigDecimal.ZERO;\n        for (InvoiceItem item : getItems()) {\n            total = total.add(item.getNetAmount());\n        }\n        return total;\n    }\n\n    @NotPersisted\n    public BigDecimal getVatAmount() {\n        BigDecimal total = BigDecimal.ZERO;\n        for (InvoiceItem item : getItems()) {\n            total = total.add(item.getVatAmount());\n        }\n        return total;\n    }\n\n    @NotPersisted\n    public BigDecimal getGrossAmount() {\n        BigDecimal total = BigDecimal.ZERO;\n        for (InvoiceItem item : getItems()) {\n            total = total.add(item.getGrossAmount());\n        }\n        return total;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public Invoice approve() {\n        setStatus(InvoiceStatus.APPROVED);\n        return this;\n    }\n\n    public boolean hideApprove() {\n        return false;\n    }\n\n    public String disableApprove() {\n        return getStatus() != InvoiceStatus.NEW ? \"Can only approve 'new' invoices\" : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public Invoice collect() {\n\n        // bulk action, so need these guards\n        if (hideCollect()) {\n            return this;\n        }\n        if (disableCollect() != null) {\n            return this;\n        }\n\n        final Numerator numerator = invoices.findCollectionNumberNumerator();\n\n        setCollectionNumber(numerator.increment());\n        this.setStatus(InvoiceStatus.COLLECTED);\n\n        informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n        return this;\n    }\n\n    public boolean hideCollect() {\n        // only applies to direct debits\n        return !getPaymentMethod().isDirectDebit();\n    }\n\n    public String disableCollect() {\n        if (getCollectionNumber() != null) {\n            return \"Collection number already assigned\";\n        }\n\n        final Numerator numerator = invoices.findCollectionNumberNumerator();\n        if (numerator == null) {\n            return \"No 'collection number' numerator found for invoice's property\";\n        }\n\n        if (getStatus() != InvoiceStatus.APPROVED) {\n            return \"Must be in status of 'approved'\";\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public Invoice invoiceNow() {\n        return invoiceOn(getClockService().now());\n    }\n\n    public boolean hideInvoiceNow() {\n        return false; // TODO: return true if action is hidden, false if visible\n    }\n\n    public String disableInvoiceNow() {\n        if (getInvoiceNumber() != null) {\n            return \"Invoice number already assigned\";\n        }\n        final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n        if (numerator == null) {\n            return \"No 'invoice number' numerator found for invoice's property\";\n        }\n        // TODO: offload valid next states to the InvoiceStatus enum? Eg\n        // getStatus.isPossible(InvoiceStatus.APPROVED)\n        //\n        if (getStatus() != InvoiceStatus.COLLECTED && getStatus() != InvoiceStatus.APPROVED) {\n            return \"Must be in status of 'collected'\";\n        }\n        return null;\n    }\n\n    @Programmatic\n    public Invoice invoiceOn(final LocalDate invoiceDate) {\n        // bulk action, so need these guards\n        if (disableInvoiceNow() != null) {\n            return this;\n        }\n        final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n        setInvoiceNumber(numerator.increment());\n        setInvoiceDate(invoiceDate);\n        this.setStatus(InvoiceStatus.INVOICED);\n        informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    /**\n     * Derived from the {@link #getSource() invoice source}.\n     */\n    public Property getProperty() {\n        return getSource().getProperty();\n    }\n\n    // //////////////////////////////////////\n\n    @PublishedAction(InvoiceEagerlyRenderedPayloadFactory.class)\n    @Bulk\n    @ActionSemantics(Of.IDEMPOTENT)\n    public Invoice submitToCoda() {\n        collect();\n        return this;\n    }\n\n    public String disableSubmitToCoda() {\n        if (getPaymentMethod().isDirectDebit()) {\n            return getStatus() == InvoiceStatus.COLLECTED ||\n                    getStatus() == InvoiceStatus.INVOICED\n                    ? null\n                    : \"Must be collected or invoiced\";\n        } else {\n            return getStatus() == InvoiceStatus.INVOICED\n                    ? null\n                    : \"Must be invoiced\";\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @Prototype\n    @Bulk\n    public void remove() {\n        for (InvoiceItem item : getItems()) {\n            item.remove();\n        }\n        getContainer().remove(this);\n    }\n\n    // //////////////////////////////////////\n\n    private Invoices invoices;\n\n    public final void injectInvoices(final Invoices invoices) {\n        this.invoices = invoices;\n    }\n}",
        "start_point": {
            "row": 57,
            "column": 0
        },
        "end_point": {
            "row": 510,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public Invoice() {\n    super(\"invoiceNumber\");\n}",
                "name": "Invoice",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    super(\"invoiceNumber\");\n}",
                "constructor": true,
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "public String title() {\n    return String.format(\"*%08d\", Integer.parseInt(getId()));\n}",
                "name": "title",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return String.format(\"*%08d\", Integer.parseInt(getId()));\n}",
                "start_point": {
                    "row": 115,
                    "column": 4
                },
                "end_point": {
                    "row": 117,
                    "column": 5
                }
            },
            {
                "definition": "@Hidden(where=Where.OBJECT_FORMS)\npublic String getNumber() {\n    return ObjectUtils.firstNonNull(\n            getInvoiceNumber(),\n            getCollectionNumber(),\n            title());\n}",
                "name": "getNumber",
                "modifiers": "@Hidden(where=Where.OBJECT_FORMS)\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return ObjectUtils.firstNonNull(\n            getInvoiceNumber(),\n            getCollectionNumber(),\n            title());\n}",
                "start_point": {
                    "row": 121,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(name = \"buyerPartyId\", allowsNull = \"false\")\n@Disabled\npublic Party getBuyer() {\n    return buyer;\n\n}",
                "name": "getBuyer",
                "modifiers": "@javax.jdo.annotations.Column(name = \"buyerPartyId\", allowsNull = \"false\")\n    @Disabled\n    public",
                "return_type": "Party",
                "parameters": [],
                "body": "{\n    return buyer;\n\n}",
                "start_point": {
                    "row": 133,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "public void setBuyer(final Party buyer) {\n    this.buyer = buyer;\n}",
                "name": "setBuyer",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Party"
                    }
                ],
                "body": "{\n    this.buyer = buyer;\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 142,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(name = \"sellerPartyId\", allowsNull = \"false\")\n@Disabled\npublic Party getSeller() {\n    return seller;\n}",
                "name": "getSeller",
                "modifiers": "@javax.jdo.annotations.Column(name = \"sellerPartyId\", allowsNull = \"false\")\n    @Disabled\n    public",
                "return_type": "Party",
                "parameters": [],
                "body": "{\n    return seller;\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 152,
                    "column": 5
                }
            },
            {
                "definition": "public void setSeller(final Party seller) {\n    this.seller = seller;\n}",
                "name": "setSeller",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Party"
                    }
                ],
                "body": "{\n    this.seller = seller;\n}",
                "start_point": {
                    "row": 154,
                    "column": 4
                },
                "end_point": {
                    "row": 156,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n@Disabled\n@Hidden(where=Where.PARENTED_TABLES)\npublic String getCollectionNumber() {\n    return collectionNumber;\n}",
                "name": "getCollectionNumber",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n    @Disabled\n    @Hidden(where=Where.PARENTED_TABLES)\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return collectionNumber;\n}",
                "start_point": {
                    "row": 162,
                    "column": 4
                },
                "end_point": {
                    "row": 167,
                    "column": 5
                }
            },
            {
                "definition": "public void setCollectionNumber(final String collectionNumber) {\n    this.collectionNumber = collectionNumber;\n}",
                "name": "setCollectionNumber",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    this.collectionNumber = collectionNumber;\n}",
                "start_point": {
                    "row": 169,
                    "column": 4
                },
                "end_point": {
                    "row": 171,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n@Disabled\n@Hidden(where=Where.PARENTED_TABLES)\npublic String getInvoiceNumber() {\n    return invoiceNumber;\n}",
                "name": "getInvoiceNumber",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"true\", length = JdoColumnLength.Invoice.NUMBER)\n    @Disabled\n    @Hidden(where=Where.PARENTED_TABLES)\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return invoiceNumber;\n}",
                "start_point": {
                    "row": 177,
                    "column": 4
                },
                "end_point": {
                    "row": 182,
                    "column": 5
                }
            },
            {
                "definition": "public void setInvoiceNumber(final String invoiceNumber) {\n    this.invoiceNumber = invoiceNumber;\n}",
                "name": "setInvoiceNumber",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    this.invoiceNumber = invoiceNumber;\n}",
                "start_point": {
                    "row": 184,
                    "column": 4
                },
                "end_point": {
                    "row": 186,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Persistent(\n        extensions = {\n                @Extension(vendorName = \"datanucleus\",\n                        key = \"mapping-strategy\",\n                        value = \"per-implementation\"),\n                @Extension(vendorName = \"datanucleus\",\n                        key = \"implementation-classes\",\n                        value = \"org.estatio.dom.lease.Lease\") })\n@javax.jdo.annotations.Columns({\n        @javax.jdo.annotations.Column(name = \"sourceLeaseId\", allowsNull = \"true\")\n})\n@Optional\n// not really, but to be compatible with JDO\n@Disabled\npublic InvoiceSource getSource() {\n    return source;\n}",
                "name": "getSource",
                "modifiers": "@javax.jdo.annotations.Persistent(\n            extensions = {\n                    @Extension(vendorName = \"datanucleus\",\n                            key = \"mapping-strategy\",\n                            value = \"per-implementation\"),\n                    @Extension(vendorName = \"datanucleus\",\n                            key = \"implementation-classes\",\n                            value = \"org.estatio.dom.lease.Lease\") })\n    @javax.jdo.annotations.Columns({\n            @javax.jdo.annotations.Column(name = \"sourceLeaseId\", allowsNull = \"true\")\n    })\n    @Optional\n    // not really, but to be compatible with JDO\n    @Disabled\n    public",
                "return_type": "InvoiceSource",
                "parameters": [],
                "body": "{\n    return source;\n}",
                "start_point": {
                    "row": 195,
                    "column": 4
                },
                "end_point": {
                    "row": 211,
                    "column": 5
                }
            },
            {
                "definition": "public void setSource(final InvoiceSource source) {\n    this.source = source;\n}",
                "name": "setSource",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoiceSource"
                    }
                ],
                "body": "{\n    this.source = source;\n}",
                "start_point": {
                    "row": 213,
                    "column": 4
                },
                "end_point": {
                    "row": 215,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n@Disabled\npublic LocalDate getInvoiceDate() {\n    return invoiceDate;\n}",
                "name": "getInvoiceDate",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Disabled\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return invoiceDate;\n}",
                "start_point": {
                    "row": 222,
                    "column": 4
                },
                "end_point": {
                    "row": 226,
                    "column": 5
                }
            },
            {
                "definition": "public void setInvoiceDate(final LocalDate invoiceDate) {\n    this.invoiceDate = invoiceDate;\n}",
                "name": "setInvoiceDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.invoiceDate = invoiceDate;\n}",
                "start_point": {
                    "row": 228,
                    "column": 4
                },
                "end_point": {
                    "row": 230,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\")\n@Disabled\npublic LocalDate getDueDate() {\n    return dueDate;\n}",
                "name": "getDueDate",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\")\n    @Disabled\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return dueDate;\n}",
                "start_point": {
                    "row": 237,
                    "column": 4
                },
                "end_point": {
                    "row": 241,
                    "column": 5
                }
            },
            {
                "definition": "public void setDueDate(final LocalDate dueDate) {\n    this.dueDate = dueDate;\n}",
                "name": "setDueDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.dueDate = dueDate;\n}",
                "start_point": {
                    "row": 243,
                    "column": 4
                },
                "end_point": {
                    "row": 245,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n@Disabled\npublic InvoiceStatus getStatus() {\n    return status;\n}",
                "name": "getStatus",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Disabled\n    public",
                "return_type": "InvoiceStatus",
                "parameters": [],
                "body": "{\n    return status;\n}",
                "start_point": {
                    "row": 251,
                    "column": 4
                },
                "end_point": {
                    "row": 255,
                    "column": 5
                }
            },
            {
                "definition": "public void setStatus(final InvoiceStatus status) {\n    this.status = status;\n}",
                "name": "setStatus",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoiceStatus"
                    }
                ],
                "body": "{\n    this.status = status;\n}",
                "start_point": {
                    "row": 257,
                    "column": 4
                },
                "end_point": {
                    "row": 259,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(name = \"currencyId\", allowsNull = \"true\")\n@Hidden(where = Where.ALL_TABLES)\n@Disabled\npublic Currency getCurrency() {\n    return currency;\n}",
                "name": "getCurrency",
                "modifiers": "@javax.jdo.annotations.Column(name = \"currencyId\", allowsNull = \"true\")\n    @Hidden(where = Where.ALL_TABLES)\n    @Disabled\n    public",
                "return_type": "Currency",
                "parameters": [],
                "body": "{\n    return currency;\n}",
                "start_point": {
                    "row": 266,
                    "column": 4
                },
                "end_point": {
                    "row": 271,
                    "column": 5
                }
            },
            {
                "definition": "public void setCurrency(final Currency currency) {\n    this.currency = currency;\n}",
                "name": "setCurrency",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Currency"
                    }
                ],
                "body": "{\n    this.currency = currency;\n}",
                "start_point": {
                    "row": 273,
                    "column": 4
                },
                "end_point": {
                    "row": 275,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n@Disabled\npublic PaymentMethod getPaymentMethod() {\n    return paymentMethod;\n}",
                "name": "getPaymentMethod",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n    @Disabled\n    public",
                "return_type": "PaymentMethod",
                "parameters": [],
                "body": "{\n    return paymentMethod;\n}",
                "start_point": {
                    "row": 281,
                    "column": 4
                },
                "end_point": {
                    "row": 285,
                    "column": 5
                }
            },
            {
                "definition": "public void setPaymentMethod(final PaymentMethod paymentMethod) {\n    this.paymentMethod = paymentMethod;\n}",
                "name": "setPaymentMethod",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "PaymentMethod"
                    }
                ],
                "body": "{\n    this.paymentMethod = paymentMethod;\n}",
                "start_point": {
                    "row": 287,
                    "column": 4
                },
                "end_point": {
                    "row": 289,
                    "column": 5
                }
            },
            {
                "definition": "@Disabled\n@Render(Type.EAGERLY)\npublic SortedSet<InvoiceItem> getItems() {\n    return items;\n}",
                "name": "getItems",
                "modifiers": "@Disabled\n    @Render(Type.EAGERLY)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return items;\n}",
                "start_point": {
                    "row": 296,
                    "column": 4
                },
                "end_point": {
                    "row": 300,
                    "column": 5
                }
            },
            {
                "definition": "public void setItems(final SortedSet<InvoiceItem> items) {\n    this.items = items;\n}",
                "name": "setItems",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "SortedSet<InvoiceItem>"
                    }
                ],
                "body": "{\n    this.items = items;\n}",
                "start_point": {
                    "row": 302,
                    "column": 4
                },
                "end_point": {
                    "row": 304,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n@Hidden\npublic BigInteger getLastItemSequence() {\n    return lastItemSequence;\n}",
                "name": "getLastItemSequence",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Hidden\n    public",
                "return_type": "BigInteger",
                "parameters": [],
                "body": "{\n    return lastItemSequence;\n}",
                "start_point": {
                    "row": 311,
                    "column": 4
                },
                "end_point": {
                    "row": 315,
                    "column": 5
                }
            },
            {
                "definition": "public void setLastItemSequence(final BigInteger lastItemSequence) {\n    this.lastItemSequence = lastItemSequence;\n}",
                "name": "setLastItemSequence",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigInteger"
                    }
                ],
                "body": "{\n    this.lastItemSequence = lastItemSequence;\n}",
                "start_point": {
                    "row": 317,
                    "column": 4
                },
                "end_point": {
                    "row": 319,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic BigInteger nextItemSequence() {\n    BigInteger nextItemSequence = getLastItemSequence() == null\n            ? BigInteger.ONE\n            : getLastItemSequence().add(BigInteger.ONE);\n    setLastItemSequence(nextItemSequence);\n    return nextItemSequence;\n}",
                "name": "nextItemSequence",
                "modifiers": "@Programmatic\n    public",
                "return_type": "BigInteger",
                "parameters": [],
                "body": "{\n    BigInteger nextItemSequence = getLastItemSequence() == null\n            ? BigInteger.ONE\n            : getLastItemSequence().add(BigInteger.ONE);\n    setLastItemSequence(nextItemSequence);\n    return nextItemSequence;\n}",
                "start_point": {
                    "row": 321,
                    "column": 4
                },
                "end_point": {
                    "row": 328,
                    "column": 5
                }
            },
            {
                "definition": "@NotPersisted\npublic BigDecimal getNetAmount() {\n    BigDecimal total = BigDecimal.ZERO;\n    for (InvoiceItem item : getItems()) {\n        total = total.add(item.getNetAmount());\n    }\n    return total;\n}",
                "name": "getNetAmount",
                "modifiers": "@NotPersisted\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    BigDecimal total = BigDecimal.ZERO;\n    for (InvoiceItem item : getItems()) {\n        total = total.add(item.getNetAmount());\n    }\n    return total;\n}",
                "start_point": {
                    "row": 332,
                    "column": 4
                },
                "end_point": {
                    "row": 339,
                    "column": 5
                }
            },
            {
                "definition": "@NotPersisted\npublic BigDecimal getVatAmount() {\n    BigDecimal total = BigDecimal.ZERO;\n    for (InvoiceItem item : getItems()) {\n        total = total.add(item.getVatAmount());\n    }\n    return total;\n}",
                "name": "getVatAmount",
                "modifiers": "@NotPersisted\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    BigDecimal total = BigDecimal.ZERO;\n    for (InvoiceItem item : getItems()) {\n        total = total.add(item.getVatAmount());\n    }\n    return total;\n}",
                "start_point": {
                    "row": 341,
                    "column": 4
                },
                "end_point": {
                    "row": 348,
                    "column": 5
                }
            },
            {
                "definition": "@NotPersisted\npublic BigDecimal getGrossAmount() {\n    BigDecimal total = BigDecimal.ZERO;\n    for (InvoiceItem item : getItems()) {\n        total = total.add(item.getGrossAmount());\n    }\n    return total;\n}",
                "name": "getGrossAmount",
                "modifiers": "@NotPersisted\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    BigDecimal total = BigDecimal.ZERO;\n    for (InvoiceItem item : getItems()) {\n        total = total.add(item.getGrossAmount());\n    }\n    return total;\n}",
                "start_point": {
                    "row": 350,
                    "column": 4
                },
                "end_point": {
                    "row": 357,
                    "column": 5
                }
            },
            {
                "definition": "@Bulk\npublic Invoice approve() {\n    setStatus(InvoiceStatus.APPROVED);\n    return this;\n}",
                "name": "approve",
                "modifiers": "@Bulk\n    public",
                "return_type": "Invoice",
                "parameters": [],
                "body": "{\n    setStatus(InvoiceStatus.APPROVED);\n    return this;\n}",
                "start_point": {
                    "row": 361,
                    "column": 4
                },
                "end_point": {
                    "row": 365,
                    "column": 5
                }
            },
            {
                "definition": "public boolean hideApprove() {\n    return false;\n}",
                "name": "hideApprove",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return false;\n}",
                "start_point": {
                    "row": 367,
                    "column": 4
                },
                "end_point": {
                    "row": 369,
                    "column": 5
                }
            },
            {
                "definition": "public String disableApprove() {\n    return getStatus() != InvoiceStatus.NEW ? \"Can only approve 'new' invoices\" : null;\n}",
                "name": "disableApprove",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return getStatus() != InvoiceStatus.NEW ? \"Can only approve 'new' invoices\" : null;\n}",
                "start_point": {
                    "row": 371,
                    "column": 4
                },
                "end_point": {
                    "row": 373,
                    "column": 5
                }
            },
            {
                "definition": "@Bulk\npublic Invoice collect() {\n\n    // bulk action, so need these guards\n    if (hideCollect()) {\n        return this;\n    }\n    if (disableCollect() != null) {\n        return this;\n    }\n\n    final Numerator numerator = invoices.findCollectionNumberNumerator();\n\n    setCollectionNumber(numerator.increment());\n    this.setStatus(InvoiceStatus.COLLECTED);\n\n    informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n    return this;\n}",
                "name": "collect",
                "modifiers": "@Bulk\n    public",
                "return_type": "Invoice",
                "parameters": [],
                "body": "{\n\n    // bulk action, so need these guards\n    if (hideCollect()) {\n        return this;\n    }\n    if (disableCollect() != null) {\n        return this;\n    }\n\n    final Numerator numerator = invoices.findCollectionNumberNumerator();\n\n    setCollectionNumber(numerator.increment());\n    this.setStatus(InvoiceStatus.COLLECTED);\n\n    informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n    return this;\n}",
                "start_point": {
                    "row": 377,
                    "column": 4
                },
                "end_point": {
                    "row": 395,
                    "column": 5
                }
            },
            {
                "definition": "public boolean hideCollect() {\n    // only applies to direct debits\n    return !getPaymentMethod().isDirectDebit();\n}",
                "name": "hideCollect",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // only applies to direct debits\n    return !getPaymentMethod().isDirectDebit();\n}",
                "start_point": {
                    "row": 397,
                    "column": 4
                },
                "end_point": {
                    "row": 400,
                    "column": 5
                }
            },
            {
                "definition": "public String disableCollect() {\n    if (getCollectionNumber() != null) {\n        return \"Collection number already assigned\";\n    }\n\n    final Numerator numerator = invoices.findCollectionNumberNumerator();\n    if (numerator == null) {\n        return \"No 'collection number' numerator found for invoice's property\";\n    }\n\n    if (getStatus() != InvoiceStatus.APPROVED) {\n        return \"Must be in status of 'approved'\";\n    }\n    return null;\n}",
                "name": "disableCollect",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    if (getCollectionNumber() != null) {\n        return \"Collection number already assigned\";\n    }\n\n    final Numerator numerator = invoices.findCollectionNumberNumerator();\n    if (numerator == null) {\n        return \"No 'collection number' numerator found for invoice's property\";\n    }\n\n    if (getStatus() != InvoiceStatus.APPROVED) {\n        return \"Must be in status of 'approved'\";\n    }\n    return null;\n}",
                "start_point": {
                    "row": 402,
                    "column": 4
                },
                "end_point": {
                    "row": 416,
                    "column": 5
                }
            },
            {
                "definition": "@Bulk\npublic Invoice invoiceNow() {\n    return invoiceOn(getClockService().now());\n}",
                "name": "invoiceNow",
                "modifiers": "@Bulk\n    public",
                "return_type": "Invoice",
                "parameters": [],
                "body": "{\n    return invoiceOn(getClockService().now());\n}",
                "start_point": {
                    "row": 420,
                    "column": 4
                },
                "end_point": {
                    "row": 423,
                    "column": 5
                }
            },
            {
                "definition": "public boolean hideInvoiceNow() {\n    return false; // TODO: return true if action is hidden, false if visible\n}",
                "name": "hideInvoiceNow",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return false; // TODO: return true if action is hidden, false if visible\n}",
                "start_point": {
                    "row": 425,
                    "column": 4
                },
                "end_point": {
                    "row": 427,
                    "column": 5
                }
            },
            {
                "definition": "public String disableInvoiceNow() {\n    if (getInvoiceNumber() != null) {\n        return \"Invoice number already assigned\";\n    }\n    final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n    if (numerator == null) {\n        return \"No 'invoice number' numerator found for invoice's property\";\n    }\n    // TODO: offload valid next states to the InvoiceStatus enum? Eg\n    // getStatus.isPossible(InvoiceStatus.APPROVED)\n    //\n    if (getStatus() != InvoiceStatus.COLLECTED && getStatus() != InvoiceStatus.APPROVED) {\n        return \"Must be in status of 'collected'\";\n    }\n    return null;\n}",
                "name": "disableInvoiceNow",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    if (getInvoiceNumber() != null) {\n        return \"Invoice number already assigned\";\n    }\n    final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n    if (numerator == null) {\n        return \"No 'invoice number' numerator found for invoice's property\";\n    }\n    // TODO: offload valid next states to the InvoiceStatus enum? Eg\n    // getStatus.isPossible(InvoiceStatus.APPROVED)\n    //\n    if (getStatus() != InvoiceStatus.COLLECTED && getStatus() != InvoiceStatus.APPROVED) {\n        return \"Must be in status of 'collected'\";\n    }\n    return null;\n}",
                "start_point": {
                    "row": 429,
                    "column": 4
                },
                "end_point": {
                    "row": 444,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic Invoice invoiceOn(final LocalDate invoiceDate) {\n    // bulk action, so need these guards\n    if (disableInvoiceNow() != null) {\n        return this;\n    }\n    final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n    setInvoiceNumber(numerator.increment());\n    setInvoiceDate(invoiceDate);\n    this.setStatus(InvoiceStatus.INVOICED);\n    informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n    return this;\n}",
                "name": "invoiceOn",
                "modifiers": "@Programmatic\n    public",
                "return_type": "Invoice",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    // bulk action, so need these guards\n    if (disableInvoiceNow() != null) {\n        return this;\n    }\n    final Numerator numerator = invoices.findInvoiceNumberNumerator(getProperty());\n    setInvoiceNumber(numerator.increment());\n    setInvoiceDate(invoiceDate);\n    this.setStatus(InvoiceStatus.INVOICED);\n    informUser(\"Assigned \" + this.getCollectionNumber() + \" to invoice \" + getContainer().titleOf(this));\n    return this;\n}",
                "start_point": {
                    "row": 446,
                    "column": 4
                },
                "end_point": {
                    "row": 458,
                    "column": 5
                }
            },
            {
                "definition": "public Property getProperty() {\n    return getSource().getProperty();\n}",
                "name": "getProperty",
                "modifiers": "public",
                "return_type": "Property",
                "parameters": [],
                "body": "{\n    return getSource().getProperty();\n}",
                "start_point": {
                    "row": 465,
                    "column": 4
                },
                "end_point": {
                    "row": 467,
                    "column": 5
                }
            },
            {
                "definition": "@PublishedAction(InvoiceEagerlyRenderedPayloadFactory.class)\n@Bulk\n@ActionSemantics(Of.IDEMPOTENT)\npublic Invoice submitToCoda() {\n    collect();\n    return this;\n}",
                "name": "submitToCoda",
                "modifiers": "@PublishedAction(InvoiceEagerlyRenderedPayloadFactory.class)\n    @Bulk\n    @ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": "Invoice",
                "parameters": [],
                "body": "{\n    collect();\n    return this;\n}",
                "start_point": {
                    "row": 471,
                    "column": 4
                },
                "end_point": {
                    "row": 477,
                    "column": 5
                }
            },
            {
                "definition": "public String disableSubmitToCoda() {\n    if (getPaymentMethod().isDirectDebit()) {\n        return getStatus() == InvoiceStatus.COLLECTED ||\n                getStatus() == InvoiceStatus.INVOICED\n                ? null\n                : \"Must be collected or invoiced\";\n    } else {\n        return getStatus() == InvoiceStatus.INVOICED\n                ? null\n                : \"Must be invoiced\";\n    }\n}",
                "name": "disableSubmitToCoda",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    if (getPaymentMethod().isDirectDebit()) {\n        return getStatus() == InvoiceStatus.COLLECTED ||\n                getStatus() == InvoiceStatus.INVOICED\n                ? null\n                : \"Must be collected or invoiced\";\n    } else {\n        return getStatus() == InvoiceStatus.INVOICED\n                ? null\n                : \"Must be invoiced\";\n    }\n}",
                "start_point": {
                    "row": 479,
                    "column": 4
                },
                "end_point": {
                    "row": 490,
                    "column": 5
                }
            },
            {
                "definition": "@Prototype\n@Bulk\npublic void remove() {\n    for (InvoiceItem item : getItems()) {\n        item.remove();\n    }\n    getContainer().remove(this);\n}",
                "name": "remove",
                "modifiers": "@Prototype\n    @Bulk\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    for (InvoiceItem item : getItems()) {\n        item.remove();\n    }\n    getContainer().remove(this);\n}",
                "start_point": {
                    "row": 494,
                    "column": 4
                },
                "end_point": {
                    "row": 501,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectInvoices(final Invoices invoices) {\n    this.invoices = invoices;\n}",
                "name": "injectInvoices",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Invoices"
                    }
                ],
                "body": "{\n    this.invoices = invoices;\n}",
                "start_point": {
                    "row": 507,
                    "column": 4
                },
                "end_point": {
                    "row": 509,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dom/src/main/java/org/estatio/dom/lease/LeaseItem.java",
        "definition": "@javax.jdo.annotations.PersistenceCapable(identityType = IdentityType.DATASTORE)\n@javax.jdo.annotations.DatastoreIdentity(\n        strategy = IdGeneratorStrategy.NATIVE,\n        column = \"id\")\n@javax.jdo.annotations.Version(\n        strategy = VersionStrategy.VERSION_NUMBER,\n        column = \"version\")\n@javax.jdo.annotations.Indices({\n        @javax.jdo.annotations.Index(\n                name = \"LeaseItem_lease_type_sequence_IDX\",\n                members = { \"lease\", \"type\", \"sequence\" }),\n        @javax.jdo.annotations.Index(\n                name = \"LeaseItem_lease_type_startDate_IDX\",\n                members = { \"lease\", \"type\", \"startDate\" })\n})\n@javax.jdo.annotations.Queries({\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseAndTypeAndStartDate\",\n                language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseItem \"\n                        + \"WHERE lease == :lease \"\n                        + \"   && type == :type \"\n                        + \"   && startDate == :startDate\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseAndTypeAndStartDateAndSequence\",\n                language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseItem \"\n                        + \"WHERE lease == :lease \"\n                        + \"&& type == :type \"\n                        + \"&& startDate == :startDate \"\n                        + \"&& sequence == :sequence\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseAndTypeAndEndDate\",\n                language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseItem \"\n                        + \"WHERE lease == :lease \"\n                        + \"   && endDate == :endDate\")\n})\n@Bookmarkable(BookmarkPolicy.AS_CHILD)\npublic class LeaseItem\n        extends EstatioMutableObject<LeaseItem>\n        implements WithIntervalMutable<LeaseItem>, WithSequence {\n\n    private static final int PAGE_SIZE = 15;\n\n    public LeaseItem() {\n        super(\"lease, type, sequence desc\");\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseItemStatus status;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Disabled\n    public LeaseItemStatus getStatus() {\n        return status;\n    }\n\n    public void setStatus(final LeaseItemStatus status) {\n        this.status = status;\n    }\n\n    // //////////////////////////////////////\n\n    private Lease lease;\n\n    @javax.jdo.annotations.Column(name = \"leaseId\", allowsNull = \"false\")\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Title(sequence = \"1\", append = \":\")\n    public Lease getLease() {\n        return lease;\n    }\n\n    public void setLease(final Lease lease) {\n        this.lease = lease;\n    }\n\n    // //////////////////////////////////////\n\n    private BigInteger sequence;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\")\n    @Hidden\n    @Override\n    public BigInteger getSequence() {\n        return sequence;\n    }\n\n    @Override\n    public void setSequence(final BigInteger sequence) {\n        this.sequence = sequence;\n    }\n\n    @Programmatic\n    public LeaseTerm findTermWithSequence(final BigInteger sequence) {\n        // for (LeaseTerm term : getTerms()) {\n        // if (sequence.equals(term.getSequence())) {\n        // return term;\n        // }\n        // }\n        // return null;\n        // TODO: the code above proved to be very unreliable when using the api.\n        // Have to investigate further\n        return leaseTerms.findLeaseTermByLeaseItemAndSequence(this, sequence);\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseItemType type;\n\n    @javax.jdo.annotations.Persistent(defaultFetchGroup = \"true\")\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.TYPE_ENUM)\n    @Title(sequence = \"2\")\n    public LeaseItemType getType() {\n        return type;\n    }\n\n    public void setType(final LeaseItemType type) {\n        this.type = type;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate startDate;\n\n    @Optional\n    @Disabled\n    @Override\n    public LocalDate getStartDate() {\n        return startDate;\n    }\n\n    @Override\n    public void setStartDate(final LocalDate startDate) {\n        this.startDate = startDate;\n    }\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate endDate;\n\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Optional\n    @Disabled\n    public LocalDate getEndDate() {\n        return endDate;\n    }\n\n    public void setEndDate(final LocalDate endDate) {\n        this.endDate = endDate;\n    }\n\n    // //////////////////////////////////////\n\n    private WithIntervalMutable.Helper<LeaseItem> changeDates = new WithIntervalMutable.Helper<LeaseItem>(this);\n\n    WithIntervalMutable.Helper<LeaseItem> getChangeDates() {\n        return changeDates;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    @Override\n    public LeaseItem changeDates(\n            final @Named(\"Start Date\") @Optional LocalDate startDate,\n            final @Named(\"End Date\") @Optional LocalDate endDate) {\n        return getChangeDates().changeDates(startDate, endDate);\n    }\n\n    public String disableChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return null;\n    }\n\n    @Override\n    public LocalDate default0ChangeDates() {\n        return getChangeDates().default0ChangeDates();\n    }\n\n    @Override\n    public LocalDate default1ChangeDates() {\n        return getChangeDates().default1ChangeDates();\n    }\n\n    @Override\n    public String validateChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return getChangeDates().validateChangeDates(startDate, endDate);\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    @Override\n    public LocalDateInterval getInterval() {\n        return LocalDateInterval.including(getStartDate(), getEndDate());\n    }\n\n    @Programmatic\n    @Override\n    public LocalDateInterval getEffectiveInterval() {\n        return getInterval().overlap(getLease().getEffectiveInterval());\n    }\n\n    // //////////////////////////////////////\n\n    public boolean isCurrent() {\n        return isActiveOn(getClockService().now());\n    }\n\n    private boolean isActiveOn(final LocalDate localDate) {\n        return getEffectiveInterval().contains(localDate);\n    }\n\n    // //////////////////////////////////////\n\n    private InvoicingFrequency invoicingFrequency;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.INVOICING_FREQUENCY_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    public InvoicingFrequency getInvoicingFrequency() {\n        return invoicingFrequency;\n    }\n\n    public void setInvoicingFrequency(final InvoicingFrequency invoicingFrequency) {\n        this.invoicingFrequency = invoicingFrequency;\n    }\n\n    // //////////////////////////////////////\n\n    private PaymentMethod paymentMethod;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    public PaymentMethod getPaymentMethod() {\n        return paymentMethod;\n    }\n\n    public void setPaymentMethod(final PaymentMethod paymentMethod) {\n        this.paymentMethod = paymentMethod;\n    }\n\n    // //////////////////////////////////////\n\n    private Charge charge;\n\n    @javax.jdo.annotations.Column(name = \"chargeId\", allowsNull = \"false\")\n    public Charge getCharge() {\n        return charge;\n    }\n\n    public void setCharge(final Charge charge) {\n        this.charge = charge;\n    }\n\n    public List<Charge> choicesCharge() {\n        return charges.allCharges();\n    }\n\n    // //////////////////////////////////////\n\n    @Disabled\n    @Optional\n    public BigDecimal getTrialValue() {\n        final LeaseTerm currentTerm = currentTerm(getClockService().now());\n        return currentTerm != null ? currentTerm.getTrialValue() : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Disabled\n    @Optional\n    public BigDecimal getApprovedValue() {\n        LeaseTerm currentTerm = currentTerm(getClockService().now());\n        return currentTerm != null ? currentTerm.getApprovedValue() : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public LeaseTerm currentTerm(final LocalDate date) {\n        for (LeaseTerm term : getTerms()) {\n            if (term.isActiveOn(date)) {\n                return term;\n            }\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent(mappedBy = \"leaseItem\")\n    private SortedSet<LeaseTerm> terms = new TreeSet<LeaseTerm>();\n\n    @Render(Type.EAGERLY)\n    @Paged(PAGE_SIZE)\n    public SortedSet<LeaseTerm> getTerms() {\n        return terms;\n    }\n\n    public void setTerms(final SortedSet<LeaseTerm> terms) {\n        this.terms = terms;\n    }\n\n    @Programmatic\n    public LeaseTerm findTerm(final LocalDate startDate) {\n        for (LeaseTerm term : getTerms()) {\n            if (startDate.equals(term.getStartDate())) {\n                return term;\n            }\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseTerm newTerm(\n            final @Named(\"Start date\") LocalDate startDate) {\n        LeaseTerm lastTerm = getTerms().size() > 0 ? getTerms().last() : null;\n        LeaseTerm term = leaseTerms.newLeaseTerm(this, lastTerm, startDate);\n        term.initialize();\n        return term;\n    }\n\n    public LocalDate default0NewTerm() {\n        LeaseTerm last = null;\n        try {\n            last = getTerms().last();\n        } catch (NoSuchElementException e) {\n            return getStartDate();\n        }\n        if (last.getEndDate() != null) {\n            return last.getInterval().endDateExcluding();\n        }\n        return last.getStartDate().plusYears(1).withMonthOfYear(1).withDayOfMonth(1);\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseItem verify() {\n        verifyUntil(getClockService().now());\n        return this;\n    }\n\n    @Programmatic\n    public void verifyUntil(final LocalDate date) {\n        for (LeaseTerm term : getTerms()) {\n            if (term.getPrevious() == null) {\n                // since verify is recursive on terms only start on the main\n                // term\n                term.verifyUntil(date);\n            }\n        }\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseItem calculate(\n            final @Named(\"Period start Date\") LocalDate startDate,\n            final @Named(\"Period end date\") @Optional LocalDate endDate,\n            final @Named(\"Due date\") LocalDate dueDate,\n            final @Named(\"Run Type\") InvoiceRunType runType) {\n        for (LeaseTerm term : getTerms()) {\n            term.calculate(startDate, endDate, dueDate, runType);\n        }\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    BigDecimal valueForPeriod(\n            final InvoicingFrequency frequency,\n            final LocalDate periodStartDate,\n            final LocalDate dueDate) {\n        BigDecimal total = new BigDecimal(0);\n        for (LeaseTerm term : getTerms()) {\n            total = total.add(term.valueForPeriod(periodStartDate, dueDate, frequency));\n        }\n        return total;\n    }\n\n    // //////////////////////////////////////\n\n    private Charges charges;\n\n    public final void injectCharges(final Charges charges) {\n        this.charges = charges;\n    }\n\n    private LeaseTerms leaseTerms;\n\n    public final void injectLeaseTerms(final LeaseTerms leaseTerms) {\n        this.leaseTerms = leaseTerms;\n    }\n\n}",
        "package": "package org.estatio.dom.lease;",
        "tree_path": "LeaseItem",
        "name": "LeaseItem",
        "modifiers": "@javax.jdo.annotations.PersistenceCapable(identityType = IdentityType.DATASTORE)\n@javax.jdo.annotations.DatastoreIdentity(\n        strategy = IdGeneratorStrategy.NATIVE,\n        column = \"id\")\n@javax.jdo.annotations.Version(\n        strategy = VersionStrategy.VERSION_NUMBER,\n        column = \"version\")\n@javax.jdo.annotations.Indices({\n        @javax.jdo.annotations.Index(\n                name = \"LeaseItem_lease_type_sequence_IDX\",\n                members = { \"lease\", \"type\", \"sequence\" }),\n        @javax.jdo.annotations.Index(\n                name = \"LeaseItem_lease_type_startDate_IDX\",\n                members = { \"lease\", \"type\", \"startDate\" })\n})\n@javax.jdo.annotations.Queries({\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseAndTypeAndStartDate\",\n                language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseItem \"\n                        + \"WHERE lease == :lease \"\n                        + \"   && type == :type \"\n                        + \"   && startDate == :startDate\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseAndTypeAndStartDateAndSequence\",\n                language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseItem \"\n                        + \"WHERE lease == :lease \"\n                        + \"&& type == :type \"\n                        + \"&& startDate == :startDate \"\n                        + \"&& sequence == :sequence\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseAndTypeAndEndDate\",\n                language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseItem \"\n                        + \"WHERE lease == :lease \"\n                        + \"   && endDate == :endDate\")\n})\n@Bookmarkable(BookmarkPolicy.AS_CHILD)\npublic",
        "superclass": "extends EstatioMutableObject<LeaseItem>",
        "super_interfaces": "implements WithIntervalMutable<LeaseItem>, WithSequence",
        "body": "{\n\n    private static final int PAGE_SIZE = 15;\n\n    public LeaseItem() {\n        super(\"lease, type, sequence desc\");\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseItemStatus status;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Disabled\n    public LeaseItemStatus getStatus() {\n        return status;\n    }\n\n    public void setStatus(final LeaseItemStatus status) {\n        this.status = status;\n    }\n\n    // //////////////////////////////////////\n\n    private Lease lease;\n\n    @javax.jdo.annotations.Column(name = \"leaseId\", allowsNull = \"false\")\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Title(sequence = \"1\", append = \":\")\n    public Lease getLease() {\n        return lease;\n    }\n\n    public void setLease(final Lease lease) {\n        this.lease = lease;\n    }\n\n    // //////////////////////////////////////\n\n    private BigInteger sequence;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\")\n    @Hidden\n    @Override\n    public BigInteger getSequence() {\n        return sequence;\n    }\n\n    @Override\n    public void setSequence(final BigInteger sequence) {\n        this.sequence = sequence;\n    }\n\n    @Programmatic\n    public LeaseTerm findTermWithSequence(final BigInteger sequence) {\n        // for (LeaseTerm term : getTerms()) {\n        // if (sequence.equals(term.getSequence())) {\n        // return term;\n        // }\n        // }\n        // return null;\n        // TODO: the code above proved to be very unreliable when using the api.\n        // Have to investigate further\n        return leaseTerms.findLeaseTermByLeaseItemAndSequence(this, sequence);\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseItemType type;\n\n    @javax.jdo.annotations.Persistent(defaultFetchGroup = \"true\")\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.TYPE_ENUM)\n    @Title(sequence = \"2\")\n    public LeaseItemType getType() {\n        return type;\n    }\n\n    public void setType(final LeaseItemType type) {\n        this.type = type;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate startDate;\n\n    @Optional\n    @Disabled\n    @Override\n    public LocalDate getStartDate() {\n        return startDate;\n    }\n\n    @Override\n    public void setStartDate(final LocalDate startDate) {\n        this.startDate = startDate;\n    }\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate endDate;\n\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Optional\n    @Disabled\n    public LocalDate getEndDate() {\n        return endDate;\n    }\n\n    public void setEndDate(final LocalDate endDate) {\n        this.endDate = endDate;\n    }\n\n    // //////////////////////////////////////\n\n    private WithIntervalMutable.Helper<LeaseItem> changeDates = new WithIntervalMutable.Helper<LeaseItem>(this);\n\n    WithIntervalMutable.Helper<LeaseItem> getChangeDates() {\n        return changeDates;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    @Override\n    public LeaseItem changeDates(\n            final @Named(\"Start Date\") @Optional LocalDate startDate,\n            final @Named(\"End Date\") @Optional LocalDate endDate) {\n        return getChangeDates().changeDates(startDate, endDate);\n    }\n\n    public String disableChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return null;\n    }\n\n    @Override\n    public LocalDate default0ChangeDates() {\n        return getChangeDates().default0ChangeDates();\n    }\n\n    @Override\n    public LocalDate default1ChangeDates() {\n        return getChangeDates().default1ChangeDates();\n    }\n\n    @Override\n    public String validateChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return getChangeDates().validateChangeDates(startDate, endDate);\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    @Override\n    public LocalDateInterval getInterval() {\n        return LocalDateInterval.including(getStartDate(), getEndDate());\n    }\n\n    @Programmatic\n    @Override\n    public LocalDateInterval getEffectiveInterval() {\n        return getInterval().overlap(getLease().getEffectiveInterval());\n    }\n\n    // //////////////////////////////////////\n\n    public boolean isCurrent() {\n        return isActiveOn(getClockService().now());\n    }\n\n    private boolean isActiveOn(final LocalDate localDate) {\n        return getEffectiveInterval().contains(localDate);\n    }\n\n    // //////////////////////////////////////\n\n    private InvoicingFrequency invoicingFrequency;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.INVOICING_FREQUENCY_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    public InvoicingFrequency getInvoicingFrequency() {\n        return invoicingFrequency;\n    }\n\n    public void setInvoicingFrequency(final InvoicingFrequency invoicingFrequency) {\n        this.invoicingFrequency = invoicingFrequency;\n    }\n\n    // //////////////////////////////////////\n\n    private PaymentMethod paymentMethod;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    public PaymentMethod getPaymentMethod() {\n        return paymentMethod;\n    }\n\n    public void setPaymentMethod(final PaymentMethod paymentMethod) {\n        this.paymentMethod = paymentMethod;\n    }\n\n    // //////////////////////////////////////\n\n    private Charge charge;\n\n    @javax.jdo.annotations.Column(name = \"chargeId\", allowsNull = \"false\")\n    public Charge getCharge() {\n        return charge;\n    }\n\n    public void setCharge(final Charge charge) {\n        this.charge = charge;\n    }\n\n    public List<Charge> choicesCharge() {\n        return charges.allCharges();\n    }\n\n    // //////////////////////////////////////\n\n    @Disabled\n    @Optional\n    public BigDecimal getTrialValue() {\n        final LeaseTerm currentTerm = currentTerm(getClockService().now());\n        return currentTerm != null ? currentTerm.getTrialValue() : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Disabled\n    @Optional\n    public BigDecimal getApprovedValue() {\n        LeaseTerm currentTerm = currentTerm(getClockService().now());\n        return currentTerm != null ? currentTerm.getApprovedValue() : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public LeaseTerm currentTerm(final LocalDate date) {\n        for (LeaseTerm term : getTerms()) {\n            if (term.isActiveOn(date)) {\n                return term;\n            }\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent(mappedBy = \"leaseItem\")\n    private SortedSet<LeaseTerm> terms = new TreeSet<LeaseTerm>();\n\n    @Render(Type.EAGERLY)\n    @Paged(PAGE_SIZE)\n    public SortedSet<LeaseTerm> getTerms() {\n        return terms;\n    }\n\n    public void setTerms(final SortedSet<LeaseTerm> terms) {\n        this.terms = terms;\n    }\n\n    @Programmatic\n    public LeaseTerm findTerm(final LocalDate startDate) {\n        for (LeaseTerm term : getTerms()) {\n            if (startDate.equals(term.getStartDate())) {\n                return term;\n            }\n        }\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseTerm newTerm(\n            final @Named(\"Start date\") LocalDate startDate) {\n        LeaseTerm lastTerm = getTerms().size() > 0 ? getTerms().last() : null;\n        LeaseTerm term = leaseTerms.newLeaseTerm(this, lastTerm, startDate);\n        term.initialize();\n        return term;\n    }\n\n    public LocalDate default0NewTerm() {\n        LeaseTerm last = null;\n        try {\n            last = getTerms().last();\n        } catch (NoSuchElementException e) {\n            return getStartDate();\n        }\n        if (last.getEndDate() != null) {\n            return last.getInterval().endDateExcluding();\n        }\n        return last.getStartDate().plusYears(1).withMonthOfYear(1).withDayOfMonth(1);\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseItem verify() {\n        verifyUntil(getClockService().now());\n        return this;\n    }\n\n    @Programmatic\n    public void verifyUntil(final LocalDate date) {\n        for (LeaseTerm term : getTerms()) {\n            if (term.getPrevious() == null) {\n                // since verify is recursive on terms only start on the main\n                // term\n                term.verifyUntil(date);\n            }\n        }\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseItem calculate(\n            final @Named(\"Period start Date\") LocalDate startDate,\n            final @Named(\"Period end date\") @Optional LocalDate endDate,\n            final @Named(\"Due date\") LocalDate dueDate,\n            final @Named(\"Run Type\") InvoiceRunType runType) {\n        for (LeaseTerm term : getTerms()) {\n            term.calculate(startDate, endDate, dueDate, runType);\n        }\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    BigDecimal valueForPeriod(\n            final InvoicingFrequency frequency,\n            final LocalDate periodStartDate,\n            final LocalDate dueDate) {\n        BigDecimal total = new BigDecimal(0);\n        for (LeaseTerm term : getTerms()) {\n            total = total.add(term.valueForPeriod(periodStartDate, dueDate, frequency));\n        }\n        return total;\n    }\n\n    // //////////////////////////////////////\n\n    private Charges charges;\n\n    public final void injectCharges(final Charges charges) {\n        this.charges = charges;\n    }\n\n    private LeaseTerms leaseTerms;\n\n    public final void injectLeaseTerms(final LeaseTerms leaseTerms) {\n        this.leaseTerms = leaseTerms;\n    }\n\n}",
        "start_point": {
            "row": 70,
            "column": 0
        },
        "end_point": {
            "row": 471,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public LeaseItem() {\n    super(\"lease, type, sequence desc\");\n}",
                "name": "LeaseItem",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    super(\"lease, type, sequence desc\");\n}",
                "constructor": true,
                "start_point": {
                    "row": 118,
                    "column": 4
                },
                "end_point": {
                    "row": 120,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n@Hidden(where = Where.PARENTED_TABLES)\n@Disabled\npublic LeaseItemStatus getStatus() {\n    return status;\n}",
                "name": "getStatus",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Disabled\n    public",
                "return_type": "LeaseItemStatus",
                "parameters": [],
                "body": "{\n    return status;\n}",
                "start_point": {
                    "row": 126,
                    "column": 4
                },
                "end_point": {
                    "row": 131,
                    "column": 5
                }
            },
            {
                "definition": "public void setStatus(final LeaseItemStatus status) {\n    this.status = status;\n}",
                "name": "setStatus",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseItemStatus"
                    }
                ],
                "body": "{\n    this.status = status;\n}",
                "start_point": {
                    "row": 133,
                    "column": 4
                },
                "end_point": {
                    "row": 135,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(name = \"leaseId\", allowsNull = \"false\")\n@Hidden(where = Where.PARENTED_TABLES)\n@Title(sequence = \"1\", append = \":\")\npublic Lease getLease() {\n    return lease;\n}",
                "name": "getLease",
                "modifiers": "@javax.jdo.annotations.Column(name = \"leaseId\", allowsNull = \"false\")\n    @Hidden(where = Where.PARENTED_TABLES)\n    @Title(sequence = \"1\", append = \":\")\n    public",
                "return_type": "Lease",
                "parameters": [],
                "body": "{\n    return lease;\n}",
                "start_point": {
                    "row": 141,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "public void setLease(final Lease lease) {\n    this.lease = lease;\n}",
                "name": "setLease",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Lease"
                    }
                ],
                "body": "{\n    this.lease = lease;\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 150,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\")\n@Hidden\n@Override\npublic BigInteger getSequence() {\n    return sequence;\n}",
                "name": "getSequence",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\")\n    @Hidden\n    @Override\n    public",
                "return_type": "BigInteger",
                "parameters": [],
                "body": "{\n    return sequence;\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 161,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setSequence(final BigInteger sequence) {\n    this.sequence = sequence;\n}",
                "name": "setSequence",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigInteger"
                    }
                ],
                "body": "{\n    this.sequence = sequence;\n}",
                "start_point": {
                    "row": 163,
                    "column": 4
                },
                "end_point": {
                    "row": 166,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic LeaseTerm findTermWithSequence(final BigInteger sequence) {\n    // for (LeaseTerm term : getTerms()) {\n    // if (sequence.equals(term.getSequence())) {\n    // return term;\n    // }\n    // }\n    // return null;\n    // TODO: the code above proved to be very unreliable when using the api.\n    // Have to investigate further\n    return leaseTerms.findLeaseTermByLeaseItemAndSequence(this, sequence);\n}",
                "name": "findTermWithSequence",
                "modifiers": "@Programmatic\n    public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigInteger"
                    }
                ],
                "body": "{\n    // for (LeaseTerm term : getTerms()) {\n    // if (sequence.equals(term.getSequence())) {\n    // return term;\n    // }\n    // }\n    // return null;\n    // TODO: the code above proved to be very unreliable when using the api.\n    // Have to investigate further\n    return leaseTerms.findLeaseTermByLeaseItemAndSequence(this, sequence);\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 179,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Persistent(defaultFetchGroup = \"true\")\n@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.TYPE_ENUM)\n@Title(sequence = \"2\")\npublic LeaseItemType getType() {\n    return type;\n}",
                "name": "getType",
                "modifiers": "@javax.jdo.annotations.Persistent(defaultFetchGroup = \"true\")\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.TYPE_ENUM)\n    @Title(sequence = \"2\")\n    public",
                "return_type": "LeaseItemType",
                "parameters": [],
                "body": "{\n    return type;\n}",
                "start_point": {
                    "row": 185,
                    "column": 4
                },
                "end_point": {
                    "row": 190,
                    "column": 5
                }
            },
            {
                "definition": "public void setType(final LeaseItemType type) {\n    this.type = type;\n}",
                "name": "setType",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseItemType"
                    }
                ],
                "body": "{\n    this.type = type;\n}",
                "start_point": {
                    "row": 192,
                    "column": 4
                },
                "end_point": {
                    "row": 194,
                    "column": 5
                }
            },
            {
                "definition": "@Optional\n@Disabled\n@Override\npublic LocalDate getStartDate() {\n    return startDate;\n}",
                "name": "getStartDate",
                "modifiers": "@Optional\n    @Disabled\n    @Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return startDate;\n}",
                "start_point": {
                    "row": 201,
                    "column": 4
                },
                "end_point": {
                    "row": 206,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setStartDate(final LocalDate startDate) {\n    this.startDate = startDate;\n}",
                "name": "setStartDate",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.startDate = startDate;\n}",
                "start_point": {
                    "row": 208,
                    "column": 4
                },
                "end_point": {
                    "row": 211,
                    "column": 5
                }
            },
            {
                "definition": "@Hidden(where = Where.PARENTED_TABLES)\n@Optional\n@Disabled\npublic LocalDate getEndDate() {\n    return endDate;\n}",
                "name": "getEndDate",
                "modifiers": "@Hidden(where = Where.PARENTED_TABLES)\n    @Optional\n    @Disabled\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return endDate;\n}",
                "start_point": {
                    "row": 216,
                    "column": 4
                },
                "end_point": {
                    "row": 221,
                    "column": 5
                }
            },
            {
                "definition": "public void setEndDate(final LocalDate endDate) {\n    this.endDate = endDate;\n}",
                "name": "setEndDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.endDate = endDate;\n}",
                "start_point": {
                    "row": 223,
                    "column": 4
                },
                "end_point": {
                    "row": 225,
                    "column": 5
                }
            },
            {
                "definition": "WithIntervalMutable.Helper<LeaseItem> getChangeDates() {\n    return changeDates;\n}",
                "name": "getChangeDates",
                "modifiers": null,
                "return_type": null,
                "parameters": [],
                "body": "{\n    return changeDates;\n}",
                "start_point": {
                    "row": 231,
                    "column": 4
                },
                "end_point": {
                    "row": 233,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\n@Override\npublic LeaseItem changeDates(\n        final @Named(\"Start Date\") @Optional LocalDate startDate,\n        final @Named(\"End Date\") @Optional LocalDate endDate) {\n    return getChangeDates().changeDates(startDate, endDate);\n}",
                "name": "changeDates",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    @Override\n    public",
                "return_type": "LeaseItem",
                "parameters": [
                    {
                        "type": "final @Named(\"Start Date\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"End Date\") @Optional",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return getChangeDates().changeDates(startDate, endDate);\n}",
                "start_point": {
                    "row": 235,
                    "column": 4
                },
                "end_point": {
                    "row": 241,
                    "column": 5
                }
            },
            {
                "definition": "public String disableChangeDates(\n        final LocalDate startDate,\n        final LocalDate endDate) {\n    return null;\n}",
                "name": "disableChangeDates",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 243,
                    "column": 4
                },
                "end_point": {
                    "row": 247,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic LocalDate default0ChangeDates() {\n    return getChangeDates().default0ChangeDates();\n}",
                "name": "default0ChangeDates",
                "modifiers": "@Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return getChangeDates().default0ChangeDates();\n}",
                "start_point": {
                    "row": 249,
                    "column": 4
                },
                "end_point": {
                    "row": 252,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic LocalDate default1ChangeDates() {\n    return getChangeDates().default1ChangeDates();\n}",
                "name": "default1ChangeDates",
                "modifiers": "@Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return getChangeDates().default1ChangeDates();\n}",
                "start_point": {
                    "row": 254,
                    "column": 4
                },
                "end_point": {
                    "row": 257,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String validateChangeDates(\n        final LocalDate startDate,\n        final LocalDate endDate) {\n    return getChangeDates().validateChangeDates(startDate, endDate);\n}",
                "name": "validateChangeDates",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return getChangeDates().validateChangeDates(startDate, endDate);\n}",
                "start_point": {
                    "row": 259,
                    "column": 4
                },
                "end_point": {
                    "row": 264,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\n@Override\npublic LocalDateInterval getInterval() {\n    return LocalDateInterval.including(getStartDate(), getEndDate());\n}",
                "name": "getInterval",
                "modifiers": "@Programmatic\n    @Override\n    public",
                "return_type": "LocalDateInterval",
                "parameters": [],
                "body": "{\n    return LocalDateInterval.including(getStartDate(), getEndDate());\n}",
                "start_point": {
                    "row": 268,
                    "column": 4
                },
                "end_point": {
                    "row": 272,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\n@Override\npublic LocalDateInterval getEffectiveInterval() {\n    return getInterval().overlap(getLease().getEffectiveInterval());\n}",
                "name": "getEffectiveInterval",
                "modifiers": "@Programmatic\n    @Override\n    public",
                "return_type": "LocalDateInterval",
                "parameters": [],
                "body": "{\n    return getInterval().overlap(getLease().getEffectiveInterval());\n}",
                "start_point": {
                    "row": 274,
                    "column": 4
                },
                "end_point": {
                    "row": 278,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isCurrent() {\n    return isActiveOn(getClockService().now());\n}",
                "name": "isCurrent",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return isActiveOn(getClockService().now());\n}",
                "start_point": {
                    "row": 282,
                    "column": 4
                },
                "end_point": {
                    "row": 284,
                    "column": 5
                }
            },
            {
                "definition": "private boolean isActiveOn(final LocalDate localDate) {\n    return getEffectiveInterval().contains(localDate);\n}",
                "name": "isActiveOn",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return getEffectiveInterval().contains(localDate);\n}",
                "start_point": {
                    "row": 286,
                    "column": 4
                },
                "end_point": {
                    "row": 288,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.INVOICING_FREQUENCY_ENUM)\n@Hidden(where = Where.PARENTED_TABLES)\npublic InvoicingFrequency getInvoicingFrequency() {\n    return invoicingFrequency;\n}",
                "name": "getInvoicingFrequency",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.INVOICING_FREQUENCY_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    public",
                "return_type": "InvoicingFrequency",
                "parameters": [],
                "body": "{\n    return invoicingFrequency;\n}",
                "start_point": {
                    "row": 294,
                    "column": 4
                },
                "end_point": {
                    "row": 298,
                    "column": 5
                }
            },
            {
                "definition": "public void setInvoicingFrequency(final InvoicingFrequency invoicingFrequency) {\n    this.invoicingFrequency = invoicingFrequency;\n}",
                "name": "setInvoicingFrequency",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoicingFrequency"
                    }
                ],
                "body": "{\n    this.invoicingFrequency = invoicingFrequency;\n}",
                "start_point": {
                    "row": 300,
                    "column": 4
                },
                "end_point": {
                    "row": 302,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n@Hidden(where = Where.PARENTED_TABLES)\npublic PaymentMethod getPaymentMethod() {\n    return paymentMethod;\n}",
                "name": "getPaymentMethod",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.PAYMENT_METHOD_ENUM)\n    @Hidden(where = Where.PARENTED_TABLES)\n    public",
                "return_type": "PaymentMethod",
                "parameters": [],
                "body": "{\n    return paymentMethod;\n}",
                "start_point": {
                    "row": 308,
                    "column": 4
                },
                "end_point": {
                    "row": 312,
                    "column": 5
                }
            },
            {
                "definition": "public void setPaymentMethod(final PaymentMethod paymentMethod) {\n    this.paymentMethod = paymentMethod;\n}",
                "name": "setPaymentMethod",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "PaymentMethod"
                    }
                ],
                "body": "{\n    this.paymentMethod = paymentMethod;\n}",
                "start_point": {
                    "row": 314,
                    "column": 4
                },
                "end_point": {
                    "row": 316,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(name = \"chargeId\", allowsNull = \"false\")\npublic Charge getCharge() {\n    return charge;\n}",
                "name": "getCharge",
                "modifiers": "@javax.jdo.annotations.Column(name = \"chargeId\", allowsNull = \"false\")\n    public",
                "return_type": "Charge",
                "parameters": [],
                "body": "{\n    return charge;\n}",
                "start_point": {
                    "row": 322,
                    "column": 4
                },
                "end_point": {
                    "row": 325,
                    "column": 5
                }
            },
            {
                "definition": "public void setCharge(final Charge charge) {\n    this.charge = charge;\n}",
                "name": "setCharge",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Charge"
                    }
                ],
                "body": "{\n    this.charge = charge;\n}",
                "start_point": {
                    "row": 327,
                    "column": 4
                },
                "end_point": {
                    "row": 329,
                    "column": 5
                }
            },
            {
                "definition": "public List<Charge> choicesCharge() {\n    return charges.allCharges();\n}",
                "name": "choicesCharge",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return charges.allCharges();\n}",
                "start_point": {
                    "row": 331,
                    "column": 4
                },
                "end_point": {
                    "row": 333,
                    "column": 5
                }
            },
            {
                "definition": "@Disabled\n@Optional\npublic BigDecimal getTrialValue() {\n    final LeaseTerm currentTerm = currentTerm(getClockService().now());\n    return currentTerm != null ? currentTerm.getTrialValue() : null;\n}",
                "name": "getTrialValue",
                "modifiers": "@Disabled\n    @Optional\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    final LeaseTerm currentTerm = currentTerm(getClockService().now());\n    return currentTerm != null ? currentTerm.getTrialValue() : null;\n}",
                "start_point": {
                    "row": 337,
                    "column": 4
                },
                "end_point": {
                    "row": 342,
                    "column": 5
                }
            },
            {
                "definition": "@Disabled\n@Optional\npublic BigDecimal getApprovedValue() {\n    LeaseTerm currentTerm = currentTerm(getClockService().now());\n    return currentTerm != null ? currentTerm.getApprovedValue() : null;\n}",
                "name": "getApprovedValue",
                "modifiers": "@Disabled\n    @Optional\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    LeaseTerm currentTerm = currentTerm(getClockService().now());\n    return currentTerm != null ? currentTerm.getApprovedValue() : null;\n}",
                "start_point": {
                    "row": 346,
                    "column": 4
                },
                "end_point": {
                    "row": 351,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic LeaseTerm currentTerm(final LocalDate date) {\n    for (LeaseTerm term : getTerms()) {\n        if (term.isActiveOn(date)) {\n            return term;\n        }\n    }\n    return null;\n}",
                "name": "currentTerm",
                "modifiers": "@Programmatic\n    public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    for (LeaseTerm term : getTerms()) {\n        if (term.isActiveOn(date)) {\n            return term;\n        }\n    }\n    return null;\n}",
                "start_point": {
                    "row": 355,
                    "column": 4
                },
                "end_point": {
                    "row": 363,
                    "column": 5
                }
            },
            {
                "definition": "@Render(Type.EAGERLY)\n@Paged(PAGE_SIZE)\npublic SortedSet<LeaseTerm> getTerms() {\n    return terms;\n}",
                "name": "getTerms",
                "modifiers": "@Render(Type.EAGERLY)\n    @Paged(PAGE_SIZE)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return terms;\n}",
                "start_point": {
                    "row": 370,
                    "column": 4
                },
                "end_point": {
                    "row": 374,
                    "column": 5
                }
            },
            {
                "definition": "public void setTerms(final SortedSet<LeaseTerm> terms) {\n    this.terms = terms;\n}",
                "name": "setTerms",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "SortedSet<LeaseTerm>"
                    }
                ],
                "body": "{\n    this.terms = terms;\n}",
                "start_point": {
                    "row": 376,
                    "column": 4
                },
                "end_point": {
                    "row": 378,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic LeaseTerm findTerm(final LocalDate startDate) {\n    for (LeaseTerm term : getTerms()) {\n        if (startDate.equals(term.getStartDate())) {\n            return term;\n        }\n    }\n    return null;\n}",
                "name": "findTerm",
                "modifiers": "@Programmatic\n    public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    for (LeaseTerm term : getTerms()) {\n        if (startDate.equals(term.getStartDate())) {\n            return term;\n        }\n    }\n    return null;\n}",
                "start_point": {
                    "row": 380,
                    "column": 4
                },
                "end_point": {
                    "row": 388,
                    "column": 5
                }
            },
            {
                "definition": "public LeaseTerm newTerm(\n        final @Named(\"Start date\") LocalDate startDate) {\n    LeaseTerm lastTerm = getTerms().size() > 0 ? getTerms().last() : null;\n    LeaseTerm term = leaseTerms.newLeaseTerm(this, lastTerm, startDate);\n    term.initialize();\n    return term;\n}",
                "name": "newTerm",
                "modifiers": "public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final @Named(\"Start date\")",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    LeaseTerm lastTerm = getTerms().size() > 0 ? getTerms().last() : null;\n    LeaseTerm term = leaseTerms.newLeaseTerm(this, lastTerm, startDate);\n    term.initialize();\n    return term;\n}",
                "start_point": {
                    "row": 392,
                    "column": 4
                },
                "end_point": {
                    "row": 398,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate default0NewTerm() {\n    LeaseTerm last = null;\n    try {\n        last = getTerms().last();\n    } catch (NoSuchElementException e) {\n        return getStartDate();\n    }\n    if (last.getEndDate() != null) {\n        return last.getInterval().endDateExcluding();\n    }\n    return last.getStartDate().plusYears(1).withMonthOfYear(1).withDayOfMonth(1);\n}",
                "name": "default0NewTerm",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    LeaseTerm last = null;\n    try {\n        last = getTerms().last();\n    } catch (NoSuchElementException e) {\n        return getStartDate();\n    }\n    if (last.getEndDate() != null) {\n        return last.getInterval().endDateExcluding();\n    }\n    return last.getStartDate().plusYears(1).withMonthOfYear(1).withDayOfMonth(1);\n}",
                "start_point": {
                    "row": 400,
                    "column": 4
                },
                "end_point": {
                    "row": 411,
                    "column": 5
                }
            },
            {
                "definition": "public LeaseItem verify() {\n    verifyUntil(getClockService().now());\n    return this;\n}",
                "name": "verify",
                "modifiers": "public",
                "return_type": "LeaseItem",
                "parameters": [],
                "body": "{\n    verifyUntil(getClockService().now());\n    return this;\n}",
                "start_point": {
                    "row": 415,
                    "column": 4
                },
                "end_point": {
                    "row": 418,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic void verifyUntil(final LocalDate date) {\n    for (LeaseTerm term : getTerms()) {\n        if (term.getPrevious() == null) {\n            // since verify is recursive on terms only start on the main\n            // term\n            term.verifyUntil(date);\n        }\n    }\n}",
                "name": "verifyUntil",
                "modifiers": "@Programmatic\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    for (LeaseTerm term : getTerms()) {\n        if (term.getPrevious() == null) {\n            // since verify is recursive on terms only start on the main\n            // term\n            term.verifyUntil(date);\n        }\n    }\n}",
                "start_point": {
                    "row": 420,
                    "column": 4
                },
                "end_point": {
                    "row": 429,
                    "column": 5
                }
            },
            {
                "definition": "public LeaseItem calculate(\n        final @Named(\"Period start Date\") LocalDate startDate,\n        final @Named(\"Period end date\") @Optional LocalDate endDate,\n        final @Named(\"Due date\") LocalDate dueDate,\n        final @Named(\"Run Type\") InvoiceRunType runType) {\n    for (LeaseTerm term : getTerms()) {\n        term.calculate(startDate, endDate, dueDate, runType);\n    }\n    return this;\n}",
                "name": "calculate",
                "modifiers": "public",
                "return_type": "LeaseItem",
                "parameters": [
                    {
                        "type": "final @Named(\"Period start Date\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"Period end date\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"Due date\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"Run Type\")",
                        "name": "InvoiceRunType"
                    }
                ],
                "body": "{\n    for (LeaseTerm term : getTerms()) {\n        term.calculate(startDate, endDate, dueDate, runType);\n    }\n    return this;\n}",
                "start_point": {
                    "row": 433,
                    "column": 4
                },
                "end_point": {
                    "row": 442,
                    "column": 5
                }
            },
            {
                "definition": "BigDecimal valueForPeriod(\n        final InvoicingFrequency frequency,\n        final LocalDate periodStartDate,\n        final LocalDate dueDate) {\n    BigDecimal total = new BigDecimal(0);\n    for (LeaseTerm term : getTerms()) {\n        total = total.add(term.valueForPeriod(periodStartDate, dueDate, frequency));\n    }\n    return total;\n}",
                "name": "valueForPeriod",
                "modifiers": null,
                "return_type": "BigDecimal",
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoicingFrequency"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    BigDecimal total = new BigDecimal(0);\n    for (LeaseTerm term : getTerms()) {\n        total = total.add(term.valueForPeriod(periodStartDate, dueDate, frequency));\n    }\n    return total;\n}",
                "start_point": {
                    "row": 446,
                    "column": 4
                },
                "end_point": {
                    "row": 455,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectCharges(final Charges charges) {\n    this.charges = charges;\n}",
                "name": "injectCharges",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Charges"
                    }
                ],
                "body": "{\n    this.charges = charges;\n}",
                "start_point": {
                    "row": 461,
                    "column": 4
                },
                "end_point": {
                    "row": 463,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectLeaseTerms(final LeaseTerms leaseTerms) {\n    this.leaseTerms = leaseTerms;\n}",
                "name": "injectLeaseTerms",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerms"
                    }
                ],
                "body": "{\n    this.leaseTerms = leaseTerms;\n}",
                "start_point": {
                    "row": 467,
                    "column": 4
                },
                "end_point": {
                    "row": 469,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dom/src/main/java/org/estatio/dom/lease/LeaseTerm.java",
        "definition": "@javax.jdo.annotations.PersistenceCapable(identityType = IdentityType.DATASTORE)\n@javax.jdo.annotations.Inheritance(strategy = InheritanceStrategy.NEW_TABLE)\n@javax.jdo.annotations.DatastoreIdentity(\n        strategy = IdGeneratorStrategy.IDENTITY,\n        column = \"id\")\n@javax.jdo.annotations.Version(\n        strategy = VersionStrategy.VERSION_NUMBER,\n        column = \"version\")\n@javax.jdo.annotations.Discriminator(\n        strategy = DiscriminatorStrategy.CLASS_NAME,\n        column = \"discriminator\")\n@javax.jdo.annotations.Indices({\n        @javax.jdo.annotations.Index(\n                name = \"LeaseTerm_leaseItem_startDate_IDX\",\n                members = { \"leaseItem\", \"startDate\" }) })\n@javax.jdo.annotations.Queries({\n        @javax.jdo.annotations.Query(\n                name = \"findByStatusAndActiveDate\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE status == :status \"\n                        + \"   && startDate <= :date \"\n                        + \"   && (endDate == null || endDate >= :date)\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseItemAndSequence\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE leaseItem == :leaseItem \"\n                        + \"   && sequence == :sequence\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseItemAndStartDate\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE leaseItem == :leaseItem \"\n                        + \"   && startDate == :startDate\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseItemAndEndDate\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE leaseItem == :leaseItem \"\n                        + \"   && endDate == :endDate\")\n})\n@Bookmarkable(BookmarkPolicy.AS_CHILD)\npublic abstract class LeaseTerm\n        extends EstatioMutableObject<LeaseTerm>\n        implements WithIntervalMutable<LeaseTerm>, Chained<LeaseTerm>, WithSequence {\n\n    public LeaseTerm() {\n        // TODO: the integration tests fail if this is made DESCending.\n        super(\"leaseItem, sequence, startDate\");\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LeaseItem leaseItem;\n\n    @javax.jdo.annotations.Column(name = \"leaseItemId\", allowsNull = \"false\")\n    @Hidden(where = Where.REFERENCES_PARENT)\n    @Disabled\n    @Title(sequence = \"1\", append = \":\")\n    public LeaseItem getLeaseItem() {\n        return leaseItem;\n    }\n\n    public void setLeaseItem(final LeaseItem leaseItem) {\n        this.leaseItem = leaseItem;\n    }\n\n    // //////////////////////////////////////\n\n    private BigInteger sequence;\n\n    @Hidden\n    @Optional\n    public BigInteger getSequence() {\n        return sequence;\n    }\n\n    public void setSequence(final BigInteger sequence) {\n        this.sequence = sequence;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate startDate;\n\n    @Title(sequence = \"2\", append = \"-\")\n    @Optional\n    @Disabled\n    @Override\n    public LocalDate getStartDate() {\n        return startDate;\n    }\n\n    @Override\n    public void setStartDate(final LocalDate startDate) {\n        this.startDate = startDate;\n    }\n\n    public void modifyStartDate(final LocalDate startDate) {\n        LocalDate currentStartDate = getStartDate();\n        if (startDate != null && !startDate.equals(currentStartDate)) {\n            setStartDate(startDate);\n        }\n        if (getPrevious() != null) {\n            getPrevious().modifyEndDate(getInterval().endDateFromStartDate());\n        }\n    }\n\n    public void clearStartDate() {\n        LocalDate currentStartDate = getStartDate();\n        if (currentStartDate == null) {\n            return;\n        }\n        setStartDate(null);\n        // TODO: shouldn't there be some logic reciprocal to that in\n        // modifyStartDate ?\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate endDate;\n\n    @Title(sequence = \"3\")\n    @Disabled\n    @Optional\n    public LocalDate getEndDate() {\n        return endDate;\n    }\n\n    public void setEndDate(final LocalDate endDate) {\n        this.endDate = endDate;\n    }\n\n    public void modifyEndDate(final LocalDate endDate) {\n        LocalDate currentEndDate = getEndDate();\n        if (endDate == null && currentEndDate == null || endDate.equals(currentEndDate)) {\n            return;\n        }\n        setEndDate(endDate);\n    }\n\n    public void clearEndDate() {\n        LocalDate currentEndDate = getEndDate();\n        if (currentEndDate == null) {\n            return;\n        }\n        setEndDate(null);\n    }\n\n    // //////////////////////////////////////\n\n    private WithIntervalMutable.Helper<LeaseTerm> changeDates = new WithIntervalMutable.Helper<LeaseTerm>(this);\n\n    WithIntervalMutable.Helper<LeaseTerm> getChangeDates() {\n        return changeDates;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    @Override\n    public LeaseTerm changeDates(\n            final @Named(\"Start Date\") @Optional LocalDate startDate,\n            final @Named(\"End Date\") @Optional LocalDate endDate) {\n        return getChangeDates().changeDates(startDate, endDate);\n    }\n\n    public String disableChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return null;\n    }\n\n    @Override\n    public LocalDate default0ChangeDates() {\n        return getChangeDates().default0ChangeDates();\n    }\n\n    @Override\n    public LocalDate default1ChangeDates() {\n        return getChangeDates().default1ChangeDates();\n    }\n\n    @Override\n    public String validateChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return getChangeDates().validateChangeDates(startDate, endDate);\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    @Override\n    public LocalDateInterval getInterval() {\n        return LocalDateInterval.including(getStartDate(), getEndDate());\n    }\n\n    @Programmatic\n    public LocalDateInterval getEffectiveInterval() {\n        return getInterval().overlap(getLeaseItem().getEffectiveInterval());\n    }\n\n    // //////////////////////////////////////\n\n    public boolean isCurrent() {\n        return isActiveOn(getClockService().now());\n    }\n\n    @Programmatic\n    public boolean isActiveOn(final LocalDate localDate) {\n        LocalDateInterval effectiveInterval = getEffectiveInterval();\n        if (effectiveInterval == null) {\n            return false;\n        }\n        return effectiveInterval.contains(localDate);\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseTermStatus status;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Disabled\n    public LeaseTermStatus getStatus() {\n        return status;\n    }\n\n    public void setStatus(final LeaseTermStatus status) {\n        this.status = status;\n    }\n\n    public void created() {\n        setStatus(LeaseTermStatus.NEW);\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseTermFrequency frequency;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.LEASE_TERM_FREQUENCY_ENUM)\n    public LeaseTermFrequency getFrequency() {\n        return frequency;\n    }\n\n    public void setFrequency(final LeaseTermFrequency frequency) {\n        this.frequency = frequency;\n    }\n\n    // //////////////////////////////////////\n\n    public BigDecimal getTrialValue() {\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    public BigDecimal getApprovedValue() {\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Column(name = \"previousLeaseTermId\")\n    @javax.jdo.annotations.Persistent(mappedBy = \"next\")\n    private LeaseTerm previous;\n\n    @Named(\"Previous Term\")\n    @Hidden(where = Where.ALL_TABLES)\n    @Optional\n    @Override\n    public LeaseTerm getPrevious() {\n        return previous;\n    }\n\n    public void setPrevious(final LeaseTerm previous) {\n        this.previous = previous;\n    }\n\n    public void modifyPrevious(final LeaseTerm previous) {\n        LeaseTerm currentPrevious = getPrevious();\n        if (previous == null || previous.equals(currentPrevious)) {\n            return;\n        }\n        clearPrevious();\n        previous.setNext(this);\n        setPrevious(previous);\n    }\n\n    public void clearPrevious() {\n        LeaseTerm currentPrevious = getPrevious();\n        if (currentPrevious == null) {\n            return;\n        }\n        currentPrevious.setNext(null);\n        setPrevious(null);\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Column(name = \"nextLeaseTermId\")\n    private LeaseTerm next;\n\n    @Hidden(where = Where.ALL_TABLES)\n    @Named(\"Next Term\")\n    @Optional\n    @Override\n    public LeaseTerm getNext() {\n        return next;\n    }\n\n    public void setNext(final LeaseTerm next) {\n        this.next = next;\n    }\n\n    public void modifyNext(final LeaseTerm next) {\n        LeaseTerm currentNext = getNext();\n        if (next == null || next.equals(currentNext)) {\n            return;\n        }\n        if (currentNext != null) {\n            currentNext.clearPrevious();\n        }\n        next.modifyPrevious(this);\n    }\n\n    public void clearNext() {\n        LeaseTerm currentNext = getNext();\n        if (currentNext == null) {\n            return;\n        }\n        currentNext.clearPrevious();\n    }\n\n    // //////////////////////////////////////\n\n    @Persistent(mappedBy = \"leaseTerm\")\n    private SortedSet<InvoiceItemForLease> invoiceItems = new TreeSet<InvoiceItemForLease>();\n\n    @Render(Type.EAGERLY)\n    public SortedSet<InvoiceItemForLease> getInvoiceItems() {\n        return invoiceItems;\n    }\n\n    public void setInvoiceItems(final SortedSet<InvoiceItemForLease> invoiceItems) {\n        this.invoiceItems = invoiceItems;\n    }\n\n    public void addToInvoiceItems(final InvoiceItemForLease invoiceItem) {\n        if (invoiceItem == null || getInvoiceItems().contains(invoiceItem)) {\n            return;\n        }\n        invoiceItem.clearLeaseTerm();\n        invoiceItem.setLeaseTerm(this);\n        getInvoiceItems().add(invoiceItem);\n    }\n\n    public void removeFromInvoiceItems(final InvoiceItemForLease invoiceItem) {\n        if (invoiceItem == null || !getInvoiceItems().contains(invoiceItem)) {\n            return;\n        }\n        invoiceItem.setLeaseTerm(null);\n        getInvoiceItems().remove(invoiceItem);\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    @Prototype\n    public void remove() {\n        if (getNext() != null) {\n            getNext().remove();\n        }\n        if (this.getInvoiceItems().size() == 0) {\n            // CHECKSTYLE.OFF: \n            // TODO: Disabled, see EST-273\n            // this.modifyPrevious(null);\n            // getContainer().remove(this);\n            // CHECKSTYLE.ON: \n        }\n    }\n\n    @Programmatic\n    public void removeUnapprovedInvoiceItemsForDate(final LocalDate startDate, final LocalDate dueDate) {\n        for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n            Invoice invoice = invoiceItem.getInvoice();\n            if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                    startDate.equals(invoiceItem.getStartDate()) &&\n                    dueDate.equals(invoiceItem.getDueDate())) {\n                invoiceItem.setInvoice(null);\n                invoiceItem.clearLeaseTerm();\n                getContainer().flush();\n                remove(invoiceItem);\n            }\n        }\n    }\n\n    @Programmatic\n    public InvoiceItemForLease findOrCreateUnapprovedInvoiceItemFor(\n            final LocalDate startDate,\n            final LocalDate dueDate) {\n        InvoiceItemForLease ii = findUnapprovedInvoiceItemFor(startDate, dueDate);\n        if (ii == null) {\n            ii = invoiceItemsForLease.newInvoiceItem(this, startDate, dueDate);\n        }\n        return ii;\n    }\n\n    @Programmatic\n    public InvoiceItemForLease findUnapprovedInvoiceItemFor(\n            final LocalDate startDate,\n            final LocalDate dueDate) {\n        for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n            Invoice invoice = invoiceItem.getInvoice();\n            if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                    this.equals(invoiceItem.getLeaseTerm()) &&\n                    startDate.equals(invoiceItem.getStartDate()) &&\n                    dueDate.equals(invoiceItem.getDueDate())) {\n                return invoiceItem;\n            }\n        }\n        return null;\n    }\n\n    @Programmatic\n    public BigDecimal invoicedValueFor(final LocalDate startDate) {\n        BigDecimal invoicedValue = new BigDecimal(0);\n        for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n            Invoice invoice = invoiceItem.getInvoice();\n            if (invoice == null || invoice.getStatus() == InvoiceStatus.NEW ||\n                    invoiceItem.getStartDate() == null ||\n                    invoiceItem.getStartDate().compareTo(startDate) != 0) {\n                continue;\n            }\n            invoicedValue = invoicedValue.add(invoiceItem.getNetAmount());\n        }\n        return invoicedValue;\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public LeaseTerm calculate(\n            final @Named(\"Period Start Date\") LocalDate startDate,\n            final @Named(\"Due Date\") LocalDate dueDate) {\n        return calculate(startDate, null, dueDate, InvoiceRunType.NORMAL_RUN);\n    }\n\n    public LeaseTerm calculate(\n            final @Named(\"Period start Date\") LocalDate startDate,\n            final @Named(\"Period end Date\") @Optional LocalDate endDate,\n            final @Named(\"Due Date\") LocalDate dueDate,\n            final @Named(\"Run Type\") InvoiceRunType runType) {\n        invoiceCalculationService.calculateAndInvoice(\n                this, startDate, endDate, dueDate, getLeaseItem().getInvoicingFrequency(), runType);\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public LeaseTerm verify() {\n        verifyUntil(getClockService().now());\n        return this;\n    }\n\n    @Programmatic\n    public void verifyUntil(final LocalDate date) {\n        update();\n        // convenience code to automatically create terms but not for terms who\n        // have a start date after today\n        LeaseTerm nextTerm = getNext();\n        if (nextTerm == null && getNextStartDate().compareTo(date) <= 0) {\n            nextTerm = createNext(getNextStartDate());\n        }\n        if (nextTerm != null) {\n            nextTerm.verifyUntil(date);\n        }\n    }\n\n    private LocalDate getNextStartDate() {\n        LocalDate nextStartDate = getInterval().endDateExcluding();\n        if (nextStartDate == null) {\n            return getFrequency().nextDate(getStartDate());\n        }\n        return nextStartDate;\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseTerm createNext(\n            final @Named(\"Start date\") LocalDate nextStartDate) {\n        LeaseTerm nextTerm = getNext();\n        if (nextTerm != null) {\n            return nextTerm;\n        }\n        // Don't create terms after termination date\n        LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n        if (terminationDate != null &&\n                terminationDate.isBefore(nextStartDate)) {\n            return null;\n        }\n        // Ok, we need to create a term\n        nextTerm = terms.newLeaseTerm(getLeaseItem(), this, nextStartDate);\n        nextTerm.initialize();\n        nextTerm.modifyStartDate(nextStartDate);\n        nextTerm.update();\n        return nextTerm;\n    }\n\n    // //////////////////////////////////////\n\n    protected void initialize() {\n        setStatus(LeaseTermStatus.NEW);\n        LeaseTerm previousTerm = getPrevious();\n        BigInteger sequence = BigInteger.ONE;\n        if (previousTerm != null) {\n            sequence = previousTerm.getSequence().add(BigInteger.ONE);\n            setFrequency(previousTerm.getFrequency());\n        }\n        setSequence(sequence);\n    }\n\n    @Programmatic\n    protected void update() {\n        // terminate the last term\n        LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n        if (terminationDate != null && getNext() == null) {\n            if (getEndDate() == null || getEndDate().compareTo(terminationDate) > 0) {\n                setEndDate(terminationDate);\n            }\n        }\n        // Get the end date from the next start date\n        if (getEndDate() == null && getNext() != null) {\n            modifyEndDate(getNext().getInterval().endDateFromStartDate());\n        }\n\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public void copyValuesTo(final LeaseTerm target) {\n        target.setStartDate(getStartDate());\n        target.setEndDate(getEndDate());\n        target.setStatus(getStatus());\n        target.setFrequency(getFrequency());\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    @ActionSemantics(Of.IDEMPOTENT)\n    public LeaseTerm approve() {\n        if (!getStatus().isApproved()) {\n            setStatus(LeaseTermStatus.APPROVED);\n        }\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public BigDecimal valueForDate(final LocalDate dueDate) {\n        return getTrialValue();\n    }\n\n    @Programmatic\n    BigDecimal valueForPeriod(\n            final LocalDate periodStartDate,\n            final LocalDate dueDate,\n            final InvoicingFrequency frequency) {\n        return invoiceCalculationService.calculateSumForAllPeriods(this, periodStartDate, dueDate, frequency);\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    public String toString() {\n        return getInterval().toString() + \" / \";\n    }\n\n    // //////////////////////////////////////\n\n    private InvoiceItemsForLease invoiceItemsForLease;\n\n    public final void injectInvoiceItemsForLease(final InvoiceItemsForLease invoiceItemsForLease) {\n        this.invoiceItemsForLease = invoiceItemsForLease;\n    }\n\n    private InvoiceCalculationService invoiceCalculationService;\n\n    public final void injectInvoiceCalculationService(final InvoiceCalculationService invoiceCalculationService) {\n        this.invoiceCalculationService = invoiceCalculationService;\n    }\n\n    private LeaseTerms terms;\n\n    public final void injectLeaseTerms(final LeaseTerms terms) {\n        this.terms = terms;\n    }\n\n}",
        "package": "package org.estatio.dom.lease;",
        "tree_path": "LeaseTerm",
        "name": "LeaseTerm",
        "modifiers": "@javax.jdo.annotations.PersistenceCapable(identityType = IdentityType.DATASTORE)\n@javax.jdo.annotations.Inheritance(strategy = InheritanceStrategy.NEW_TABLE)\n@javax.jdo.annotations.DatastoreIdentity(\n        strategy = IdGeneratorStrategy.IDENTITY,\n        column = \"id\")\n@javax.jdo.annotations.Version(\n        strategy = VersionStrategy.VERSION_NUMBER,\n        column = \"version\")\n@javax.jdo.annotations.Discriminator(\n        strategy = DiscriminatorStrategy.CLASS_NAME,\n        column = \"discriminator\")\n@javax.jdo.annotations.Indices({\n        @javax.jdo.annotations.Index(\n                name = \"LeaseTerm_leaseItem_startDate_IDX\",\n                members = { \"leaseItem\", \"startDate\" }) })\n@javax.jdo.annotations.Queries({\n        @javax.jdo.annotations.Query(\n                name = \"findByStatusAndActiveDate\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE status == :status \"\n                        + \"   && startDate <= :date \"\n                        + \"   && (endDate == null || endDate >= :date)\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseItemAndSequence\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE leaseItem == :leaseItem \"\n                        + \"   && sequence == :sequence\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseItemAndStartDate\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE leaseItem == :leaseItem \"\n                        + \"   && startDate == :startDate\"),\n        @javax.jdo.annotations.Query(\n                name = \"findByLeaseItemAndEndDate\", language = \"JDOQL\",\n                value = \"SELECT \"\n                        + \"FROM org.estatio.dom.lease.LeaseTerm \"\n                        + \"WHERE leaseItem == :leaseItem \"\n                        + \"   && endDate == :endDate\")\n})\n@Bookmarkable(BookmarkPolicy.AS_CHILD)\npublic abstract",
        "superclass": "extends EstatioMutableObject<LeaseTerm>",
        "super_interfaces": "implements WithIntervalMutable<LeaseTerm>, Chained<LeaseTerm>, WithSequence",
        "body": "{\n\n    public LeaseTerm() {\n        // TODO: the integration tests fail if this is made DESCending.\n        super(\"leaseItem, sequence, startDate\");\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LeaseItem leaseItem;\n\n    @javax.jdo.annotations.Column(name = \"leaseItemId\", allowsNull = \"false\")\n    @Hidden(where = Where.REFERENCES_PARENT)\n    @Disabled\n    @Title(sequence = \"1\", append = \":\")\n    public LeaseItem getLeaseItem() {\n        return leaseItem;\n    }\n\n    public void setLeaseItem(final LeaseItem leaseItem) {\n        this.leaseItem = leaseItem;\n    }\n\n    // //////////////////////////////////////\n\n    private BigInteger sequence;\n\n    @Hidden\n    @Optional\n    public BigInteger getSequence() {\n        return sequence;\n    }\n\n    public void setSequence(final BigInteger sequence) {\n        this.sequence = sequence;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate startDate;\n\n    @Title(sequence = \"2\", append = \"-\")\n    @Optional\n    @Disabled\n    @Override\n    public LocalDate getStartDate() {\n        return startDate;\n    }\n\n    @Override\n    public void setStartDate(final LocalDate startDate) {\n        this.startDate = startDate;\n    }\n\n    public void modifyStartDate(final LocalDate startDate) {\n        LocalDate currentStartDate = getStartDate();\n        if (startDate != null && !startDate.equals(currentStartDate)) {\n            setStartDate(startDate);\n        }\n        if (getPrevious() != null) {\n            getPrevious().modifyEndDate(getInterval().endDateFromStartDate());\n        }\n    }\n\n    public void clearStartDate() {\n        LocalDate currentStartDate = getStartDate();\n        if (currentStartDate == null) {\n            return;\n        }\n        setStartDate(null);\n        // TODO: shouldn't there be some logic reciprocal to that in\n        // modifyStartDate ?\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate endDate;\n\n    @Title(sequence = \"3\")\n    @Disabled\n    @Optional\n    public LocalDate getEndDate() {\n        return endDate;\n    }\n\n    public void setEndDate(final LocalDate endDate) {\n        this.endDate = endDate;\n    }\n\n    public void modifyEndDate(final LocalDate endDate) {\n        LocalDate currentEndDate = getEndDate();\n        if (endDate == null && currentEndDate == null || endDate.equals(currentEndDate)) {\n            return;\n        }\n        setEndDate(endDate);\n    }\n\n    public void clearEndDate() {\n        LocalDate currentEndDate = getEndDate();\n        if (currentEndDate == null) {\n            return;\n        }\n        setEndDate(null);\n    }\n\n    // //////////////////////////////////////\n\n    private WithIntervalMutable.Helper<LeaseTerm> changeDates = new WithIntervalMutable.Helper<LeaseTerm>(this);\n\n    WithIntervalMutable.Helper<LeaseTerm> getChangeDates() {\n        return changeDates;\n    }\n\n    @ActionSemantics(Of.IDEMPOTENT)\n    @Override\n    public LeaseTerm changeDates(\n            final @Named(\"Start Date\") @Optional LocalDate startDate,\n            final @Named(\"End Date\") @Optional LocalDate endDate) {\n        return getChangeDates().changeDates(startDate, endDate);\n    }\n\n    public String disableChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return null;\n    }\n\n    @Override\n    public LocalDate default0ChangeDates() {\n        return getChangeDates().default0ChangeDates();\n    }\n\n    @Override\n    public LocalDate default1ChangeDates() {\n        return getChangeDates().default1ChangeDates();\n    }\n\n    @Override\n    public String validateChangeDates(\n            final LocalDate startDate,\n            final LocalDate endDate) {\n        return getChangeDates().validateChangeDates(startDate, endDate);\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    @Override\n    public LocalDateInterval getInterval() {\n        return LocalDateInterval.including(getStartDate(), getEndDate());\n    }\n\n    @Programmatic\n    public LocalDateInterval getEffectiveInterval() {\n        return getInterval().overlap(getLeaseItem().getEffectiveInterval());\n    }\n\n    // //////////////////////////////////////\n\n    public boolean isCurrent() {\n        return isActiveOn(getClockService().now());\n    }\n\n    @Programmatic\n    public boolean isActiveOn(final LocalDate localDate) {\n        LocalDateInterval effectiveInterval = getEffectiveInterval();\n        if (effectiveInterval == null) {\n            return false;\n        }\n        return effectiveInterval.contains(localDate);\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseTermStatus status;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Disabled\n    public LeaseTermStatus getStatus() {\n        return status;\n    }\n\n    public void setStatus(final LeaseTermStatus status) {\n        this.status = status;\n    }\n\n    public void created() {\n        setStatus(LeaseTermStatus.NEW);\n    }\n\n    // //////////////////////////////////////\n\n    private LeaseTermFrequency frequency;\n\n    @javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.LEASE_TERM_FREQUENCY_ENUM)\n    public LeaseTermFrequency getFrequency() {\n        return frequency;\n    }\n\n    public void setFrequency(final LeaseTermFrequency frequency) {\n        this.frequency = frequency;\n    }\n\n    // //////////////////////////////////////\n\n    public BigDecimal getTrialValue() {\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    public BigDecimal getApprovedValue() {\n        return null;\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Column(name = \"previousLeaseTermId\")\n    @javax.jdo.annotations.Persistent(mappedBy = \"next\")\n    private LeaseTerm previous;\n\n    @Named(\"Previous Term\")\n    @Hidden(where = Where.ALL_TABLES)\n    @Optional\n    @Override\n    public LeaseTerm getPrevious() {\n        return previous;\n    }\n\n    public void setPrevious(final LeaseTerm previous) {\n        this.previous = previous;\n    }\n\n    public void modifyPrevious(final LeaseTerm previous) {\n        LeaseTerm currentPrevious = getPrevious();\n        if (previous == null || previous.equals(currentPrevious)) {\n            return;\n        }\n        clearPrevious();\n        previous.setNext(this);\n        setPrevious(previous);\n    }\n\n    public void clearPrevious() {\n        LeaseTerm currentPrevious = getPrevious();\n        if (currentPrevious == null) {\n            return;\n        }\n        currentPrevious.setNext(null);\n        setPrevious(null);\n    }\n\n    // //////////////////////////////////////\n\n    @javax.jdo.annotations.Column(name = \"nextLeaseTermId\")\n    private LeaseTerm next;\n\n    @Hidden(where = Where.ALL_TABLES)\n    @Named(\"Next Term\")\n    @Optional\n    @Override\n    public LeaseTerm getNext() {\n        return next;\n    }\n\n    public void setNext(final LeaseTerm next) {\n        this.next = next;\n    }\n\n    public void modifyNext(final LeaseTerm next) {\n        LeaseTerm currentNext = getNext();\n        if (next == null || next.equals(currentNext)) {\n            return;\n        }\n        if (currentNext != null) {\n            currentNext.clearPrevious();\n        }\n        next.modifyPrevious(this);\n    }\n\n    public void clearNext() {\n        LeaseTerm currentNext = getNext();\n        if (currentNext == null) {\n            return;\n        }\n        currentNext.clearPrevious();\n    }\n\n    // //////////////////////////////////////\n\n    @Persistent(mappedBy = \"leaseTerm\")\n    private SortedSet<InvoiceItemForLease> invoiceItems = new TreeSet<InvoiceItemForLease>();\n\n    @Render(Type.EAGERLY)\n    public SortedSet<InvoiceItemForLease> getInvoiceItems() {\n        return invoiceItems;\n    }\n\n    public void setInvoiceItems(final SortedSet<InvoiceItemForLease> invoiceItems) {\n        this.invoiceItems = invoiceItems;\n    }\n\n    public void addToInvoiceItems(final InvoiceItemForLease invoiceItem) {\n        if (invoiceItem == null || getInvoiceItems().contains(invoiceItem)) {\n            return;\n        }\n        invoiceItem.clearLeaseTerm();\n        invoiceItem.setLeaseTerm(this);\n        getInvoiceItems().add(invoiceItem);\n    }\n\n    public void removeFromInvoiceItems(final InvoiceItemForLease invoiceItem) {\n        if (invoiceItem == null || !getInvoiceItems().contains(invoiceItem)) {\n            return;\n        }\n        invoiceItem.setLeaseTerm(null);\n        getInvoiceItems().remove(invoiceItem);\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    @Prototype\n    public void remove() {\n        if (getNext() != null) {\n            getNext().remove();\n        }\n        if (this.getInvoiceItems().size() == 0) {\n            // CHECKSTYLE.OFF: \n            // TODO: Disabled, see EST-273\n            // this.modifyPrevious(null);\n            // getContainer().remove(this);\n            // CHECKSTYLE.ON: \n        }\n    }\n\n    @Programmatic\n    public void removeUnapprovedInvoiceItemsForDate(final LocalDate startDate, final LocalDate dueDate) {\n        for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n            Invoice invoice = invoiceItem.getInvoice();\n            if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                    startDate.equals(invoiceItem.getStartDate()) &&\n                    dueDate.equals(invoiceItem.getDueDate())) {\n                invoiceItem.setInvoice(null);\n                invoiceItem.clearLeaseTerm();\n                getContainer().flush();\n                remove(invoiceItem);\n            }\n        }\n    }\n\n    @Programmatic\n    public InvoiceItemForLease findOrCreateUnapprovedInvoiceItemFor(\n            final LocalDate startDate,\n            final LocalDate dueDate) {\n        InvoiceItemForLease ii = findUnapprovedInvoiceItemFor(startDate, dueDate);\n        if (ii == null) {\n            ii = invoiceItemsForLease.newInvoiceItem(this, startDate, dueDate);\n        }\n        return ii;\n    }\n\n    @Programmatic\n    public InvoiceItemForLease findUnapprovedInvoiceItemFor(\n            final LocalDate startDate,\n            final LocalDate dueDate) {\n        for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n            Invoice invoice = invoiceItem.getInvoice();\n            if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                    this.equals(invoiceItem.getLeaseTerm()) &&\n                    startDate.equals(invoiceItem.getStartDate()) &&\n                    dueDate.equals(invoiceItem.getDueDate())) {\n                return invoiceItem;\n            }\n        }\n        return null;\n    }\n\n    @Programmatic\n    public BigDecimal invoicedValueFor(final LocalDate startDate) {\n        BigDecimal invoicedValue = new BigDecimal(0);\n        for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n            Invoice invoice = invoiceItem.getInvoice();\n            if (invoice == null || invoice.getStatus() == InvoiceStatus.NEW ||\n                    invoiceItem.getStartDate() == null ||\n                    invoiceItem.getStartDate().compareTo(startDate) != 0) {\n                continue;\n            }\n            invoicedValue = invoicedValue.add(invoiceItem.getNetAmount());\n        }\n        return invoicedValue;\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public LeaseTerm calculate(\n            final @Named(\"Period Start Date\") LocalDate startDate,\n            final @Named(\"Due Date\") LocalDate dueDate) {\n        return calculate(startDate, null, dueDate, InvoiceRunType.NORMAL_RUN);\n    }\n\n    public LeaseTerm calculate(\n            final @Named(\"Period start Date\") LocalDate startDate,\n            final @Named(\"Period end Date\") @Optional LocalDate endDate,\n            final @Named(\"Due Date\") LocalDate dueDate,\n            final @Named(\"Run Type\") InvoiceRunType runType) {\n        invoiceCalculationService.calculateAndInvoice(\n                this, startDate, endDate, dueDate, getLeaseItem().getInvoicingFrequency(), runType);\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    public LeaseTerm verify() {\n        verifyUntil(getClockService().now());\n        return this;\n    }\n\n    @Programmatic\n    public void verifyUntil(final LocalDate date) {\n        update();\n        // convenience code to automatically create terms but not for terms who\n        // have a start date after today\n        LeaseTerm nextTerm = getNext();\n        if (nextTerm == null && getNextStartDate().compareTo(date) <= 0) {\n            nextTerm = createNext(getNextStartDate());\n        }\n        if (nextTerm != null) {\n            nextTerm.verifyUntil(date);\n        }\n    }\n\n    private LocalDate getNextStartDate() {\n        LocalDate nextStartDate = getInterval().endDateExcluding();\n        if (nextStartDate == null) {\n            return getFrequency().nextDate(getStartDate());\n        }\n        return nextStartDate;\n    }\n\n    // //////////////////////////////////////\n\n    public LeaseTerm createNext(\n            final @Named(\"Start date\") LocalDate nextStartDate) {\n        LeaseTerm nextTerm = getNext();\n        if (nextTerm != null) {\n            return nextTerm;\n        }\n        // Don't create terms after termination date\n        LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n        if (terminationDate != null &&\n                terminationDate.isBefore(nextStartDate)) {\n            return null;\n        }\n        // Ok, we need to create a term\n        nextTerm = terms.newLeaseTerm(getLeaseItem(), this, nextStartDate);\n        nextTerm.initialize();\n        nextTerm.modifyStartDate(nextStartDate);\n        nextTerm.update();\n        return nextTerm;\n    }\n\n    // //////////////////////////////////////\n\n    protected void initialize() {\n        setStatus(LeaseTermStatus.NEW);\n        LeaseTerm previousTerm = getPrevious();\n        BigInteger sequence = BigInteger.ONE;\n        if (previousTerm != null) {\n            sequence = previousTerm.getSequence().add(BigInteger.ONE);\n            setFrequency(previousTerm.getFrequency());\n        }\n        setSequence(sequence);\n    }\n\n    @Programmatic\n    protected void update() {\n        // terminate the last term\n        LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n        if (terminationDate != null && getNext() == null) {\n            if (getEndDate() == null || getEndDate().compareTo(terminationDate) > 0) {\n                setEndDate(terminationDate);\n            }\n        }\n        // Get the end date from the next start date\n        if (getEndDate() == null && getNext() != null) {\n            modifyEndDate(getNext().getInterval().endDateFromStartDate());\n        }\n\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public void copyValuesTo(final LeaseTerm target) {\n        target.setStartDate(getStartDate());\n        target.setEndDate(getEndDate());\n        target.setStatus(getStatus());\n        target.setFrequency(getFrequency());\n    }\n\n    // //////////////////////////////////////\n\n    @Bulk\n    @ActionSemantics(Of.IDEMPOTENT)\n    public LeaseTerm approve() {\n        if (!getStatus().isApproved()) {\n            setStatus(LeaseTermStatus.APPROVED);\n        }\n        return this;\n    }\n\n    // //////////////////////////////////////\n\n    @Programmatic\n    public BigDecimal valueForDate(final LocalDate dueDate) {\n        return getTrialValue();\n    }\n\n    @Programmatic\n    BigDecimal valueForPeriod(\n            final LocalDate periodStartDate,\n            final LocalDate dueDate,\n            final InvoicingFrequency frequency) {\n        return invoiceCalculationService.calculateSumForAllPeriods(this, periodStartDate, dueDate, frequency);\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    public String toString() {\n        return getInterval().toString() + \" / \";\n    }\n\n    // //////////////////////////////////////\n\n    private InvoiceItemsForLease invoiceItemsForLease;\n\n    public final void injectInvoiceItemsForLease(final InvoiceItemsForLease invoiceItemsForLease) {\n        this.invoiceItemsForLease = invoiceItemsForLease;\n    }\n\n    private InvoiceCalculationService invoiceCalculationService;\n\n    public final void injectInvoiceCalculationService(final InvoiceCalculationService invoiceCalculationService) {\n        this.invoiceCalculationService = invoiceCalculationService;\n    }\n\n    private LeaseTerms terms;\n\n    public final void injectLeaseTerms(final LeaseTerms terms) {\n        this.terms = terms;\n    }\n\n}",
        "start_point": {
            "row": 63,
            "column": 0
        },
        "end_point": {
            "row": 667,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public LeaseTerm() {\n    // TODO: the integration tests fail if this is made DESCending.\n    super(\"leaseItem, sequence, startDate\");\n}",
                "name": "LeaseTerm",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    // TODO: the integration tests fail if this is made DESCending.\n    super(\"leaseItem, sequence, startDate\");\n}",
                "constructor": true,
                "start_point": {
                    "row": 110,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(name = \"leaseItemId\", allowsNull = \"false\")\n@Hidden(where = Where.REFERENCES_PARENT)\n@Disabled\n@Title(sequence = \"1\", append = \":\")\npublic LeaseItem getLeaseItem() {\n    return leaseItem;\n}",
                "name": "getLeaseItem",
                "modifiers": "@javax.jdo.annotations.Column(name = \"leaseItemId\", allowsNull = \"false\")\n    @Hidden(where = Where.REFERENCES_PARENT)\n    @Disabled\n    @Title(sequence = \"1\", append = \":\")\n    public",
                "return_type": "LeaseItem",
                "parameters": [],
                "body": "{\n    return leaseItem;\n}",
                "start_point": {
                    "row": 120,
                    "column": 4
                },
                "end_point": {
                    "row": 126,
                    "column": 5
                }
            },
            {
                "definition": "public void setLeaseItem(final LeaseItem leaseItem) {\n    this.leaseItem = leaseItem;\n}",
                "name": "setLeaseItem",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseItem"
                    }
                ],
                "body": "{\n    this.leaseItem = leaseItem;\n}",
                "start_point": {
                    "row": 128,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "@Hidden\n@Optional\npublic BigInteger getSequence() {\n    return sequence;\n}",
                "name": "getSequence",
                "modifiers": "@Hidden\n    @Optional\n    public",
                "return_type": "BigInteger",
                "parameters": [],
                "body": "{\n    return sequence;\n}",
                "start_point": {
                    "row": 136,
                    "column": 4
                },
                "end_point": {
                    "row": 140,
                    "column": 5
                }
            },
            {
                "definition": "public void setSequence(final BigInteger sequence) {\n    this.sequence = sequence;\n}",
                "name": "setSequence",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigInteger"
                    }
                ],
                "body": "{\n    this.sequence = sequence;\n}",
                "start_point": {
                    "row": 142,
                    "column": 4
                },
                "end_point": {
                    "row": 144,
                    "column": 5
                }
            },
            {
                "definition": "@Title(sequence = \"2\", append = \"-\")\n@Optional\n@Disabled\n@Override\npublic LocalDate getStartDate() {\n    return startDate;\n}",
                "name": "getStartDate",
                "modifiers": "@Title(sequence = \"2\", append = \"-\")\n    @Optional\n    @Disabled\n    @Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return startDate;\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 157,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setStartDate(final LocalDate startDate) {\n    this.startDate = startDate;\n}",
                "name": "setStartDate",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.startDate = startDate;\n}",
                "start_point": {
                    "row": 159,
                    "column": 4
                },
                "end_point": {
                    "row": 162,
                    "column": 5
                }
            },
            {
                "definition": "public void modifyStartDate(final LocalDate startDate) {\n    LocalDate currentStartDate = getStartDate();\n    if (startDate != null && !startDate.equals(currentStartDate)) {\n        setStartDate(startDate);\n    }\n    if (getPrevious() != null) {\n        getPrevious().modifyEndDate(getInterval().endDateFromStartDate());\n    }\n}",
                "name": "modifyStartDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    LocalDate currentStartDate = getStartDate();\n    if (startDate != null && !startDate.equals(currentStartDate)) {\n        setStartDate(startDate);\n    }\n    if (getPrevious() != null) {\n        getPrevious().modifyEndDate(getInterval().endDateFromStartDate());\n    }\n}",
                "start_point": {
                    "row": 164,
                    "column": 4
                },
                "end_point": {
                    "row": 172,
                    "column": 5
                }
            },
            {
                "definition": "public void clearStartDate() {\n    LocalDate currentStartDate = getStartDate();\n    if (currentStartDate == null) {\n        return;\n    }\n    setStartDate(null);\n    // TODO: shouldn't there be some logic reciprocal to that in\n    // modifyStartDate ?\n}",
                "name": "clearStartDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    LocalDate currentStartDate = getStartDate();\n    if (currentStartDate == null) {\n        return;\n    }\n    setStartDate(null);\n    // TODO: shouldn't there be some logic reciprocal to that in\n    // modifyStartDate ?\n}",
                "start_point": {
                    "row": 174,
                    "column": 4
                },
                "end_point": {
                    "row": 182,
                    "column": 5
                }
            },
            {
                "definition": "@Title(sequence = \"3\")\n@Disabled\n@Optional\npublic LocalDate getEndDate() {\n    return endDate;\n}",
                "name": "getEndDate",
                "modifiers": "@Title(sequence = \"3\")\n    @Disabled\n    @Optional\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return endDate;\n}",
                "start_point": {
                    "row": 189,
                    "column": 4
                },
                "end_point": {
                    "row": 194,
                    "column": 5
                }
            },
            {
                "definition": "public void setEndDate(final LocalDate endDate) {\n    this.endDate = endDate;\n}",
                "name": "setEndDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.endDate = endDate;\n}",
                "start_point": {
                    "row": 196,
                    "column": 4
                },
                "end_point": {
                    "row": 198,
                    "column": 5
                }
            },
            {
                "definition": "public void modifyEndDate(final LocalDate endDate) {\n    LocalDate currentEndDate = getEndDate();\n    if (endDate == null && currentEndDate == null || endDate.equals(currentEndDate)) {\n        return;\n    }\n    setEndDate(endDate);\n}",
                "name": "modifyEndDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    LocalDate currentEndDate = getEndDate();\n    if (endDate == null && currentEndDate == null || endDate.equals(currentEndDate)) {\n        return;\n    }\n    setEndDate(endDate);\n}",
                "start_point": {
                    "row": 200,
                    "column": 4
                },
                "end_point": {
                    "row": 206,
                    "column": 5
                }
            },
            {
                "definition": "public void clearEndDate() {\n    LocalDate currentEndDate = getEndDate();\n    if (currentEndDate == null) {\n        return;\n    }\n    setEndDate(null);\n}",
                "name": "clearEndDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    LocalDate currentEndDate = getEndDate();\n    if (currentEndDate == null) {\n        return;\n    }\n    setEndDate(null);\n}",
                "start_point": {
                    "row": 208,
                    "column": 4
                },
                "end_point": {
                    "row": 214,
                    "column": 5
                }
            },
            {
                "definition": "WithIntervalMutable.Helper<LeaseTerm> getChangeDates() {\n    return changeDates;\n}",
                "name": "getChangeDates",
                "modifiers": null,
                "return_type": null,
                "parameters": [],
                "body": "{\n    return changeDates;\n}",
                "start_point": {
                    "row": 220,
                    "column": 4
                },
                "end_point": {
                    "row": 222,
                    "column": 5
                }
            },
            {
                "definition": "@ActionSemantics(Of.IDEMPOTENT)\n@Override\npublic LeaseTerm changeDates(\n        final @Named(\"Start Date\") @Optional LocalDate startDate,\n        final @Named(\"End Date\") @Optional LocalDate endDate) {\n    return getChangeDates().changeDates(startDate, endDate);\n}",
                "name": "changeDates",
                "modifiers": "@ActionSemantics(Of.IDEMPOTENT)\n    @Override\n    public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final @Named(\"Start Date\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"End Date\") @Optional",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return getChangeDates().changeDates(startDate, endDate);\n}",
                "start_point": {
                    "row": 224,
                    "column": 4
                },
                "end_point": {
                    "row": 230,
                    "column": 5
                }
            },
            {
                "definition": "public String disableChangeDates(\n        final LocalDate startDate,\n        final LocalDate endDate) {\n    return null;\n}",
                "name": "disableChangeDates",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 232,
                    "column": 4
                },
                "end_point": {
                    "row": 236,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic LocalDate default0ChangeDates() {\n    return getChangeDates().default0ChangeDates();\n}",
                "name": "default0ChangeDates",
                "modifiers": "@Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return getChangeDates().default0ChangeDates();\n}",
                "start_point": {
                    "row": 238,
                    "column": 4
                },
                "end_point": {
                    "row": 241,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic LocalDate default1ChangeDates() {\n    return getChangeDates().default1ChangeDates();\n}",
                "name": "default1ChangeDates",
                "modifiers": "@Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return getChangeDates().default1ChangeDates();\n}",
                "start_point": {
                    "row": 243,
                    "column": 4
                },
                "end_point": {
                    "row": 246,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String validateChangeDates(\n        final LocalDate startDate,\n        final LocalDate endDate) {\n    return getChangeDates().validateChangeDates(startDate, endDate);\n}",
                "name": "validateChangeDates",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return getChangeDates().validateChangeDates(startDate, endDate);\n}",
                "start_point": {
                    "row": 248,
                    "column": 4
                },
                "end_point": {
                    "row": 253,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\n@Override\npublic LocalDateInterval getInterval() {\n    return LocalDateInterval.including(getStartDate(), getEndDate());\n}",
                "name": "getInterval",
                "modifiers": "@Programmatic\n    @Override\n    public",
                "return_type": "LocalDateInterval",
                "parameters": [],
                "body": "{\n    return LocalDateInterval.including(getStartDate(), getEndDate());\n}",
                "start_point": {
                    "row": 257,
                    "column": 4
                },
                "end_point": {
                    "row": 261,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic LocalDateInterval getEffectiveInterval() {\n    return getInterval().overlap(getLeaseItem().getEffectiveInterval());\n}",
                "name": "getEffectiveInterval",
                "modifiers": "@Programmatic\n    public",
                "return_type": "LocalDateInterval",
                "parameters": [],
                "body": "{\n    return getInterval().overlap(getLeaseItem().getEffectiveInterval());\n}",
                "start_point": {
                    "row": 263,
                    "column": 4
                },
                "end_point": {
                    "row": 266,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isCurrent() {\n    return isActiveOn(getClockService().now());\n}",
                "name": "isCurrent",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return isActiveOn(getClockService().now());\n}",
                "start_point": {
                    "row": 270,
                    "column": 4
                },
                "end_point": {
                    "row": 272,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic boolean isActiveOn(final LocalDate localDate) {\n    LocalDateInterval effectiveInterval = getEffectiveInterval();\n    if (effectiveInterval == null) {\n        return false;\n    }\n    return effectiveInterval.contains(localDate);\n}",
                "name": "isActiveOn",
                "modifiers": "@Programmatic\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    LocalDateInterval effectiveInterval = getEffectiveInterval();\n    if (effectiveInterval == null) {\n        return false;\n    }\n    return effectiveInterval.contains(localDate);\n}",
                "start_point": {
                    "row": 274,
                    "column": 4
                },
                "end_point": {
                    "row": 281,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n@Disabled\npublic LeaseTermStatus getStatus() {\n    return status;\n}",
                "name": "getStatus",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.STATUS_ENUM)\n    @Disabled\n    public",
                "return_type": "LeaseTermStatus",
                "parameters": [],
                "body": "{\n    return status;\n}",
                "start_point": {
                    "row": 287,
                    "column": 4
                },
                "end_point": {
                    "row": 291,
                    "column": 5
                }
            },
            {
                "definition": "public void setStatus(final LeaseTermStatus status) {\n    this.status = status;\n}",
                "name": "setStatus",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTermStatus"
                    }
                ],
                "body": "{\n    this.status = status;\n}",
                "start_point": {
                    "row": 293,
                    "column": 4
                },
                "end_point": {
                    "row": 295,
                    "column": 5
                }
            },
            {
                "definition": "public void created() {\n    setStatus(LeaseTermStatus.NEW);\n}",
                "name": "created",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    setStatus(LeaseTermStatus.NEW);\n}",
                "start_point": {
                    "row": 297,
                    "column": 4
                },
                "end_point": {
                    "row": 299,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.LEASE_TERM_FREQUENCY_ENUM)\npublic LeaseTermFrequency getFrequency() {\n    return frequency;\n}",
                "name": "getFrequency",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"false\", length = JdoColumnLength.LEASE_TERM_FREQUENCY_ENUM)\n    public",
                "return_type": "LeaseTermFrequency",
                "parameters": [],
                "body": "{\n    return frequency;\n}",
                "start_point": {
                    "row": 305,
                    "column": 4
                },
                "end_point": {
                    "row": 308,
                    "column": 5
                }
            },
            {
                "definition": "public void setFrequency(final LeaseTermFrequency frequency) {\n    this.frequency = frequency;\n}",
                "name": "setFrequency",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTermFrequency"
                    }
                ],
                "body": "{\n    this.frequency = frequency;\n}",
                "start_point": {
                    "row": 310,
                    "column": 4
                },
                "end_point": {
                    "row": 312,
                    "column": 5
                }
            },
            {
                "definition": "public BigDecimal getTrialValue() {\n    return null;\n}",
                "name": "getTrialValue",
                "modifiers": "public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 316,
                    "column": 4
                },
                "end_point": {
                    "row": 318,
                    "column": 5
                }
            },
            {
                "definition": "public BigDecimal getApprovedValue() {\n    return null;\n}",
                "name": "getApprovedValue",
                "modifiers": "public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 322,
                    "column": 4
                },
                "end_point": {
                    "row": 324,
                    "column": 5
                }
            },
            {
                "definition": "@Named(\"Previous Term\")\n@Hidden(where = Where.ALL_TABLES)\n@Optional\n@Override\npublic LeaseTerm getPrevious() {\n    return previous;\n}",
                "name": "getPrevious",
                "modifiers": "@Named(\"Previous Term\")\n    @Hidden(where = Where.ALL_TABLES)\n    @Optional\n    @Override\n    public",
                "return_type": "LeaseTerm",
                "parameters": [],
                "body": "{\n    return previous;\n}",
                "start_point": {
                    "row": 332,
                    "column": 4
                },
                "end_point": {
                    "row": 338,
                    "column": 5
                }
            },
            {
                "definition": "public void setPrevious(final LeaseTerm previous) {\n    this.previous = previous;\n}",
                "name": "setPrevious",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerm"
                    }
                ],
                "body": "{\n    this.previous = previous;\n}",
                "start_point": {
                    "row": 340,
                    "column": 4
                },
                "end_point": {
                    "row": 342,
                    "column": 5
                }
            },
            {
                "definition": "public void modifyPrevious(final LeaseTerm previous) {\n    LeaseTerm currentPrevious = getPrevious();\n    if (previous == null || previous.equals(currentPrevious)) {\n        return;\n    }\n    clearPrevious();\n    previous.setNext(this);\n    setPrevious(previous);\n}",
                "name": "modifyPrevious",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerm"
                    }
                ],
                "body": "{\n    LeaseTerm currentPrevious = getPrevious();\n    if (previous == null || previous.equals(currentPrevious)) {\n        return;\n    }\n    clearPrevious();\n    previous.setNext(this);\n    setPrevious(previous);\n}",
                "start_point": {
                    "row": 344,
                    "column": 4
                },
                "end_point": {
                    "row": 352,
                    "column": 5
                }
            },
            {
                "definition": "public void clearPrevious() {\n    LeaseTerm currentPrevious = getPrevious();\n    if (currentPrevious == null) {\n        return;\n    }\n    currentPrevious.setNext(null);\n    setPrevious(null);\n}",
                "name": "clearPrevious",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    LeaseTerm currentPrevious = getPrevious();\n    if (currentPrevious == null) {\n        return;\n    }\n    currentPrevious.setNext(null);\n    setPrevious(null);\n}",
                "start_point": {
                    "row": 354,
                    "column": 4
                },
                "end_point": {
                    "row": 361,
                    "column": 5
                }
            },
            {
                "definition": "@Hidden(where = Where.ALL_TABLES)\n@Named(\"Next Term\")\n@Optional\n@Override\npublic LeaseTerm getNext() {\n    return next;\n}",
                "name": "getNext",
                "modifiers": "@Hidden(where = Where.ALL_TABLES)\n    @Named(\"Next Term\")\n    @Optional\n    @Override\n    public",
                "return_type": "LeaseTerm",
                "parameters": [],
                "body": "{\n    return next;\n}",
                "start_point": {
                    "row": 368,
                    "column": 4
                },
                "end_point": {
                    "row": 374,
                    "column": 5
                }
            },
            {
                "definition": "public void setNext(final LeaseTerm next) {\n    this.next = next;\n}",
                "name": "setNext",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerm"
                    }
                ],
                "body": "{\n    this.next = next;\n}",
                "start_point": {
                    "row": 376,
                    "column": 4
                },
                "end_point": {
                    "row": 378,
                    "column": 5
                }
            },
            {
                "definition": "public void modifyNext(final LeaseTerm next) {\n    LeaseTerm currentNext = getNext();\n    if (next == null || next.equals(currentNext)) {\n        return;\n    }\n    if (currentNext != null) {\n        currentNext.clearPrevious();\n    }\n    next.modifyPrevious(this);\n}",
                "name": "modifyNext",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerm"
                    }
                ],
                "body": "{\n    LeaseTerm currentNext = getNext();\n    if (next == null || next.equals(currentNext)) {\n        return;\n    }\n    if (currentNext != null) {\n        currentNext.clearPrevious();\n    }\n    next.modifyPrevious(this);\n}",
                "start_point": {
                    "row": 380,
                    "column": 4
                },
                "end_point": {
                    "row": 389,
                    "column": 5
                }
            },
            {
                "definition": "public void clearNext() {\n    LeaseTerm currentNext = getNext();\n    if (currentNext == null) {\n        return;\n    }\n    currentNext.clearPrevious();\n}",
                "name": "clearNext",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    LeaseTerm currentNext = getNext();\n    if (currentNext == null) {\n        return;\n    }\n    currentNext.clearPrevious();\n}",
                "start_point": {
                    "row": 391,
                    "column": 4
                },
                "end_point": {
                    "row": 397,
                    "column": 5
                }
            },
            {
                "definition": "@Render(Type.EAGERLY)\npublic SortedSet<InvoiceItemForLease> getInvoiceItems() {\n    return invoiceItems;\n}",
                "name": "getInvoiceItems",
                "modifiers": "@Render(Type.EAGERLY)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return invoiceItems;\n}",
                "start_point": {
                    "row": 404,
                    "column": 4
                },
                "end_point": {
                    "row": 407,
                    "column": 5
                }
            },
            {
                "definition": "public void setInvoiceItems(final SortedSet<InvoiceItemForLease> invoiceItems) {\n    this.invoiceItems = invoiceItems;\n}",
                "name": "setInvoiceItems",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "SortedSet<InvoiceItemForLease>"
                    }
                ],
                "body": "{\n    this.invoiceItems = invoiceItems;\n}",
                "start_point": {
                    "row": 409,
                    "column": 4
                },
                "end_point": {
                    "row": 411,
                    "column": 5
                }
            },
            {
                "definition": "public void addToInvoiceItems(final InvoiceItemForLease invoiceItem) {\n    if (invoiceItem == null || getInvoiceItems().contains(invoiceItem)) {\n        return;\n    }\n    invoiceItem.clearLeaseTerm();\n    invoiceItem.setLeaseTerm(this);\n    getInvoiceItems().add(invoiceItem);\n}",
                "name": "addToInvoiceItems",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoiceItemForLease"
                    }
                ],
                "body": "{\n    if (invoiceItem == null || getInvoiceItems().contains(invoiceItem)) {\n        return;\n    }\n    invoiceItem.clearLeaseTerm();\n    invoiceItem.setLeaseTerm(this);\n    getInvoiceItems().add(invoiceItem);\n}",
                "start_point": {
                    "row": 413,
                    "column": 4
                },
                "end_point": {
                    "row": 420,
                    "column": 5
                }
            },
            {
                "definition": "public void removeFromInvoiceItems(final InvoiceItemForLease invoiceItem) {\n    if (invoiceItem == null || !getInvoiceItems().contains(invoiceItem)) {\n        return;\n    }\n    invoiceItem.setLeaseTerm(null);\n    getInvoiceItems().remove(invoiceItem);\n}",
                "name": "removeFromInvoiceItems",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoiceItemForLease"
                    }
                ],
                "body": "{\n    if (invoiceItem == null || !getInvoiceItems().contains(invoiceItem)) {\n        return;\n    }\n    invoiceItem.setLeaseTerm(null);\n    getInvoiceItems().remove(invoiceItem);\n}",
                "start_point": {
                    "row": 422,
                    "column": 4
                },
                "end_point": {
                    "row": 428,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\n@Prototype\npublic void remove() {\n    if (getNext() != null) {\n        getNext().remove();\n    }\n    if (this.getInvoiceItems().size() == 0) {\n        // CHECKSTYLE.OFF: \n        // TODO: Disabled, see EST-273\n        // this.modifyPrevious(null);\n        // getContainer().remove(this);\n        // CHECKSTYLE.ON: \n    }\n}",
                "name": "remove",
                "modifiers": "@Programmatic\n    @Prototype\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    if (getNext() != null) {\n        getNext().remove();\n    }\n    if (this.getInvoiceItems().size() == 0) {\n        // CHECKSTYLE.OFF: \n        // TODO: Disabled, see EST-273\n        // this.modifyPrevious(null);\n        // getContainer().remove(this);\n        // CHECKSTYLE.ON: \n    }\n}",
                "start_point": {
                    "row": 432,
                    "column": 4
                },
                "end_point": {
                    "row": 445,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic void removeUnapprovedInvoiceItemsForDate(final LocalDate startDate, final LocalDate dueDate) {\n    for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n        Invoice invoice = invoiceItem.getInvoice();\n        if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                startDate.equals(invoiceItem.getStartDate()) &&\n                dueDate.equals(invoiceItem.getDueDate())) {\n            invoiceItem.setInvoice(null);\n            invoiceItem.clearLeaseTerm();\n            getContainer().flush();\n            remove(invoiceItem);\n        }\n    }\n}",
                "name": "removeUnapprovedInvoiceItemsForDate",
                "modifiers": "@Programmatic\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n        Invoice invoice = invoiceItem.getInvoice();\n        if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                startDate.equals(invoiceItem.getStartDate()) &&\n                dueDate.equals(invoiceItem.getDueDate())) {\n            invoiceItem.setInvoice(null);\n            invoiceItem.clearLeaseTerm();\n            getContainer().flush();\n            remove(invoiceItem);\n        }\n    }\n}",
                "start_point": {
                    "row": 447,
                    "column": 4
                },
                "end_point": {
                    "row": 460,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic InvoiceItemForLease findOrCreateUnapprovedInvoiceItemFor(\n        final LocalDate startDate,\n        final LocalDate dueDate) {\n    InvoiceItemForLease ii = findUnapprovedInvoiceItemFor(startDate, dueDate);\n    if (ii == null) {\n        ii = invoiceItemsForLease.newInvoiceItem(this, startDate, dueDate);\n    }\n    return ii;\n}",
                "name": "findOrCreateUnapprovedInvoiceItemFor",
                "modifiers": "@Programmatic\n    public",
                "return_type": "InvoiceItemForLease",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    InvoiceItemForLease ii = findUnapprovedInvoiceItemFor(startDate, dueDate);\n    if (ii == null) {\n        ii = invoiceItemsForLease.newInvoiceItem(this, startDate, dueDate);\n    }\n    return ii;\n}",
                "start_point": {
                    "row": 462,
                    "column": 4
                },
                "end_point": {
                    "row": 471,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic InvoiceItemForLease findUnapprovedInvoiceItemFor(\n        final LocalDate startDate,\n        final LocalDate dueDate) {\n    for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n        Invoice invoice = invoiceItem.getInvoice();\n        if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                this.equals(invoiceItem.getLeaseTerm()) &&\n                startDate.equals(invoiceItem.getStartDate()) &&\n                dueDate.equals(invoiceItem.getDueDate())) {\n            return invoiceItem;\n        }\n    }\n    return null;\n}",
                "name": "findUnapprovedInvoiceItemFor",
                "modifiers": "@Programmatic\n    public",
                "return_type": "InvoiceItemForLease",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n        Invoice invoice = invoiceItem.getInvoice();\n        if ((invoice == null || invoice.getStatus().equals(InvoiceStatus.NEW)) &&\n                this.equals(invoiceItem.getLeaseTerm()) &&\n                startDate.equals(invoiceItem.getStartDate()) &&\n                dueDate.equals(invoiceItem.getDueDate())) {\n            return invoiceItem;\n        }\n    }\n    return null;\n}",
                "start_point": {
                    "row": 473,
                    "column": 4
                },
                "end_point": {
                    "row": 487,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic BigDecimal invoicedValueFor(final LocalDate startDate) {\n    BigDecimal invoicedValue = new BigDecimal(0);\n    for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n        Invoice invoice = invoiceItem.getInvoice();\n        if (invoice == null || invoice.getStatus() == InvoiceStatus.NEW ||\n                invoiceItem.getStartDate() == null ||\n                invoiceItem.getStartDate().compareTo(startDate) != 0) {\n            continue;\n        }\n        invoicedValue = invoicedValue.add(invoiceItem.getNetAmount());\n    }\n    return invoicedValue;\n}",
                "name": "invoicedValueFor",
                "modifiers": "@Programmatic\n    public",
                "return_type": "BigDecimal",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    BigDecimal invoicedValue = new BigDecimal(0);\n    for (InvoiceItemForLease invoiceItem : getInvoiceItems()) {\n        Invoice invoice = invoiceItem.getInvoice();\n        if (invoice == null || invoice.getStatus() == InvoiceStatus.NEW ||\n                invoiceItem.getStartDate() == null ||\n                invoiceItem.getStartDate().compareTo(startDate) != 0) {\n            continue;\n        }\n        invoicedValue = invoicedValue.add(invoiceItem.getNetAmount());\n    }\n    return invoicedValue;\n}",
                "start_point": {
                    "row": 489,
                    "column": 4
                },
                "end_point": {
                    "row": 502,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic LeaseTerm calculate(\n        final @Named(\"Period Start Date\") LocalDate startDate,\n        final @Named(\"Due Date\") LocalDate dueDate) {\n    return calculate(startDate, null, dueDate, InvoiceRunType.NORMAL_RUN);\n}",
                "name": "calculate",
                "modifiers": "@Programmatic\n    public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final @Named(\"Period Start Date\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"Due Date\")",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return calculate(startDate, null, dueDate, InvoiceRunType.NORMAL_RUN);\n}",
                "start_point": {
                    "row": 506,
                    "column": 4
                },
                "end_point": {
                    "row": 511,
                    "column": 5
                }
            },
            {
                "definition": "public LeaseTerm calculate(\n        final @Named(\"Period start Date\") LocalDate startDate,\n        final @Named(\"Period end Date\") @Optional LocalDate endDate,\n        final @Named(\"Due Date\") LocalDate dueDate,\n        final @Named(\"Run Type\") InvoiceRunType runType) {\n    invoiceCalculationService.calculateAndInvoice(\n            this, startDate, endDate, dueDate, getLeaseItem().getInvoicingFrequency(), runType);\n    return this;\n}",
                "name": "calculate",
                "modifiers": "public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final @Named(\"Period start Date\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"Period end Date\") @Optional",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"Due Date\")",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final @Named(\"Run Type\")",
                        "name": "InvoiceRunType"
                    }
                ],
                "body": "{\n    invoiceCalculationService.calculateAndInvoice(\n            this, startDate, endDate, dueDate, getLeaseItem().getInvoicingFrequency(), runType);\n    return this;\n}",
                "start_point": {
                    "row": 513,
                    "column": 4
                },
                "end_point": {
                    "row": 521,
                    "column": 5
                }
            },
            {
                "definition": "@Bulk\npublic LeaseTerm verify() {\n    verifyUntil(getClockService().now());\n    return this;\n}",
                "name": "verify",
                "modifiers": "@Bulk\n    public",
                "return_type": "LeaseTerm",
                "parameters": [],
                "body": "{\n    verifyUntil(getClockService().now());\n    return this;\n}",
                "start_point": {
                    "row": 525,
                    "column": 4
                },
                "end_point": {
                    "row": 529,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic void verifyUntil(final LocalDate date) {\n    update();\n    // convenience code to automatically create terms but not for terms who\n    // have a start date after today\n    LeaseTerm nextTerm = getNext();\n    if (nextTerm == null && getNextStartDate().compareTo(date) <= 0) {\n        nextTerm = createNext(getNextStartDate());\n    }\n    if (nextTerm != null) {\n        nextTerm.verifyUntil(date);\n    }\n}",
                "name": "verifyUntil",
                "modifiers": "@Programmatic\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    update();\n    // convenience code to automatically create terms but not for terms who\n    // have a start date after today\n    LeaseTerm nextTerm = getNext();\n    if (nextTerm == null && getNextStartDate().compareTo(date) <= 0) {\n        nextTerm = createNext(getNextStartDate());\n    }\n    if (nextTerm != null) {\n        nextTerm.verifyUntil(date);\n    }\n}",
                "start_point": {
                    "row": 531,
                    "column": 4
                },
                "end_point": {
                    "row": 543,
                    "column": 5
                }
            },
            {
                "definition": "private LocalDate getNextStartDate() {\n    LocalDate nextStartDate = getInterval().endDateExcluding();\n    if (nextStartDate == null) {\n        return getFrequency().nextDate(getStartDate());\n    }\n    return nextStartDate;\n}",
                "name": "getNextStartDate",
                "modifiers": "private",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    LocalDate nextStartDate = getInterval().endDateExcluding();\n    if (nextStartDate == null) {\n        return getFrequency().nextDate(getStartDate());\n    }\n    return nextStartDate;\n}",
                "start_point": {
                    "row": 545,
                    "column": 4
                },
                "end_point": {
                    "row": 551,
                    "column": 5
                }
            },
            {
                "definition": "public LeaseTerm createNext(\n        final @Named(\"Start date\") LocalDate nextStartDate) {\n    LeaseTerm nextTerm = getNext();\n    if (nextTerm != null) {\n        return nextTerm;\n    }\n    // Don't create terms after termination date\n    LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n    if (terminationDate != null &&\n            terminationDate.isBefore(nextStartDate)) {\n        return null;\n    }\n    // Ok, we need to create a term\n    nextTerm = terms.newLeaseTerm(getLeaseItem(), this, nextStartDate);\n    nextTerm.initialize();\n    nextTerm.modifyStartDate(nextStartDate);\n    nextTerm.update();\n    return nextTerm;\n}",
                "name": "createNext",
                "modifiers": "public",
                "return_type": "LeaseTerm",
                "parameters": [
                    {
                        "type": "final @Named(\"Start date\")",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    LeaseTerm nextTerm = getNext();\n    if (nextTerm != null) {\n        return nextTerm;\n    }\n    // Don't create terms after termination date\n    LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n    if (terminationDate != null &&\n            terminationDate.isBefore(nextStartDate)) {\n        return null;\n    }\n    // Ok, we need to create a term\n    nextTerm = terms.newLeaseTerm(getLeaseItem(), this, nextStartDate);\n    nextTerm.initialize();\n    nextTerm.modifyStartDate(nextStartDate);\n    nextTerm.update();\n    return nextTerm;\n}",
                "start_point": {
                    "row": 555,
                    "column": 4
                },
                "end_point": {
                    "row": 573,
                    "column": 5
                }
            },
            {
                "definition": "protected void initialize() {\n    setStatus(LeaseTermStatus.NEW);\n    LeaseTerm previousTerm = getPrevious();\n    BigInteger sequence = BigInteger.ONE;\n    if (previousTerm != null) {\n        sequence = previousTerm.getSequence().add(BigInteger.ONE);\n        setFrequency(previousTerm.getFrequency());\n    }\n    setSequence(sequence);\n}",
                "name": "initialize",
                "modifiers": "protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    setStatus(LeaseTermStatus.NEW);\n    LeaseTerm previousTerm = getPrevious();\n    BigInteger sequence = BigInteger.ONE;\n    if (previousTerm != null) {\n        sequence = previousTerm.getSequence().add(BigInteger.ONE);\n        setFrequency(previousTerm.getFrequency());\n    }\n    setSequence(sequence);\n}",
                "start_point": {
                    "row": 577,
                    "column": 4
                },
                "end_point": {
                    "row": 586,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\nprotected void update() {\n    // terminate the last term\n    LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n    if (terminationDate != null && getNext() == null) {\n        if (getEndDate() == null || getEndDate().compareTo(terminationDate) > 0) {\n            setEndDate(terminationDate);\n        }\n    }\n    // Get the end date from the next start date\n    if (getEndDate() == null && getNext() != null) {\n        modifyEndDate(getNext().getInterval().endDateFromStartDate());\n    }\n\n}",
                "name": "update",
                "modifiers": "@Programmatic\n    protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // terminate the last term\n    LocalDate terminationDate = getLeaseItem().getLease().getTerminationDate();\n    if (terminationDate != null && getNext() == null) {\n        if (getEndDate() == null || getEndDate().compareTo(terminationDate) > 0) {\n            setEndDate(terminationDate);\n        }\n    }\n    // Get the end date from the next start date\n    if (getEndDate() == null && getNext() != null) {\n        modifyEndDate(getNext().getInterval().endDateFromStartDate());\n    }\n\n}",
                "start_point": {
                    "row": 588,
                    "column": 4
                },
                "end_point": {
                    "row": 602,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic void copyValuesTo(final LeaseTerm target) {\n    target.setStartDate(getStartDate());\n    target.setEndDate(getEndDate());\n    target.setStatus(getStatus());\n    target.setFrequency(getFrequency());\n}",
                "name": "copyValuesTo",
                "modifiers": "@Programmatic\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerm"
                    }
                ],
                "body": "{\n    target.setStartDate(getStartDate());\n    target.setEndDate(getEndDate());\n    target.setStatus(getStatus());\n    target.setFrequency(getFrequency());\n}",
                "start_point": {
                    "row": 606,
                    "column": 4
                },
                "end_point": {
                    "row": 612,
                    "column": 5
                }
            },
            {
                "definition": "@Bulk\n@ActionSemantics(Of.IDEMPOTENT)\npublic LeaseTerm approve() {\n    if (!getStatus().isApproved()) {\n        setStatus(LeaseTermStatus.APPROVED);\n    }\n    return this;\n}",
                "name": "approve",
                "modifiers": "@Bulk\n    @ActionSemantics(Of.IDEMPOTENT)\n    public",
                "return_type": "LeaseTerm",
                "parameters": [],
                "body": "{\n    if (!getStatus().isApproved()) {\n        setStatus(LeaseTermStatus.APPROVED);\n    }\n    return this;\n}",
                "start_point": {
                    "row": 616,
                    "column": 4
                },
                "end_point": {
                    "row": 623,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\npublic BigDecimal valueForDate(final LocalDate dueDate) {\n    return getTrialValue();\n}",
                "name": "valueForDate",
                "modifiers": "@Programmatic\n    public",
                "return_type": "BigDecimal",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return getTrialValue();\n}",
                "start_point": {
                    "row": 627,
                    "column": 4
                },
                "end_point": {
                    "row": 630,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\nBigDecimal valueForPeriod(\n        final LocalDate periodStartDate,\n        final LocalDate dueDate,\n        final InvoicingFrequency frequency) {\n    return invoiceCalculationService.calculateSumForAllPeriods(this, periodStartDate, dueDate, frequency);\n}",
                "name": "valueForPeriod",
                "modifiers": "@Programmatic",
                "return_type": "BigDecimal",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "InvoicingFrequency"
                    }
                ],
                "body": "{\n    return invoiceCalculationService.calculateSumForAllPeriods(this, periodStartDate, dueDate, frequency);\n}",
                "start_point": {
                    "row": 632,
                    "column": 4
                },
                "end_point": {
                    "row": 638,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    return getInterval().toString() + \" / \";\n}",
                "name": "toString",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return getInterval().toString() + \" / \";\n}",
                "start_point": {
                    "row": 642,
                    "column": 4
                },
                "end_point": {
                    "row": 645,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectInvoiceItemsForLease(final InvoiceItemsForLease invoiceItemsForLease) {\n    this.invoiceItemsForLease = invoiceItemsForLease;\n}",
                "name": "injectInvoiceItemsForLease",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoiceItemsForLease"
                    }
                ],
                "body": "{\n    this.invoiceItemsForLease = invoiceItemsForLease;\n}",
                "start_point": {
                    "row": 651,
                    "column": 4
                },
                "end_point": {
                    "row": 653,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectInvoiceCalculationService(final InvoiceCalculationService invoiceCalculationService) {\n    this.invoiceCalculationService = invoiceCalculationService;\n}",
                "name": "injectInvoiceCalculationService",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "InvoiceCalculationService"
                    }
                ],
                "body": "{\n    this.invoiceCalculationService = invoiceCalculationService;\n}",
                "start_point": {
                    "row": 657,
                    "column": 4
                },
                "end_point": {
                    "row": 659,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectLeaseTerms(final LeaseTerms terms) {\n    this.terms = terms;\n}",
                "name": "injectLeaseTerms",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerms"
                    }
                ],
                "body": "{\n    this.terms = terms;\n}",
                "start_point": {
                    "row": 663,
                    "column": 4
                },
                "end_point": {
                    "row": 665,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dom/src/main/java/org/estatio/dom/lease/LeaseTermForIndexableRent.java",
        "definition": "@javax.jdo.annotations.PersistenceCapable\n// identityType=IdentityType.DATASTORE inherited from superclass\n@javax.jdo.annotations.Inheritance(\n        strategy = InheritanceStrategy.SUPERCLASS_TABLE)\n// no @DatastoreIdentity nor @Version, since inherited from supertype\npublic class LeaseTermForIndexableRent extends LeaseTerm implements Indexable {\n\n    private Index index;\n\n    @javax.jdo.annotations.Column(name = \"indexId\", allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public Index getIndex() {\n        return index;\n    }\n\n    @Override\n    public void setIndex(final Index index) {\n        this.index = index;\n    }\n\n    public List<Index> choicesIndex() {\n        return indices.allIndices();\n    }\n\n    // ///////////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate baseIndexStartDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public LocalDate getBaseIndexStartDate() {\n        return baseIndexStartDate;\n    }\n\n    @Override\n    public void setBaseIndexStartDate(final LocalDate baseIndexStartDate) {\n        this.baseIndexStartDate = baseIndexStartDate;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal baseIndexValue;\n\n    @javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getBaseIndexValue() {\n        return baseIndexValue;\n    }\n\n    @Override\n    public void setBaseIndexValue(final BigDecimal baseIndexValue) {\n        this.baseIndexValue = baseIndexValue;\n    }\n\n    // ///////////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate nextIndexStartDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public LocalDate getNextIndexStartDate() {\n        return nextIndexStartDate;\n    }\n\n    @Override\n    public void setNextIndexStartDate(final LocalDate nextIndexStartDate) {\n        this.nextIndexStartDate = nextIndexStartDate;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal nextIndexValue;\n\n    @javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getNextIndexValue() {\n        return nextIndexValue;\n    }\n\n    @Override\n    public void setNextIndexValue(final BigDecimal nextIndexValue) {\n        this.nextIndexValue = nextIndexValue;\n    }\n\n    // //////////////////////////////////////\n\n    private BigDecimal rebaseFactor;\n\n    @javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.REBASE_FACTOR, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getRebaseFactor() {\n        return rebaseFactor;\n    }\n\n    @Override\n    public void setRebaseFactor(final BigDecimal rebaseFactor) {\n        this.rebaseFactor = rebaseFactor;\n\n    }\n\n    // ///////////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate effectiveDate;\n\n    @Optional\n    public LocalDate getEffectiveDate() {\n        return effectiveDate;\n    }\n\n    public void setEffectiveDate(final LocalDate effectiveDate) {\n        this.effectiveDate = effectiveDate;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal indexationPercentage;\n\n    @javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getIndexationPercentage() {\n        return indexationPercentage;\n    }\n\n    @Override\n    public void setIndexationPercentage(final BigDecimal indexationPercentage) {\n        this.indexationPercentage = indexationPercentage;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal levellingPercentage;\n\n    @javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getLevellingPercentage() {\n        return levellingPercentage;\n    }\n\n    public void setLevellingPercentage(final BigDecimal levellingPercentage) {\n        this.levellingPercentage = levellingPercentage;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal baseValue;\n\n    @javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getBaseValue() {\n        return baseValue;\n    }\n\n    public void setBaseValue(final BigDecimal baseValue) {\n        this.baseValue = baseValue;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal indexedValue;\n\n    @javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getIndexedValue() {\n        return indexedValue;\n    }\n\n    @Override\n    public void setIndexedValue(final BigDecimal indexedValue) {\n        this.indexedValue = indexedValue;\n    }\n\n    // //////////////////////////////////////\n\n    private BigDecimal settledValue;\n\n    @javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    public BigDecimal getSettledValue() {\n        return settledValue;\n    }\n\n    public void setSettledValue(final BigDecimal settledValue) {\n        this.settledValue = settledValue;\n    }\n\n    @Override\n    public BigDecimal getApprovedValue() {\n        return getStatus().isApproved() ? getTrialValue() : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    public BigDecimal getTrialValue() {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n\n    // ///////////////////////////////////////////\n\n    @Override\n    @Programmatic\n    public void initialize() {\n        super.initialize();\n        final LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n        if (previousTerm != null) {\n            LeaseTermFrequency frequency = previousTerm.getFrequency();\n            if (frequency != null) {\n                setIndex(previousTerm.getIndex());\n                setBaseIndexStartDate(previousTerm.getNextIndexStartDate());\n                setNextIndexStartDate(frequency.nextDate(previousTerm.getNextIndexStartDate()));\n                setEffectiveDate(frequency.nextDate(previousTerm.getEffectiveDate()));\n                setBaseValue(previousTerm.getSettledValue());\n                setLevellingPercentage(previousTerm.getLevellingPercentage());\n            }\n        }\n\n    }\n    \n    // //////////////////////////////////////\n    \n    public boolean isIndexable() {\n        return getSettledValue() == null \n                && getIndexedValue() == null\n                && (getBaseIndexStartDate() != null && getNextIndexStartDate() != null)\n                && (getBaseIndexStartDate().compareTo(getNextIndexStartDate()) < 0);\n    }\n    \n    // //////////////////////////////////////\n\n    @Programmatic\n    @Override\n    public void update() {\n        super.update();\n        if (isIndexable()) {\n            LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n            if (previousTerm != null) {\n                BigDecimal newBaseValue = MathUtils.firstNonZero(\n                        previousTerm.getIndexedValue(),\n                        previousTerm.getBaseValue());\n                if (getBaseValue() == null || newBaseValue.compareTo(getBaseValue()) != 0) {\n                    setBaseValue(newBaseValue);\n                }\n            }\n            indexationService.indexate(this);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    public void copyValuesTo(final LeaseTerm target) {\n        LeaseTermForIndexableRent t = (LeaseTermForIndexableRent) target;\n        super.copyValuesTo(t);\n        t.setIndex(getIndex());\n        t.setBaseIndexStartDate(getBaseIndexStartDate());\n        t.setBaseIndexValue(getBaseIndexValue());\n        t.setNextIndexStartDate(getNextIndexStartDate());\n        t.setNextIndexValue(getNextIndexValue());\n        t.setEffectiveDate(getEffectiveDate());\n        t.setIndexationPercentage(getIndexationPercentage());\n        t.setLevellingPercentage(getLevellingPercentage());\n        t.setBaseValue(getBaseValue());\n        t.setIndexedValue(getIndexedValue());\n        t.setSettledValue(getSettledValue());\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    @Programmatic\n    public BigDecimal valueForDate(final LocalDate dueDate) {\n        // use the indexed value on or after the effective date, use the base\n        // otherwise\n        if (getEffectiveDate() == null) {\n            return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n        }\n        if (getStartDate().compareTo(getEffectiveDate()) == 0) {\n            return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n        }\n        if (dueDate.compareTo(getEffectiveDate()) >= 0) {\n            return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n        }\n        return MathUtils.firstNonZero(getBaseValue(), getSettledValue());\n    }\n\n    // ///////////////////////////////////////////\n\n    private Indices indices;\n\n    public final void injectIndices(final Indices indexes) {\n        this.indices = indexes;\n    }\n\n    private IndexationService indexationService;\n\n    public final void injectIndexationService(final IndexationService indexationService) {\n        this.indexationService = indexationService;\n    }\n\n}",
        "package": "package org.estatio.dom.lease;",
        "tree_path": "LeaseTermForIndexableRent",
        "name": "LeaseTermForIndexableRent",
        "modifiers": "@javax.jdo.annotations.PersistenceCapable\n// identityType=IdentityType.DATASTORE inherited from superclass\n@javax.jdo.annotations.Inheritance(\n        strategy = InheritanceStrategy.SUPERCLASS_TABLE)\n// no @DatastoreIdentity nor @Version, since inherited from supertype\npublic",
        "superclass": "extends LeaseTerm",
        "super_interfaces": "implements Indexable",
        "body": "{\n\n    private Index index;\n\n    @javax.jdo.annotations.Column(name = \"indexId\", allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public Index getIndex() {\n        return index;\n    }\n\n    @Override\n    public void setIndex(final Index index) {\n        this.index = index;\n    }\n\n    public List<Index> choicesIndex() {\n        return indices.allIndices();\n    }\n\n    // ///////////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate baseIndexStartDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public LocalDate getBaseIndexStartDate() {\n        return baseIndexStartDate;\n    }\n\n    @Override\n    public void setBaseIndexStartDate(final LocalDate baseIndexStartDate) {\n        this.baseIndexStartDate = baseIndexStartDate;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal baseIndexValue;\n\n    @javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getBaseIndexValue() {\n        return baseIndexValue;\n    }\n\n    @Override\n    public void setBaseIndexValue(final BigDecimal baseIndexValue) {\n        this.baseIndexValue = baseIndexValue;\n    }\n\n    // ///////////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate nextIndexStartDate;\n\n    @javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public LocalDate getNextIndexStartDate() {\n        return nextIndexStartDate;\n    }\n\n    @Override\n    public void setNextIndexStartDate(final LocalDate nextIndexStartDate) {\n        this.nextIndexStartDate = nextIndexStartDate;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal nextIndexValue;\n\n    @javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getNextIndexValue() {\n        return nextIndexValue;\n    }\n\n    @Override\n    public void setNextIndexValue(final BigDecimal nextIndexValue) {\n        this.nextIndexValue = nextIndexValue;\n    }\n\n    // //////////////////////////////////////\n\n    private BigDecimal rebaseFactor;\n\n    @javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.REBASE_FACTOR, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getRebaseFactor() {\n        return rebaseFactor;\n    }\n\n    @Override\n    public void setRebaseFactor(final BigDecimal rebaseFactor) {\n        this.rebaseFactor = rebaseFactor;\n\n    }\n\n    // ///////////////////////////////////////////\n\n    @javax.jdo.annotations.Persistent\n    private LocalDate effectiveDate;\n\n    @Optional\n    public LocalDate getEffectiveDate() {\n        return effectiveDate;\n    }\n\n    public void setEffectiveDate(final LocalDate effectiveDate) {\n        this.effectiveDate = effectiveDate;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal indexationPercentage;\n\n    @javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getIndexationPercentage() {\n        return indexationPercentage;\n    }\n\n    @Override\n    public void setIndexationPercentage(final BigDecimal indexationPercentage) {\n        this.indexationPercentage = indexationPercentage;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal levellingPercentage;\n\n    @javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getLevellingPercentage() {\n        return levellingPercentage;\n    }\n\n    public void setLevellingPercentage(final BigDecimal levellingPercentage) {\n        this.levellingPercentage = levellingPercentage;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal baseValue;\n\n    @javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getBaseValue() {\n        return baseValue;\n    }\n\n    public void setBaseValue(final BigDecimal baseValue) {\n        this.baseValue = baseValue;\n    }\n\n    // ///////////////////////////////////////////\n\n    private BigDecimal indexedValue;\n\n    @javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    @Override\n    public BigDecimal getIndexedValue() {\n        return indexedValue;\n    }\n\n    @Override\n    public void setIndexedValue(final BigDecimal indexedValue) {\n        this.indexedValue = indexedValue;\n    }\n\n    // //////////////////////////////////////\n\n    private BigDecimal settledValue;\n\n    @javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    public BigDecimal getSettledValue() {\n        return settledValue;\n    }\n\n    public void setSettledValue(final BigDecimal settledValue) {\n        this.settledValue = settledValue;\n    }\n\n    @Override\n    public BigDecimal getApprovedValue() {\n        return getStatus().isApproved() ? getTrialValue() : null;\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    public BigDecimal getTrialValue() {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n\n    // ///////////////////////////////////////////\n\n    @Override\n    @Programmatic\n    public void initialize() {\n        super.initialize();\n        final LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n        if (previousTerm != null) {\n            LeaseTermFrequency frequency = previousTerm.getFrequency();\n            if (frequency != null) {\n                setIndex(previousTerm.getIndex());\n                setBaseIndexStartDate(previousTerm.getNextIndexStartDate());\n                setNextIndexStartDate(frequency.nextDate(previousTerm.getNextIndexStartDate()));\n                setEffectiveDate(frequency.nextDate(previousTerm.getEffectiveDate()));\n                setBaseValue(previousTerm.getSettledValue());\n                setLevellingPercentage(previousTerm.getLevellingPercentage());\n            }\n        }\n\n    }\n    \n    // //////////////////////////////////////\n    \n    public boolean isIndexable() {\n        return getSettledValue() == null \n                && getIndexedValue() == null\n                && (getBaseIndexStartDate() != null && getNextIndexStartDate() != null)\n                && (getBaseIndexStartDate().compareTo(getNextIndexStartDate()) < 0);\n    }\n    \n    // //////////////////////////////////////\n\n    @Programmatic\n    @Override\n    public void update() {\n        super.update();\n        if (isIndexable()) {\n            LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n            if (previousTerm != null) {\n                BigDecimal newBaseValue = MathUtils.firstNonZero(\n                        previousTerm.getIndexedValue(),\n                        previousTerm.getBaseValue());\n                if (getBaseValue() == null || newBaseValue.compareTo(getBaseValue()) != 0) {\n                    setBaseValue(newBaseValue);\n                }\n            }\n            indexationService.indexate(this);\n        }\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    public void copyValuesTo(final LeaseTerm target) {\n        LeaseTermForIndexableRent t = (LeaseTermForIndexableRent) target;\n        super.copyValuesTo(t);\n        t.setIndex(getIndex());\n        t.setBaseIndexStartDate(getBaseIndexStartDate());\n        t.setBaseIndexValue(getBaseIndexValue());\n        t.setNextIndexStartDate(getNextIndexStartDate());\n        t.setNextIndexValue(getNextIndexValue());\n        t.setEffectiveDate(getEffectiveDate());\n        t.setIndexationPercentage(getIndexationPercentage());\n        t.setLevellingPercentage(getLevellingPercentage());\n        t.setBaseValue(getBaseValue());\n        t.setIndexedValue(getIndexedValue());\n        t.setSettledValue(getSettledValue());\n    }\n\n    // //////////////////////////////////////\n\n    @Override\n    @Programmatic\n    public BigDecimal valueForDate(final LocalDate dueDate) {\n        // use the indexed value on or after the effective date, use the base\n        // otherwise\n        if (getEffectiveDate() == null) {\n            return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n        }\n        if (getStartDate().compareTo(getEffectiveDate()) == 0) {\n            return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n        }\n        if (dueDate.compareTo(getEffectiveDate()) >= 0) {\n            return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n        }\n        return MathUtils.firstNonZero(getBaseValue(), getSettledValue());\n    }\n\n    // ///////////////////////////////////////////\n\n    private Indices indices;\n\n    public final void injectIndices(final Indices indexes) {\n        this.indices = indexes;\n    }\n\n    private IndexationService indexationService;\n\n    public final void injectIndexationService(final IndexationService indexationService) {\n        this.indexationService = indexationService;\n    }\n\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 350,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@javax.jdo.annotations.Column(name = \"indexId\", allowsNull = \"true\")\n@Mandatory\n@Override\npublic Index getIndex() {\n    return index;\n}",
                "name": "getIndex",
                "modifiers": "@javax.jdo.annotations.Column(name = \"indexId\", allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public",
                "return_type": "Index",
                "parameters": [],
                "body": "{\n    return index;\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 52,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setIndex(final Index index) {\n    this.index = index;\n}",
                "name": "setIndex",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Index"
                    }
                ],
                "body": "{\n    this.index = index;\n}",
                "start_point": {
                    "row": 54,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "public List<Index> choicesIndex() {\n    return indices.allIndices();\n}",
                "name": "choicesIndex",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return indices.allIndices();\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n@Mandatory\n@Override\npublic LocalDate getBaseIndexStartDate() {\n    return baseIndexStartDate;\n}",
                "name": "getBaseIndexStartDate",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return baseIndexStartDate;\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setBaseIndexStartDate(final LocalDate baseIndexStartDate) {\n    this.baseIndexStartDate = baseIndexStartDate;\n}",
                "name": "setBaseIndexStartDate",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.baseIndexStartDate = baseIndexStartDate;\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n@Optional\n@Override\npublic BigDecimal getBaseIndexValue() {\n    return baseIndexValue;\n}",
                "name": "getBaseIndexValue",
                "modifiers": "@javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n    @Optional\n    @Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return baseIndexValue;\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setBaseIndexValue(final BigDecimal baseIndexValue) {\n    this.baseIndexValue = baseIndexValue;\n}",
                "name": "setBaseIndexValue",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.baseIndexValue = baseIndexValue;\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n@Mandatory\n@Override\npublic LocalDate getNextIndexStartDate() {\n    return nextIndexStartDate;\n}",
                "name": "getNextIndexStartDate",
                "modifiers": "@javax.jdo.annotations.Column(allowsNull = \"true\")\n    @Mandatory\n    @Override\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return nextIndexStartDate;\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setNextIndexStartDate(final LocalDate nextIndexStartDate) {\n    this.nextIndexStartDate = nextIndexStartDate;\n}",
                "name": "setNextIndexStartDate",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.nextIndexStartDate = nextIndexStartDate;\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n@Optional\n@Override\npublic BigDecimal getNextIndexValue() {\n    return nextIndexValue;\n}",
                "name": "getNextIndexValue",
                "modifiers": "@javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.INDEX_VALUE, allowsNull = \"true\")\n    @Optional\n    @Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return nextIndexValue;\n}",
                "start_point": {
                    "row": 117,
                    "column": 4
                },
                "end_point": {
                    "row": 122,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setNextIndexValue(final BigDecimal nextIndexValue) {\n    this.nextIndexValue = nextIndexValue;\n}",
                "name": "setNextIndexValue",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.nextIndexValue = nextIndexValue;\n}",
                "start_point": {
                    "row": 124,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.REBASE_FACTOR, allowsNull = \"true\")\n@Optional\n@Override\npublic BigDecimal getRebaseFactor() {\n    return rebaseFactor;\n}",
                "name": "getRebaseFactor",
                "modifiers": "@javax.jdo.annotations.Column(scale = JdoColumnScale.IndexValue.REBASE_FACTOR, allowsNull = \"true\")\n    @Optional\n    @Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return rebaseFactor;\n}",
                "start_point": {
                    "row": 133,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setRebaseFactor(final BigDecimal rebaseFactor) {\n    this.rebaseFactor = rebaseFactor;\n\n}",
                "name": "setRebaseFactor",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.rebaseFactor = rebaseFactor;\n\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 144,
                    "column": 5
                }
            },
            {
                "definition": "@Optional\npublic LocalDate getEffectiveDate() {\n    return effectiveDate;\n}",
                "name": "getEffectiveDate",
                "modifiers": "@Optional\n    public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return effectiveDate;\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "public void setEffectiveDate(final LocalDate effectiveDate) {\n    this.effectiveDate = effectiveDate;\n}",
                "name": "setEffectiveDate",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    this.effectiveDate = effectiveDate;\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 158,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n@Optional\n@Override\npublic BigDecimal getIndexationPercentage() {\n    return indexationPercentage;\n}",
                "name": "getIndexationPercentage",
                "modifiers": "@javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n    @Optional\n    @Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return indexationPercentage;\n}",
                "start_point": {
                    "row": 164,
                    "column": 4
                },
                "end_point": {
                    "row": 169,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setIndexationPercentage(final BigDecimal indexationPercentage) {\n    this.indexationPercentage = indexationPercentage;\n}",
                "name": "setIndexationPercentage",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.indexationPercentage = indexationPercentage;\n}",
                "start_point": {
                    "row": 171,
                    "column": 4
                },
                "end_point": {
                    "row": 174,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n@Optional\n@Override\npublic BigDecimal getLevellingPercentage() {\n    return levellingPercentage;\n}",
                "name": "getLevellingPercentage",
                "modifiers": "@javax.jdo.annotations.Column(scale = 1, allowsNull = \"true\")\n    @Optional\n    @Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return levellingPercentage;\n}",
                "start_point": {
                    "row": 180,
                    "column": 4
                },
                "end_point": {
                    "row": 185,
                    "column": 5
                }
            },
            {
                "definition": "public void setLevellingPercentage(final BigDecimal levellingPercentage) {\n    this.levellingPercentage = levellingPercentage;\n}",
                "name": "setLevellingPercentage",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.levellingPercentage = levellingPercentage;\n}",
                "start_point": {
                    "row": 187,
                    "column": 4
                },
                "end_point": {
                    "row": 189,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n@Optional\n@Override\npublic BigDecimal getBaseValue() {\n    return baseValue;\n}",
                "name": "getBaseValue",
                "modifiers": "@javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    @Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return baseValue;\n}",
                "start_point": {
                    "row": 195,
                    "column": 4
                },
                "end_point": {
                    "row": 200,
                    "column": 5
                }
            },
            {
                "definition": "public void setBaseValue(final BigDecimal baseValue) {\n    this.baseValue = baseValue;\n}",
                "name": "setBaseValue",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.baseValue = baseValue;\n}",
                "start_point": {
                    "row": 202,
                    "column": 4
                },
                "end_point": {
                    "row": 204,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n@Optional\n@Override\npublic BigDecimal getIndexedValue() {\n    return indexedValue;\n}",
                "name": "getIndexedValue",
                "modifiers": "@javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    @Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return indexedValue;\n}",
                "start_point": {
                    "row": 210,
                    "column": 4
                },
                "end_point": {
                    "row": 215,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setIndexedValue(final BigDecimal indexedValue) {\n    this.indexedValue = indexedValue;\n}",
                "name": "setIndexedValue",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.indexedValue = indexedValue;\n}",
                "start_point": {
                    "row": 217,
                    "column": 4
                },
                "end_point": {
                    "row": 220,
                    "column": 5
                }
            },
            {
                "definition": "@javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n@Optional\npublic BigDecimal getSettledValue() {\n    return settledValue;\n}",
                "name": "getSettledValue",
                "modifiers": "@javax.jdo.annotations.Column(scale = 2, allowsNull = \"true\")\n    @Optional\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return settledValue;\n}",
                "start_point": {
                    "row": 226,
                    "column": 4
                },
                "end_point": {
                    "row": 230,
                    "column": 5
                }
            },
            {
                "definition": "public void setSettledValue(final BigDecimal settledValue) {\n    this.settledValue = settledValue;\n}",
                "name": "setSettledValue",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "BigDecimal"
                    }
                ],
                "body": "{\n    this.settledValue = settledValue;\n}",
                "start_point": {
                    "row": 232,
                    "column": 4
                },
                "end_point": {
                    "row": 234,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic BigDecimal getApprovedValue() {\n    return getStatus().isApproved() ? getTrialValue() : null;\n}",
                "name": "getApprovedValue",
                "modifiers": "@Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return getStatus().isApproved() ? getTrialValue() : null;\n}",
                "start_point": {
                    "row": 236,
                    "column": 4
                },
                "end_point": {
                    "row": 239,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic BigDecimal getTrialValue() {\n    return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n}",
                "name": "getTrialValue",
                "modifiers": "@Override\n    public",
                "return_type": "BigDecimal",
                "parameters": [],
                "body": "{\n    return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n}",
                "start_point": {
                    "row": 243,
                    "column": 4
                },
                "end_point": {
                    "row": 246,
                    "column": 5
                }
            },
            {
                "definition": "@Override\n@Programmatic\npublic void initialize() {\n    super.initialize();\n    final LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n    if (previousTerm != null) {\n        LeaseTermFrequency frequency = previousTerm.getFrequency();\n        if (frequency != null) {\n            setIndex(previousTerm.getIndex());\n            setBaseIndexStartDate(previousTerm.getNextIndexStartDate());\n            setNextIndexStartDate(frequency.nextDate(previousTerm.getNextIndexStartDate()));\n            setEffectiveDate(frequency.nextDate(previousTerm.getEffectiveDate()));\n            setBaseValue(previousTerm.getSettledValue());\n            setLevellingPercentage(previousTerm.getLevellingPercentage());\n        }\n    }\n\n}",
                "name": "initialize",
                "modifiers": "@Override\n    @Programmatic\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    super.initialize();\n    final LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n    if (previousTerm != null) {\n        LeaseTermFrequency frequency = previousTerm.getFrequency();\n        if (frequency != null) {\n            setIndex(previousTerm.getIndex());\n            setBaseIndexStartDate(previousTerm.getNextIndexStartDate());\n            setNextIndexStartDate(frequency.nextDate(previousTerm.getNextIndexStartDate()));\n            setEffectiveDate(frequency.nextDate(previousTerm.getEffectiveDate()));\n            setBaseValue(previousTerm.getSettledValue());\n            setLevellingPercentage(previousTerm.getLevellingPercentage());\n        }\n    }\n\n}",
                "start_point": {
                    "row": 250,
                    "column": 4
                },
                "end_point": {
                    "row": 267,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isIndexable() {\n    return getSettledValue() == null \n            && getIndexedValue() == null\n            && (getBaseIndexStartDate() != null && getNextIndexStartDate() != null)\n            && (getBaseIndexStartDate().compareTo(getNextIndexStartDate()) < 0);\n}",
                "name": "isIndexable",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return getSettledValue() == null \n            && getIndexedValue() == null\n            && (getBaseIndexStartDate() != null && getNextIndexStartDate() != null)\n            && (getBaseIndexStartDate().compareTo(getNextIndexStartDate()) < 0);\n}",
                "start_point": {
                    "row": 271,
                    "column": 4
                },
                "end_point": {
                    "row": 276,
                    "column": 5
                }
            },
            {
                "definition": "@Programmatic\n@Override\npublic void update() {\n    super.update();\n    if (isIndexable()) {\n        LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n        if (previousTerm != null) {\n            BigDecimal newBaseValue = MathUtils.firstNonZero(\n                    previousTerm.getIndexedValue(),\n                    previousTerm.getBaseValue());\n            if (getBaseValue() == null || newBaseValue.compareTo(getBaseValue()) != 0) {\n                setBaseValue(newBaseValue);\n            }\n        }\n        indexationService.indexate(this);\n    }\n}",
                "name": "update",
                "modifiers": "@Programmatic\n    @Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    super.update();\n    if (isIndexable()) {\n        LeaseTermForIndexableRent previousTerm = (LeaseTermForIndexableRent) getPrevious();\n        if (previousTerm != null) {\n            BigDecimal newBaseValue = MathUtils.firstNonZero(\n                    previousTerm.getIndexedValue(),\n                    previousTerm.getBaseValue());\n            if (getBaseValue() == null || newBaseValue.compareTo(getBaseValue()) != 0) {\n                setBaseValue(newBaseValue);\n            }\n        }\n        indexationService.indexate(this);\n    }\n}",
                "start_point": {
                    "row": 280,
                    "column": 4
                },
                "end_point": {
                    "row": 296,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void copyValuesTo(final LeaseTerm target) {\n    LeaseTermForIndexableRent t = (LeaseTermForIndexableRent) target;\n    super.copyValuesTo(t);\n    t.setIndex(getIndex());\n    t.setBaseIndexStartDate(getBaseIndexStartDate());\n    t.setBaseIndexValue(getBaseIndexValue());\n    t.setNextIndexStartDate(getNextIndexStartDate());\n    t.setNextIndexValue(getNextIndexValue());\n    t.setEffectiveDate(getEffectiveDate());\n    t.setIndexationPercentage(getIndexationPercentage());\n    t.setLevellingPercentage(getLevellingPercentage());\n    t.setBaseValue(getBaseValue());\n    t.setIndexedValue(getIndexedValue());\n    t.setSettledValue(getSettledValue());\n}",
                "name": "copyValuesTo",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LeaseTerm"
                    }
                ],
                "body": "{\n    LeaseTermForIndexableRent t = (LeaseTermForIndexableRent) target;\n    super.copyValuesTo(t);\n    t.setIndex(getIndex());\n    t.setBaseIndexStartDate(getBaseIndexStartDate());\n    t.setBaseIndexValue(getBaseIndexValue());\n    t.setNextIndexStartDate(getNextIndexStartDate());\n    t.setNextIndexValue(getNextIndexValue());\n    t.setEffectiveDate(getEffectiveDate());\n    t.setIndexationPercentage(getIndexationPercentage());\n    t.setLevellingPercentage(getLevellingPercentage());\n    t.setBaseValue(getBaseValue());\n    t.setIndexedValue(getIndexedValue());\n    t.setSettledValue(getSettledValue());\n}",
                "start_point": {
                    "row": 300,
                    "column": 4
                },
                "end_point": {
                    "row": 315,
                    "column": 5
                }
            },
            {
                "definition": "@Override\n@Programmatic\npublic BigDecimal valueForDate(final LocalDate dueDate) {\n    // use the indexed value on or after the effective date, use the base\n    // otherwise\n    if (getEffectiveDate() == null) {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n    if (getStartDate().compareTo(getEffectiveDate()) == 0) {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n    if (dueDate.compareTo(getEffectiveDate()) >= 0) {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n    return MathUtils.firstNonZero(getBaseValue(), getSettledValue());\n}",
                "name": "valueForDate",
                "modifiers": "@Override\n    @Programmatic\n    public",
                "return_type": "BigDecimal",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    // use the indexed value on or after the effective date, use the base\n    // otherwise\n    if (getEffectiveDate() == null) {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n    if (getStartDate().compareTo(getEffectiveDate()) == 0) {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n    if (dueDate.compareTo(getEffectiveDate()) >= 0) {\n        return MathUtils.firstNonZero(getSettledValue(), getIndexedValue(), getBaseValue());\n    }\n    return MathUtils.firstNonZero(getBaseValue(), getSettledValue());\n}",
                "start_point": {
                    "row": 319,
                    "column": 4
                },
                "end_point": {
                    "row": 334,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectIndices(final Indices indexes) {\n    this.indices = indexes;\n}",
                "name": "injectIndices",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Indices"
                    }
                ],
                "body": "{\n    this.indices = indexes;\n}",
                "start_point": {
                    "row": 340,
                    "column": 4
                },
                "end_point": {
                    "row": 342,
                    "column": 5
                }
            },
            {
                "definition": "public final void injectIndexationService(final IndexationService indexationService) {\n    this.indexationService = indexationService;\n}",
                "name": "injectIndexationService",
                "modifiers": "public final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "IndexationService"
                    }
                ],
                "body": "{\n    this.indexationService = indexationService;\n}",
                "start_point": {
                    "row": 346,
                    "column": 4
                },
                "end_point": {
                    "row": 348,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dom/src/main/java/org/estatio/dom/valuetypes/LocalDateInterval.java",
        "definition": "public final class LocalDateInterval {\n\n    private Long startInstant;\n    private Long endInstant;\n    private static final IntervalEnding PERSISTENT_ENDING = IntervalEnding.INCLUDING_END_DATE;\n\n    public enum IntervalEnding {\n        INCLUDING_END_DATE, EXCLUDING_END_DATE\n    }\n\n    public static LocalDateInterval excluding(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public static LocalDateInterval including(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n    }\n\n    public LocalDateInterval(final LocalDate startDate, final LocalDate endDate, final IntervalEnding ending) {\n        startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n        endInstant = endDate == null\n                ? null\n                : ending == IntervalEnding.EXCLUDING_END_DATE\n                        ? endDate.toInterval().getStartMillis()\n                        : endDate.toInterval().getEndMillis();\n    }\n\n    public LocalDateInterval() {\n    }\n\n    public LocalDateInterval(final Interval interval) {\n        if (interval != null) {\n            startInstant = interval.getStartMillis();\n            endInstant = interval.getEndMillis();\n        }\n    }\n\n    public Interval asInterval() {\n        return new Interval(\n                startInstant == null ? 0 : startInstant,\n                endInstant == null ? Long.MAX_VALUE : endInstant);\n    }\n\n    public LocalDate startDate() {\n        if (startInstant == null) {\n            return null;\n        }\n        return new LocalDate(startInstant);\n    }\n\n    public LocalDate endDate() {\n        return endDate(PERSISTENT_ENDING);\n    }\n\n    public LocalDate endDate(final IntervalEnding ending) {\n        if (endInstant == null) {\n            return null;\n        }\n        LocalDate date = new LocalDate(endInstant);\n        return adjustDate(date, ending);\n    }\n\n    public LocalDate endDateExcluding() {\n        return endDate(IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public LocalDate endDateFromStartDate() {\n        return adjustDate(startDate(), PERSISTENT_ENDING);\n    }\n\n    private LocalDate adjustDate(final LocalDate date, final IntervalEnding ending) {\n        return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param localDateInterval\n     * @return\n     */\n    public boolean contains(final LocalDateInterval localDateInterval) {\n        return asInterval().contains(localDateInterval.asInterval());\n    }\n\n    /**\n     * Does this date contain the specified time interval.\n     * \n     * @param date\n     * @return\n     */\n    public boolean contains(final LocalDate date) {\n        if (endDate() == null) {\n            if (startDate() == null) {\n                return true;\n            }\n            if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n                return true;\n            }\n            return false;\n        }\n        return asInterval().contains(date.toInterval());\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param interval\n     * @return\n     */\n    public boolean overlaps(final LocalDateInterval interval) {\n        return asInterval().overlaps(interval.asInterval());\n    }\n\n    /**\n     * Gets the overlap between this interval and another interval.\n     * \n     * @param otherInterval\n     * @return\n     */\n    public LocalDateInterval overlap(final LocalDateInterval otherInterval) {\n        if (otherInterval == null || otherInterval.isInfinite()) {\n            return this;\n        }\n        final Interval thisAsInterval = asInterval();\n        final Interval otherAsInterval = otherInterval.asInterval();\n        Interval overlap = thisAsInterval.overlap(otherAsInterval);\n        if (overlap == null) {\n            return new LocalDateInterval();\n        }\n        return new LocalDateInterval(overlap);\n    }\n\n    /**\n     * Does this interval is within the specified interval\n     * \n     * @param interval\n     * @return\n     */\n    public boolean within(final LocalDateInterval interval) {\n        return interval.asInterval().contains(asInterval());\n    }\n\n    /**\n     * The duration in days\n     * \n     * @return\n     */\n    public int days() {\n        if (isInfinite()){\n            return 0;\n        }\n        Period p = new Period(asInterval(), PeriodType.days());\n        return p.getDays();\n    }\n\n    private boolean isInfinite() {\n        return startInstant == null && endInstant == null;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder =\n                new StringBuilder(\n                        startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                        endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n        return builder.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        // TODO: use Isis' ObjectContracts?\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LocalDateInterval)) {\n            return false;\n        }\n        LocalDateInterval rhs = (LocalDateInterval) obj;\n        return new EqualsBuilder().\n                append(startInstant, rhs.startInstant).\n                append(endInstant, rhs.endInstant).\n                isEquals();\n    }\n}",
        "package": "package org.estatio.dom.valuetypes;",
        "tree_path": "LocalDateInterval",
        "name": "LocalDateInterval",
        "modifiers": "public final",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private Long startInstant;\n    private Long endInstant;\n    private static final IntervalEnding PERSISTENT_ENDING = IntervalEnding.INCLUDING_END_DATE;\n\n    public enum IntervalEnding {\n        INCLUDING_END_DATE, EXCLUDING_END_DATE\n    }\n\n    public static LocalDateInterval excluding(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public static LocalDateInterval including(final LocalDate startDate, final LocalDate endDate) {\n        return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n    }\n\n    public LocalDateInterval(final LocalDate startDate, final LocalDate endDate, final IntervalEnding ending) {\n        startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n        endInstant = endDate == null\n                ? null\n                : ending == IntervalEnding.EXCLUDING_END_DATE\n                        ? endDate.toInterval().getStartMillis()\n                        : endDate.toInterval().getEndMillis();\n    }\n\n    public LocalDateInterval() {\n    }\n\n    public LocalDateInterval(final Interval interval) {\n        if (interval != null) {\n            startInstant = interval.getStartMillis();\n            endInstant = interval.getEndMillis();\n        }\n    }\n\n    public Interval asInterval() {\n        return new Interval(\n                startInstant == null ? 0 : startInstant,\n                endInstant == null ? Long.MAX_VALUE : endInstant);\n    }\n\n    public LocalDate startDate() {\n        if (startInstant == null) {\n            return null;\n        }\n        return new LocalDate(startInstant);\n    }\n\n    public LocalDate endDate() {\n        return endDate(PERSISTENT_ENDING);\n    }\n\n    public LocalDate endDate(final IntervalEnding ending) {\n        if (endInstant == null) {\n            return null;\n        }\n        LocalDate date = new LocalDate(endInstant);\n        return adjustDate(date, ending);\n    }\n\n    public LocalDate endDateExcluding() {\n        return endDate(IntervalEnding.EXCLUDING_END_DATE);\n    }\n\n    public LocalDate endDateFromStartDate() {\n        return adjustDate(startDate(), PERSISTENT_ENDING);\n    }\n\n    private LocalDate adjustDate(final LocalDate date, final IntervalEnding ending) {\n        return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param localDateInterval\n     * @return\n     */\n    public boolean contains(final LocalDateInterval localDateInterval) {\n        return asInterval().contains(localDateInterval.asInterval());\n    }\n\n    /**\n     * Does this date contain the specified time interval.\n     * \n     * @param date\n     * @return\n     */\n    public boolean contains(final LocalDate date) {\n        if (endDate() == null) {\n            if (startDate() == null) {\n                return true;\n            }\n            if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n                return true;\n            }\n            return false;\n        }\n        return asInterval().contains(date.toInterval());\n    }\n\n    /**\n     * Does this time interval contain the specified time interval.\n     * \n     * @param interval\n     * @return\n     */\n    public boolean overlaps(final LocalDateInterval interval) {\n        return asInterval().overlaps(interval.asInterval());\n    }\n\n    /**\n     * Gets the overlap between this interval and another interval.\n     * \n     * @param otherInterval\n     * @return\n     */\n    public LocalDateInterval overlap(final LocalDateInterval otherInterval) {\n        if (otherInterval == null || otherInterval.isInfinite()) {\n            return this;\n        }\n        final Interval thisAsInterval = asInterval();\n        final Interval otherAsInterval = otherInterval.asInterval();\n        Interval overlap = thisAsInterval.overlap(otherAsInterval);\n        if (overlap == null) {\n            return new LocalDateInterval();\n        }\n        return new LocalDateInterval(overlap);\n    }\n\n    /**\n     * Does this interval is within the specified interval\n     * \n     * @param interval\n     * @return\n     */\n    public boolean within(final LocalDateInterval interval) {\n        return interval.asInterval().contains(asInterval());\n    }\n\n    /**\n     * The duration in days\n     * \n     * @return\n     */\n    public int days() {\n        if (isInfinite()){\n            return 0;\n        }\n        Period p = new Period(asInterval(), PeriodType.days());\n        return p.getDays();\n    }\n\n    private boolean isInfinite() {\n        return startInstant == null && endInstant == null;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder =\n                new StringBuilder(\n                        startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                        endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n        return builder.toString();\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        // TODO: use Isis' ObjectContracts?\n        if (obj == null) {\n            return false;\n        }\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof LocalDateInterval)) {\n            return false;\n        }\n        LocalDateInterval rhs = (LocalDateInterval) obj;\n        return new EqualsBuilder().\n                append(startInstant, rhs.startInstant).\n                append(endInstant, rhs.endInstant).\n                isEquals();\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 213,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public static LocalDateInterval excluding(final LocalDate startDate, final LocalDate endDate) {\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n}",
                "name": "excluding",
                "modifiers": "public static",
                "return_type": "LocalDateInterval",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.EXCLUDING_END_DATE);\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 38,
                    "column": 5
                }
            },
            {
                "definition": "public static LocalDateInterval including(final LocalDate startDate, final LocalDate endDate) {\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n}",
                "name": "including",
                "modifiers": "public static",
                "return_type": "LocalDateInterval",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    return new LocalDateInterval(startDate, endDate, IntervalEnding.INCLUDING_END_DATE);\n}",
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 42,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval(final LocalDate startDate, final LocalDate endDate, final IntervalEnding ending) {\n    startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n    endInstant = endDate == null\n            ? null\n            : ending == IntervalEnding.EXCLUDING_END_DATE\n                    ? endDate.toInterval().getStartMillis()\n                    : endDate.toInterval().getEndMillis();\n}",
                "name": "LocalDateInterval",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "IntervalEnding"
                    }
                ],
                "body": "{\n    startInstant = startDate == null ? null : startDate.toInterval().getStartMillis();\n    endInstant = endDate == null\n            ? null\n            : ending == IntervalEnding.EXCLUDING_END_DATE\n                    ? endDate.toInterval().getStartMillis()\n                    : endDate.toInterval().getEndMillis();\n}",
                "constructor": true,
                "start_point": {
                    "row": 44,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval() {\n}",
                "name": "LocalDateInterval",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval(final Interval interval) {\n    if (interval != null) {\n        startInstant = interval.getStartMillis();\n        endInstant = interval.getEndMillis();\n    }\n}",
                "name": "LocalDateInterval",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "final",
                        "name": "Interval"
                    }
                ],
                "body": "{\n    if (interval != null) {\n        startInstant = interval.getStartMillis();\n        endInstant = interval.getEndMillis();\n    }\n}",
                "constructor": true,
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "public Interval asInterval() {\n    return new Interval(\n            startInstant == null ? 0 : startInstant,\n            endInstant == null ? Long.MAX_VALUE : endInstant);\n}",
                "name": "asInterval",
                "modifiers": "public",
                "return_type": "Interval",
                "parameters": [],
                "body": "{\n    return new Interval(\n            startInstant == null ? 0 : startInstant,\n            endInstant == null ? Long.MAX_VALUE : endInstant);\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 67,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate startDate() {\n    if (startInstant == null) {\n        return null;\n    }\n    return new LocalDate(startInstant);\n}",
                "name": "startDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    if (startInstant == null) {\n        return null;\n    }\n    return new LocalDate(startInstant);\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDate() {\n    return endDate(PERSISTENT_ENDING);\n}",
                "name": "endDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return endDate(PERSISTENT_ENDING);\n}",
                "start_point": {
                    "row": 76,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDate(final IntervalEnding ending) {\n    if (endInstant == null) {\n        return null;\n    }\n    LocalDate date = new LocalDate(endInstant);\n    return adjustDate(date, ending);\n}",
                "name": "endDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [
                    {
                        "type": "final",
                        "name": "IntervalEnding"
                    }
                ],
                "body": "{\n    if (endInstant == null) {\n        return null;\n    }\n    LocalDate date = new LocalDate(endInstant);\n    return adjustDate(date, ending);\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 86,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDateExcluding() {\n    return endDate(IntervalEnding.EXCLUDING_END_DATE);\n}",
                "name": "endDateExcluding",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return endDate(IntervalEnding.EXCLUDING_END_DATE);\n}",
                "start_point": {
                    "row": 88,
                    "column": 4
                },
                "end_point": {
                    "row": 90,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDate endDateFromStartDate() {\n    return adjustDate(startDate(), PERSISTENT_ENDING);\n}",
                "name": "endDateFromStartDate",
                "modifiers": "public",
                "return_type": "LocalDate",
                "parameters": [],
                "body": "{\n    return adjustDate(startDate(), PERSISTENT_ENDING);\n}",
                "start_point": {
                    "row": 92,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "private LocalDate adjustDate(final LocalDate date, final IntervalEnding ending) {\n    return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n}",
                "name": "adjustDate",
                "modifiers": "private",
                "return_type": "LocalDate",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    },
                    {
                        "type": "final",
                        "name": "IntervalEnding"
                    }
                ],
                "body": "{\n    return ending == IntervalEnding.INCLUDING_END_DATE ? date.minusDays(1) : date;\n\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            },
            {
                "definition": "public boolean contains(final LocalDateInterval localDateInterval) {\n    return asInterval().contains(localDateInterval.asInterval());\n}",
                "name": "contains",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    return asInterval().contains(localDateInterval.asInterval());\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "public boolean contains(final LocalDate date) {\n    if (endDate() == null) {\n        if (startDate() == null) {\n            return true;\n        }\n        if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n            return true;\n        }\n        return false;\n    }\n    return asInterval().contains(date.toInterval());\n}",
                "name": "contains",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDate"
                    }
                ],
                "body": "{\n    if (endDate() == null) {\n        if (startDate() == null) {\n            return true;\n        }\n        if (date.isEqual(startDate()) || date.isAfter(startDate())) {\n            return true;\n        }\n        return false;\n    }\n    return asInterval().contains(date.toInterval());\n}",
                "start_point": {
                    "row": 117,
                    "column": 4
                },
                "end_point": {
                    "row": 128,
                    "column": 5
                }
            },
            {
                "definition": "public boolean overlaps(final LocalDateInterval interval) {\n    return asInterval().overlaps(interval.asInterval());\n}",
                "name": "overlaps",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    return asInterval().overlaps(interval.asInterval());\n}",
                "start_point": {
                    "row": 136,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "public LocalDateInterval overlap(final LocalDateInterval otherInterval) {\n    if (otherInterval == null || otherInterval.isInfinite()) {\n        return this;\n    }\n    final Interval thisAsInterval = asInterval();\n    final Interval otherAsInterval = otherInterval.asInterval();\n    Interval overlap = thisAsInterval.overlap(otherAsInterval);\n    if (overlap == null) {\n        return new LocalDateInterval();\n    }\n    return new LocalDateInterval(overlap);\n}",
                "name": "overlap",
                "modifiers": "public",
                "return_type": "LocalDateInterval",
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    if (otherInterval == null || otherInterval.isInfinite()) {\n        return this;\n    }\n    final Interval thisAsInterval = asInterval();\n    final Interval otherAsInterval = otherInterval.asInterval();\n    Interval overlap = thisAsInterval.overlap(otherAsInterval);\n    if (overlap == null) {\n        return new LocalDateInterval();\n    }\n    return new LocalDateInterval(overlap);\n}",
                "start_point": {
                    "row": 146,
                    "column": 4
                },
                "end_point": {
                    "row": 157,
                    "column": 5
                }
            },
            {
                "definition": "public boolean within(final LocalDateInterval interval) {\n    return interval.asInterval().contains(asInterval());\n}",
                "name": "within",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "LocalDateInterval"
                    }
                ],
                "body": "{\n    return interval.asInterval().contains(asInterval());\n}",
                "start_point": {
                    "row": 165,
                    "column": 4
                },
                "end_point": {
                    "row": 167,
                    "column": 5
                }
            },
            {
                "definition": "public int days() {\n    if (isInfinite()){\n        return 0;\n    }\n    Period p = new Period(asInterval(), PeriodType.days());\n    return p.getDays();\n}",
                "name": "days",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    if (isInfinite()){\n        return 0;\n    }\n    Period p = new Period(asInterval(), PeriodType.days());\n    return p.getDays();\n}",
                "start_point": {
                    "row": 174,
                    "column": 4
                },
                "end_point": {
                    "row": 180,
                    "column": 5
                }
            },
            {
                "definition": "private boolean isInfinite() {\n    return startInstant == null && endInstant == null;\n}",
                "name": "isInfinite",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return startInstant == null && endInstant == null;\n}",
                "start_point": {
                    "row": 182,
                    "column": 4
                },
                "end_point": {
                    "row": 184,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    StringBuilder builder =\n            new StringBuilder(\n                    startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                    endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n    return builder.toString();\n}",
                "name": "toString",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    StringBuilder builder =\n            new StringBuilder(\n                    startDate() == null ? \"----------\" : startDate().toString(\"yyyy-MM-dd\")).append(\"/\").append(\n                    endDate() == null ? \"----------\" : endDate().toString(\"yyyy-MM-dd\"));\n    return builder.toString();\n}",
                "start_point": {
                    "row": 186,
                    "column": 4
                },
                "end_point": {
                    "row": 193,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(final Object obj) {\n    // TODO: use Isis' ObjectContracts?\n    if (obj == null) {\n        return false;\n    }\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof LocalDateInterval)) {\n        return false;\n    }\n    LocalDateInterval rhs = (LocalDateInterval) obj;\n    return new EqualsBuilder().\n            append(startInstant, rhs.startInstant).\n            append(endInstant, rhs.endInstant).\n            isEquals();\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Object"
                    }
                ],
                "body": "{\n    // TODO: use Isis' ObjectContracts?\n    if (obj == null) {\n        return false;\n    }\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof LocalDateInterval)) {\n        return false;\n    }\n    LocalDateInterval rhs = (LocalDateInterval) obj;\n    return new EqualsBuilder().\n            append(startInstant, rhs.startInstant).\n            append(endInstant, rhs.endInstant).\n            isEquals();\n}",
                "start_point": {
                    "row": 195,
                    "column": 4
                },
                "end_point": {
                    "row": 212,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dom/src/test/java/org/estatio/dom/invoice/viewmodel/InvoiceSummaryForPropertyDueDateTest_viewModelInit.java",
        "definition": "public class InvoiceSummaryForPropertyDueDateTest_viewModelInit {\n\n    @Rule\n    public JUnitRuleMockery2 context = JUnitRuleMockery2.createFor(Mode.INTERFACES_ONLY);\n\n    @Mock\n    private ViewModelSupport viewModelSupport;\n    \n    @Mock\n    private ViewModelSupport.Memento viewModelSupportMemento;\n    \n\n    private InvoiceSummaryForPropertyDueDate viewModel;\n\n    @Before\n    public void setUp() throws Exception {\n        viewModel = new InvoiceSummaryForPropertyDueDate();\n        viewModel.injectViewModelSupport(viewModelSupport);\n        \n        viewModel.setReference(\"OXF\");\n        viewModel.setDueDate(new LocalDate(2013,4,1));\n        viewModel.setNetAmount(new BigDecimal(\"10.00\"));\n        viewModel.setVatAmount(new BigDecimal(\"1.75\"));\n        viewModel.setGrossAmount(new BigDecimal(\"11.75\"));\n        viewModel.setTotal(123);\n    }\n\n    @Test\n    public void memento() {\n        \n        context.checking(new Expectations() {\n            {\n                oneOf(viewModelSupport).create();\n                will(returnValue(viewModelSupportMemento));\n                \n                oneOf(viewModelSupportMemento).set(\"reference\", \"OXF\");\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"dueDate\", new LocalDate(2013,4,1));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"netAmount\", new BigDecimal(\"10.00\"));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"vatAmount\", new BigDecimal(\"1.75\"));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"grossAmount\", new BigDecimal(\"11.75\"));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"total\", 123);\n                will(returnValue(viewModelSupportMemento));\n                \n                oneOf(viewModelSupportMemento).asString();\n                will(returnValue(\"encodedXml\"));\n            }\n        });\n        \n        assertThat(viewModel.viewModelMemento(), is(\"encodedXml\"));\n    }\n\n    @Test\n    public void init() {\n        \n        context.checking(new Expectations() {\n            {\n                oneOf(viewModelSupport).parse(\"encodedXml\");\n                will(returnValue(viewModelSupportMemento));\n                \n                oneOf(viewModelSupportMemento).get(\"reference\", String.class);\n                will(returnValue(\"OXF\"));\n                oneOf(viewModelSupportMemento).get(\"dueDate\", LocalDate.class);\n                will(returnValue(new LocalDate(2013,4,1)));\n                oneOf(viewModelSupportMemento).get(\"netAmount\", BigDecimal.class);\n                will(returnValue(new BigDecimal(\"10.00\")));\n                oneOf(viewModelSupportMemento).get(\"vatAmount\", BigDecimal.class);\n                will(returnValue(new BigDecimal(\"1.75\")));\n                oneOf(viewModelSupportMemento).get(\"grossAmount\", BigDecimal.class);\n                will(returnValue(new BigDecimal(\"11.75\")));\n                oneOf(viewModelSupportMemento).get(\"total\", Integer.class);\n                will(returnValue(123));\n            }\n        });\n        \n        viewModel.viewModelInit(\"encodedXml\");\n        \n        assertThat(viewModel.getReference(), is(\"OXF\"));\n        assertThat(viewModel.getDueDate(), is(new LocalDate(2013,4,1)));\n        assertThat(viewModel.getNetAmount(), is(new BigDecimal(\"10.00\")));\n        assertThat(viewModel.getVatAmount(), is(new BigDecimal(\"1.75\")));\n        assertThat(viewModel.getGrossAmount(), is(new BigDecimal(\"11.75\")));\n        assertThat(viewModel.getTotal(), is(123));\n\n    }\n}",
        "package": "package org.estatio.dom.invoice.viewmodel;",
        "tree_path": "InvoiceSummaryForPropertyDueDateTest_viewModelInit",
        "name": "InvoiceSummaryForPropertyDueDateTest_viewModelInit",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @Rule\n    public JUnitRuleMockery2 context = JUnitRuleMockery2.createFor(Mode.INTERFACES_ONLY);\n\n    @Mock\n    private ViewModelSupport viewModelSupport;\n    \n    @Mock\n    private ViewModelSupport.Memento viewModelSupportMemento;\n    \n\n    private InvoiceSummaryForPropertyDueDate viewModel;\n\n    @Before\n    public void setUp() throws Exception {\n        viewModel = new InvoiceSummaryForPropertyDueDate();\n        viewModel.injectViewModelSupport(viewModelSupport);\n        \n        viewModel.setReference(\"OXF\");\n        viewModel.setDueDate(new LocalDate(2013,4,1));\n        viewModel.setNetAmount(new BigDecimal(\"10.00\"));\n        viewModel.setVatAmount(new BigDecimal(\"1.75\"));\n        viewModel.setGrossAmount(new BigDecimal(\"11.75\"));\n        viewModel.setTotal(123);\n    }\n\n    @Test\n    public void memento() {\n        \n        context.checking(new Expectations() {\n            {\n                oneOf(viewModelSupport).create();\n                will(returnValue(viewModelSupportMemento));\n                \n                oneOf(viewModelSupportMemento).set(\"reference\", \"OXF\");\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"dueDate\", new LocalDate(2013,4,1));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"netAmount\", new BigDecimal(\"10.00\"));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"vatAmount\", new BigDecimal(\"1.75\"));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"grossAmount\", new BigDecimal(\"11.75\"));\n                will(returnValue(viewModelSupportMemento));\n                oneOf(viewModelSupportMemento).set(\"total\", 123);\n                will(returnValue(viewModelSupportMemento));\n                \n                oneOf(viewModelSupportMemento).asString();\n                will(returnValue(\"encodedXml\"));\n            }\n        });\n        \n        assertThat(viewModel.viewModelMemento(), is(\"encodedXml\"));\n    }\n\n    @Test\n    public void init() {\n        \n        context.checking(new Expectations() {\n            {\n                oneOf(viewModelSupport).parse(\"encodedXml\");\n                will(returnValue(viewModelSupportMemento));\n                \n                oneOf(viewModelSupportMemento).get(\"reference\", String.class);\n                will(returnValue(\"OXF\"));\n                oneOf(viewModelSupportMemento).get(\"dueDate\", LocalDate.class);\n                will(returnValue(new LocalDate(2013,4,1)));\n                oneOf(viewModelSupportMemento).get(\"netAmount\", BigDecimal.class);\n                will(returnValue(new BigDecimal(\"10.00\")));\n                oneOf(viewModelSupportMemento).get(\"vatAmount\", BigDecimal.class);\n                will(returnValue(new BigDecimal(\"1.75\")));\n                oneOf(viewModelSupportMemento).get(\"grossAmount\", BigDecimal.class);\n                will(returnValue(new BigDecimal(\"11.75\")));\n                oneOf(viewModelSupportMemento).get(\"total\", Integer.class);\n                will(returnValue(123));\n            }\n        });\n        \n        viewModel.viewModelInit(\"encodedXml\");\n        \n        assertThat(viewModel.getReference(), is(\"OXF\"));\n        assertThat(viewModel.getDueDate(), is(new LocalDate(2013,4,1)));\n        assertThat(viewModel.getNetAmount(), is(new BigDecimal(\"10.00\")));\n        assertThat(viewModel.getVatAmount(), is(new BigDecimal(\"1.75\")));\n        assertThat(viewModel.getGrossAmount(), is(new BigDecimal(\"11.75\")));\n        assertThat(viewModel.getTotal(), is(123));\n\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 123,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Before\npublic void setUp() throws Exception {\n    viewModel = new InvoiceSummaryForPropertyDueDate();\n    viewModel.injectViewModelSupport(viewModelSupport);\n    \n    viewModel.setReference(\"OXF\");\n    viewModel.setDueDate(new LocalDate(2013,4,1));\n    viewModel.setNetAmount(new BigDecimal(\"10.00\"));\n    viewModel.setVatAmount(new BigDecimal(\"1.75\"));\n    viewModel.setGrossAmount(new BigDecimal(\"11.75\"));\n    viewModel.setTotal(123);\n}",
                "name": "setUp",
                "modifiers": "@Before\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    viewModel = new InvoiceSummaryForPropertyDueDate();\n    viewModel.injectViewModelSupport(viewModelSupport);\n    \n    viewModel.setReference(\"OXF\");\n    viewModel.setDueDate(new LocalDate(2013,4,1));\n    viewModel.setNetAmount(new BigDecimal(\"10.00\"));\n    viewModel.setVatAmount(new BigDecimal(\"1.75\"));\n    viewModel.setGrossAmount(new BigDecimal(\"11.75\"));\n    viewModel.setTotal(123);\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 59,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void memento() {\n    \n    context.checking(new Expectations() {\n        {\n            oneOf(viewModelSupport).create();\n            will(returnValue(viewModelSupportMemento));\n            \n            oneOf(viewModelSupportMemento).set(\"reference\", \"OXF\");\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"dueDate\", new LocalDate(2013,4,1));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"netAmount\", new BigDecimal(\"10.00\"));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"vatAmount\", new BigDecimal(\"1.75\"));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"grossAmount\", new BigDecimal(\"11.75\"));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"total\", 123);\n            will(returnValue(viewModelSupportMemento));\n            \n            oneOf(viewModelSupportMemento).asString();\n            will(returnValue(\"encodedXml\"));\n        }\n    });\n    \n    assertThat(viewModel.viewModelMemento(), is(\"encodedXml\"));\n}",
                "name": "memento",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    \n    context.checking(new Expectations() {\n        {\n            oneOf(viewModelSupport).create();\n            will(returnValue(viewModelSupportMemento));\n            \n            oneOf(viewModelSupportMemento).set(\"reference\", \"OXF\");\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"dueDate\", new LocalDate(2013,4,1));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"netAmount\", new BigDecimal(\"10.00\"));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"vatAmount\", new BigDecimal(\"1.75\"));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"grossAmount\", new BigDecimal(\"11.75\"));\n            will(returnValue(viewModelSupportMemento));\n            oneOf(viewModelSupportMemento).set(\"total\", 123);\n            will(returnValue(viewModelSupportMemento));\n            \n            oneOf(viewModelSupportMemento).asString();\n            will(returnValue(\"encodedXml\"));\n        }\n    });\n    \n    assertThat(viewModel.viewModelMemento(), is(\"encodedXml\"));\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void init() {\n    \n    context.checking(new Expectations() {\n        {\n            oneOf(viewModelSupport).parse(\"encodedXml\");\n            will(returnValue(viewModelSupportMemento));\n            \n            oneOf(viewModelSupportMemento).get(\"reference\", String.class);\n            will(returnValue(\"OXF\"));\n            oneOf(viewModelSupportMemento).get(\"dueDate\", LocalDate.class);\n            will(returnValue(new LocalDate(2013,4,1)));\n            oneOf(viewModelSupportMemento).get(\"netAmount\", BigDecimal.class);\n            will(returnValue(new BigDecimal(\"10.00\")));\n            oneOf(viewModelSupportMemento).get(\"vatAmount\", BigDecimal.class);\n            will(returnValue(new BigDecimal(\"1.75\")));\n            oneOf(viewModelSupportMemento).get(\"grossAmount\", BigDecimal.class);\n            will(returnValue(new BigDecimal(\"11.75\")));\n            oneOf(viewModelSupportMemento).get(\"total\", Integer.class);\n            will(returnValue(123));\n        }\n    });\n    \n    viewModel.viewModelInit(\"encodedXml\");\n    \n    assertThat(viewModel.getReference(), is(\"OXF\"));\n    assertThat(viewModel.getDueDate(), is(new LocalDate(2013,4,1)));\n    assertThat(viewModel.getNetAmount(), is(new BigDecimal(\"10.00\")));\n    assertThat(viewModel.getVatAmount(), is(new BigDecimal(\"1.75\")));\n    assertThat(viewModel.getGrossAmount(), is(new BigDecimal(\"11.75\")));\n    assertThat(viewModel.getTotal(), is(123));\n\n}",
                "name": "init",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    \n    context.checking(new Expectations() {\n        {\n            oneOf(viewModelSupport).parse(\"encodedXml\");\n            will(returnValue(viewModelSupportMemento));\n            \n            oneOf(viewModelSupportMemento).get(\"reference\", String.class);\n            will(returnValue(\"OXF\"));\n            oneOf(viewModelSupportMemento).get(\"dueDate\", LocalDate.class);\n            will(returnValue(new LocalDate(2013,4,1)));\n            oneOf(viewModelSupportMemento).get(\"netAmount\", BigDecimal.class);\n            will(returnValue(new BigDecimal(\"10.00\")));\n            oneOf(viewModelSupportMemento).get(\"vatAmount\", BigDecimal.class);\n            will(returnValue(new BigDecimal(\"1.75\")));\n            oneOf(viewModelSupportMemento).get(\"grossAmount\", BigDecimal.class);\n            will(returnValue(new BigDecimal(\"11.75\")));\n            oneOf(viewModelSupportMemento).get(\"total\", Integer.class);\n            will(returnValue(123));\n        }\n    });\n    \n    viewModel.viewModelInit(\"encodedXml\");\n    \n    assertThat(viewModel.getReference(), is(\"OXF\"));\n    assertThat(viewModel.getDueDate(), is(new LocalDate(2013,4,1)));\n    assertThat(viewModel.getNetAmount(), is(new BigDecimal(\"10.00\")));\n    assertThat(viewModel.getVatAmount(), is(new BigDecimal(\"1.75\")));\n    assertThat(viewModel.getGrossAmount(), is(new BigDecimal(\"11.75\")));\n    assertThat(viewModel.getTotal(), is(123));\n\n}",
                "start_point": {
                    "row": 90,
                    "column": 4
                },
                "end_point": {
                    "row": 122,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "integtests/src/test/java/org/estatio/integration/tests/api/ApiIntegrationTest.java",
        "definition": "@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class ApiIntegrationTest extends EstatioIntegrationTest {\n\n    private static final LocalDate START_DATE = new LocalDate(2012, 1, 1);\n    private Api api;\n    private Leases leases;\n    private Properties properties;\n    private Parties parties;\n    private CommunicationChannels communicationChannels;\n    private Units<?> units;\n    private Occupancies leaseUnits;\n    private AgreementRoleTypes agreementRoleTypes;\n    private ClockService clockService;\n    private PostalAddresses postalAddresses;\n    private PhoneOrFaxNumbers phoneOrFaxNumbers;\n    private EmailAddresses emailAddresses;\n    private Countries countries;\n    private States states;\n    private Taxes taxes;\n    private ChargeGroups chargeGroups;\n    private Charges charges;\n\n    @BeforeClass\n    public static void setupTransactionalData() {\n        scenarioExecution().install(new EstatioTransactionalObjectsFixture());\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        api = service(Api.class);\n        leases = service(Leases.class);\n        properties = service(Properties.class);\n        states = service(States.class);\n        chargeGroups = service(ChargeGroups.class);\n        charges = service(Charges.class);\n        parties = service(Parties.class);\n        communicationChannels = service(CommunicationChannels.class);\n        units = (Units<?>) service(Units.class);\n        leaseUnits = service(Occupancies.class);\n        agreementRoleTypes = service(AgreementRoleTypes.class);\n        clockService = service(ClockService.class);\n        phoneOrFaxNumbers = service(PhoneOrFaxNumbers.class);\n        emailAddresses = service(EmailAddresses.class);\n        postalAddresses = service(PostalAddresses.class);\n        countries = service(Countries.class);\n        taxes = service(Taxes.class);\n\n    }\n\n    @Test\n    public void t00_refData() throws Exception {\n\n        // country\n        api.putCountry(\"NLD\", \"NL\", \"Netherlands\");\n\n        Country netherlands = countries.findCountry(\"NLD\");\n        Assert.assertNotNull(netherlands);\n        assertThat(netherlands.getReference(), is(\"NLD\"));\n        assertThat(netherlands.getAlpha2Code(), is(\"NL\"));\n        assertThat(netherlands.getName(), is(\"Netherlands\"));\n\n        // state\n        api.putState(\"NH\", \"North Holland\", \"NLD\");\n        State state = states.findState(\"NH\");\n        Assert.assertNotNull(state);\n        assertThat(state.getReference(), is(\"NH\"));\n        assertThat(state.getName(), is(\"North Holland\"));\n        assertThat(state.getCountry(), is(netherlands));\n\n        api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21.0), new LocalDate(1980, 1, 1));\n        api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21), new LocalDate(1980, 1, 1));\n\n        final Tax tax = taxes.findTaxByReference(\"APITAXREF\");\n        Assert.assertNotNull(tax);\n        assertThat(tax.getReference(), is(\"APITAXREF\"));\n        assertThat(tax.getName(), is(\"APITAX Name\"));\n        Assert.assertNotNull(tax.percentageFor(LocalDate.now()));\n\n        api.putCharge(\"APICHARGEREF\", \"APICHARGENAME\", \"API CHARGE\", \"APITAXREF\", \"APICHARGEGROUP\");\n\n        final ChargeGroup chargeGroup = chargeGroups.findChargeGroup(\"APICHARGEGROUP\");\n        Assert.assertNotNull(chargeGroup);\n        assertThat(chargeGroup.getReference(), is(\"APICHARGEGROUP\"));\n        assertThat(chargeGroup.getName(), is(\"APICHARGEGROUP\"));\n\n        final Charge charge = charges.findCharge(\"APICHARGEREF\");\n        Assert.assertNotNull(charge);\n        assertThat(charge.getReference(), is(\"APICHARGEREF\"));\n        assertThat(charge.getName(), is(\"APICHARGENAME\"));\n        assertThat(charge.getDescription(), is(\"API CHARGE\"));\n        assertThat(charge.getTax(), is(tax));\n        assertThat(charge.getGroup(), is(chargeGroup));\n    }\n\n    @Test\n    public void t01_putAsset() throws Exception {\n        api.putProperty(\"APIPROP\", \"Apiland\", \"NLD\", \"ApiCity\", \"SHOPPING_CENTER\", null, null, null, \"HELLOWORLD\", \"APIFORMAT\");\n        api.putUnit(\"APIUNIT\", \"APIPROP\", \"APIONWER\", \"Name\", \"BOUTIQUE\", new LocalDate(1999, 6, 1), null, null, null, null, null, null, null, null, null, null, null);\n        Assert.assertThat(properties.findProperties(\"APIPROP\").size(), Is.is(1));\n    }\n\n    @Test\n    public void t02_putOrganisation() {\n        api.putOrganisation(\"APITENANT\", \"API Tenant\", \"vat\", \"fiscal\");\n        api.putOrganisation(\"APILANDLORD\", \"API Landlord\", \"vat\", \"fiscal\");\n        Assert.assertThat(parties.findParties(\"API*\").size(), Is.is(2));\n    }\n\n    @Test\n    public void t03_putPartyCommunicationChannels() {\n        api.putPartyCommunicationChannels(\"APITENANT\", \"APITENANT\", \"Address1\", \"Address2\", \"CITY\", \"Postal Code\", \"NH\", \"NLD\", \"+31987654321\", \"+31876543210\", \"test@api.local\");\n        Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.POSTAL_ADDRESS));\n        Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.FAX_NUMBER));\n        Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.PHONE_NUMBER));\n    }\n\n    @Test\n    public void t03_putPartyCommunicationChannelsWithoutReference() {\n        api.putPartyCommunicationChannels(\"APITENANT\", null, \"NewAddress1\", \"NewAddress2\", \"NewCity\", \"NewPostCode\", \"NH\", \"NLD\", \"+31222222222\", \"+31333333333\", \"test@example.com\");\n        Party party = parties.findPartyByReference(\"APITENANT\");\n        Assert.assertNotNull(postalAddresses.findByAddress(party, \"NewAddress1\", \"NewPostCode\", \"NewCity\", countries.findCountry(\"NLD\")));\n        Assert.assertNotNull(phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, \"+31222222222\"));\n        Assert.assertNotNull(emailAddresses.findByEmailAddress(party, \"test@example.com\"));\n    }\n\n    @Test\n    public void t04_putLeaseWorks() throws Exception {\n        api.putLease(\"APILEASE\", \"Lease\", \"APITENANT\", \"APILANDLORD\", \"APILEASETYPE\", START_DATE, new LocalDate(2021, 12, 31), null, \"APIPROP\");\n        Lease lease = leases.findLeaseByReference(\"APILEASE\");\n        Assert.assertNotNull(lease);\n        Assert.assertThat(lease.getRoles().size(), Is.is(2));\n    }\n\n    @Test\n    public void t05_putLeaseUnitWorks() throws Exception {\n        api.putOccupancy(\"APILEASE\", \"APIUNIT\", START_DATE, null, null, null, \"APISIZE\", \"ABIBRAND\", \"APISECTOR\", \"APIACTIVITY\", \"YES\", \"YES\", \"YES\");\n        Lease l = leases.findLeaseByReference(\"APILEASE\");\n        Unit u = units.findUnitByReference(\"APIUNIT\");\n        Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n        Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n    }\n\n    @Test\n    public void t05b_putLeasePostalAddress() throws Exception {\n        api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n        final Lease l = leases.findLeaseByReference(\"APILEASE\");\n        final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n        final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n        Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n    }\n\n    @Test\n    public void t05b_putLeasePostalAddress_idempotent() throws Exception {\n        api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n        final Lease l = leases.findLeaseByReference(\"APILEASE\");\n        final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n        final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n        Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n    }\n\n    @Test\n    public void t06_putLeaseItemWorks() throws Exception {\n        api.putLeaseItem(\"APILEASE\", \"APITENANT\", \"APIUNIT\", LeaseItemType.RENT.name(), BigInteger.valueOf(1), START_DATE, new LocalDate(2012, 12, 31), \"APICHARGEREF\", null, InvoicingFrequency.QUARTERLY_IN_ADVANCE.name(), PaymentMethod.DIRECT_DEBIT.name(), LeaseItemStatus.APPROVED.name());\n        Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getItems().size(), Is.is(1));\n    }\n\n    @Test\n    public void t07_putLeaseTermWorks() throws Exception {\n        api.putLeaseTermForIndexableRent(\n                \"APILEASE\",\n                \"APITENANT\",\n                \"APIUNIT\",\n                BigInteger.valueOf(1),\n                LeaseItemType.RENT.name(),\n                START_DATE,\n                BigInteger.valueOf(1),\n                START_DATE,\n                new LocalDate(2012, 12, 31),\n                LeaseTermStatus.NEW.name(),\n                null,\n                null,\n                BigDecimal.valueOf(12345),\n                BigDecimal.valueOf(12345),\n                null,\n                null,\n                null,\n                \"APIINDEX\",\n                LeaseTermFrequency.YEARLY.name(),\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null);\n        api.putLeaseTermForIndexableRent(\"APILEASE\",\n                \"APITENANT\",\n                \"APIUNIT\",\n                BigInteger.valueOf(1),\n                LeaseItemType.RENT.name(),\n                START_DATE,\n                BigInteger.valueOf(2),\n                new LocalDate(2013, 1, 1),\n                new LocalDate(2013, 12, 31),\n                LeaseTermStatus.NEW.name(),\n                null,\n                null,\n                BigDecimal.valueOf(12345),\n                BigDecimal.valueOf(12345),\n                null,\n                null,\n                null,\n                \"APIINDEX\",\n                LeaseTermFrequency.YEARLY.name(),\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null, \n                null);\n        Lease lease = leases.findLeaseByReference(\"APILEASE\");\n        Assert.assertThat(lease.getItems().first().getTerms().size(), Is.is(2));\n    }\n\n    @Test\n    public void t08_putBreakOptionWorks() throws Exception {\n        api.putBreakOption(\"APILEASE\", \"FIXED\", \"TENANT\", new LocalDate(2015, 1, 1), new LocalDate(2014, 7, 1), null, \"Test\");\n        api.putBreakOption(\"APILEASE\", \"ROLLING\", \"MUTUAL\", new LocalDate(2019, 1, 1), null, \"6m\", \"Test\");\n        Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getBreakOptions().size(), Is.is(2));\n    }\n\n}",
        "package": "package org.estatio.integration.tests.api;",
        "tree_path": "ApiIntegrationTest",
        "name": "ApiIntegrationTest",
        "modifiers": "@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic",
        "superclass": "extends EstatioIntegrationTest",
        "super_interfaces": null,
        "body": "{\n\n    private static final LocalDate START_DATE = new LocalDate(2012, 1, 1);\n    private Api api;\n    private Leases leases;\n    private Properties properties;\n    private Parties parties;\n    private CommunicationChannels communicationChannels;\n    private Units<?> units;\n    private Occupancies leaseUnits;\n    private AgreementRoleTypes agreementRoleTypes;\n    private ClockService clockService;\n    private PostalAddresses postalAddresses;\n    private PhoneOrFaxNumbers phoneOrFaxNumbers;\n    private EmailAddresses emailAddresses;\n    private Countries countries;\n    private States states;\n    private Taxes taxes;\n    private ChargeGroups chargeGroups;\n    private Charges charges;\n\n    @BeforeClass\n    public static void setupTransactionalData() {\n        scenarioExecution().install(new EstatioTransactionalObjectsFixture());\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        api = service(Api.class);\n        leases = service(Leases.class);\n        properties = service(Properties.class);\n        states = service(States.class);\n        chargeGroups = service(ChargeGroups.class);\n        charges = service(Charges.class);\n        parties = service(Parties.class);\n        communicationChannels = service(CommunicationChannels.class);\n        units = (Units<?>) service(Units.class);\n        leaseUnits = service(Occupancies.class);\n        agreementRoleTypes = service(AgreementRoleTypes.class);\n        clockService = service(ClockService.class);\n        phoneOrFaxNumbers = service(PhoneOrFaxNumbers.class);\n        emailAddresses = service(EmailAddresses.class);\n        postalAddresses = service(PostalAddresses.class);\n        countries = service(Countries.class);\n        taxes = service(Taxes.class);\n\n    }\n\n    @Test\n    public void t00_refData() throws Exception {\n\n        // country\n        api.putCountry(\"NLD\", \"NL\", \"Netherlands\");\n\n        Country netherlands = countries.findCountry(\"NLD\");\n        Assert.assertNotNull(netherlands);\n        assertThat(netherlands.getReference(), is(\"NLD\"));\n        assertThat(netherlands.getAlpha2Code(), is(\"NL\"));\n        assertThat(netherlands.getName(), is(\"Netherlands\"));\n\n        // state\n        api.putState(\"NH\", \"North Holland\", \"NLD\");\n        State state = states.findState(\"NH\");\n        Assert.assertNotNull(state);\n        assertThat(state.getReference(), is(\"NH\"));\n        assertThat(state.getName(), is(\"North Holland\"));\n        assertThat(state.getCountry(), is(netherlands));\n\n        api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21.0), new LocalDate(1980, 1, 1));\n        api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21), new LocalDate(1980, 1, 1));\n\n        final Tax tax = taxes.findTaxByReference(\"APITAXREF\");\n        Assert.assertNotNull(tax);\n        assertThat(tax.getReference(), is(\"APITAXREF\"));\n        assertThat(tax.getName(), is(\"APITAX Name\"));\n        Assert.assertNotNull(tax.percentageFor(LocalDate.now()));\n\n        api.putCharge(\"APICHARGEREF\", \"APICHARGENAME\", \"API CHARGE\", \"APITAXREF\", \"APICHARGEGROUP\");\n\n        final ChargeGroup chargeGroup = chargeGroups.findChargeGroup(\"APICHARGEGROUP\");\n        Assert.assertNotNull(chargeGroup);\n        assertThat(chargeGroup.getReference(), is(\"APICHARGEGROUP\"));\n        assertThat(chargeGroup.getName(), is(\"APICHARGEGROUP\"));\n\n        final Charge charge = charges.findCharge(\"APICHARGEREF\");\n        Assert.assertNotNull(charge);\n        assertThat(charge.getReference(), is(\"APICHARGEREF\"));\n        assertThat(charge.getName(), is(\"APICHARGENAME\"));\n        assertThat(charge.getDescription(), is(\"API CHARGE\"));\n        assertThat(charge.getTax(), is(tax));\n        assertThat(charge.getGroup(), is(chargeGroup));\n    }\n\n    @Test\n    public void t01_putAsset() throws Exception {\n        api.putProperty(\"APIPROP\", \"Apiland\", \"NLD\", \"ApiCity\", \"SHOPPING_CENTER\", null, null, null, \"HELLOWORLD\", \"APIFORMAT\");\n        api.putUnit(\"APIUNIT\", \"APIPROP\", \"APIONWER\", \"Name\", \"BOUTIQUE\", new LocalDate(1999, 6, 1), null, null, null, null, null, null, null, null, null, null, null);\n        Assert.assertThat(properties.findProperties(\"APIPROP\").size(), Is.is(1));\n    }\n\n    @Test\n    public void t02_putOrganisation() {\n        api.putOrganisation(\"APITENANT\", \"API Tenant\", \"vat\", \"fiscal\");\n        api.putOrganisation(\"APILANDLORD\", \"API Landlord\", \"vat\", \"fiscal\");\n        Assert.assertThat(parties.findParties(\"API*\").size(), Is.is(2));\n    }\n\n    @Test\n    public void t03_putPartyCommunicationChannels() {\n        api.putPartyCommunicationChannels(\"APITENANT\", \"APITENANT\", \"Address1\", \"Address2\", \"CITY\", \"Postal Code\", \"NH\", \"NLD\", \"+31987654321\", \"+31876543210\", \"test@api.local\");\n        Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.POSTAL_ADDRESS));\n        Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.FAX_NUMBER));\n        Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.PHONE_NUMBER));\n    }\n\n    @Test\n    public void t03_putPartyCommunicationChannelsWithoutReference() {\n        api.putPartyCommunicationChannels(\"APITENANT\", null, \"NewAddress1\", \"NewAddress2\", \"NewCity\", \"NewPostCode\", \"NH\", \"NLD\", \"+31222222222\", \"+31333333333\", \"test@example.com\");\n        Party party = parties.findPartyByReference(\"APITENANT\");\n        Assert.assertNotNull(postalAddresses.findByAddress(party, \"NewAddress1\", \"NewPostCode\", \"NewCity\", countries.findCountry(\"NLD\")));\n        Assert.assertNotNull(phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, \"+31222222222\"));\n        Assert.assertNotNull(emailAddresses.findByEmailAddress(party, \"test@example.com\"));\n    }\n\n    @Test\n    public void t04_putLeaseWorks() throws Exception {\n        api.putLease(\"APILEASE\", \"Lease\", \"APITENANT\", \"APILANDLORD\", \"APILEASETYPE\", START_DATE, new LocalDate(2021, 12, 31), null, \"APIPROP\");\n        Lease lease = leases.findLeaseByReference(\"APILEASE\");\n        Assert.assertNotNull(lease);\n        Assert.assertThat(lease.getRoles().size(), Is.is(2));\n    }\n\n    @Test\n    public void t05_putLeaseUnitWorks() throws Exception {\n        api.putOccupancy(\"APILEASE\", \"APIUNIT\", START_DATE, null, null, null, \"APISIZE\", \"ABIBRAND\", \"APISECTOR\", \"APIACTIVITY\", \"YES\", \"YES\", \"YES\");\n        Lease l = leases.findLeaseByReference(\"APILEASE\");\n        Unit u = units.findUnitByReference(\"APIUNIT\");\n        Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n        Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n    }\n\n    @Test\n    public void t05b_putLeasePostalAddress() throws Exception {\n        api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n        final Lease l = leases.findLeaseByReference(\"APILEASE\");\n        final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n        final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n        Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n    }\n\n    @Test\n    public void t05b_putLeasePostalAddress_idempotent() throws Exception {\n        api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n        final Lease l = leases.findLeaseByReference(\"APILEASE\");\n        final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n        final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n        Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n    }\n\n    @Test\n    public void t06_putLeaseItemWorks() throws Exception {\n        api.putLeaseItem(\"APILEASE\", \"APITENANT\", \"APIUNIT\", LeaseItemType.RENT.name(), BigInteger.valueOf(1), START_DATE, new LocalDate(2012, 12, 31), \"APICHARGEREF\", null, InvoicingFrequency.QUARTERLY_IN_ADVANCE.name(), PaymentMethod.DIRECT_DEBIT.name(), LeaseItemStatus.APPROVED.name());\n        Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getItems().size(), Is.is(1));\n    }\n\n    @Test\n    public void t07_putLeaseTermWorks() throws Exception {\n        api.putLeaseTermForIndexableRent(\n                \"APILEASE\",\n                \"APITENANT\",\n                \"APIUNIT\",\n                BigInteger.valueOf(1),\n                LeaseItemType.RENT.name(),\n                START_DATE,\n                BigInteger.valueOf(1),\n                START_DATE,\n                new LocalDate(2012, 12, 31),\n                LeaseTermStatus.NEW.name(),\n                null,\n                null,\n                BigDecimal.valueOf(12345),\n                BigDecimal.valueOf(12345),\n                null,\n                null,\n                null,\n                \"APIINDEX\",\n                LeaseTermFrequency.YEARLY.name(),\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null);\n        api.putLeaseTermForIndexableRent(\"APILEASE\",\n                \"APITENANT\",\n                \"APIUNIT\",\n                BigInteger.valueOf(1),\n                LeaseItemType.RENT.name(),\n                START_DATE,\n                BigInteger.valueOf(2),\n                new LocalDate(2013, 1, 1),\n                new LocalDate(2013, 12, 31),\n                LeaseTermStatus.NEW.name(),\n                null,\n                null,\n                BigDecimal.valueOf(12345),\n                BigDecimal.valueOf(12345),\n                null,\n                null,\n                null,\n                \"APIINDEX\",\n                LeaseTermFrequency.YEARLY.name(),\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null,\n                null, \n                null);\n        Lease lease = leases.findLeaseByReference(\"APILEASE\");\n        Assert.assertThat(lease.getItems().first().getTerms().size(), Is.is(2));\n    }\n\n    @Test\n    public void t08_putBreakOptionWorks() throws Exception {\n        api.putBreakOption(\"APILEASE\", \"FIXED\", \"TENANT\", new LocalDate(2015, 1, 1), new LocalDate(2014, 7, 1), null, \"Test\");\n        api.putBreakOption(\"APILEASE\", \"ROLLING\", \"MUTUAL\", new LocalDate(2019, 1, 1), null, \"6m\", \"Test\");\n        Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getBreakOptions().size(), Is.is(2));\n    }\n\n}",
        "start_point": {
            "row": 73,
            "column": 0
        },
        "end_point": {
            "row": 309,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@BeforeClass\npublic static void setupTransactionalData() {\n    scenarioExecution().install(new EstatioTransactionalObjectsFixture());\n}",
                "name": "setupTransactionalData",
                "modifiers": "@BeforeClass\n    public static",
                "return_type": null,
                "parameters": [],
                "body": "{\n    scenarioExecution().install(new EstatioTransactionalObjectsFixture());\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            },
            {
                "definition": "@Before\npublic void setUp() throws Exception {\n    api = service(Api.class);\n    leases = service(Leases.class);\n    properties = service(Properties.class);\n    states = service(States.class);\n    chargeGroups = service(ChargeGroups.class);\n    charges = service(Charges.class);\n    parties = service(Parties.class);\n    communicationChannels = service(CommunicationChannels.class);\n    units = (Units<?>) service(Units.class);\n    leaseUnits = service(Occupancies.class);\n    agreementRoleTypes = service(AgreementRoleTypes.class);\n    clockService = service(ClockService.class);\n    phoneOrFaxNumbers = service(PhoneOrFaxNumbers.class);\n    emailAddresses = service(EmailAddresses.class);\n    postalAddresses = service(PostalAddresses.class);\n    countries = service(Countries.class);\n    taxes = service(Taxes.class);\n\n}",
                "name": "setUp",
                "modifiers": "@Before\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api = service(Api.class);\n    leases = service(Leases.class);\n    properties = service(Properties.class);\n    states = service(States.class);\n    chargeGroups = service(ChargeGroups.class);\n    charges = service(Charges.class);\n    parties = service(Parties.class);\n    communicationChannels = service(CommunicationChannels.class);\n    units = (Units<?>) service(Units.class);\n    leaseUnits = service(Occupancies.class);\n    agreementRoleTypes = service(AgreementRoleTypes.class);\n    clockService = service(ClockService.class);\n    phoneOrFaxNumbers = service(PhoneOrFaxNumbers.class);\n    emailAddresses = service(EmailAddresses.class);\n    postalAddresses = service(PostalAddresses.class);\n    countries = service(Countries.class);\n    taxes = service(Taxes.class);\n\n}",
                "start_point": {
                    "row": 100,
                    "column": 4
                },
                "end_point": {
                    "row": 120,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t00_refData() throws Exception {\n\n    // country\n    api.putCountry(\"NLD\", \"NL\", \"Netherlands\");\n\n    Country netherlands = countries.findCountry(\"NLD\");\n    Assert.assertNotNull(netherlands);\n    assertThat(netherlands.getReference(), is(\"NLD\"));\n    assertThat(netherlands.getAlpha2Code(), is(\"NL\"));\n    assertThat(netherlands.getName(), is(\"Netherlands\"));\n\n    // state\n    api.putState(\"NH\", \"North Holland\", \"NLD\");\n    State state = states.findState(\"NH\");\n    Assert.assertNotNull(state);\n    assertThat(state.getReference(), is(\"NH\"));\n    assertThat(state.getName(), is(\"North Holland\"));\n    assertThat(state.getCountry(), is(netherlands));\n\n    api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21.0), new LocalDate(1980, 1, 1));\n    api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21), new LocalDate(1980, 1, 1));\n\n    final Tax tax = taxes.findTaxByReference(\"APITAXREF\");\n    Assert.assertNotNull(tax);\n    assertThat(tax.getReference(), is(\"APITAXREF\"));\n    assertThat(tax.getName(), is(\"APITAX Name\"));\n    Assert.assertNotNull(tax.percentageFor(LocalDate.now()));\n\n    api.putCharge(\"APICHARGEREF\", \"APICHARGENAME\", \"API CHARGE\", \"APITAXREF\", \"APICHARGEGROUP\");\n\n    final ChargeGroup chargeGroup = chargeGroups.findChargeGroup(\"APICHARGEGROUP\");\n    Assert.assertNotNull(chargeGroup);\n    assertThat(chargeGroup.getReference(), is(\"APICHARGEGROUP\"));\n    assertThat(chargeGroup.getName(), is(\"APICHARGEGROUP\"));\n\n    final Charge charge = charges.findCharge(\"APICHARGEREF\");\n    Assert.assertNotNull(charge);\n    assertThat(charge.getReference(), is(\"APICHARGEREF\"));\n    assertThat(charge.getName(), is(\"APICHARGENAME\"));\n    assertThat(charge.getDescription(), is(\"API CHARGE\"));\n    assertThat(charge.getTax(), is(tax));\n    assertThat(charge.getGroup(), is(chargeGroup));\n}",
                "name": "t00_refData",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n\n    // country\n    api.putCountry(\"NLD\", \"NL\", \"Netherlands\");\n\n    Country netherlands = countries.findCountry(\"NLD\");\n    Assert.assertNotNull(netherlands);\n    assertThat(netherlands.getReference(), is(\"NLD\"));\n    assertThat(netherlands.getAlpha2Code(), is(\"NL\"));\n    assertThat(netherlands.getName(), is(\"Netherlands\"));\n\n    // state\n    api.putState(\"NH\", \"North Holland\", \"NLD\");\n    State state = states.findState(\"NH\");\n    Assert.assertNotNull(state);\n    assertThat(state.getReference(), is(\"NH\"));\n    assertThat(state.getName(), is(\"North Holland\"));\n    assertThat(state.getCountry(), is(netherlands));\n\n    api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21.0), new LocalDate(1980, 1, 1));\n    api.putTax(\"APITAXREF\", \"APITAX Name\", BigDecimal.valueOf(21), new LocalDate(1980, 1, 1));\n\n    final Tax tax = taxes.findTaxByReference(\"APITAXREF\");\n    Assert.assertNotNull(tax);\n    assertThat(tax.getReference(), is(\"APITAXREF\"));\n    assertThat(tax.getName(), is(\"APITAX Name\"));\n    Assert.assertNotNull(tax.percentageFor(LocalDate.now()));\n\n    api.putCharge(\"APICHARGEREF\", \"APICHARGENAME\", \"API CHARGE\", \"APITAXREF\", \"APICHARGEGROUP\");\n\n    final ChargeGroup chargeGroup = chargeGroups.findChargeGroup(\"APICHARGEGROUP\");\n    Assert.assertNotNull(chargeGroup);\n    assertThat(chargeGroup.getReference(), is(\"APICHARGEGROUP\"));\n    assertThat(chargeGroup.getName(), is(\"APICHARGEGROUP\"));\n\n    final Charge charge = charges.findCharge(\"APICHARGEREF\");\n    Assert.assertNotNull(charge);\n    assertThat(charge.getReference(), is(\"APICHARGEREF\"));\n    assertThat(charge.getName(), is(\"APICHARGENAME\"));\n    assertThat(charge.getDescription(), is(\"API CHARGE\"));\n    assertThat(charge.getTax(), is(tax));\n    assertThat(charge.getGroup(), is(chargeGroup));\n}",
                "start_point": {
                    "row": 122,
                    "column": 4
                },
                "end_point": {
                    "row": 165,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t01_putAsset() throws Exception {\n    api.putProperty(\"APIPROP\", \"Apiland\", \"NLD\", \"ApiCity\", \"SHOPPING_CENTER\", null, null, null, \"HELLOWORLD\", \"APIFORMAT\");\n    api.putUnit(\"APIUNIT\", \"APIPROP\", \"APIONWER\", \"Name\", \"BOUTIQUE\", new LocalDate(1999, 6, 1), null, null, null, null, null, null, null, null, null, null, null);\n    Assert.assertThat(properties.findProperties(\"APIPROP\").size(), Is.is(1));\n}",
                "name": "t01_putAsset",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putProperty(\"APIPROP\", \"Apiland\", \"NLD\", \"ApiCity\", \"SHOPPING_CENTER\", null, null, null, \"HELLOWORLD\", \"APIFORMAT\");\n    api.putUnit(\"APIUNIT\", \"APIPROP\", \"APIONWER\", \"Name\", \"BOUTIQUE\", new LocalDate(1999, 6, 1), null, null, null, null, null, null, null, null, null, null, null);\n    Assert.assertThat(properties.findProperties(\"APIPROP\").size(), Is.is(1));\n}",
                "start_point": {
                    "row": 167,
                    "column": 4
                },
                "end_point": {
                    "row": 172,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t02_putOrganisation() {\n    api.putOrganisation(\"APITENANT\", \"API Tenant\", \"vat\", \"fiscal\");\n    api.putOrganisation(\"APILANDLORD\", \"API Landlord\", \"vat\", \"fiscal\");\n    Assert.assertThat(parties.findParties(\"API*\").size(), Is.is(2));\n}",
                "name": "t02_putOrganisation",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putOrganisation(\"APITENANT\", \"API Tenant\", \"vat\", \"fiscal\");\n    api.putOrganisation(\"APILANDLORD\", \"API Landlord\", \"vat\", \"fiscal\");\n    Assert.assertThat(parties.findParties(\"API*\").size(), Is.is(2));\n}",
                "start_point": {
                    "row": 174,
                    "column": 4
                },
                "end_point": {
                    "row": 179,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t03_putPartyCommunicationChannels() {\n    api.putPartyCommunicationChannels(\"APITENANT\", \"APITENANT\", \"Address1\", \"Address2\", \"CITY\", \"Postal Code\", \"NH\", \"NLD\", \"+31987654321\", \"+31876543210\", \"test@api.local\");\n    Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.POSTAL_ADDRESS));\n    Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.FAX_NUMBER));\n    Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.PHONE_NUMBER));\n}",
                "name": "t03_putPartyCommunicationChannels",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putPartyCommunicationChannels(\"APITENANT\", \"APITENANT\", \"Address1\", \"Address2\", \"CITY\", \"Postal Code\", \"NH\", \"NLD\", \"+31987654321\", \"+31876543210\", \"test@api.local\");\n    Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.POSTAL_ADDRESS));\n    Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.FAX_NUMBER));\n    Assert.assertNotNull(communicationChannels.findByReferenceAndType(\"APITENANT\", CommunicationChannelType.PHONE_NUMBER));\n}",
                "start_point": {
                    "row": 181,
                    "column": 4
                },
                "end_point": {
                    "row": 187,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t03_putPartyCommunicationChannelsWithoutReference() {\n    api.putPartyCommunicationChannels(\"APITENANT\", null, \"NewAddress1\", \"NewAddress2\", \"NewCity\", \"NewPostCode\", \"NH\", \"NLD\", \"+31222222222\", \"+31333333333\", \"test@example.com\");\n    Party party = parties.findPartyByReference(\"APITENANT\");\n    Assert.assertNotNull(postalAddresses.findByAddress(party, \"NewAddress1\", \"NewPostCode\", \"NewCity\", countries.findCountry(\"NLD\")));\n    Assert.assertNotNull(phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, \"+31222222222\"));\n    Assert.assertNotNull(emailAddresses.findByEmailAddress(party, \"test@example.com\"));\n}",
                "name": "t03_putPartyCommunicationChannelsWithoutReference",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putPartyCommunicationChannels(\"APITENANT\", null, \"NewAddress1\", \"NewAddress2\", \"NewCity\", \"NewPostCode\", \"NH\", \"NLD\", \"+31222222222\", \"+31333333333\", \"test@example.com\");\n    Party party = parties.findPartyByReference(\"APITENANT\");\n    Assert.assertNotNull(postalAddresses.findByAddress(party, \"NewAddress1\", \"NewPostCode\", \"NewCity\", countries.findCountry(\"NLD\")));\n    Assert.assertNotNull(phoneOrFaxNumbers.findByPhoneOrFaxNumber(party, \"+31222222222\"));\n    Assert.assertNotNull(emailAddresses.findByEmailAddress(party, \"test@example.com\"));\n}",
                "start_point": {
                    "row": 189,
                    "column": 4
                },
                "end_point": {
                    "row": 196,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t04_putLeaseWorks() throws Exception {\n    api.putLease(\"APILEASE\", \"Lease\", \"APITENANT\", \"APILANDLORD\", \"APILEASETYPE\", START_DATE, new LocalDate(2021, 12, 31), null, \"APIPROP\");\n    Lease lease = leases.findLeaseByReference(\"APILEASE\");\n    Assert.assertNotNull(lease);\n    Assert.assertThat(lease.getRoles().size(), Is.is(2));\n}",
                "name": "t04_putLeaseWorks",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putLease(\"APILEASE\", \"Lease\", \"APITENANT\", \"APILANDLORD\", \"APILEASETYPE\", START_DATE, new LocalDate(2021, 12, 31), null, \"APIPROP\");\n    Lease lease = leases.findLeaseByReference(\"APILEASE\");\n    Assert.assertNotNull(lease);\n    Assert.assertThat(lease.getRoles().size(), Is.is(2));\n}",
                "start_point": {
                    "row": 198,
                    "column": 4
                },
                "end_point": {
                    "row": 204,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t05_putLeaseUnitWorks() throws Exception {\n    api.putOccupancy(\"APILEASE\", \"APIUNIT\", START_DATE, null, null, null, \"APISIZE\", \"ABIBRAND\", \"APISECTOR\", \"APIACTIVITY\", \"YES\", \"YES\", \"YES\");\n    Lease l = leases.findLeaseByReference(\"APILEASE\");\n    Unit u = units.findUnitByReference(\"APIUNIT\");\n    Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n    Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n}",
                "name": "t05_putLeaseUnitWorks",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putOccupancy(\"APILEASE\", \"APIUNIT\", START_DATE, null, null, null, \"APISIZE\", \"ABIBRAND\", \"APISECTOR\", \"APIACTIVITY\", \"YES\", \"YES\", \"YES\");\n    Lease l = leases.findLeaseByReference(\"APILEASE\");\n    Unit u = units.findUnitByReference(\"APIUNIT\");\n    Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n    Assert.assertNotNull(leaseUnits.findByLeaseAndUnitAndStartDate(l, u, START_DATE));\n}",
                "start_point": {
                    "row": 206,
                    "column": 4
                },
                "end_point": {
                    "row": 213,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t05b_putLeasePostalAddress() throws Exception {\n    api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n    final Lease l = leases.findLeaseByReference(\"APILEASE\");\n    final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n    final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n    Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n}",
                "name": "t05b_putLeasePostalAddress",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n    final Lease l = leases.findLeaseByReference(\"APILEASE\");\n    final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n    final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n    Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n}",
                "start_point": {
                    "row": 215,
                    "column": 4
                },
                "end_point": {
                    "row": 222,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t05b_putLeasePostalAddress_idempotent() throws Exception {\n    api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n    final Lease l = leases.findLeaseByReference(\"APILEASE\");\n    final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n    final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n    Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n}",
                "name": "t05b_putLeasePostalAddress_idempotent",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putLeasePostalAddress(\"APITENANT\", LeaseConstants.ART_TENANT, \"APILEASE\", \"Address1\", \"Address2\", \"PostalCode\", \"City\", \"NH\", \"NLD\", BigInteger.valueOf(1));\n    final Lease l = leases.findLeaseByReference(\"APILEASE\");\n    final AgreementRoleType artTenant = agreementRoleTypes.findByTitle(LeaseConstants.ART_TENANT);\n    final AgreementRole ar = l.findRoleWithType(artTenant, clockService.now());\n    Assert.assertThat(ar.getCommunicationChannels().size(), Is.is(1));\n}",
                "start_point": {
                    "row": 224,
                    "column": 4
                },
                "end_point": {
                    "row": 231,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t06_putLeaseItemWorks() throws Exception {\n    api.putLeaseItem(\"APILEASE\", \"APITENANT\", \"APIUNIT\", LeaseItemType.RENT.name(), BigInteger.valueOf(1), START_DATE, new LocalDate(2012, 12, 31), \"APICHARGEREF\", null, InvoicingFrequency.QUARTERLY_IN_ADVANCE.name(), PaymentMethod.DIRECT_DEBIT.name(), LeaseItemStatus.APPROVED.name());\n    Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getItems().size(), Is.is(1));\n}",
                "name": "t06_putLeaseItemWorks",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putLeaseItem(\"APILEASE\", \"APITENANT\", \"APIUNIT\", LeaseItemType.RENT.name(), BigInteger.valueOf(1), START_DATE, new LocalDate(2012, 12, 31), \"APICHARGEREF\", null, InvoicingFrequency.QUARTERLY_IN_ADVANCE.name(), PaymentMethod.DIRECT_DEBIT.name(), LeaseItemStatus.APPROVED.name());\n    Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getItems().size(), Is.is(1));\n}",
                "start_point": {
                    "row": 233,
                    "column": 4
                },
                "end_point": {
                    "row": 237,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t07_putLeaseTermWorks() throws Exception {\n    api.putLeaseTermForIndexableRent(\n            \"APILEASE\",\n            \"APITENANT\",\n            \"APIUNIT\",\n            BigInteger.valueOf(1),\n            LeaseItemType.RENT.name(),\n            START_DATE,\n            BigInteger.valueOf(1),\n            START_DATE,\n            new LocalDate(2012, 12, 31),\n            LeaseTermStatus.NEW.name(),\n            null,\n            null,\n            BigDecimal.valueOf(12345),\n            BigDecimal.valueOf(12345),\n            null,\n            null,\n            null,\n            \"APIINDEX\",\n            LeaseTermFrequency.YEARLY.name(),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    api.putLeaseTermForIndexableRent(\"APILEASE\",\n            \"APITENANT\",\n            \"APIUNIT\",\n            BigInteger.valueOf(1),\n            LeaseItemType.RENT.name(),\n            START_DATE,\n            BigInteger.valueOf(2),\n            new LocalDate(2013, 1, 1),\n            new LocalDate(2013, 12, 31),\n            LeaseTermStatus.NEW.name(),\n            null,\n            null,\n            BigDecimal.valueOf(12345),\n            BigDecimal.valueOf(12345),\n            null,\n            null,\n            null,\n            \"APIINDEX\",\n            LeaseTermFrequency.YEARLY.name(),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null, \n            null);\n    Lease lease = leases.findLeaseByReference(\"APILEASE\");\n    Assert.assertThat(lease.getItems().first().getTerms().size(), Is.is(2));\n}",
                "name": "t07_putLeaseTermWorks",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putLeaseTermForIndexableRent(\n            \"APILEASE\",\n            \"APITENANT\",\n            \"APIUNIT\",\n            BigInteger.valueOf(1),\n            LeaseItemType.RENT.name(),\n            START_DATE,\n            BigInteger.valueOf(1),\n            START_DATE,\n            new LocalDate(2012, 12, 31),\n            LeaseTermStatus.NEW.name(),\n            null,\n            null,\n            BigDecimal.valueOf(12345),\n            BigDecimal.valueOf(12345),\n            null,\n            null,\n            null,\n            \"APIINDEX\",\n            LeaseTermFrequency.YEARLY.name(),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null);\n    api.putLeaseTermForIndexableRent(\"APILEASE\",\n            \"APITENANT\",\n            \"APIUNIT\",\n            BigInteger.valueOf(1),\n            LeaseItemType.RENT.name(),\n            START_DATE,\n            BigInteger.valueOf(2),\n            new LocalDate(2013, 1, 1),\n            new LocalDate(2013, 12, 31),\n            LeaseTermStatus.NEW.name(),\n            null,\n            null,\n            BigDecimal.valueOf(12345),\n            BigDecimal.valueOf(12345),\n            null,\n            null,\n            null,\n            \"APIINDEX\",\n            LeaseTermFrequency.YEARLY.name(),\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null, \n            null);\n    Lease lease = leases.findLeaseByReference(\"APILEASE\");\n    Assert.assertThat(lease.getItems().first().getTerms().size(), Is.is(2));\n}",
                "start_point": {
                    "row": 239,
                    "column": 4
                },
                "end_point": {
                    "row": 300,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void t08_putBreakOptionWorks() throws Exception {\n    api.putBreakOption(\"APILEASE\", \"FIXED\", \"TENANT\", new LocalDate(2015, 1, 1), new LocalDate(2014, 7, 1), null, \"Test\");\n    api.putBreakOption(\"APILEASE\", \"ROLLING\", \"MUTUAL\", new LocalDate(2019, 1, 1), null, \"6m\", \"Test\");\n    Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getBreakOptions().size(), Is.is(2));\n}",
                "name": "t08_putBreakOptionWorks",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    api.putBreakOption(\"APILEASE\", \"FIXED\", \"TENANT\", new LocalDate(2015, 1, 1), new LocalDate(2014, 7, 1), null, \"Test\");\n    api.putBreakOption(\"APILEASE\", \"ROLLING\", \"MUTUAL\", new LocalDate(2019, 1, 1), null, \"6m\", \"Test\");\n    Assert.assertThat(leases.findLeaseByReference(\"APILEASE\").getBreakOptions().size(), Is.is(2));\n}",
                "start_point": {
                    "row": 302,
                    "column": 4
                },
                "end_point": {
                    "row": 307,
                    "column": 5
                }
            }
        ]
    }
]