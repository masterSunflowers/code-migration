[
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/SecurityConfiguration.java",
        "definition": "@Configuration\n@ComponentScan(\"io.gravitee.am.management.handlers.admin.controller\")\n@EnableWebSecurity\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    private final Logger logger = LoggerFactory.getLogger(SecurityConfiguration.class);\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Autowired\n    private JWTCookieGenerator jwtCookieGenerator;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth)  {\n        logger.info(\"Loading identity providers to handle user authentication\");\n\n        // By default we are associating users added to the domain\n        auth.authenticationProvider(userAuthenticationProvider());\n        auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .requestMatchers()\n                .antMatchers(\"/authorize\", \"/login\", \"/login/callback\", \"/logout\")\n                .and()\n            .authorizeRequests()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .loginPage(\"/login\")\n                .successHandler(authenticationSuccessHandler())\n                .permitAll()\n                .and()\n            .logout()\n                .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n                .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n                .invalidateHttpSession(true)\n                .addLogoutHandler(cookieClearingLogoutHandler())\n                .and()\n            .exceptionHandling()\n                .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))\n                .and()\n            .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n    }\n\n    @Bean\n    public DomainBasedAuthenticationProvider userAuthenticationProvider() {\n        return new DomainBasedAuthenticationProvider();\n    }\n\n    @Bean\n    public Filter clientOAuth2Filter() {\n        OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n        oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n        return oAuth2ClientAuthenticationFilter;\n    }\n\n    @Bean\n    public AuthenticationSuccessListener authenticationSuccessListener() {\n        return new AuthenticationSuccessListener();\n    }\n\n    @Bean\n    public LogoutHandler cookieClearingLogoutHandler() {\n        return new CookieClearingLogoutHandler();\n    }\n\n    @Bean\n    public AuthenticationSuccessHandler authenticationSuccessHandler() {\n        CustomSavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n        successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n        return successHandler;\n    }\n\n    @Bean\n    public IdentityProviderManager identityProviderManager() {\n        return new IdentityProviderManagerImpl();\n    }\n\n    @Bean\n    public JWTCookieGenerator jwtCookieGenerator() {\n        return new JWTCookieGenerator();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin;",
        "tree_path": "SecurityConfiguration",
        "name": "SecurityConfiguration",
        "modifiers": "@Configuration\n@ComponentScan(\"io.gravitee.am.management.handlers.admin.controller\")\n@EnableWebSecurity\npublic",
        "superclass": "extends WebSecurityConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(SecurityConfiguration.class);\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Autowired\n    private JWTCookieGenerator jwtCookieGenerator;\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth)  {\n        logger.info(\"Loading identity providers to handle user authentication\");\n\n        // By default we are associating users added to the domain\n        auth.authenticationProvider(userAuthenticationProvider());\n        auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n            .requestMatchers()\n                .antMatchers(\"/authorize\", \"/login\", \"/login/callback\", \"/logout\")\n                .and()\n            .authorizeRequests()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .loginPage(\"/login\")\n                .successHandler(authenticationSuccessHandler())\n                .permitAll()\n                .and()\n            .logout()\n                .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n                .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n                .invalidateHttpSession(true)\n                .addLogoutHandler(cookieClearingLogoutHandler())\n                .and()\n            .exceptionHandling()\n                .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))\n                .and()\n            .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n    }\n\n    @Bean\n    public DomainBasedAuthenticationProvider userAuthenticationProvider() {\n        return new DomainBasedAuthenticationProvider();\n    }\n\n    @Bean\n    public Filter clientOAuth2Filter() {\n        OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n        oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n        return oAuth2ClientAuthenticationFilter;\n    }\n\n    @Bean\n    public AuthenticationSuccessListener authenticationSuccessListener() {\n        return new AuthenticationSuccessListener();\n    }\n\n    @Bean\n    public LogoutHandler cookieClearingLogoutHandler() {\n        return new CookieClearingLogoutHandler();\n    }\n\n    @Bean\n    public AuthenticationSuccessHandler authenticationSuccessHandler() {\n        CustomSavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n        successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n        return successHandler;\n    }\n\n    @Bean\n    public IdentityProviderManager identityProviderManager() {\n        return new IdentityProviderManagerImpl();\n    }\n\n    @Bean\n    public JWTCookieGenerator jwtCookieGenerator() {\n        return new JWTCookieGenerator();\n    }\n}",
        "start_point": {
            "row": 47,
            "column": 0
        },
        "end_point": {
            "row": 134,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\nprotected void configure(AuthenticationManagerBuilder auth)  {\n    logger.info(\"Loading identity providers to handle user authentication\");\n\n    // By default we are associating users added to the domain\n    auth.authenticationProvider(userAuthenticationProvider());\n    auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n}",
                "name": "configure",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthenticationManagerBuilder",
                        "name": "auth"
                    }
                ],
                "body": "{\n    logger.info(\"Loading identity providers to handle user authentication\");\n\n    // By default we are associating users added to the domain\n    auth.authenticationProvider(userAuthenticationProvider());\n    auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 67,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http\n        .requestMatchers()\n            .antMatchers(\"/authorize\", \"/login\", \"/login/callback\", \"/logout\")\n            .and()\n        .authorizeRequests()\n            .anyRequest().authenticated()\n            .and()\n        .formLogin()\n            .loginPage(\"/login\")\n            .successHandler(authenticationSuccessHandler())\n            .permitAll()\n            .and()\n        .logout()\n            .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n            .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n            .invalidateHttpSession(true)\n            .addLogoutHandler(cookieClearingLogoutHandler())\n            .and()\n        .exceptionHandling()\n            .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))\n            .and()\n        .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n}",
                "name": "configure",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpSecurity",
                        "name": "http"
                    }
                ],
                "body": "{\n    http\n        .requestMatchers()\n            .antMatchers(\"/authorize\", \"/login\", \"/login/callback\", \"/logout\")\n            .and()\n        .authorizeRequests()\n            .anyRequest().authenticated()\n            .and()\n        .formLogin()\n            .loginPage(\"/login\")\n            .successHandler(authenticationSuccessHandler())\n            .permitAll()\n            .and()\n        .logout()\n            .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n            .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n            .invalidateHttpSession(true)\n            .addLogoutHandler(cookieClearingLogoutHandler())\n            .and()\n        .exceptionHandling()\n            .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint(\"/login\"))\n            .and()\n        .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic DomainBasedAuthenticationProvider userAuthenticationProvider() {\n    return new DomainBasedAuthenticationProvider();\n}",
                "name": "userAuthenticationProvider",
                "modifiers": "@Bean\n    public",
                "return_type": "DomainBasedAuthenticationProvider",
                "parameters": [],
                "body": "{\n    return new DomainBasedAuthenticationProvider();\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic Filter clientOAuth2Filter() {\n    OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n    oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n    return oAuth2ClientAuthenticationFilter;\n}",
                "name": "clientOAuth2Filter",
                "modifiers": "@Bean\n    public",
                "return_type": "Filter",
                "parameters": [],
                "body": "{\n    OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n    oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n    return oAuth2ClientAuthenticationFilter;\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthenticationSuccessListener authenticationSuccessListener() {\n    return new AuthenticationSuccessListener();\n}",
                "name": "authenticationSuccessListener",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthenticationSuccessListener",
                "parameters": [],
                "body": "{\n    return new AuthenticationSuccessListener();\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic LogoutHandler cookieClearingLogoutHandler() {\n    return new CookieClearingLogoutHandler();\n}",
                "name": "cookieClearingLogoutHandler",
                "modifiers": "@Bean\n    public",
                "return_type": "LogoutHandler",
                "parameters": [],
                "body": "{\n    return new CookieClearingLogoutHandler();\n}",
                "start_point": {
                    "row": 113,
                    "column": 4
                },
                "end_point": {
                    "row": 116,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthenticationSuccessHandler authenticationSuccessHandler() {\n    CustomSavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n    successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n    return successHandler;\n}",
                "name": "authenticationSuccessHandler",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthenticationSuccessHandler",
                "parameters": [],
                "body": "{\n    CustomSavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n    successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n    return successHandler;\n}",
                "start_point": {
                    "row": 118,
                    "column": 4
                },
                "end_point": {
                    "row": 123,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic IdentityProviderManager identityProviderManager() {\n    return new IdentityProviderManagerImpl();\n}",
                "name": "identityProviderManager",
                "modifiers": "@Bean\n    public",
                "return_type": "IdentityProviderManager",
                "parameters": [],
                "body": "{\n    return new IdentityProviderManagerImpl();\n}",
                "start_point": {
                    "row": 125,
                    "column": 4
                },
                "end_point": {
                    "row": 128,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic JWTCookieGenerator jwtCookieGenerator() {\n    return new JWTCookieGenerator();\n}",
                "name": "jwtCookieGenerator",
                "modifiers": "@Bean\n    public",
                "return_type": "JWTCookieGenerator",
                "parameters": [],
                "body": "{\n    return new JWTCookieGenerator();\n}",
                "start_point": {
                    "row": 130,
                    "column": 4
                },
                "end_point": {
                    "row": 133,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/controller/AuthorizationController.java",
        "definition": "@Controller\npublic class AuthorizationController {\n\n    private static final String REDIRECT_URI = \"redirect_uri\";\n\n    @RequestMapping(value = \"/authorize\")\n    public void authorize(HttpServletResponse response, @RequestParam Map<String, String> parameters, HttpSession session) throws IOException {\n        String redirectUriParameter = parameters.get(REDIRECT_URI);\n        if (redirectUriParameter == null || redirectUriParameter.isEmpty()) {\n            throw new IllegalArgumentException(\"A redirectUri must be either supplied\");\n        }\n        response.sendRedirect(redirectUriParameter);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.controller;",
        "tree_path": "AuthorizationController",
        "name": "AuthorizationController",
        "modifiers": "@Controller\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private static final String REDIRECT_URI = \"redirect_uri\";\n\n    @RequestMapping(value = \"/authorize\")\n    public void authorize(HttpServletResponse response, @RequestParam Map<String, String> parameters, HttpSession session) throws IOException {\n        String redirectUriParameter = parameters.get(REDIRECT_URI);\n        if (redirectUriParameter == null || redirectUriParameter.isEmpty()) {\n            throw new IllegalArgumentException(\"A redirectUri must be either supplied\");\n        }\n        response.sendRedirect(redirectUriParameter);\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 43,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@RequestMapping(value = \"/authorize\")\npublic void authorize(HttpServletResponse response, @RequestParam Map<String, String> parameters, HttpSession session) throws IOException {\n    String redirectUriParameter = parameters.get(REDIRECT_URI);\n    if (redirectUriParameter == null || redirectUriParameter.isEmpty()) {\n        throw new IllegalArgumentException(\"A redirectUri must be either supplied\");\n    }\n    response.sendRedirect(redirectUriParameter);\n}",
                "name": "authorize",
                "modifiers": "@RequestMapping(value = \"/authorize\")\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "@RequestParam",
                        "name": "Map<String, String>"
                    },
                    {
                        "type": "HttpSession",
                        "name": "session"
                    }
                ],
                "body": "{\n    String redirectUriParameter = parameters.get(REDIRECT_URI);\n    if (redirectUriParameter == null || redirectUriParameter.isEmpty()) {\n        throw new IllegalArgumentException(\"A redirectUri must be either supplied\");\n    }\n    response.sendRedirect(redirectUriParameter);\n}",
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 42,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/provider/jwt/JWTCookieGenerator.java",
        "definition": "public class JWTCookieGenerator {\n\n    private static final boolean DEFAULT_JWT_COOKIE_SECURE = false;\n    private static final String DEFAULT_JWT_COOKIE_PATH = \"/\";\n    private static final String DEFAULT_JWT_COOKIE_DOMAIN = \"\";\n    private static final String DEFAULT_JWT_SECRET = \"myJWT4Gr4v1t33_S3cr3t\";\n    private static final int DEFAULT_JWT_EXPIRE_AFTER = 604800;\n\n    @Autowired\n    private Environment environment;\n\n    public Cookie generate(final User user) {\n        String compactJws = Jwts.builder()\n                .setSubject(user.getUsername())\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + JWTCookieGenerator.DEFAULT_JWT_EXPIRE_AFTER))\n                .setClaims(user.getAdditionalInformation())\n                .signWith(SignatureAlgorithm.HS512, environment.getProperty(\"jwt.secret\", DEFAULT_JWT_SECRET))\n                .compact();\n        return generate(\"Bearer \" + compactJws);\n    }\n\n    private Cookie generate(final String value) {\n        final Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, value);\n        cookie.setHttpOnly(true);\n        cookie.setSecure(environment.getProperty(\"jwt.cookie-secure\", Boolean.class, DEFAULT_JWT_COOKIE_SECURE));\n        cookie.setPath(environment.getProperty(\"jwt.cookie-path\", DEFAULT_JWT_COOKIE_PATH));\n        cookie.setDomain(environment.getProperty(\"jwt.cookie-domain\", DEFAULT_JWT_COOKIE_DOMAIN));\n        cookie.setMaxAge(environment.getProperty(\"jwt.expire-after\", Integer.class, DEFAULT_JWT_EXPIRE_AFTER));\n        return cookie;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.provider.jwt;",
        "tree_path": "JWTCookieGenerator",
        "name": "JWTCookieGenerator",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private static final boolean DEFAULT_JWT_COOKIE_SECURE = false;\n    private static final String DEFAULT_JWT_COOKIE_PATH = \"/\";\n    private static final String DEFAULT_JWT_COOKIE_DOMAIN = \"\";\n    private static final String DEFAULT_JWT_SECRET = \"myJWT4Gr4v1t33_S3cr3t\";\n    private static final int DEFAULT_JWT_EXPIRE_AFTER = 604800;\n\n    @Autowired\n    private Environment environment;\n\n    public Cookie generate(final User user) {\n        String compactJws = Jwts.builder()\n                .setSubject(user.getUsername())\n                .setIssuedAt(new Date())\n                .setExpiration(new Date(System.currentTimeMillis() + JWTCookieGenerator.DEFAULT_JWT_EXPIRE_AFTER))\n                .setClaims(user.getAdditionalInformation())\n                .signWith(SignatureAlgorithm.HS512, environment.getProperty(\"jwt.secret\", DEFAULT_JWT_SECRET))\n                .compact();\n        return generate(\"Bearer \" + compactJws);\n    }\n\n    private Cookie generate(final String value) {\n        final Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, value);\n        cookie.setHttpOnly(true);\n        cookie.setSecure(environment.getProperty(\"jwt.cookie-secure\", Boolean.class, DEFAULT_JWT_COOKIE_SECURE));\n        cookie.setPath(environment.getProperty(\"jwt.cookie-path\", DEFAULT_JWT_COOKIE_PATH));\n        cookie.setDomain(environment.getProperty(\"jwt.cookie-domain\", DEFAULT_JWT_COOKIE_DOMAIN));\n        cookie.setMaxAge(environment.getProperty(\"jwt.expire-after\", Integer.class, DEFAULT_JWT_EXPIRE_AFTER));\n        return cookie;\n    }\n}",
        "start_point": {
            "row": 31,
            "column": 0
        },
        "end_point": {
            "row": 62,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "public Cookie generate(final User user) {\n    String compactJws = Jwts.builder()\n            .setSubject(user.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + JWTCookieGenerator.DEFAULT_JWT_EXPIRE_AFTER))\n            .setClaims(user.getAdditionalInformation())\n            .signWith(SignatureAlgorithm.HS512, environment.getProperty(\"jwt.secret\", DEFAULT_JWT_SECRET))\n            .compact();\n    return generate(\"Bearer \" + compactJws);\n}",
                "name": "generate",
                "modifiers": "public",
                "return_type": "Cookie",
                "parameters": [
                    {
                        "type": "final",
                        "name": "User"
                    }
                ],
                "body": "{\n    String compactJws = Jwts.builder()\n            .setSubject(user.getUsername())\n            .setIssuedAt(new Date())\n            .setExpiration(new Date(System.currentTimeMillis() + JWTCookieGenerator.DEFAULT_JWT_EXPIRE_AFTER))\n            .setClaims(user.getAdditionalInformation())\n            .signWith(SignatureAlgorithm.HS512, environment.getProperty(\"jwt.secret\", DEFAULT_JWT_SECRET))\n            .compact();\n    return generate(\"Bearer \" + compactJws);\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "private Cookie generate(final String value) {\n    final Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, value);\n    cookie.setHttpOnly(true);\n    cookie.setSecure(environment.getProperty(\"jwt.cookie-secure\", Boolean.class, DEFAULT_JWT_COOKIE_SECURE));\n    cookie.setPath(environment.getProperty(\"jwt.cookie-path\", DEFAULT_JWT_COOKIE_PATH));\n    cookie.setDomain(environment.getProperty(\"jwt.cookie-domain\", DEFAULT_JWT_COOKIE_DOMAIN));\n    cookie.setMaxAge(environment.getProperty(\"jwt.expire-after\", Integer.class, DEFAULT_JWT_EXPIRE_AFTER));\n    return cookie;\n}",
                "name": "generate",
                "modifiers": "private",
                "return_type": "Cookie",
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    final Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, value);\n    cookie.setHttpOnly(true);\n    cookie.setSecure(environment.getProperty(\"jwt.cookie-secure\", Boolean.class, DEFAULT_JWT_COOKIE_SECURE));\n    cookie.setPath(environment.getProperty(\"jwt.cookie-path\", DEFAULT_JWT_COOKIE_PATH));\n    cookie.setDomain(environment.getProperty(\"jwt.cookie-domain\", DEFAULT_JWT_COOKIE_DOMAIN));\n    cookie.setMaxAge(environment.getProperty(\"jwt.expire-after\", Integer.class, DEFAULT_JWT_EXPIRE_AFTER));\n    return cookie;\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/provider/security/DomainBasedAuthenticationProvider.java",
        "definition": "public class DomainBasedAuthenticationProvider implements AuthenticationProvider {\n\n    private final Logger logger = LoggerFactory.getLogger(DomainBasedAuthenticationProvider.class);\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    private static final String SOURCE = \"source\";\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n\n        Map<String, String> details = new HashMap<>();\n        Set<String> identities = domain.getIdentities();\n        Iterator<String> iter = identities.iterator();\n        io.gravitee.am.identityprovider.api.User user = null;\n\n        // Create a end-user authentication for underlying providers associated to the domain\n        io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n                authentication.getName(),\n                authentication.getCredentials());\n\n        while (iter.hasNext() && user == null) {\n            String provider = iter.next();\n            io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                    identityProviderManager.get(provider);\n\n            if (authenticationProvider == null) {\n                throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n            }\n\n            try {\n                user = authenticationProvider.loadUserByUsername(provAuthentication);\n                // set user identity provider source\n                details.put(SOURCE, provider);\n            } catch (Exception ex) {\n                logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n                throw new BadCredentialsException(ex.getMessage(), ex);\n            }\n        }\n\n        if (user != null) {\n            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n            authenticationToken.setDetails(details);\n            return authenticationToken;\n        }\n\n        throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n    }\n\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return authentication.equals(\n                UsernamePasswordAuthenticationToken.class);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.provider.security;",
        "tree_path": "DomainBasedAuthenticationProvider",
        "name": "DomainBasedAuthenticationProvider",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements AuthenticationProvider",
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(DomainBasedAuthenticationProvider.class);\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    private static final String SOURCE = \"source\";\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n\n        Map<String, String> details = new HashMap<>();\n        Set<String> identities = domain.getIdentities();\n        Iterator<String> iter = identities.iterator();\n        io.gravitee.am.identityprovider.api.User user = null;\n\n        // Create a end-user authentication for underlying providers associated to the domain\n        io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n                authentication.getName(),\n                authentication.getCredentials());\n\n        while (iter.hasNext() && user == null) {\n            String provider = iter.next();\n            io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                    identityProviderManager.get(provider);\n\n            if (authenticationProvider == null) {\n                throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n            }\n\n            try {\n                user = authenticationProvider.loadUserByUsername(provAuthentication);\n                // set user identity provider source\n                details.put(SOURCE, provider);\n            } catch (Exception ex) {\n                logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n                throw new BadCredentialsException(ex.getMessage(), ex);\n            }\n        }\n\n        if (user != null) {\n            UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n            authenticationToken.setDetails(details);\n            return authenticationToken;\n        }\n\n        throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n    }\n\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return authentication.equals(\n                UsernamePasswordAuthenticationToken.class);\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 100,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Authentication authenticate(Authentication authentication) throws AuthenticationException {\n\n    Map<String, String> details = new HashMap<>();\n    Set<String> identities = domain.getIdentities();\n    Iterator<String> iter = identities.iterator();\n    io.gravitee.am.identityprovider.api.User user = null;\n\n    // Create a end-user authentication for underlying providers associated to the domain\n    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n            authentication.getName(),\n            authentication.getCredentials());\n\n    while (iter.hasNext() && user == null) {\n        String provider = iter.next();\n        io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                identityProviderManager.get(provider);\n\n        if (authenticationProvider == null) {\n            throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n        }\n\n        try {\n            user = authenticationProvider.loadUserByUsername(provAuthentication);\n            // set user identity provider source\n            details.put(SOURCE, provider);\n        } catch (Exception ex) {\n            logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    if (user != null) {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n        authenticationToken.setDetails(details);\n        return authenticationToken;\n    }\n\n    throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n}",
                "name": "authenticate",
                "modifiers": "@Override\n    public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n\n    Map<String, String> details = new HashMap<>();\n    Set<String> identities = domain.getIdentities();\n    Iterator<String> iter = identities.iterator();\n    io.gravitee.am.identityprovider.api.User user = null;\n\n    // Create a end-user authentication for underlying providers associated to the domain\n    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n            authentication.getName(),\n            authentication.getCredentials());\n\n    while (iter.hasNext() && user == null) {\n        String provider = iter.next();\n        io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                identityProviderManager.get(provider);\n\n        if (authenticationProvider == null) {\n            throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n        }\n\n        try {\n            user = authenticationProvider.loadUserByUsername(provAuthentication);\n            // set user identity provider source\n            details.put(SOURCE, provider);\n        } catch (Exception ex) {\n            logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    if (user != null) {\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n        authenticationToken.setDetails(details);\n        return authenticationToken;\n    }\n\n    throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n}",
                "start_point": {
                    "row": 54,
                    "column": 4
                },
                "end_point": {
                    "row": 93,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean supports(Class<?> authentication) {\n    return authentication.equals(\n            UsernamePasswordAuthenticationToken.class);\n}",
                "name": "supports",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Class<?>",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    return authentication.equals(\n            UsernamePasswordAuthenticationToken.class);\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/resources/CurrentUserResource.java",
        "definition": "@Api(tags = {\"users\", \"current\"})\n@Path(\"/user\")\npublic class CurrentUserResource extends AbstractResource {\n\n    private Logger logger = LoggerFactory.getLogger(CurrentUserResource.class);\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Get the current user\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"Current user successfully fetched\", response = User.class),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void get(@Suspended final AsyncResponse response) {\n        Single<Map<String, Object>> currentUserSource = Single.create(emitter -> {\n            try {\n                if (isAuthenticated()) {\n                    UsernamePasswordAuthenticationToken authenticatedUser = (UsernamePasswordAuthenticationToken) getAuthenticatedUser();\n                    emitter.onSuccess(((io.gravitee.am.identityprovider.api.User) authenticatedUser.getPrincipal()).getAdditionalInformation());\n                } else {\n                    emitter.onError(new IllegalAccessException(\"Current user is not authenticated\"));\n                }\n            } catch (Exception ex) {\n                logger.error(\"Failed to get user profile information\", ex);\n                emitter.onError(ex);\n            }\n        });\n\n        currentUserSource.subscribe(\n                result -> response.resume(result),\n                error -> response.resume(error));\n\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.resources;",
        "tree_path": "CurrentUserResource",
        "name": "CurrentUserResource",
        "modifiers": "@Api(tags = {\"users\", \"current\"})\n@Path(\"/user\")\npublic",
        "superclass": "extends AbstractResource",
        "super_interfaces": null,
        "body": "{\n\n    private Logger logger = LoggerFactory.getLogger(CurrentUserResource.class);\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Get the current user\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"Current user successfully fetched\", response = User.class),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void get(@Suspended final AsyncResponse response) {\n        Single<Map<String, Object>> currentUserSource = Single.create(emitter -> {\n            try {\n                if (isAuthenticated()) {\n                    UsernamePasswordAuthenticationToken authenticatedUser = (UsernamePasswordAuthenticationToken) getAuthenticatedUser();\n                    emitter.onSuccess(((io.gravitee.am.identityprovider.api.User) authenticatedUser.getPrincipal()).getAdditionalInformation());\n                } else {\n                    emitter.onError(new IllegalAccessException(\"Current user is not authenticated\"));\n                }\n            } catch (Exception ex) {\n                logger.error(\"Failed to get user profile information\", ex);\n                emitter.onError(ex);\n            }\n        });\n\n        currentUserSource.subscribe(\n                result -> response.resume(result),\n                error -> response.resume(error));\n\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 71,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@GET\n@Produces(MediaType.APPLICATION_JSON)\n@ApiOperation(value = \"Get the current user\")\n@ApiResponses({\n        @ApiResponse(code = 200, message = \"Current user successfully fetched\", response = User.class),\n        @ApiResponse(code = 500, message = \"Internal server error\")})\npublic void get(@Suspended final AsyncResponse response) {\n    Single<Map<String, Object>> currentUserSource = Single.create(emitter -> {\n        try {\n            if (isAuthenticated()) {\n                UsernamePasswordAuthenticationToken authenticatedUser = (UsernamePasswordAuthenticationToken) getAuthenticatedUser();\n                emitter.onSuccess(((io.gravitee.am.identityprovider.api.User) authenticatedUser.getPrincipal()).getAdditionalInformation());\n            } else {\n                emitter.onError(new IllegalAccessException(\"Current user is not authenticated\"));\n            }\n        } catch (Exception ex) {\n            logger.error(\"Failed to get user profile information\", ex);\n            emitter.onError(ex);\n        }\n    });\n\n    currentUserSource.subscribe(\n            result -> response.resume(result),\n            error -> response.resume(error));\n\n}",
                "name": "get",
                "modifiers": "@GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Get the current user\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"Current user successfully fetched\", response = User.class),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Suspended final",
                        "name": "AsyncResponse"
                    }
                ],
                "body": "{\n    Single<Map<String, Object>> currentUserSource = Single.create(emitter -> {\n        try {\n            if (isAuthenticated()) {\n                UsernamePasswordAuthenticationToken authenticatedUser = (UsernamePasswordAuthenticationToken) getAuthenticatedUser();\n                emitter.onSuccess(((io.gravitee.am.identityprovider.api.User) authenticatedUser.getPrincipal()).getAdditionalInformation());\n            } else {\n                emitter.onError(new IllegalAccessException(\"Current user is not authenticated\"));\n            }\n        } catch (Exception ex) {\n            logger.error(\"Failed to get user profile information\", ex);\n            emitter.onError(ex);\n        }\n    });\n\n    currentUserSource.subscribe(\n            result -> response.resume(result),\n            error -> response.resume(error));\n\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/spring/security/filter/JWTAuthenticationFilter.java",
        "definition": "public class JWTAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\n\n    @Value(\"${jwt.secret:myJWT4Gr4v1t33_S3cr3t}\")\n    private String jwtSecret;\n    @Value(\"${jwt.cookie-path:/}\")\n    private String jwtCookiePath;\n\n    public JWTAuthenticationFilter(RequestMatcher requiresAuthenticationRequestMatcher) {\n        super(requiresAuthenticationRequestMatcher);\n        setAuthenticationManager(new NoopAuthenticationManager());\n        setAuthenticationSuccessHandler(new JwtAuthenticationSuccessHandler());\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        final Optional<Cookie> optionalStringToken;\n\n        if (request.getCookies() == null) {\n            optionalStringToken = Optional.empty();\n        } else {\n            optionalStringToken = Arrays.stream(request.getCookies())\n                    .filter(cookie -> HttpHeaders.AUTHORIZATION.equals(cookie.getName()))\n                    .findAny();\n        }\n\n        if (!optionalStringToken.isPresent() || !optionalStringToken.get().getValue().startsWith(\"Bearer \")) {\n            throw new BadCredentialsException(\"No JWT token found\");\n        }\n\n        String authToken = optionalStringToken.get().getValue().substring(7);\n\n        try {\n            Claims claims = Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken).getBody();\n            DefaultUser user = new DefaultUser(claims.getSubject());\n            user.setAdditonalInformation(claims);\n            return new UsernamePasswordAuthenticationToken(user, null, AuthorityUtils.NO_AUTHORITIES);\n        } catch (Exception ex) {\n            removeJWTAuthenticationCookie(response);\n            throw new BadCredentialsException(\"Error occurs while attempting authentication\", ex);\n        }\n    }\n\n    @Override\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {\n        super.successfulAuthentication(request, response, chain, authResult);\n\n        // As this is a REST authentication, after success we need to continue the request normally\n        // and return the response as if the resource was not secured at all\n        chain.doFilter(request, response);\n    }\n\n    private void removeJWTAuthenticationCookie(HttpServletResponse response) {\n        Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n        cookie.setPath(jwtCookiePath);\n        cookie.setMaxAge(0);\n        response.addCookie(cookie);\n    }\n\n    private static class NoopAuthenticationManager implements AuthenticationManager {\n\n        @Override\n        public Authentication authenticate(Authentication authentication)\n                throws AuthenticationException {\n            // We only use JWT library to authenticate the user, authentication manager is not required\n            throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n        }\n\n    }\n\n    private static class JwtAuthenticationSuccessHandler implements AuthenticationSuccessHandler {\n\n        @Override\n        public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n            // We do not need to do anything extra on REST authentication success, because there is no page to redirect to\n        }\n\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.spring.security.filter;",
        "tree_path": "JWTAuthenticationFilter",
        "name": "JWTAuthenticationFilter",
        "modifiers": "public",
        "superclass": "extends AbstractAuthenticationProcessingFilter",
        "super_interfaces": null,
        "body": "{\n\n    @Value(\"${jwt.secret:myJWT4Gr4v1t33_S3cr3t}\")\n    private String jwtSecret;\n    @Value(\"${jwt.cookie-path:/}\")\n    private String jwtCookiePath;\n\n    public JWTAuthenticationFilter(RequestMatcher requiresAuthenticationRequestMatcher) {\n        super(requiresAuthenticationRequestMatcher);\n        setAuthenticationManager(new NoopAuthenticationManager());\n        setAuthenticationSuccessHandler(new JwtAuthenticationSuccessHandler());\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        final Optional<Cookie> optionalStringToken;\n\n        if (request.getCookies() == null) {\n            optionalStringToken = Optional.empty();\n        } else {\n            optionalStringToken = Arrays.stream(request.getCookies())\n                    .filter(cookie -> HttpHeaders.AUTHORIZATION.equals(cookie.getName()))\n                    .findAny();\n        }\n\n        if (!optionalStringToken.isPresent() || !optionalStringToken.get().getValue().startsWith(\"Bearer \")) {\n            throw new BadCredentialsException(\"No JWT token found\");\n        }\n\n        String authToken = optionalStringToken.get().getValue().substring(7);\n\n        try {\n            Claims claims = Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken).getBody();\n            DefaultUser user = new DefaultUser(claims.getSubject());\n            user.setAdditonalInformation(claims);\n            return new UsernamePasswordAuthenticationToken(user, null, AuthorityUtils.NO_AUTHORITIES);\n        } catch (Exception ex) {\n            removeJWTAuthenticationCookie(response);\n            throw new BadCredentialsException(\"Error occurs while attempting authentication\", ex);\n        }\n    }\n\n    @Override\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {\n        super.successfulAuthentication(request, response, chain, authResult);\n\n        // As this is a REST authentication, after success we need to continue the request normally\n        // and return the response as if the resource was not secured at all\n        chain.doFilter(request, response);\n    }\n\n    private void removeJWTAuthenticationCookie(HttpServletResponse response) {\n        Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n        cookie.setPath(jwtCookiePath);\n        cookie.setMaxAge(0);\n        response.addCookie(cookie);\n    }\n\n    private static class NoopAuthenticationManager implements AuthenticationManager {\n\n        @Override\n        public Authentication authenticate(Authentication authentication)\n                throws AuthenticationException {\n            // We only use JWT library to authenticate the user, authentication manager is not required\n            throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n        }\n\n    }\n\n    private static class JwtAuthenticationSuccessHandler implements AuthenticationSuccessHandler {\n\n        @Override\n        public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n            // We do not need to do anything extra on REST authentication success, because there is no page to redirect to\n        }\n\n    }\n}",
        "start_point": {
            "row": 41,
            "column": 0
        },
        "end_point": {
            "row": 118,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "public JWTAuthenticationFilter(RequestMatcher requiresAuthenticationRequestMatcher) {\n    super(requiresAuthenticationRequestMatcher);\n    setAuthenticationManager(new NoopAuthenticationManager());\n    setAuthenticationSuccessHandler(new JwtAuthenticationSuccessHandler());\n}",
                "name": "JWTAuthenticationFilter",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "RequestMatcher",
                        "name": "requiresAuthenticationRequestMatcher"
                    }
                ],
                "body": "{\n    super(requiresAuthenticationRequestMatcher);\n    setAuthenticationManager(new NoopAuthenticationManager());\n    setAuthenticationSuccessHandler(new JwtAuthenticationSuccessHandler());\n}",
                "constructor": true,
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 52,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n    final Optional<Cookie> optionalStringToken;\n\n    if (request.getCookies() == null) {\n        optionalStringToken = Optional.empty();\n    } else {\n        optionalStringToken = Arrays.stream(request.getCookies())\n                .filter(cookie -> HttpHeaders.AUTHORIZATION.equals(cookie.getName()))\n                .findAny();\n    }\n\n    if (!optionalStringToken.isPresent() || !optionalStringToken.get().getValue().startsWith(\"Bearer \")) {\n        throw new BadCredentialsException(\"No JWT token found\");\n    }\n\n    String authToken = optionalStringToken.get().getValue().substring(7);\n\n    try {\n        Claims claims = Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken).getBody();\n        DefaultUser user = new DefaultUser(claims.getSubject());\n        user.setAdditonalInformation(claims);\n        return new UsernamePasswordAuthenticationToken(user, null, AuthorityUtils.NO_AUTHORITIES);\n    } catch (Exception ex) {\n        removeJWTAuthenticationCookie(response);\n        throw new BadCredentialsException(\"Error occurs while attempting authentication\", ex);\n    }\n}",
                "name": "attemptAuthentication",
                "modifiers": "@Override\n    public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    final Optional<Cookie> optionalStringToken;\n\n    if (request.getCookies() == null) {\n        optionalStringToken = Optional.empty();\n    } else {\n        optionalStringToken = Arrays.stream(request.getCookies())\n                .filter(cookie -> HttpHeaders.AUTHORIZATION.equals(cookie.getName()))\n                .findAny();\n    }\n\n    if (!optionalStringToken.isPresent() || !optionalStringToken.get().getValue().startsWith(\"Bearer \")) {\n        throw new BadCredentialsException(\"No JWT token found\");\n    }\n\n    String authToken = optionalStringToken.get().getValue().substring(7);\n\n    try {\n        Claims claims = Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken).getBody();\n        DefaultUser user = new DefaultUser(claims.getSubject());\n        user.setAdditonalInformation(claims);\n        return new UsernamePasswordAuthenticationToken(user, null, AuthorityUtils.NO_AUTHORITIES);\n    } catch (Exception ex) {\n        removeJWTAuthenticationCookie(response);\n        throw new BadCredentialsException(\"Error occurs while attempting authentication\", ex);\n    }\n}",
                "start_point": {
                    "row": 54,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {\n    super.successfulAuthentication(request, response, chain, authResult);\n\n    // As this is a REST authentication, after success we need to continue the request normally\n    // and return the response as if the resource was not secured at all\n    chain.doFilter(request, response);\n}",
                "name": "successfulAuthentication",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "FilterChain",
                        "name": "chain"
                    },
                    {
                        "type": "Authentication",
                        "name": "authResult"
                    }
                ],
                "body": "{\n    super.successfulAuthentication(request, response, chain, authResult);\n\n    // As this is a REST authentication, after success we need to continue the request normally\n    // and return the response as if the resource was not secured at all\n    chain.doFilter(request, response);\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 90,
                    "column": 5
                }
            },
            {
                "definition": "private void removeJWTAuthenticationCookie(HttpServletResponse response) {\n    Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n    cookie.setPath(jwtCookiePath);\n    cookie.setMaxAge(0);\n    response.addCookie(cookie);\n}",
                "name": "removeJWTAuthenticationCookie",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n    cookie.setPath(jwtCookiePath);\n    cookie.setMaxAge(0);\n    response.addCookie(cookie);\n}",
                "start_point": {
                    "row": 92,
                    "column": 4
                },
                "end_point": {
                    "row": 97,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/spring/security/filter/JWTAuthenticationFilter.java",
        "definition": "private static class NoopAuthenticationManager implements AuthenticationManager {\n\n    @Override\n    public Authentication authenticate(Authentication authentication)\n            throws AuthenticationException {\n        // We only use JWT library to authenticate the user, authentication manager is not required\n        throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.spring.security.filter;",
        "tree_path": "JWTAuthenticationFilter.NoopAuthenticationManager",
        "name": "NoopAuthenticationManager",
        "modifiers": "private static",
        "superclass": null,
        "super_interfaces": "implements AuthenticationManager",
        "body": "{\n\n    @Override\n    public Authentication authenticate(Authentication authentication)\n            throws AuthenticationException {\n        // We only use JWT library to authenticate the user, authentication manager is not required\n        throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n    }\n\n}",
        "start_point": {
            "row": 99,
            "column": 4
        },
        "end_point": {
            "row": 108,
            "column": 5
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Authentication authenticate(Authentication authentication)\n        throws AuthenticationException {\n    // We only use JWT library to authenticate the user, authentication manager is not required\n    throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n}",
                "name": "authenticate",
                "modifiers": "@Override\n        public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    // We only use JWT library to authenticate the user, authentication manager is not required\n    throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n}",
                "start_point": {
                    "row": 101,
                    "column": 8
                },
                "end_point": {
                    "row": 106,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/spring/security/filter/JWTAuthenticationFilter.java",
        "definition": "private static class JwtAuthenticationSuccessHandler implements AuthenticationSuccessHandler {\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        // We do not need to do anything extra on REST authentication success, because there is no page to redirect to\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.spring.security.filter;",
        "tree_path": "JWTAuthenticationFilter.JwtAuthenticationSuccessHandler",
        "name": "JwtAuthenticationSuccessHandler",
        "modifiers": "private static",
        "superclass": null,
        "super_interfaces": "implements AuthenticationSuccessHandler",
        "body": "{\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        // We do not need to do anything extra on REST authentication success, because there is no page to redirect to\n    }\n\n}",
        "start_point": {
            "row": 110,
            "column": 4
        },
        "end_point": {
            "row": 117,
            "column": 5
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n    // We do not need to do anything extra on REST authentication success, because there is no page to redirect to\n}",
                "name": "onAuthenticationSuccess",
                "modifiers": "@Override\n        public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    // We do not need to do anything extra on REST authentication success, because there is no page to redirect to\n}",
                "start_point": {
                    "row": 112,
                    "column": 8
                },
                "end_point": {
                    "row": 115,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/spring/security/web/RestAuthenticationEntryPoint.java",
        "definition": "public class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        // This is invoked when user tries to access a secured REST resource without supplying any credentials\n        // We should just send a 401 Unauthorized response because there is no 'login page' to redirect to\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.spring.security.web;",
        "tree_path": "RestAuthenticationEntryPoint",
        "name": "RestAuthenticationEntryPoint",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements AuthenticationEntryPoint",
        "body": "{\n\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n        // This is invoked when user tries to access a secured REST resource without supplying any credentials\n        // We should just send a 401 Unauthorized response because there is no 'login page' to redirect to\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 37,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {\n    // This is invoked when user tries to access a secured REST resource without supplying any credentials\n    // We should just send a 401 Unauthorized response because there is no 'login page' to redirect to\n    response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n}",
                "name": "commence",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "AuthenticationException",
                        "name": "authException"
                    }
                ],
                "body": "{\n    // This is invoked when user tries to access a secured REST resource without supplying any credentials\n    // We should just send a 401 Unauthorized response because there is no 'login page' to redirect to\n    response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n}",
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 36,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/test/java/io/gravitee/am/management/service/DeployAdminDomainUpgraderTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class DeployAdminDomainUpgraderTest {\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    @InjectMocks\n    private DeployAdminDomainUpgrader deployAdminDomainUpgrader = new DeployAdminDomainUpgrader();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private EventManager eventManager;\n\n    @Test\n    public void shouldDeployAdminDomain() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        deployAdminDomainUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(eventManager, times(1)).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n    }\n\n    @Test\n    public void shouldDeployAdminDomain_domainNotFound() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n        deployAdminDomainUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(eventManager,never()).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n    }\n\n}",
        "package": "package io.gravitee.am.management.service;",
        "tree_path": "DeployAdminDomainUpgraderTest",
        "name": "DeployAdminDomainUpgraderTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    @InjectMocks\n    private DeployAdminDomainUpgrader deployAdminDomainUpgrader = new DeployAdminDomainUpgrader();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private EventManager eventManager;\n\n    @Test\n    public void shouldDeployAdminDomain() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        deployAdminDomainUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(eventManager, times(1)).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n    }\n\n    @Test\n    public void shouldDeployAdminDomain_domainNotFound() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n        deployAdminDomainUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(eventManager,never()).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n    }\n\n}",
        "start_point": {
            "row": 36,
            "column": 0
        },
        "end_point": {
            "row": 76,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldDeployAdminDomain() {\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    deployAdminDomainUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(eventManager, times(1)).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n}",
                "name": "shouldDeployAdminDomain",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    deployAdminDomainUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(eventManager, times(1)).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n}",
                "start_point": {
                    "row": 50,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldDeployAdminDomain_domainNotFound() {\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n    deployAdminDomainUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(eventManager,never()).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n}",
                "name": "shouldDeployAdminDomain_domainNotFound",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n    deployAdminDomainUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(eventManager,never()).publishEvent(eq(DomainEvent.DEPLOY), any(Domain.class));\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/test/java/io/gravitee/am/management/service/InitializeUpgraderTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class InitializeUpgraderTest {\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n\n    @InjectMocks\n    private InitializeUpgrader initializeUpgrader = new InitializeUpgrader();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private IdentityProviderService identityProviderService;\n\n    @Test\n    public void shouldCreateAdminDomain() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n        when(identityProviderService.create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class))).thenReturn(Single.just(new IdentityProvider()));\n        when(domainService.create(any(NewDomain.class))).thenReturn(Single.just(adminDomain));\n        when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n        when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(identityProviderService, times(1)).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, times(1)).create(any(NewDomain.class));\n        verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n        verify(clientService, never()).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n    }\n\n    @Test\n    public void shouldUpdateAdminDomain_adminClientExists() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n        adminDomain.setMaster(true);\n\n        final Client adminClient = new Client();\n        adminClient.setId(ADMIN_CLIENT_ID);\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n        when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.just(adminClient));\n        when(clientService.delete(ADMIN_CLIENT_ID)).thenReturn(Single.just(Irrelevant.CLIENT));\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n        verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(clientService, times(1)).delete(ADMIN_CLIENT_ID);\n\n        verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, never()).create(any(NewDomain.class));\n        verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n    }\n\n    @Test\n    public void shouldUpdateAdminDomain_adminClientNotFound() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n        adminDomain.setMaster(true);\n\n        final Client adminClient = new Client();\n        adminClient.setId(ADMIN_CLIENT_ID);\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n        when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n\n        verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n        verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, never()).create(any(NewDomain.class));\n        verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n    }\n\n    @Test\n    public void shouldUpdateMasterFlagAdminDomain_adminClientNotFound() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n        adminDomain.setMaster(false);\n\n        final Client adminClient = new Client();\n        adminClient.setId(ADMIN_CLIENT_ID);\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n        when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n        verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n\n        verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n        verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, never()).create(any(NewDomain.class));\n    }\n\n\n}",
        "package": "package io.gravitee.am.management.service;",
        "tree_path": "InitializeUpgraderTest",
        "name": "InitializeUpgraderTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n\n    @InjectMocks\n    private InitializeUpgrader initializeUpgrader = new InitializeUpgrader();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private IdentityProviderService identityProviderService;\n\n    @Test\n    public void shouldCreateAdminDomain() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n        when(identityProviderService.create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class))).thenReturn(Single.just(new IdentityProvider()));\n        when(domainService.create(any(NewDomain.class))).thenReturn(Single.just(adminDomain));\n        when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n        when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(identityProviderService, times(1)).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, times(1)).create(any(NewDomain.class));\n        verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n        verify(clientService, never()).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n    }\n\n    @Test\n    public void shouldUpdateAdminDomain_adminClientExists() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n        adminDomain.setMaster(true);\n\n        final Client adminClient = new Client();\n        adminClient.setId(ADMIN_CLIENT_ID);\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n        when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.just(adminClient));\n        when(clientService.delete(ADMIN_CLIENT_ID)).thenReturn(Single.just(Irrelevant.CLIENT));\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n        verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(clientService, times(1)).delete(ADMIN_CLIENT_ID);\n\n        verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, never()).create(any(NewDomain.class));\n        verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n    }\n\n    @Test\n    public void shouldUpdateAdminDomain_adminClientNotFound() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n        adminDomain.setMaster(true);\n\n        final Client adminClient = new Client();\n        adminClient.setId(ADMIN_CLIENT_ID);\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n        when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n\n        verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n        verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, never()).create(any(NewDomain.class));\n        verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n    }\n\n    @Test\n    public void shouldUpdateMasterFlagAdminDomain_adminClientNotFound() {\n        final Domain adminDomain = new Domain();\n        adminDomain.setId(ADMIN_DOMAIN);\n        adminDomain.setName(\"ADMIN\");\n        adminDomain.setMaster(false);\n\n        final Client adminClient = new Client();\n        adminClient.setId(ADMIN_CLIENT_ID);\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n\n        when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n        when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n        when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n        initializeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n        verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n        verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n\n        verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n        verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n        verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n        verify(domainService, never()).create(any(NewDomain.class));\n    }\n\n\n}",
        "start_point": {
            "row": 43,
            "column": 0
        },
        "end_point": {
            "row": 166,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldCreateAdminDomain() {\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n    when(identityProviderService.create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class))).thenReturn(Single.just(new IdentityProvider()));\n    when(domainService.create(any(NewDomain.class))).thenReturn(Single.just(adminDomain));\n    when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n    when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(identityProviderService, times(1)).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, times(1)).create(any(NewDomain.class));\n    verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n    verify(clientService, never()).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n}",
                "name": "shouldCreateAdminDomain",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.empty());\n    when(identityProviderService.create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class))).thenReturn(Single.just(new IdentityProvider()));\n    when(domainService.create(any(NewDomain.class))).thenReturn(Single.just(adminDomain));\n    when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n    when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(identityProviderService, times(1)).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, times(1)).create(any(NewDomain.class));\n    verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n    verify(clientService, never()).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdateAdminDomain_adminClientExists() {\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n    adminDomain.setMaster(true);\n\n    final Client adminClient = new Client();\n    adminClient.setId(ADMIN_CLIENT_ID);\n    adminClient.setClientId(ADMIN_CLIENT_ID);\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n    when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.just(adminClient));\n    when(clientService.delete(ADMIN_CLIENT_ID)).thenReturn(Single.just(Irrelevant.CLIENT));\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n    verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(clientService, times(1)).delete(ADMIN_CLIENT_ID);\n\n    verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, never()).create(any(NewDomain.class));\n    verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n}",
                "name": "shouldUpdateAdminDomain_adminClientExists",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n    adminDomain.setMaster(true);\n\n    final Client adminClient = new Client();\n    adminClient.setId(ADMIN_CLIENT_ID);\n    adminClient.setClientId(ADMIN_CLIENT_ID);\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n    when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.just(adminClient));\n    when(clientService.delete(ADMIN_CLIENT_ID)).thenReturn(Single.just(Irrelevant.CLIENT));\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n    verify(domainService, times(1)).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(clientService, times(1)).delete(ADMIN_CLIENT_ID);\n\n    verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, never()).create(any(NewDomain.class));\n    verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdateAdminDomain_adminClientNotFound() {\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n    adminDomain.setMaster(true);\n\n    final Client adminClient = new Client();\n    adminClient.setId(ADMIN_CLIENT_ID);\n    adminClient.setClientId(ADMIN_CLIENT_ID);\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n    when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n\n    verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n    verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, never()).create(any(NewDomain.class));\n    verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n}",
                "name": "shouldUpdateAdminDomain_adminClientNotFound",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n    adminDomain.setMaster(true);\n\n    final Client adminClient = new Client();\n    adminClient.setId(ADMIN_CLIENT_ID);\n    adminClient.setClientId(ADMIN_CLIENT_ID);\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    when(domainService.update(eq(ADMIN_DOMAIN), any(UpdateDomain.class))).thenReturn(Single.just(adminDomain));\n    when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n\n    verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n    verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, never()).create(any(NewDomain.class));\n    verify(domainService, never()).setMasterDomain(ADMIN_DOMAIN, true);\n}",
                "start_point": {
                    "row": 111,
                    "column": 4
                },
                "end_point": {
                    "row": 136,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdateMasterFlagAdminDomain_adminClientNotFound() {\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n    adminDomain.setMaster(false);\n\n    final Client adminClient = new Client();\n    adminClient.setId(ADMIN_CLIENT_ID);\n    adminClient.setClientId(ADMIN_CLIENT_ID);\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n    when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n    verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n\n    verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n    verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, never()).create(any(NewDomain.class));\n}",
                "name": "shouldUpdateMasterFlagAdminDomain_adminClientNotFound",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Domain adminDomain = new Domain();\n    adminDomain.setId(ADMIN_DOMAIN);\n    adminDomain.setName(\"ADMIN\");\n    adminDomain.setMaster(false);\n\n    final Client adminClient = new Client();\n    adminClient.setId(ADMIN_CLIENT_ID);\n    adminClient.setClientId(ADMIN_CLIENT_ID);\n\n    when(domainService.findById(ADMIN_DOMAIN)).thenReturn(Maybe.just(adminDomain));\n    when(clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)).thenReturn(Maybe.empty());\n    when(domainService.setMasterDomain(ADMIN_DOMAIN, true)).thenReturn(Single.just(adminDomain));\n\n    initializeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findById(ADMIN_DOMAIN);\n    verify(clientService, times(1)).findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID);\n    verify(domainService, times(1)).setMasterDomain(ADMIN_DOMAIN, true);\n\n    verify(domainService, never()).update(eq(ADMIN_DOMAIN), any(UpdateDomain.class));\n    verify(clientService, never()).delete(ADMIN_CLIENT_ID);\n    verify(identityProviderService, never()).create(eq(ADMIN_DOMAIN), any(NewIdentityProvider.class));\n    verify(domainService, never()).create(any(NewDomain.class));\n}",
                "start_point": {
                    "row": 138,
                    "column": 4
                },
                "end_point": {
                    "row": 163,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/test/java/io/gravitee/am/management/service/ScopeUpgraderTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class ScopeUpgraderTest {\n\n    @InjectMocks\n    private ScopeUpgrader scopeUpgrader = new ScopeUpgrader();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ScopeService scopeService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private RoleService roleService;\n\n    @Test\n    public void shouldCreateScopes_withRoleAndClientScopes() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        final Scope clientScope = new Scope();\n        clientScope.setId(\"client-scope-key\");\n        clientScope.setKey(\"client-scope-key\");\n\n        final Client client = new Client();\n        client.setId(\"client-id\");\n        client.setScopes(Collections.singletonList(clientScope.getKey()));\n\n        final Scope roleScope = new Scope();\n        roleScope.setId(\"role-scope-key\");\n        roleScope.setKey(\"role-scope-key\");\n\n        final Role role = new Role();\n        role.setId(\"role-id\");\n        role.setPermissions(Collections.singletonList(roleScope.getKey()));\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n        when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n        when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n        when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(3)).findByDomain(domain.getId());\n        verify(clientService, times(1)).findByDomain(domain.getId());\n        verify(roleService, times(1)).findByDomain(domain.getId());\n        verify(scopeService, times(2)).create(any(String.class), any(NewScope.class));\n    }\n\n    @Test\n    public void shouldNotCreateScopes_domainHasScopes() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(domainScope)));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(1)).findByDomain(domain.getId());\n        verify(clientService, never()).findByDomain(domain.getId());\n        verify(roleService, never()).findByDomain(domain.getId());\n        verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n    }\n\n\n    @Test\n    public void shouldNotCreateScopes_noClientAndNoRole() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n        when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n        when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n        when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(1)).findByDomain(domain.getId());\n        verify(clientService, times(1)).findByDomain(domain.getId());\n        verify(roleService, times(1)).findByDomain(domain.getId());\n        verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n    }\n\n    @Test\n    public void shouldNotCreateScopes_clientsAndRolesHaveNoScopes() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        final Client client = new Client();\n        client.setId(\"client-id\");\n        client.setScopes(null);\n\n        final Role role = new Role();\n        role.setId(\"role-id\");\n        role.setPermissions(null);\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n        when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n        when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n        when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(1)).findByDomain(domain.getId());\n        verify(clientService, times(1)).findByDomain(domain.getId());\n        verify(roleService, times(1)).findByDomain(domain.getId());\n        verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n    }\n}",
        "package": "package io.gravitee.am.management.service;",
        "tree_path": "ScopeUpgraderTest",
        "name": "ScopeUpgraderTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private ScopeUpgrader scopeUpgrader = new ScopeUpgrader();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ScopeService scopeService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private RoleService roleService;\n\n    @Test\n    public void shouldCreateScopes_withRoleAndClientScopes() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        final Scope clientScope = new Scope();\n        clientScope.setId(\"client-scope-key\");\n        clientScope.setKey(\"client-scope-key\");\n\n        final Client client = new Client();\n        client.setId(\"client-id\");\n        client.setScopes(Collections.singletonList(clientScope.getKey()));\n\n        final Scope roleScope = new Scope();\n        roleScope.setId(\"role-scope-key\");\n        roleScope.setKey(\"role-scope-key\");\n\n        final Role role = new Role();\n        role.setId(\"role-id\");\n        role.setPermissions(Collections.singletonList(roleScope.getKey()));\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n        when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n        when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n        when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(3)).findByDomain(domain.getId());\n        verify(clientService, times(1)).findByDomain(domain.getId());\n        verify(roleService, times(1)).findByDomain(domain.getId());\n        verify(scopeService, times(2)).create(any(String.class), any(NewScope.class));\n    }\n\n    @Test\n    public void shouldNotCreateScopes_domainHasScopes() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(domainScope)));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(1)).findByDomain(domain.getId());\n        verify(clientService, never()).findByDomain(domain.getId());\n        verify(roleService, never()).findByDomain(domain.getId());\n        verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n    }\n\n\n    @Test\n    public void shouldNotCreateScopes_noClientAndNoRole() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n        when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n        when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n        when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(1)).findByDomain(domain.getId());\n        verify(clientService, times(1)).findByDomain(domain.getId());\n        verify(roleService, times(1)).findByDomain(domain.getId());\n        verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n    }\n\n    @Test\n    public void shouldNotCreateScopes_clientsAndRolesHaveNoScopes() {\n        final Scope domainScope = new Scope();\n        domainScope.setId(\"domain-scope-key\");\n        domainScope.setKey(\"domain-scope-key\");\n\n        final String domainId = \"domain-id\";\n        final String domainName = \"domain-name\";\n        final Domain domain = new Domain();\n        domain.setId(domainId);\n        domain.setName(domainName);\n\n        final Client client = new Client();\n        client.setId(\"client-id\");\n        client.setScopes(null);\n\n        final Role role = new Role();\n        role.setId(\"role-id\");\n        role.setPermissions(null);\n\n        when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n        when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n        when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n        when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n        when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n        scopeUpgrader.upgrade();\n\n        verify(domainService, times(1)).findAll();\n        verify(scopeService, times(1)).findByDomain(domain.getId());\n        verify(clientService, times(1)).findByDomain(domain.getId());\n        verify(roleService, times(1)).findByDomain(domain.getId());\n        verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n    }\n}",
        "start_point": {
            "row": 43,
            "column": 0
        },
        "end_point": {
            "row": 193,
            "column": 1
        },
        "file_mode": "Added",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldCreateScopes_withRoleAndClientScopes() {\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    final Scope clientScope = new Scope();\n    clientScope.setId(\"client-scope-key\");\n    clientScope.setKey(\"client-scope-key\");\n\n    final Client client = new Client();\n    client.setId(\"client-id\");\n    client.setScopes(Collections.singletonList(clientScope.getKey()));\n\n    final Scope roleScope = new Scope();\n    roleScope.setId(\"role-scope-key\");\n    roleScope.setKey(\"role-scope-key\");\n\n    final Role role = new Role();\n    role.setId(\"role-id\");\n    role.setPermissions(Collections.singletonList(roleScope.getKey()));\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n    when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n    when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n    when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(3)).findByDomain(domain.getId());\n    verify(clientService, times(1)).findByDomain(domain.getId());\n    verify(roleService, times(1)).findByDomain(domain.getId());\n    verify(scopeService, times(2)).create(any(String.class), any(NewScope.class));\n}",
                "name": "shouldCreateScopes_withRoleAndClientScopes",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    final Scope clientScope = new Scope();\n    clientScope.setId(\"client-scope-key\");\n    clientScope.setKey(\"client-scope-key\");\n\n    final Client client = new Client();\n    client.setId(\"client-id\");\n    client.setScopes(Collections.singletonList(clientScope.getKey()));\n\n    final Scope roleScope = new Scope();\n    roleScope.setId(\"role-scope-key\");\n    roleScope.setKey(\"role-scope-key\");\n\n    final Role role = new Role();\n    role.setId(\"role-id\");\n    role.setPermissions(Collections.singletonList(roleScope.getKey()));\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n    when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n    when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n    when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(3)).findByDomain(domain.getId());\n    verify(clientService, times(1)).findByDomain(domain.getId());\n    verify(roleService, times(1)).findByDomain(domain.getId());\n    verify(scopeService, times(2)).create(any(String.class), any(NewScope.class));\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldNotCreateScopes_domainHasScopes() {\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(domainScope)));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(1)).findByDomain(domain.getId());\n    verify(clientService, never()).findByDomain(domain.getId());\n    verify(roleService, never()).findByDomain(domain.getId());\n    verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n}",
                "name": "shouldNotCreateScopes_domainHasScopes",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(domainScope)));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(1)).findByDomain(domain.getId());\n    verify(clientService, never()).findByDomain(domain.getId());\n    verify(roleService, never()).findByDomain(domain.getId());\n    verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldNotCreateScopes_noClientAndNoRole() {\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n    when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n    when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n    when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(1)).findByDomain(domain.getId());\n    verify(clientService, times(1)).findByDomain(domain.getId());\n    verify(roleService, times(1)).findByDomain(domain.getId());\n    verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n}",
                "name": "shouldNotCreateScopes_noClientAndNoRole",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n    when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n    when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet()));\n    when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(1)).findByDomain(domain.getId());\n    verify(clientService, times(1)).findByDomain(domain.getId());\n    verify(roleService, times(1)).findByDomain(domain.getId());\n    verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n}",
                "start_point": {
                    "row": 130,
                    "column": 4
                },
                "end_point": {
                    "row": 156,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldNotCreateScopes_clientsAndRolesHaveNoScopes() {\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    final Client client = new Client();\n    client.setId(\"client-id\");\n    client.setScopes(null);\n\n    final Role role = new Role();\n    role.setId(\"role-id\");\n    role.setPermissions(null);\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n    when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n    when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n    when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(1)).findByDomain(domain.getId());\n    verify(clientService, times(1)).findByDomain(domain.getId());\n    verify(roleService, times(1)).findByDomain(domain.getId());\n    verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n}",
                "name": "shouldNotCreateScopes_clientsAndRolesHaveNoScopes",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Scope domainScope = new Scope();\n    domainScope.setId(\"domain-scope-key\");\n    domainScope.setKey(\"domain-scope-key\");\n\n    final String domainId = \"domain-id\";\n    final String domainName = \"domain-name\";\n    final Domain domain = new Domain();\n    domain.setId(domainId);\n    domain.setName(domainName);\n\n    final Client client = new Client();\n    client.setId(\"client-id\");\n    client.setScopes(null);\n\n    final Role role = new Role();\n    role.setId(\"role-id\");\n    role.setPermissions(null);\n\n    when(domainService.findAll()).thenReturn(Single.just(Collections.singleton(domain)));\n    when(scopeService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.emptySet())).thenReturn(Single.just(Collections.singleton(domainScope)));\n    when(clientService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(client)));\n    when(roleService.findByDomain(domain.getId())).thenReturn(Single.just(Collections.singleton(role)));\n    when(scopeService.create(any(String.class), any(NewScope.class))).thenReturn(Single.just(new Scope()));\n\n    scopeUpgrader.upgrade();\n\n    verify(domainService, times(1)).findAll();\n    verify(scopeService, times(1)).findByDomain(domain.getId());\n    verify(clientService, times(1)).findByDomain(domain.getId());\n    verify(roleService, times(1)).findByDomain(domain.getId());\n    verify(scopeService, never()).create(any(String.class), any(NewScope.class));\n\n}",
                "start_point": {
                    "row": 158,
                    "column": 4
                },
                "end_point": {
                    "row": 192,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-certificate/gravitee-am-certificate-javakeystore/src/main/java/io/gravitee/am/certificate/javakeystore/provider/JavaKeyStoreProvider.java",
        "definition": "public class JavaKeyStoreProvider implements CertificateProvider, InitializingBean {\n\n    private KeyPair keyPair;\n\n    @Autowired\n    private JavaKeyStoreConfiguration configuration;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        FileInputStream is = new FileInputStream(configuration.getJks());\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(is, configuration.getStorepass().toCharArray());\n        Key key = keystore.getKey(configuration.getAlias(), configuration.getKeypass().toCharArray());\n        if (key instanceof PrivateKey) {\n            // Get certificate of public key\n            Certificate cert = keystore.getCertificate(configuration.getAlias());\n            // Get public key\n            PublicKey publicKey = cert.getPublicKey();\n            // Return a key pair\n            keyPair = new KeyPair(publicKey, (PrivateKey) key);\n        } else {\n            throw new IllegalArgumentException(\"A RSA Signer must be supplied\");\n        }\n    }\n\n    @Override\n    public String sign(String payload) {\n        return Jwts.builder().setPayload(payload).signWith(SignatureAlgorithm.RS512, keyPair.getPrivate()).compact();\n    }\n\n    @Override\n    public String publicKey() {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n       /* encode the \"ssh-rsa\" string */\n        try {\n            byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n            out.write(sshrsa);\n            /* Encode the public exponent */\n            BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n            byte[] data = e.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            /* Encode the modulus */\n            BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n            data = m.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            return Base64.getEncoder().encodeToString(out.toByteArray());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private void encodeUInt32(int value, OutputStream out) throws IOException {\n        byte[] tmp = new byte[4];\n        tmp[0] = (byte)((value >>> 24) & 0xff);\n        tmp[1] = (byte)((value >>> 16) & 0xff);\n        tmp[2] = (byte)((value >>> 8) & 0xff);\n        tmp[3] = (byte)(value & 0xff);\n        out.write(tmp);\n    }\n\n\n}",
        "package": "package io.gravitee.am.certificate.javakeystore.provider;",
        "tree_path": "JavaKeyStoreProvider",
        "name": "JavaKeyStoreProvider",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements CertificateProvider, InitializingBean",
        "body": "{\n\n    private KeyPair keyPair;\n\n    @Autowired\n    private JavaKeyStoreConfiguration configuration;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        FileInputStream is = new FileInputStream(configuration.getJks());\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(is, configuration.getStorepass().toCharArray());\n        Key key = keystore.getKey(configuration.getAlias(), configuration.getKeypass().toCharArray());\n        if (key instanceof PrivateKey) {\n            // Get certificate of public key\n            Certificate cert = keystore.getCertificate(configuration.getAlias());\n            // Get public key\n            PublicKey publicKey = cert.getPublicKey();\n            // Return a key pair\n            keyPair = new KeyPair(publicKey, (PrivateKey) key);\n        } else {\n            throw new IllegalArgumentException(\"A RSA Signer must be supplied\");\n        }\n    }\n\n    @Override\n    public String sign(String payload) {\n        return Jwts.builder().setPayload(payload).signWith(SignatureAlgorithm.RS512, keyPair.getPrivate()).compact();\n    }\n\n    @Override\n    public String publicKey() {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n       /* encode the \"ssh-rsa\" string */\n        try {\n            byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n            out.write(sshrsa);\n            /* Encode the public exponent */\n            BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n            byte[] data = e.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            /* Encode the modulus */\n            BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n            data = m.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            return Base64.getEncoder().encodeToString(out.toByteArray());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private void encodeUInt32(int value, OutputStream out) throws IOException {\n        byte[] tmp = new byte[4];\n        tmp[0] = (byte)((value >>> 24) & 0xff);\n        tmp[1] = (byte)((value >>> 16) & 0xff);\n        tmp[2] = (byte)((value >>> 8) & 0xff);\n        tmp[3] = (byte)(value & 0xff);\n        out.write(tmp);\n    }\n\n\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 101,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void afterPropertiesSet() throws Exception {\n    FileInputStream is = new FileInputStream(configuration.getJks());\n    KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n    keystore.load(is, configuration.getStorepass().toCharArray());\n    Key key = keystore.getKey(configuration.getAlias(), configuration.getKeypass().toCharArray());\n    if (key instanceof PrivateKey) {\n        // Get certificate of public key\n        Certificate cert = keystore.getCertificate(configuration.getAlias());\n        // Get public key\n        PublicKey publicKey = cert.getPublicKey();\n        // Return a key pair\n        keyPair = new KeyPair(publicKey, (PrivateKey) key);\n    } else {\n        throw new IllegalArgumentException(\"A RSA Signer must be supplied\");\n    }\n}",
                "name": "afterPropertiesSet",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    FileInputStream is = new FileInputStream(configuration.getJks());\n    KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n    keystore.load(is, configuration.getStorepass().toCharArray());\n    Key key = keystore.getKey(configuration.getAlias(), configuration.getKeypass().toCharArray());\n    if (key instanceof PrivateKey) {\n        // Get certificate of public key\n        Certificate cert = keystore.getCertificate(configuration.getAlias());\n        // Get public key\n        PublicKey publicKey = cert.getPublicKey();\n        // Return a key pair\n        keyPair = new KeyPair(publicKey, (PrivateKey) key);\n    } else {\n        throw new IllegalArgumentException(\"A RSA Signer must be supplied\");\n    }\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String sign(String payload) {\n    return Jwts.builder().setPayload(payload).signWith(SignatureAlgorithm.RS512, keyPair.getPrivate()).compact();\n}",
                "name": "sign",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "payload"
                    }
                ],
                "body": "{\n    return Jwts.builder().setPayload(payload).signWith(SignatureAlgorithm.RS512, keyPair.getPrivate()).compact();\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 66,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String publicKey() {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n   /* encode the \"ssh-rsa\" string */\n    try {\n        byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n        out.write(sshrsa);\n        /* Encode the public exponent */\n        BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n        byte[] data = e.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        /* Encode the modulus */\n        BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n        data = m.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        return Base64.getEncoder().encodeToString(out.toByteArray());\n    } catch (Exception e) {\n        return null;\n    }\n}",
                "name": "publicKey",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n   /* encode the \"ssh-rsa\" string */\n    try {\n        byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n        out.write(sshrsa);\n        /* Encode the public exponent */\n        BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n        byte[] data = e.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        /* Encode the modulus */\n        BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n        data = m.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        return Base64.getEncoder().encodeToString(out.toByteArray());\n    } catch (Exception e) {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            },
            {
                "definition": "private void encodeUInt32(int value, OutputStream out) throws IOException {\n    byte[] tmp = new byte[4];\n    tmp[0] = (byte)((value >>> 24) & 0xff);\n    tmp[1] = (byte)((value >>> 16) & 0xff);\n    tmp[2] = (byte)((value >>> 8) & 0xff);\n    tmp[3] = (byte)(value & 0xff);\n    out.write(tmp);\n}",
                "name": "encodeUInt32",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "int",
                        "name": "value"
                    },
                    {
                        "type": "OutputStream",
                        "name": "out"
                    }
                ],
                "body": "{\n    byte[] tmp = new byte[4];\n    tmp[0] = (byte)((value >>> 24) & 0xff);\n    tmp[1] = (byte)((value >>> 16) & 0xff);\n    tmp[2] = (byte)((value >>> 8) & 0xff);\n    tmp[3] = (byte)(value & 0xff);\n    out.write(tmp);\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-identityprovider/gravitee-am-identityprovider-github/src/main/java/io/gravitee/am/identityprovider/github/authentication/GithubAuthenticationProvider.java",
        "definition": "@Import(GithubAuthenticationProviderConfiguration.class)\npublic class GithubAuthenticationProvider implements OAuth2AuthenticationProvider {\n\n    private static final Logger logger = LoggerFactory.getLogger(GithubAuthenticationProvider.class);\n    private static final String CLIENT_ID = \"client_id\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            Map<String, String> params = extractMap(content);\n            String accessToken = params.get(\"access_token\");\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"token \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate github user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n        additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n        additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n        additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n        additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n        additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n        additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n        additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n        additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n        additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n        additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n        additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n        additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n        additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n        additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n    }\n}",
        "package": "package io.gravitee.am.identityprovider.github.authentication;",
        "tree_path": "GithubAuthenticationProvider",
        "name": "GithubAuthenticationProvider",
        "modifiers": "@Import(GithubAuthenticationProviderConfiguration.class)\npublic",
        "superclass": null,
        "super_interfaces": "implements OAuth2AuthenticationProvider",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(GithubAuthenticationProvider.class);\n    private static final String CLIENT_ID = \"client_id\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            Map<String, String> params = extractMap(content);\n            String accessToken = params.get(\"access_token\");\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"token \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate github user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n        additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n        additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n        additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n        additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n        additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n        additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n        additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n        additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n        additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n        additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n        additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n        additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n        additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n        additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n    }\n}",
        "start_point": {
            "row": 50,
            "column": 0
        },
        "end_point": {
            "row": 160,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic User loadUserByUsername(Authentication authentication) {\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        Map<String, String> params = extractMap(content);\n        String accessToken = params.get(\"access_token\");\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"token \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate github user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        Map<String, String> params = extractMap(content);\n        String accessToken = params.get(\"access_token\");\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"token \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate github user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 97,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic User loadUserByUsername(String username) {\n    return null;\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 99,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2IdentityProviderConfiguration configuration() {\n    return configuration;\n}",
                "name": "configuration",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2IdentityProviderConfiguration",
                "parameters": [],
                "body": "{\n    return configuration;\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "private User createUser(JsonNode jsonNode) {\n    User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n    additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n    additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n    additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n    additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n    additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n    additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n    additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n    additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n    additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n    additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n    additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n    additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n    additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n    additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "name": "createUser",
                "modifiers": "private",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "jsonNode"
                    }
                ],
                "body": "{\n    User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n    additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n    additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n    additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n    additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n    additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n    additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n    additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n    additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n    additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n    additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n    additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n    additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n    additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n    additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 140,
                    "column": 5
                }
            },
            {
                "definition": "private String read(Reader rd) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "name": "read",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "Reader",
                        "name": "rd"
                    }
                ],
                "body": "{\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "start_point": {
                    "row": 142,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, String> extractMap(String param) {\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n}",
                "name": "extractMap",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "param"
                    }
                ],
                "body": "{\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 159,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-identityprovider/gravitee-am-identityprovider-oauth2-generic/src/main/java/io/gravitee/am/identityprovider/oauth2/authentication/OAuth2GenericAuthenticationProvider.java",
        "definition": "@Import(OAuth2GenericAuthenticationProviderConfiguration.class)\npublic class OAuth2GenericAuthenticationProvider implements OAuth2AuthenticationProvider {\n\n    private static final Logger logger = LoggerFactory.getLogger(OAuth2GenericAuthenticationProvider.class);\n    private static final String CLIENT_ID = \"client_id\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n    private static final String GRANT_TYPE = \"grant_type\";\n    private static final String CLAIMS_SUB = \"sub\";\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Autowired\n    private OAuth2GenericIdentityProviderMapper mapper;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            urlParameters.add(new BasicNameValuePair(GRANT_TYPE, \"authorization_code\"));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            JsonNode params = objectMapper.readTree(content);\n            String accessToken = params.get(\"access_token\").asText();\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n        if (this.mapper.getMappers() != null) {\n            this.mapper.getMappers().forEach((k, v) -> {\n                if (jsonNode.get(v) != null) {\n                    additionalInformation.put(k, jsonNode.get(v).asText());\n                }\n            });\n        }\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n\n    }\n}",
        "package": "package io.gravitee.am.identityprovider.oauth2.authentication;",
        "tree_path": "OAuth2GenericAuthenticationProvider",
        "name": "OAuth2GenericAuthenticationProvider",
        "modifiers": "@Import(OAuth2GenericAuthenticationProviderConfiguration.class)\npublic",
        "superclass": null,
        "super_interfaces": "implements OAuth2AuthenticationProvider",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(OAuth2GenericAuthenticationProvider.class);\n    private static final String CLIENT_ID = \"client_id\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n    private static final String GRANT_TYPE = \"grant_type\";\n    private static final String CLAIMS_SUB = \"sub\";\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Autowired\n    private OAuth2GenericIdentityProviderMapper mapper;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            urlParameters.add(new BasicNameValuePair(GRANT_TYPE, \"authorization_code\"));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            JsonNode params = objectMapper.readTree(content);\n            String accessToken = params.get(\"access_token\").asText();\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n        if (this.mapper.getMappers() != null) {\n            this.mapper.getMappers().forEach((k, v) -> {\n                if (jsonNode.get(v) != null) {\n                    additionalInformation.put(k, jsonNode.get(v).asText());\n                }\n            });\n        }\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n\n    }\n}",
        "start_point": {
            "row": 50,
            "column": 0
        },
        "end_point": {
            "row": 150,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic User loadUserByUsername(Authentication authentication) {\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        urlParameters.add(new BasicNameValuePair(GRANT_TYPE, \"authorization_code\"));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        JsonNode params = objectMapper.readTree(content);\n        String accessToken = params.get(\"access_token\").asText();\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(REDIRECT_URI, (String) authentication.getAdditionalInformation().get(REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        urlParameters.add(new BasicNameValuePair(GRANT_TYPE, \"authorization_code\"));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        JsonNode params = objectMapper.readTree(content);\n        String accessToken = params.get(\"access_token\").asText();\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 103,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic User loadUserByUsername(String username) {\n    return null;\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 105,
                    "column": 4
                },
                "end_point": {
                    "row": 108,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2IdentityProviderConfiguration configuration() {\n    return configuration;\n}",
                "name": "configuration",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2IdentityProviderConfiguration",
                "parameters": [],
                "body": "{\n    return configuration;\n}",
                "start_point": {
                    "row": 110,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            },
            {
                "definition": "private User createUser(JsonNode jsonNode) {\n    User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n    if (this.mapper.getMappers() != null) {\n        this.mapper.getMappers().forEach((k, v) -> {\n            if (jsonNode.get(v) != null) {\n                additionalInformation.put(k, jsonNode.get(v).asText());\n            }\n        });\n    }\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "name": "createUser",
                "modifiers": "private",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "jsonNode"
                    }
                ],
                "body": "{\n    User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n    if (this.mapper.getMappers() != null) {\n        this.mapper.getMappers().forEach((k, v) -> {\n            if (jsonNode.get(v) != null) {\n                additionalInformation.put(k, jsonNode.get(v).asText());\n            }\n        });\n    }\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "start_point": {
                    "row": 115,
                    "column": 4
                },
                "end_point": {
                    "row": 129,
                    "column": 5
                }
            },
            {
                "definition": "private String read(Reader rd) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "name": "read",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "Reader",
                        "name": "rd"
                    }
                ],
                "body": "{\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "start_point": {
                    "row": 131,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, String> extractMap(String param) {\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n\n}",
                "name": "extractMap",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "param"
                    }
                ],
                "body": "{\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/ManagementApplication.java",
        "definition": "public class ManagementApplication extends ResourceConfig {\n\n    public ManagementApplication() {\n\n        BeanConfig beanConfig = new BeanConfig();\n        beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n        beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n        beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n        beanConfig.setScan(true);\n\n        register(DomainsResource.class);\n        register(PlatformResource.class);\n        register(DashboardResource.class);\n        register(CurrentUserResource.class);\n\n        register(ObjectMapperResolver.class);\n        register(ManagementExceptionMapper.class);\n        register(UnrecognizedPropertyExceptionMapper.class);\n        register(ThrowableMapper.class);\n        register(NotFoundExceptionMapper.class);\n        register(BadRequestExceptionMapper.class);\n\n        register(UriBuilderRequestFilter.class);\n        register(ByteArrayOutputStreamWriter.class);\n        register(JacksonFeature.class);\n\n        register(ApiListingResource.class);\n        register(SwaggerSerializers.class);\n\n        property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api;",
        "tree_path": "ManagementApplication",
        "name": "ManagementApplication",
        "modifiers": "public",
        "superclass": "extends ResourceConfig",
        "super_interfaces": null,
        "body": "{\n\n    public ManagementApplication() {\n\n        BeanConfig beanConfig = new BeanConfig();\n        beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n        beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n        beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n        beanConfig.setScan(true);\n\n        register(DomainsResource.class);\n        register(PlatformResource.class);\n        register(DashboardResource.class);\n        register(CurrentUserResource.class);\n\n        register(ObjectMapperResolver.class);\n        register(ManagementExceptionMapper.class);\n        register(UnrecognizedPropertyExceptionMapper.class);\n        register(ThrowableMapper.class);\n        register(NotFoundExceptionMapper.class);\n        register(BadRequestExceptionMapper.class);\n\n        register(UriBuilderRequestFilter.class);\n        register(ByteArrayOutputStreamWriter.class);\n        register(JacksonFeature.class);\n\n        register(ApiListingResource.class);\n        register(SwaggerSerializers.class);\n\n        property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n    }\n}",
        "start_point": {
            "row": 35,
            "column": 0
        },
        "end_point": {
            "row": 66,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public ManagementApplication() {\n\n    BeanConfig beanConfig = new BeanConfig();\n    beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n    beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n    beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n    beanConfig.setScan(true);\n\n    register(DomainsResource.class);\n    register(PlatformResource.class);\n    register(DashboardResource.class);\n    register(CurrentUserResource.class);\n\n    register(ObjectMapperResolver.class);\n    register(ManagementExceptionMapper.class);\n    register(UnrecognizedPropertyExceptionMapper.class);\n    register(ThrowableMapper.class);\n    register(NotFoundExceptionMapper.class);\n    register(BadRequestExceptionMapper.class);\n\n    register(UriBuilderRequestFilter.class);\n    register(ByteArrayOutputStreamWriter.class);\n    register(JacksonFeature.class);\n\n    register(ApiListingResource.class);\n    register(SwaggerSerializers.class);\n\n    property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n}",
                "name": "ManagementApplication",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n\n    BeanConfig beanConfig = new BeanConfig();\n    beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n    beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n    beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n    beanConfig.setScan(true);\n\n    register(DomainsResource.class);\n    register(PlatformResource.class);\n    register(DashboardResource.class);\n    register(CurrentUserResource.class);\n\n    register(ObjectMapperResolver.class);\n    register(ManagementExceptionMapper.class);\n    register(UnrecognizedPropertyExceptionMapper.class);\n    register(ThrowableMapper.class);\n    register(NotFoundExceptionMapper.class);\n    register(BadRequestExceptionMapper.class);\n\n    register(UriBuilderRequestFilter.class);\n    register(ByteArrayOutputStreamWriter.class);\n    register(JacksonFeature.class);\n\n    register(ApiListingResource.class);\n    register(SwaggerSerializers.class);\n\n    property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n}",
                "constructor": true,
                "start_point": {
                    "row": 37,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/resources/DomainsResource.java",
        "definition": "@Path(\"/domains\")\n@Api(tags = {\"domain\"})\npublic class DomainsResource extends AbstractResource {\n\n    @Autowired\n    private DomainService domainService;\n\n    @Context\n    private ResourceContext resourceContext;\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(\n            value = \"List security domains\",\n            notes = \"List all the security domains accessible to the current user.\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void list(@Suspended final AsyncResponse response) {\n         domainService.findAll()\n                 .map(domains ->\n                        domains.stream()\n                                .filter(domain -> !domain.isMaster())\n                                .map(domain -> {\n                                    domain.setLoginForm(null);\n                                    return domain;\n                                })\n                                .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                                .collect(Collectors.toList()))\n                .subscribe(\n                        result -> response.resume(Response.ok(result).build()),\n                        error -> response.resume(error));\n    }\n\n    @POST\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Create a security domain\")\n    @ApiResponses({\n            @ApiResponse(code = 201, message = \"Domain successfully created\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void create(\n            @ApiParam(name = \"domain\", required = true)\n            @Valid @NotNull final NewDomain newDomain,\n            @Suspended final AsyncResponse response) {\n        domainService.create(newDomain)\n                .subscribe(\n                        domain -> response.resume(Response\n                                                    .created(URI.create(\"/domains/\" + domain.getId()))\n                                                    .entity(domain)\n                                                    .build()),\n                        error -> response.resume(error));\n    }\n\n    @Path(\"{domain}\")\n    public DomainResource getDomainResource() {\n        return resourceContext.getResource(DomainResource.class);\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.resources;",
        "tree_path": "DomainsResource",
        "name": "DomainsResource",
        "modifiers": "@Path(\"/domains\")\n@Api(tags = {\"domain\"})\npublic",
        "superclass": "extends AbstractResource",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private DomainService domainService;\n\n    @Context\n    private ResourceContext resourceContext;\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(\n            value = \"List security domains\",\n            notes = \"List all the security domains accessible to the current user.\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void list(@Suspended final AsyncResponse response) {\n         domainService.findAll()\n                 .map(domains ->\n                        domains.stream()\n                                .filter(domain -> !domain.isMaster())\n                                .map(domain -> {\n                                    domain.setLoginForm(null);\n                                    return domain;\n                                })\n                                .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                                .collect(Collectors.toList()))\n                .subscribe(\n                        result -> response.resume(Response.ok(result).build()),\n                        error -> response.resume(error));\n    }\n\n    @POST\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Create a security domain\")\n    @ApiResponses({\n            @ApiResponse(code = 201, message = \"Domain successfully created\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void create(\n            @ApiParam(name = \"domain\", required = true)\n            @Valid @NotNull final NewDomain newDomain,\n            @Suspended final AsyncResponse response) {\n        domainService.create(newDomain)\n                .subscribe(\n                        domain -> response.resume(Response\n                                                    .created(URI.create(\"/domains/\" + domain.getId()))\n                                                    .entity(domain)\n                                                    .build()),\n                        error -> response.resume(error));\n    }\n\n    @Path(\"{domain}\")\n    public DomainResource getDomainResource() {\n        return resourceContext.getResource(DomainResource.class);\n    }\n\n}",
        "start_point": {
            "row": 41,
            "column": 0
        },
        "end_point": {
            "row": 100,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@GET\n@Produces(MediaType.APPLICATION_JSON)\n@ApiOperation(\n        value = \"List security domains\",\n        notes = \"List all the security domains accessible to the current user.\")\n@ApiResponses({\n        @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n        @ApiResponse(code = 500, message = \"Internal server error\")})\npublic void list(@Suspended final AsyncResponse response) {\n     domainService.findAll()\n             .map(domains ->\n                    domains.stream()\n                            .filter(domain -> !domain.isMaster())\n                            .map(domain -> {\n                                domain.setLoginForm(null);\n                                return domain;\n                            })\n                            .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                            .collect(Collectors.toList()))\n            .subscribe(\n                    result -> response.resume(Response.ok(result).build()),\n                    error -> response.resume(error));\n}",
                "name": "list",
                "modifiers": "@GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(\n            value = \"List security domains\",\n            notes = \"List all the security domains accessible to the current user.\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Suspended final",
                        "name": "AsyncResponse"
                    }
                ],
                "body": "{\n     domainService.findAll()\n             .map(domains ->\n                    domains.stream()\n                            .filter(domain -> !domain.isMaster())\n                            .map(domain -> {\n                                domain.setLoginForm(null);\n                                return domain;\n                            })\n                            .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                            .collect(Collectors.toList()))\n            .subscribe(\n                    result -> response.resume(Response.ok(result).build()),\n                    error -> response.resume(error));\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "@POST\n@Produces(MediaType.APPLICATION_JSON)\n@Consumes(MediaType.APPLICATION_JSON)\n@ApiOperation(value = \"Create a security domain\")\n@ApiResponses({\n        @ApiResponse(code = 201, message = \"Domain successfully created\"),\n        @ApiResponse(code = 500, message = \"Internal server error\")})\npublic void create(\n        @ApiParam(name = \"domain\", required = true)\n        @Valid @NotNull final NewDomain newDomain,\n        @Suspended final AsyncResponse response) {\n    domainService.create(newDomain)\n            .subscribe(\n                    domain -> response.resume(Response\n                                                .created(URI.create(\"/domains/\" + domain.getId()))\n                                                .entity(domain)\n                                                .build()),\n                    error -> response.resume(error));\n}",
                "name": "create",
                "modifiers": "@POST\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Create a security domain\")\n    @ApiResponses({\n            @ApiResponse(code = 201, message = \"Domain successfully created\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@ApiParam(name = \"domain\", required = true)\n            @Valid @NotNull final",
                        "name": "NewDomain"
                    },
                    {
                        "type": "@Suspended final",
                        "name": "AsyncResponse"
                    }
                ],
                "body": "{\n    domainService.create(newDomain)\n            .subscribe(\n                    domain -> response.resume(Response\n                                                .created(URI.create(\"/domains/\" + domain.getId()))\n                                                .entity(domain)\n                                                .build()),\n                    error -> response.resume(error));\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 93,
                    "column": 5
                }
            },
            {
                "definition": "@Path(\"{domain}\")\npublic DomainResource getDomainResource() {\n    return resourceContext.getResource(DomainResource.class);\n}",
                "name": "getDomainResource",
                "modifiers": "@Path(\"{domain}\")\n    public",
                "return_type": "DomainResource",
                "parameters": [],
                "body": "{\n    return resourceContext.getResource(DomainResource.class);\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/spring/security/SecurityConfiguration.java",
        "definition": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private Environment environment;\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n                .cors()\n            .and()\n                .authorizeRequests()\n                    .antMatchers(HttpMethod.OPTIONS, \"/**\").permitAll()\n                    .anyRequest().authenticated()\n            .and()\n                .httpBasic()\n                    .disable()\n                .csrf()\n                    .disable()\n            .exceptionHandling()\n                .authenticationEntryPoint(restAuthenticationEntryPoint())\n                .and()\n            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n    }\n\n    @Bean\n    public Filter jwtAuthenticationFilter() {\n        return new JWTAuthenticationFilter(new AntPathRequestMatcher(\"/**\"));\n    }\n\n    @Bean\n    public AuthenticationEntryPoint restAuthenticationEntryPoint() {\n        return new RestAuthenticationEntryPoint();\n    }\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        final CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.setAllowedOrigins(getPropertiesAsList(\"http.cors.allow-origin\", \"*\"));\n        config.setAllowedHeaders(getPropertiesAsList(\"http.cors.allow-headers\", \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With, If-Match\"));\n        config.setAllowedMethods(getPropertiesAsList(\"http.cors.allow-methods\", \"OPTIONS, GET, POST, PUT, DELETE\"));\n        config.setMaxAge(environment.getProperty(\"http.cors.max-age\", Long.class, 1728000L));\n\n        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        return source;\n    }\n\n    private List<String> getPropertiesAsList(final String propertyKey, final String defaultValue) {\n        String property = environment.getProperty(propertyKey);\n        if (property == null) {\n            property = defaultValue;\n        }\n        return asList(property.replaceAll(\"\\\\s+\",\"\").split(\",\"));\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.spring.security;",
        "tree_path": "SecurityConfiguration",
        "name": "SecurityConfiguration",
        "modifiers": "@Configuration\n@EnableWebSecurity\npublic",
        "superclass": "extends WebSecurityConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private Environment environment;\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n                .cors()\n            .and()\n                .authorizeRequests()\n                    .antMatchers(HttpMethod.OPTIONS, \"/**\").permitAll()\n                    .anyRequest().authenticated()\n            .and()\n                .httpBasic()\n                    .disable()\n                .csrf()\n                    .disable()\n            .exceptionHandling()\n                .authenticationEntryPoint(restAuthenticationEntryPoint())\n                .and()\n            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n    }\n\n    @Bean\n    public Filter jwtAuthenticationFilter() {\n        return new JWTAuthenticationFilter(new AntPathRequestMatcher(\"/**\"));\n    }\n\n    @Bean\n    public AuthenticationEntryPoint restAuthenticationEntryPoint() {\n        return new RestAuthenticationEntryPoint();\n    }\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        final CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true);\n        config.setAllowedOrigins(getPropertiesAsList(\"http.cors.allow-origin\", \"*\"));\n        config.setAllowedHeaders(getPropertiesAsList(\"http.cors.allow-headers\", \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With, If-Match\"));\n        config.setAllowedMethods(getPropertiesAsList(\"http.cors.allow-methods\", \"OPTIONS, GET, POST, PUT, DELETE\"));\n        config.setMaxAge(environment.getProperty(\"http.cors.max-age\", Long.class, 1728000L));\n\n        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(\"/**\", config);\n        return source;\n    }\n\n    private List<String> getPropertiesAsList(final String propertyKey, final String defaultValue) {\n        String property = environment.getProperty(propertyKey);\n        if (property == null) {\n            property = defaultValue;\n        }\n        return asList(property.replaceAll(\"\\\\s+\",\"\").split(\",\"));\n    }\n\n}",
        "start_point": {
            "row": 44,
            "column": 0
        },
        "end_point": {
            "row": 105,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void configure(HttpSecurity http) throws Exception {\n    http\n        .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n        .and()\n            .cors()\n        .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"/**\").permitAll()\n                .anyRequest().authenticated()\n        .and()\n            .httpBasic()\n                .disable()\n            .csrf()\n                .disable()\n        .exceptionHandling()\n            .authenticationEntryPoint(restAuthenticationEntryPoint())\n            .and()\n        .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpSecurity",
                        "name": "http"
                    }
                ],
                "body": "{\n    http\n        .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n        .and()\n            .cors()\n        .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"/**\").permitAll()\n                .anyRequest().authenticated()\n        .and()\n            .httpBasic()\n                .disable()\n            .csrf()\n                .disable()\n        .exceptionHandling()\n            .authenticationEntryPoint(restAuthenticationEntryPoint())\n            .and()\n        .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic Filter jwtAuthenticationFilter() {\n    return new JWTAuthenticationFilter(new AntPathRequestMatcher(\"/**\"));\n}",
                "name": "jwtAuthenticationFilter",
                "modifiers": "@Bean\n    public",
                "return_type": "Filter",
                "parameters": [],
                "body": "{\n    return new JWTAuthenticationFilter(new AntPathRequestMatcher(\"/**\"));\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 76,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthenticationEntryPoint restAuthenticationEntryPoint() {\n    return new RestAuthenticationEntryPoint();\n}",
                "name": "restAuthenticationEntryPoint",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthenticationEntryPoint",
                "parameters": [],
                "body": "{\n    return new RestAuthenticationEntryPoint();\n}",
                "start_point": {
                    "row": 78,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic CorsConfigurationSource corsConfigurationSource() {\n    final CorsConfiguration config = new CorsConfiguration();\n    config.setAllowCredentials(true);\n    config.setAllowedOrigins(getPropertiesAsList(\"http.cors.allow-origin\", \"*\"));\n    config.setAllowedHeaders(getPropertiesAsList(\"http.cors.allow-headers\", \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With, If-Match\"));\n    config.setAllowedMethods(getPropertiesAsList(\"http.cors.allow-methods\", \"OPTIONS, GET, POST, PUT, DELETE\"));\n    config.setMaxAge(environment.getProperty(\"http.cors.max-age\", Long.class, 1728000L));\n\n    final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n    source.registerCorsConfiguration(\"/**\", config);\n    return source;\n}",
                "name": "corsConfigurationSource",
                "modifiers": "@Bean\n    public",
                "return_type": "CorsConfigurationSource",
                "parameters": [],
                "body": "{\n    final CorsConfiguration config = new CorsConfiguration();\n    config.setAllowCredentials(true);\n    config.setAllowedOrigins(getPropertiesAsList(\"http.cors.allow-origin\", \"*\"));\n    config.setAllowedHeaders(getPropertiesAsList(\"http.cors.allow-headers\", \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With, If-Match\"));\n    config.setAllowedMethods(getPropertiesAsList(\"http.cors.allow-methods\", \"OPTIONS, GET, POST, PUT, DELETE\"));\n    config.setMaxAge(environment.getProperty(\"http.cors.max-age\", Long.class, 1728000L));\n\n    final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n    source.registerCorsConfiguration(\"/**\", config);\n    return source;\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "private List<String> getPropertiesAsList(final String propertyKey, final String defaultValue) {\n    String property = environment.getProperty(propertyKey);\n    if (property == null) {\n        property = defaultValue;\n    }\n    return asList(property.replaceAll(\"\\\\s+\",\"\").split(\",\"));\n}",
                "name": "getPropertiesAsList",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    String property = environment.getProperty(propertyKey);\n    if (property == null) {\n        property = defaultValue;\n    }\n    return asList(property.replaceAll(\"\\\\s+\",\"\").split(\",\"));\n}",
                "start_point": {
                    "row": 97,
                    "column": 4
                },
                "end_point": {
                    "row": 103,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/DeployAdminDomainUpgrader.java",
        "definition": "@Component\npublic class DeployAdminDomainUpgrader implements Upgrader, Ordered {\n\n    private static final Logger logger = LoggerFactory.getLogger(DeployAdminDomainUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private EventManager eventManager;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n        domainService.findById(ADMIN_DOMAIN)\n                .switchIfEmpty(Maybe.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n                .subscribe(\n                        adminDomain -> eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain),\n                        error -> {\n                            logger.error(\"Failed to find admin domain\", error);\n                            throw new IllegalStateException(\"Failed to deploy admin domain\", error);\n                        }\n                );\n        return true;\n    }\n\n    @Override\n    public int getOrder() {\n        return 170;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "DeployAdminDomainUpgrader",
        "name": "DeployAdminDomainUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(DeployAdminDomainUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private EventManager eventManager;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n        domainService.findById(ADMIN_DOMAIN)\n                .switchIfEmpty(Maybe.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n                .subscribe(\n                        adminDomain -> eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain),\n                        error -> {\n                            logger.error(\"Failed to find admin domain\", error);\n                            throw new IllegalStateException(\"Failed to deploy admin domain\", error);\n                        }\n                );\n        return true;\n    }\n\n    @Override\n    public int getOrder() {\n        return 170;\n    }\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 63,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n    domainService.findById(ADMIN_DOMAIN)\n            .switchIfEmpty(Maybe.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n            .subscribe(\n                    adminDomain -> eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain),\n                    error -> {\n                        logger.error(\"Failed to find admin domain\", error);\n                        throw new IllegalStateException(\"Failed to deploy admin domain\", error);\n                    }\n            );\n    return true;\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n    domainService.findById(ADMIN_DOMAIN)\n            .switchIfEmpty(Maybe.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n            .subscribe(\n                    adminDomain -> eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain),\n                    error -> {\n                        logger.error(\"Failed to find admin domain\", error);\n                        throw new IllegalStateException(\"Failed to deploy admin domain\", error);\n                    }\n            );\n    return true;\n}",
                "start_point": {
                    "row": 44,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return 170;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return 170;\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 62,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/InitializeUpgrader.java",
        "definition": "@Component\npublic class InitializeUpgrader implements Upgrader, Ordered {\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        domainService.findById(ADMIN_DOMAIN)\n                .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n                .flatMap(adminDomain -> {\n                    logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                    if (!adminDomain.isMaster()) {\n                        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                        return domainService.setMasterDomain(adminDomain.getId(), true);\n                    }\n                    return Single.just(adminDomain);\n                })\n                .flatMap(adminDomain -> {\n                    // New since AM v2\n                    // Move admin client identity providers to admin domain and remove the admin client\n                    return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                            .map(client -> Optional.of(client))\n                            .defaultIfEmpty(Optional.empty())\n                            .flatMapSingle(optionalClient -> {\n                                if (optionalClient.isPresent()) {\n                                    Client adminClient = optionalClient.get();\n                                    logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                    UpdateDomain updateDomain = new UpdateDomain();\n                                    updateDomain.setName(adminDomain.getName());\n                                    updateDomain.setPath(adminDomain.getPath());\n                                    updateDomain.setDescription(adminDomain.getDescription());\n                                    updateDomain.setEnabled(adminDomain.isEnabled());\n                                    updateDomain.setIdentities(adminClient.getIdentities());\n                                    updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                    return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                            .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                                }\n                                return Single.just(adminDomain);\n                            });\n\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof DomainNotFoundException) {\n                        return domainNotFoundFallback();\n                    }\n                    return Single.error(new TechnicalManagementException(ex));\n                })\n                .subscribe();\n\n        return true;\n    }\n\n    private Single<Domain> domainNotFoundFallback() {\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        return domainService.create(adminDomain)\n                .flatMap(createdDomain -> {\n                    // Create an inline identity provider\n                    logger.info(\"Create an user-inline provider\");\n                    NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                    adminIdentityProvider.setType(\"inline-am-idp\");\n                    adminIdentityProvider.setName(\"Inline users\");\n                    adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                    return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                            .flatMap(createdIdentityProvider -> {\n                                logger.info(\"Associate user-inline provider to previously created domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(createdDomain.getName());\n                                updateDomain.setPath(createdDomain.getPath());\n                                updateDomain.setDescription(createdDomain.getDescription());\n                                updateDomain.setEnabled(createdDomain.isEnabled());\n                                updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                                updateDomain.setEnabled(true);\n                                return domainService.update(createdDomain.getId(), updateDomain);\n                            });\n                })\n                .flatMap(createdDomain -> {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(createdDomain.getId(), true);\n                });\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "InitializeUpgrader",
        "name": "InitializeUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        domainService.findById(ADMIN_DOMAIN)\n                .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n                .flatMap(adminDomain -> {\n                    logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                    if (!adminDomain.isMaster()) {\n                        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                        return domainService.setMasterDomain(adminDomain.getId(), true);\n                    }\n                    return Single.just(adminDomain);\n                })\n                .flatMap(adminDomain -> {\n                    // New since AM v2\n                    // Move admin client identity providers to admin domain and remove the admin client\n                    return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                            .map(client -> Optional.of(client))\n                            .defaultIfEmpty(Optional.empty())\n                            .flatMapSingle(optionalClient -> {\n                                if (optionalClient.isPresent()) {\n                                    Client adminClient = optionalClient.get();\n                                    logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                    UpdateDomain updateDomain = new UpdateDomain();\n                                    updateDomain.setName(adminDomain.getName());\n                                    updateDomain.setPath(adminDomain.getPath());\n                                    updateDomain.setDescription(adminDomain.getDescription());\n                                    updateDomain.setEnabled(adminDomain.isEnabled());\n                                    updateDomain.setIdentities(adminClient.getIdentities());\n                                    updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                    return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                            .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                                }\n                                return Single.just(adminDomain);\n                            });\n\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof DomainNotFoundException) {\n                        return domainNotFoundFallback();\n                    }\n                    return Single.error(new TechnicalManagementException(ex));\n                })\n                .subscribe();\n\n        return true;\n    }\n\n    private Single<Domain> domainNotFoundFallback() {\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        return domainService.create(adminDomain)\n                .flatMap(createdDomain -> {\n                    // Create an inline identity provider\n                    logger.info(\"Create an user-inline provider\");\n                    NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                    adminIdentityProvider.setType(\"inline-am-idp\");\n                    adminIdentityProvider.setName(\"Inline users\");\n                    adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                    return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                            .flatMap(createdIdentityProvider -> {\n                                logger.info(\"Associate user-inline provider to previously created domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(createdDomain.getName());\n                                updateDomain.setPath(createdDomain.getPath());\n                                updateDomain.setDescription(createdDomain.getDescription());\n                                updateDomain.setEnabled(createdDomain.isEnabled());\n                                updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                                updateDomain.setEnabled(true);\n                                return domainService.update(createdDomain.getId(), updateDomain);\n                            });\n                })\n                .flatMap(createdDomain -> {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(createdDomain.getId(), true);\n                });\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "start_point": {
            "row": 42,
            "column": 0
        },
        "end_point": {
            "row": 147,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    domainService.findById(ADMIN_DOMAIN)\n            .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n            .flatMap(adminDomain -> {\n                logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                if (!adminDomain.isMaster()) {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(adminDomain.getId(), true);\n                }\n                return Single.just(adminDomain);\n            })\n            .flatMap(adminDomain -> {\n                // New since AM v2\n                // Move admin client identity providers to admin domain and remove the admin client\n                return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                        .map(client -> Optional.of(client))\n                        .defaultIfEmpty(Optional.empty())\n                        .flatMapSingle(optionalClient -> {\n                            if (optionalClient.isPresent()) {\n                                Client adminClient = optionalClient.get();\n                                logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(adminDomain.getName());\n                                updateDomain.setPath(adminDomain.getPath());\n                                updateDomain.setDescription(adminDomain.getDescription());\n                                updateDomain.setEnabled(adminDomain.isEnabled());\n                                updateDomain.setIdentities(adminClient.getIdentities());\n                                updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                        .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                            }\n                            return Single.just(adminDomain);\n                        });\n\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof DomainNotFoundException) {\n                    return domainNotFoundFallback();\n                }\n                return Single.error(new TechnicalManagementException(ex));\n            })\n            .subscribe();\n\n    return true;\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    domainService.findById(ADMIN_DOMAIN)\n            .switchIfEmpty(Single.error(new DomainNotFoundException(ADMIN_DOMAIN)))\n            .flatMap(adminDomain -> {\n                logger.info(\"{} domain already exists. Apply required upgrades.\", ADMIN_DOMAIN);\n                if (!adminDomain.isMaster()) {\n                    logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                    return domainService.setMasterDomain(adminDomain.getId(), true);\n                }\n                return Single.just(adminDomain);\n            })\n            .flatMap(adminDomain -> {\n                // New since AM v2\n                // Move admin client identity providers to admin domain and remove the admin client\n                return clientService.findByDomainAndClientId(ADMIN_DOMAIN, ADMIN_CLIENT_ID)\n                        .map(client -> Optional.of(client))\n                        .defaultIfEmpty(Optional.empty())\n                        .flatMapSingle(optionalClient -> {\n                            if (optionalClient.isPresent()) {\n                                Client adminClient = optionalClient.get();\n                                logger.info(\"Admin client found, move its identity providers to the admin domain\");\n                                UpdateDomain updateDomain = new UpdateDomain();\n                                updateDomain.setName(adminDomain.getName());\n                                updateDomain.setPath(adminDomain.getPath());\n                                updateDomain.setDescription(adminDomain.getDescription());\n                                updateDomain.setEnabled(adminDomain.isEnabled());\n                                updateDomain.setIdentities(adminClient.getIdentities());\n                                updateDomain.setOauth2Identities(adminClient.getOauth2Identities());\n                                return domainService.update(ADMIN_DOMAIN, updateDomain)\n                                        .flatMap(domain -> clientService.delete(adminClient.getId()).flatMap(irrelevant -> Single.just(domain)));\n                            }\n                            return Single.just(adminDomain);\n                        });\n\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof DomainNotFoundException) {\n                    return domainNotFoundFallback();\n                }\n                return Single.error(new TechnicalManagementException(ex));\n            })\n            .subscribe();\n\n    return true;\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 108,
                    "column": 5
                }
            },
            {
                "definition": "private Single<Domain> domainNotFoundFallback() {\n    // Create a new admin domain\n    logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n    NewDomain adminDomain = new NewDomain();\n    adminDomain.setName(\"admin\");\n    adminDomain.setDescription(\"AM Admin domain\");\n    return domainService.create(adminDomain)\n            .flatMap(createdDomain -> {\n                // Create an inline identity provider\n                logger.info(\"Create an user-inline provider\");\n                NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                adminIdentityProvider.setType(\"inline-am-idp\");\n                adminIdentityProvider.setName(\"Inline users\");\n                adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                        .flatMap(createdIdentityProvider -> {\n                            logger.info(\"Associate user-inline provider to previously created domain\");\n                            UpdateDomain updateDomain = new UpdateDomain();\n                            updateDomain.setName(createdDomain.getName());\n                            updateDomain.setPath(createdDomain.getPath());\n                            updateDomain.setDescription(createdDomain.getDescription());\n                            updateDomain.setEnabled(createdDomain.isEnabled());\n                            updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                            updateDomain.setEnabled(true);\n                            return domainService.update(createdDomain.getId(), updateDomain);\n                        });\n            })\n            .flatMap(createdDomain -> {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                return domainService.setMasterDomain(createdDomain.getId(), true);\n            });\n}",
                "name": "domainNotFoundFallback",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // Create a new admin domain\n    logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n    NewDomain adminDomain = new NewDomain();\n    adminDomain.setName(\"admin\");\n    adminDomain.setDescription(\"AM Admin domain\");\n    return domainService.create(adminDomain)\n            .flatMap(createdDomain -> {\n                // Create an inline identity provider\n                logger.info(\"Create an user-inline provider\");\n                NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n                adminIdentityProvider.setType(\"inline-am-idp\");\n                adminIdentityProvider.setName(\"Inline users\");\n                adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n                return identityProviderService.create(createdDomain.getId(), adminIdentityProvider)\n                        .flatMap(createdIdentityProvider -> {\n                            logger.info(\"Associate user-inline provider to previously created domain\");\n                            UpdateDomain updateDomain = new UpdateDomain();\n                            updateDomain.setName(createdDomain.getName());\n                            updateDomain.setPath(createdDomain.getPath());\n                            updateDomain.setDescription(createdDomain.getDescription());\n                            updateDomain.setEnabled(createdDomain.isEnabled());\n                            updateDomain.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n                            updateDomain.setEnabled(true);\n                            return domainService.update(createdDomain.getId(), updateDomain);\n                        });\n            })\n            .flatMap(createdDomain -> {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                return domainService.setMasterDomain(createdDomain.getId(), true);\n            });\n}",
                "start_point": {
                    "row": 110,
                    "column": 4
                },
                "end_point": {
                    "row": 141,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "start_point": {
                    "row": 143,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/ScopeUpgrader.java",
        "definition": "@Component\npublic class ScopeUpgrader implements Upgrader, Ordered {\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(ScopeUpgrader.class);\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Applying scope upgrade\");\n        domainService.findAll()\n                .flatMapObservable(domains -> Observable.fromIterable(domains))\n                .flatMapSingle(domain -> upgradeDomain(domain))\n                .subscribe();\n        return true;\n    }\n\n    private Single<List<Scope>> upgradeDomain(Domain domain) {\n        logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n        return scopeService.findByDomain(domain.getId())\n                .flatMap(scopes -> {\n                    if (scopes.isEmpty()) {\n                        logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n                        return createClientScopes(domain)\n                                .flatMap(irrelevant -> createRoleScopes(domain));\n                    }\n                    return Single.just(new ArrayList<>(scopes));\n                });\n    }\n\n    private Single<List<Scope>> createClientScopes(Domain domain) {\n        return clientService.findByDomain(domain.getId())\n                .filter(clients -> clients != null)\n                .flatMapObservable(clients -> Observable.fromIterable(clients))\n                .filter(client -> client.getScopes() != null)\n                .flatMap(client -> Observable.fromIterable(client.getScopes()))\n                .flatMapSingle(scope -> createScope(domain.getId(), scope))\n                .toList();\n    }\n\n    private Single<List<Scope>> createRoleScopes(Domain domain) {\n        return roleService.findByDomain(domain.getId())\n                .filter(roles -> roles != null)\n                .flatMapObservable(roles -> Observable.fromIterable(roles))\n                .filter(role -> role.getPermissions() != null)\n                .flatMap(role -> Observable.fromIterable(role.getPermissions()))\n                .flatMapSingle(scope -> createScope(domain.getId(), scope))\n                .toList();\n    }\n\n    private Single<Scope> createScope(String domain, String scopeKey) {\n        return scopeService.findByDomain(domain)\n                .flatMap(scopes -> {\n                    Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n                    if (!optScope.isPresent()) {\n                        logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n                        NewScope scope = new NewScope();\n                        scope.setKey(scopeKey);\n                        scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n                        scope.setDescription(\"Default description for scope \" + scopeKey);\n                        return scopeService.create(domain, scope);\n                    }\n                    return Single.just(optScope.get());\n                });\n    }\n\n    @Override\n    public int getOrder() {\n        return 160;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "ScopeUpgrader",
        "name": "ScopeUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(ScopeUpgrader.class);\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Applying scope upgrade\");\n        domainService.findAll()\n                .flatMapObservable(domains -> Observable.fromIterable(domains))\n                .flatMapSingle(domain -> upgradeDomain(domain))\n                .subscribe();\n        return true;\n    }\n\n    private Single<List<Scope>> upgradeDomain(Domain domain) {\n        logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n        return scopeService.findByDomain(domain.getId())\n                .flatMap(scopes -> {\n                    if (scopes.isEmpty()) {\n                        logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n                        return createClientScopes(domain)\n                                .flatMap(irrelevant -> createRoleScopes(domain));\n                    }\n                    return Single.just(new ArrayList<>(scopes));\n                });\n    }\n\n    private Single<List<Scope>> createClientScopes(Domain domain) {\n        return clientService.findByDomain(domain.getId())\n                .filter(clients -> clients != null)\n                .flatMapObservable(clients -> Observable.fromIterable(clients))\n                .filter(client -> client.getScopes() != null)\n                .flatMap(client -> Observable.fromIterable(client.getScopes()))\n                .flatMapSingle(scope -> createScope(domain.getId(), scope))\n                .toList();\n    }\n\n    private Single<List<Scope>> createRoleScopes(Domain domain) {\n        return roleService.findByDomain(domain.getId())\n                .filter(roles -> roles != null)\n                .flatMapObservable(roles -> Observable.fromIterable(roles))\n                .filter(role -> role.getPermissions() != null)\n                .flatMap(role -> Observable.fromIterable(role.getPermissions()))\n                .flatMapSingle(scope -> createScope(domain.getId(), scope))\n                .toList();\n    }\n\n    private Single<Scope> createScope(String domain, String scopeKey) {\n        return scopeService.findByDomain(domain)\n                .flatMap(scopes -> {\n                    Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n                    if (!optScope.isPresent()) {\n                        logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n                        NewScope scope = new NewScope();\n                        scope.setKey(scopeKey);\n                        scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n                        scope.setDescription(\"Default description for scope \" + scopeKey);\n                        return scopeService.create(domain, scope);\n                    }\n                    return Single.just(optScope.get());\n                });\n    }\n\n    @Override\n    public int getOrder() {\n        return 160;\n    }\n}",
        "start_point": {
            "row": 41,
            "column": 0
        },
        "end_point": {
            "row": 124,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Applying scope upgrade\");\n    domainService.findAll()\n            .flatMapObservable(domains -> Observable.fromIterable(domains))\n            .flatMapSingle(domain -> upgradeDomain(domain))\n            .subscribe();\n    return true;\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Applying scope upgrade\");\n    domainService.findAll()\n            .flatMapObservable(domains -> Observable.fromIterable(domains))\n            .flatMapSingle(domain -> upgradeDomain(domain))\n            .subscribe();\n    return true;\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 69,
                    "column": 5
                }
            },
            {
                "definition": "private Single<List<Scope>> upgradeDomain(Domain domain) {\n    logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n    return scopeService.findByDomain(domain.getId())\n            .flatMap(scopes -> {\n                if (scopes.isEmpty()) {\n                    logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n                    return createClientScopes(domain)\n                            .flatMap(irrelevant -> createRoleScopes(domain));\n                }\n                return Single.just(new ArrayList<>(scopes));\n            });\n}",
                "name": "upgradeDomain",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n    return scopeService.findByDomain(domain.getId())\n            .flatMap(scopes -> {\n                if (scopes.isEmpty()) {\n                    logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n                    return createClientScopes(domain)\n                            .flatMap(irrelevant -> createRoleScopes(domain));\n                }\n                return Single.just(new ArrayList<>(scopes));\n            });\n}",
                "start_point": {
                    "row": 71,
                    "column": 4
                },
                "end_point": {
                    "row": 82,
                    "column": 5
                }
            },
            {
                "definition": "private Single<List<Scope>> createClientScopes(Domain domain) {\n    return clientService.findByDomain(domain.getId())\n            .filter(clients -> clients != null)\n            .flatMapObservable(clients -> Observable.fromIterable(clients))\n            .filter(client -> client.getScopes() != null)\n            .flatMap(client -> Observable.fromIterable(client.getScopes()))\n            .flatMapSingle(scope -> createScope(domain.getId(), scope))\n            .toList();\n}",
                "name": "createClientScopes",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    return clientService.findByDomain(domain.getId())\n            .filter(clients -> clients != null)\n            .flatMapObservable(clients -> Observable.fromIterable(clients))\n            .filter(client -> client.getScopes() != null)\n            .flatMap(client -> Observable.fromIterable(client.getScopes()))\n            .flatMapSingle(scope -> createScope(domain.getId(), scope))\n            .toList();\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 92,
                    "column": 5
                }
            },
            {
                "definition": "private Single<List<Scope>> createRoleScopes(Domain domain) {\n    return roleService.findByDomain(domain.getId())\n            .filter(roles -> roles != null)\n            .flatMapObservable(roles -> Observable.fromIterable(roles))\n            .filter(role -> role.getPermissions() != null)\n            .flatMap(role -> Observable.fromIterable(role.getPermissions()))\n            .flatMapSingle(scope -> createScope(domain.getId(), scope))\n            .toList();\n}",
                "name": "createRoleScopes",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    return roleService.findByDomain(domain.getId())\n            .filter(roles -> roles != null)\n            .flatMapObservable(roles -> Observable.fromIterable(roles))\n            .filter(role -> role.getPermissions() != null)\n            .flatMap(role -> Observable.fromIterable(role.getPermissions()))\n            .flatMapSingle(scope -> createScope(domain.getId(), scope))\n            .toList();\n}",
                "start_point": {
                    "row": 94,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "private Single<Scope> createScope(String domain, String scopeKey) {\n    return scopeService.findByDomain(domain)\n            .flatMap(scopes -> {\n                Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n                if (!optScope.isPresent()) {\n                    logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n                    NewScope scope = new NewScope();\n                    scope.setKey(scopeKey);\n                    scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n                    scope.setDescription(\"Default description for scope \" + scopeKey);\n                    return scopeService.create(domain, scope);\n                }\n                return Single.just(optScope.get());\n            });\n}",
                "name": "createScope",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    },
                    {
                        "type": "String",
                        "name": "scopeKey"
                    }
                ],
                "body": "{\n    return scopeService.findByDomain(domain)\n            .flatMap(scopes -> {\n                Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n                if (!optScope.isPresent()) {\n                    logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n                    NewScope scope = new NewScope();\n                    scope.setKey(scopeKey);\n                    scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n                    scope.setDescription(\"Default description for scope \" + scopeKey);\n                    return scopeService.create(domain, scope);\n                }\n                return Single.just(optScope.get());\n            });\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 118,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return 160;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return 160;\n}",
                "start_point": {
                    "row": 120,
                    "column": 4
                },
                "end_point": {
                    "row": 123,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-model/src/main/java/io/gravitee/am/model/Domain.java",
        "definition": "public class Domain {\n\n    /**\n     * Domain identifier.\n     */\n    private String id;\n\n    /**\n     * Domain name.\n     */\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    private boolean enabled;\n\n    /**\n     * Domain master flag.\n     */\n    private boolean master;\n\n    /**\n     * Domain creation date\n     */\n    private Date createdAt;\n\n    /**\n     * Domain last updated date\n     */\n    private Date updatedAt;\n\n    /**\n     * Domain HTTP path\n     */\n    private String path;\n\n    private LoginForm loginForm;\n\n    private Set<String> identities;\n\n    private Set<String> oauth2Identities;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginForm getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginForm loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    public Set<String> getIdentities() {\n        return identities;\n    }\n\n    public void setIdentities(Set<String> identities) {\n        this.identities = identities;\n    }\n\n    public Set<String> getOauth2Identities() {\n        return oauth2Identities;\n    }\n\n    public void setOauth2Identities(Set<String> oauth2Identities) {\n        this.oauth2Identities = oauth2Identities;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Domain domain = (Domain) o;\n\n        return id.equals(domain.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "package": "package io.gravitee.am.model;",
        "tree_path": "Domain",
        "name": "Domain",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * Domain identifier.\n     */\n    private String id;\n\n    /**\n     * Domain name.\n     */\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    private boolean enabled;\n\n    /**\n     * Domain master flag.\n     */\n    private boolean master;\n\n    /**\n     * Domain creation date\n     */\n    private Date createdAt;\n\n    /**\n     * Domain last updated date\n     */\n    private Date updatedAt;\n\n    /**\n     * Domain HTTP path\n     */\n    private String path;\n\n    private LoginForm loginForm;\n\n    private Set<String> identities;\n\n    private Set<String> oauth2Identities;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginForm getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginForm loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    public Set<String> getIdentities() {\n        return identities;\n    }\n\n    public void setIdentities(Set<String> identities) {\n        this.identities = identities;\n    }\n\n    public Set<String> getOauth2Identities() {\n        return oauth2Identities;\n    }\n\n    public void setOauth2Identities(Set<String> oauth2Identities) {\n        this.oauth2Identities = oauth2Identities;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Domain domain = (Domain) o;\n\n        return id.equals(domain.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 176,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public String getId() {\n    return id;\n}",
                "name": "getId",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return id;\n}",
                "start_point": {
                    "row": 74,
                    "column": 4
                },
                "end_point": {
                    "row": 76,
                    "column": 5
                }
            },
            {
                "definition": "public void setId(String id) {\n    this.id = id;\n}",
                "name": "setId",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    this.id = id;\n}",
                "start_point": {
                    "row": 78,
                    "column": 4
                },
                "end_point": {
                    "row": 80,
                    "column": 5
                }
            },
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 82,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            },
            {
                "definition": "public String getDescription() {\n    return description;\n}",
                "name": "getDescription",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return description;\n}",
                "start_point": {
                    "row": 90,
                    "column": 4
                },
                "end_point": {
                    "row": 92,
                    "column": 5
                }
            },
            {
                "definition": "public void setDescription(String description) {\n    this.description = description;\n}",
                "name": "setDescription",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "description"
                    }
                ],
                "body": "{\n    this.description = description;\n}",
                "start_point": {
                    "row": 94,
                    "column": 4
                },
                "end_point": {
                    "row": 96,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 98,
                    "column": 4
                },
                "end_point": {
                    "row": 100,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 104,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isMaster() {\n    return master;\n}",
                "name": "isMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return master;\n}",
                "start_point": {
                    "row": 106,
                    "column": 4
                },
                "end_point": {
                    "row": 108,
                    "column": 5
                }
            },
            {
                "definition": "public void setMaster(boolean master) {\n    this.master = master;\n}",
                "name": "setMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "master"
                    }
                ],
                "body": "{\n    this.master = master;\n}",
                "start_point": {
                    "row": 110,
                    "column": 4
                },
                "end_point": {
                    "row": 112,
                    "column": 5
                }
            },
            {
                "definition": "public Date getCreatedAt() {\n    return createdAt;\n}",
                "name": "getCreatedAt",
                "modifiers": "public",
                "return_type": "Date",
                "parameters": [],
                "body": "{\n    return createdAt;\n}",
                "start_point": {
                    "row": 114,
                    "column": 4
                },
                "end_point": {
                    "row": 116,
                    "column": 5
                }
            },
            {
                "definition": "public void setCreatedAt(Date createdAt) {\n    this.createdAt = createdAt;\n}",
                "name": "setCreatedAt",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Date",
                        "name": "createdAt"
                    }
                ],
                "body": "{\n    this.createdAt = createdAt;\n}",
                "start_point": {
                    "row": 118,
                    "column": 4
                },
                "end_point": {
                    "row": 120,
                    "column": 5
                }
            },
            {
                "definition": "public Date getUpdatedAt() {\n    return updatedAt;\n}",
                "name": "getUpdatedAt",
                "modifiers": "public",
                "return_type": "Date",
                "parameters": [],
                "body": "{\n    return updatedAt;\n}",
                "start_point": {
                    "row": 122,
                    "column": 4
                },
                "end_point": {
                    "row": 124,
                    "column": 5
                }
            },
            {
                "definition": "public void setUpdatedAt(Date updatedAt) {\n    this.updatedAt = updatedAt;\n}",
                "name": "setUpdatedAt",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Date",
                        "name": "updatedAt"
                    }
                ],
                "body": "{\n    this.updatedAt = updatedAt;\n}",
                "start_point": {
                    "row": 126,
                    "column": 4
                },
                "end_point": {
                    "row": 128,
                    "column": 5
                }
            },
            {
                "definition": "public String getPath() {\n    return path;\n}",
                "name": "getPath",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return path;\n}",
                "start_point": {
                    "row": 130,
                    "column": 4
                },
                "end_point": {
                    "row": 132,
                    "column": 5
                }
            },
            {
                "definition": "public void setPath(String path) {\n    this.path = path;\n}",
                "name": "setPath",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "path"
                    }
                ],
                "body": "{\n    this.path = path;\n}",
                "start_point": {
                    "row": 134,
                    "column": 4
                },
                "end_point": {
                    "row": 136,
                    "column": 5
                }
            },
            {
                "definition": "public LoginForm getLoginForm() {\n    return loginForm;\n}",
                "name": "getLoginForm",
                "modifiers": "public",
                "return_type": "LoginForm",
                "parameters": [],
                "body": "{\n    return loginForm;\n}",
                "start_point": {
                    "row": 138,
                    "column": 4
                },
                "end_point": {
                    "row": 140,
                    "column": 5
                }
            },
            {
                "definition": "public void setLoginForm(LoginForm loginForm) {\n    this.loginForm = loginForm;\n}",
                "name": "setLoginForm",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "LoginForm",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    this.loginForm = loginForm;\n}",
                "start_point": {
                    "row": 142,
                    "column": 4
                },
                "end_point": {
                    "row": 144,
                    "column": 5
                }
            },
            {
                "definition": "public Set<String> getIdentities() {\n    return identities;\n}",
                "name": "getIdentities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return identities;\n}",
                "start_point": {
                    "row": 146,
                    "column": 4
                },
                "end_point": {
                    "row": 148,
                    "column": 5
                }
            },
            {
                "definition": "public void setIdentities(Set<String> identities) {\n    this.identities = identities;\n}",
                "name": "setIdentities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "identities"
                    }
                ],
                "body": "{\n    this.identities = identities;\n}",
                "start_point": {
                    "row": 150,
                    "column": 4
                },
                "end_point": {
                    "row": 152,
                    "column": 5
                }
            },
            {
                "definition": "public Set<String> getOauth2Identities() {\n    return oauth2Identities;\n}",
                "name": "getOauth2Identities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return oauth2Identities;\n}",
                "start_point": {
                    "row": 154,
                    "column": 4
                },
                "end_point": {
                    "row": 156,
                    "column": 5
                }
            },
            {
                "definition": "public void setOauth2Identities(Set<String> oauth2Identities) {\n    this.oauth2Identities = oauth2Identities;\n}",
                "name": "setOauth2Identities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "oauth2Identities"
                    }
                ],
                "body": "{\n    this.oauth2Identities = oauth2Identities;\n}",
                "start_point": {
                    "row": 158,
                    "column": 4
                },
                "end_point": {
                    "row": 160,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    Domain domain = (Domain) o;\n\n    return id.equals(domain.id);\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    Domain domain = (Domain) o;\n\n    return id.equals(domain.id);\n}",
                "start_point": {
                    "row": 162,
                    "column": 4
                },
                "end_point": {
                    "row": 170,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    return id.hashCode();\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return id.hashCode();\n}",
                "start_point": {
                    "row": 172,
                    "column": 4
                },
                "end_point": {
                    "row": 175,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-repository/gravitee-am-repository-mongodb/src/main/java/io/gravitee/am/repository/mongodb/management/MongoDomainRepository.java",
        "definition": "@Component\npublic class MongoDomainRepository extends AbstractManagementMongoRepository implements DomainRepository {\n\n    private static final String FIELD_ID = \"_id\";\n    private MongoCollection<DomainMongo> domainsCollection;\n\n    @Autowired\n    private IdGenerator idGenerator;\n\n    @PostConstruct\n    public void init() {\n        domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Single<Domain> create(Domain item) {\n        DomainMongo domain = convert(item);\n        domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n        return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Domain> update(Domain item) {\n        DomainMongo domain = convert(item);\n        return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String id) {\n        return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n    }\n\n    private Domain convert(DomainMongo domainMongo) {\n        if (domainMongo == null) {\n            return null;\n        }\n\n        Domain domain = new Domain();\n        domain.setId(domainMongo.getId());\n        domain.setPath(domainMongo.getPath());\n        domain.setCreatedAt(domainMongo.getCreatedAt());\n        domain.setUpdatedAt(domainMongo.getUpdatedAt());\n        domain.setName(domainMongo.getName());\n        domain.setDescription(domainMongo.getDescription());\n        domain.setEnabled(domainMongo.isEnabled());\n        domain.setMaster(domainMongo.isMaster());\n        domain.setLoginForm(convert(domainMongo.getLoginForm()));\n        domain.setIdentities(domainMongo.getIdentities());\n        domain.setOauth2Identities(domainMongo.getOauth2Identities());\n        return domain;\n    }\n\n    private DomainMongo convert(Domain domain) {\n        if (domain == null) {\n            return null;\n        }\n\n        DomainMongo domainMongo = new DomainMongo();\n        domainMongo.setId(domain.getId());\n        domainMongo.setPath(domain.getPath());\n        domainMongo.setCreatedAt(domain.getCreatedAt());\n        domainMongo.setUpdatedAt(domain.getUpdatedAt());\n        domainMongo.setName(domain.getName());\n        domainMongo.setDescription(domain.getDescription());\n        domainMongo.setEnabled(domain.isEnabled());\n        domainMongo.setMaster(domain.isMaster());\n        domainMongo.setLoginForm(convert(domain.getLoginForm()));\n        domainMongo.setIdentities(domain.getIdentities());\n        domainMongo.setOauth2Identities(domain.getOauth2Identities());\n        return domainMongo;\n    }\n\n    private LoginForm convert(LoginFormMongo loginFormMongo) {\n        if (loginFormMongo == null) {\n            return null;\n        }\n\n        LoginForm loginForm = new LoginForm();\n        loginForm.setEnabled(loginFormMongo.isEnabled());\n        loginForm.setContent(loginFormMongo.getContent());\n        loginForm.setAssets(loginFormMongo.getAssets());\n        return loginForm;\n    }\n\n    private LoginFormMongo convert(LoginForm loginForm) {\n        if (loginForm == null) {\n            return null;\n        }\n\n        LoginFormMongo formMongo = new LoginFormMongo();\n        formMongo.setEnabled(loginForm.isEnabled());\n        formMongo.setContent(loginForm.getContent());\n        formMongo.setAssets(loginForm.getAssets());\n        return formMongo;\n    }\n}",
        "package": "package io.gravitee.am.repository.mongodb.management;",
        "tree_path": "MongoDomainRepository",
        "name": "MongoDomainRepository",
        "modifiers": "@Component\npublic",
        "superclass": "extends AbstractManagementMongoRepository",
        "super_interfaces": "implements DomainRepository",
        "body": "{\n\n    private static final String FIELD_ID = \"_id\";\n    private MongoCollection<DomainMongo> domainsCollection;\n\n    @Autowired\n    private IdGenerator idGenerator;\n\n    @PostConstruct\n    public void init() {\n        domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Single<Domain> create(Domain item) {\n        DomainMongo domain = convert(item);\n        domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n        return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Domain> update(Domain item) {\n        DomainMongo domain = convert(item);\n        return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String id) {\n        return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n    }\n\n    private Domain convert(DomainMongo domainMongo) {\n        if (domainMongo == null) {\n            return null;\n        }\n\n        Domain domain = new Domain();\n        domain.setId(domainMongo.getId());\n        domain.setPath(domainMongo.getPath());\n        domain.setCreatedAt(domainMongo.getCreatedAt());\n        domain.setUpdatedAt(domainMongo.getUpdatedAt());\n        domain.setName(domainMongo.getName());\n        domain.setDescription(domainMongo.getDescription());\n        domain.setEnabled(domainMongo.isEnabled());\n        domain.setMaster(domainMongo.isMaster());\n        domain.setLoginForm(convert(domainMongo.getLoginForm()));\n        domain.setIdentities(domainMongo.getIdentities());\n        domain.setOauth2Identities(domainMongo.getOauth2Identities());\n        return domain;\n    }\n\n    private DomainMongo convert(Domain domain) {\n        if (domain == null) {\n            return null;\n        }\n\n        DomainMongo domainMongo = new DomainMongo();\n        domainMongo.setId(domain.getId());\n        domainMongo.setPath(domain.getPath());\n        domainMongo.setCreatedAt(domain.getCreatedAt());\n        domainMongo.setUpdatedAt(domain.getUpdatedAt());\n        domainMongo.setName(domain.getName());\n        domainMongo.setDescription(domain.getDescription());\n        domainMongo.setEnabled(domain.isEnabled());\n        domainMongo.setMaster(domain.isMaster());\n        domainMongo.setLoginForm(convert(domain.getLoginForm()));\n        domainMongo.setIdentities(domain.getIdentities());\n        domainMongo.setOauth2Identities(domain.getOauth2Identities());\n        return domainMongo;\n    }\n\n    private LoginForm convert(LoginFormMongo loginFormMongo) {\n        if (loginFormMongo == null) {\n            return null;\n        }\n\n        LoginForm loginForm = new LoginForm();\n        loginForm.setEnabled(loginFormMongo.isEnabled());\n        loginForm.setContent(loginFormMongo.getContent());\n        loginForm.setAssets(loginFormMongo.getAssets());\n        return loginForm;\n    }\n\n    private LoginFormMongo convert(LoginForm loginForm) {\n        if (loginForm == null) {\n            return null;\n        }\n\n        LoginFormMongo formMongo = new LoginFormMongo();\n        formMongo.setEnabled(loginForm.isEnabled());\n        formMongo.setContent(loginForm.getContent());\n        formMongo.setAssets(loginForm.getAssets());\n        return formMongo;\n    }\n}",
        "start_point": {
            "row": 44,
            "column": 0
        },
        "end_point": {
            "row": 154,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@PostConstruct\npublic void init() {\n    domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n}",
                "name": "init",
                "modifiers": "@PostConstruct\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findAll() {\n    return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "name": "findAll",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Maybe<Domain> findById(String id) {\n    return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n}",
                "name": "findById",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 66,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n    return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "name": "findByIdIn",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "ids"
                    }
                ],
                "body": "{\n    return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> create(Domain item) {\n    DomainMongo domain = convert(item);\n    domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n    return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "item"
                    }
                ],
                "body": "{\n    DomainMongo domain = convert(item);\n    domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n    return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> update(Domain item) {\n    DomainMongo domain = convert(item);\n    return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n}",
                "name": "update",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "item"
                    }
                ],
                "body": "{\n    DomainMongo domain = convert(item);\n    return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Irrelevant> delete(String id) {\n    return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n}",
                "name": "delete",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            },
            {
                "definition": "private Domain convert(DomainMongo domainMongo) {\n    if (domainMongo == null) {\n        return null;\n    }\n\n    Domain domain = new Domain();\n    domain.setId(domainMongo.getId());\n    domain.setPath(domainMongo.getPath());\n    domain.setCreatedAt(domainMongo.getCreatedAt());\n    domain.setUpdatedAt(domainMongo.getUpdatedAt());\n    domain.setName(domainMongo.getName());\n    domain.setDescription(domainMongo.getDescription());\n    domain.setEnabled(domainMongo.isEnabled());\n    domain.setMaster(domainMongo.isMaster());\n    domain.setLoginForm(convert(domainMongo.getLoginForm()));\n    domain.setIdentities(domainMongo.getIdentities());\n    domain.setOauth2Identities(domainMongo.getOauth2Identities());\n    return domain;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "Domain",
                "parameters": [
                    {
                        "type": "DomainMongo",
                        "name": "domainMongo"
                    }
                ],
                "body": "{\n    if (domainMongo == null) {\n        return null;\n    }\n\n    Domain domain = new Domain();\n    domain.setId(domainMongo.getId());\n    domain.setPath(domainMongo.getPath());\n    domain.setCreatedAt(domainMongo.getCreatedAt());\n    domain.setUpdatedAt(domainMongo.getUpdatedAt());\n    domain.setName(domainMongo.getName());\n    domain.setDescription(domainMongo.getDescription());\n    domain.setEnabled(domainMongo.isEnabled());\n    domain.setMaster(domainMongo.isMaster());\n    domain.setLoginForm(convert(domainMongo.getLoginForm()));\n    domain.setIdentities(domainMongo.getIdentities());\n    domain.setOauth2Identities(domainMongo.getOauth2Identities());\n    return domain;\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "private DomainMongo convert(Domain domain) {\n    if (domain == null) {\n        return null;\n    }\n\n    DomainMongo domainMongo = new DomainMongo();\n    domainMongo.setId(domain.getId());\n    domainMongo.setPath(domain.getPath());\n    domainMongo.setCreatedAt(domain.getCreatedAt());\n    domainMongo.setUpdatedAt(domain.getUpdatedAt());\n    domainMongo.setName(domain.getName());\n    domainMongo.setDescription(domain.getDescription());\n    domainMongo.setEnabled(domain.isEnabled());\n    domainMongo.setMaster(domain.isMaster());\n    domainMongo.setLoginForm(convert(domain.getLoginForm()));\n    domainMongo.setIdentities(domain.getIdentities());\n    domainMongo.setOauth2Identities(domain.getOauth2Identities());\n    return domainMongo;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "DomainMongo",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    if (domain == null) {\n        return null;\n    }\n\n    DomainMongo domainMongo = new DomainMongo();\n    domainMongo.setId(domain.getId());\n    domainMongo.setPath(domain.getPath());\n    domainMongo.setCreatedAt(domain.getCreatedAt());\n    domainMongo.setUpdatedAt(domain.getUpdatedAt());\n    domainMongo.setName(domain.getName());\n    domainMongo.setDescription(domain.getDescription());\n    domainMongo.setEnabled(domain.isEnabled());\n    domainMongo.setMaster(domain.isMaster());\n    domainMongo.setLoginForm(convert(domain.getLoginForm()));\n    domainMongo.setIdentities(domain.getIdentities());\n    domainMongo.setOauth2Identities(domain.getOauth2Identities());\n    return domainMongo;\n}",
                "start_point": {
                    "row": 111,
                    "column": 4
                },
                "end_point": {
                    "row": 129,
                    "column": 5
                }
            },
            {
                "definition": "private LoginForm convert(LoginFormMongo loginFormMongo) {\n    if (loginFormMongo == null) {\n        return null;\n    }\n\n    LoginForm loginForm = new LoginForm();\n    loginForm.setEnabled(loginFormMongo.isEnabled());\n    loginForm.setContent(loginFormMongo.getContent());\n    loginForm.setAssets(loginFormMongo.getAssets());\n    return loginForm;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "LoginForm",
                "parameters": [
                    {
                        "type": "LoginFormMongo",
                        "name": "loginFormMongo"
                    }
                ],
                "body": "{\n    if (loginFormMongo == null) {\n        return null;\n    }\n\n    LoginForm loginForm = new LoginForm();\n    loginForm.setEnabled(loginFormMongo.isEnabled());\n    loginForm.setContent(loginFormMongo.getContent());\n    loginForm.setAssets(loginFormMongo.getAssets());\n    return loginForm;\n}",
                "start_point": {
                    "row": 131,
                    "column": 4
                },
                "end_point": {
                    "row": 141,
                    "column": 5
                }
            },
            {
                "definition": "private LoginFormMongo convert(LoginForm loginForm) {\n    if (loginForm == null) {\n        return null;\n    }\n\n    LoginFormMongo formMongo = new LoginFormMongo();\n    formMongo.setEnabled(loginForm.isEnabled());\n    formMongo.setContent(loginForm.getContent());\n    formMongo.setAssets(loginForm.getAssets());\n    return formMongo;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "LoginFormMongo",
                "parameters": [
                    {
                        "type": "LoginForm",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    if (loginForm == null) {\n        return null;\n    }\n\n    LoginFormMongo formMongo = new LoginFormMongo();\n    formMongo.setEnabled(loginForm.isEnabled());\n    formMongo.setContent(loginForm.getContent());\n    formMongo.setAssets(loginForm.getAssets());\n    return formMongo;\n}",
                "start_point": {
                    "row": 143,
                    "column": 4
                },
                "end_point": {
                    "row": 153,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-repository/gravitee-am-repository-mongodb/src/main/java/io/gravitee/am/repository/mongodb/management/internal/model/DomainMongo.java",
        "definition": "public class DomainMongo extends Auditable {\n\n    @BsonId\n    private String id;\n\n    private String name;\n\n    private String description;\n\n    private boolean enabled;\n\n    private boolean master;\n\n    private String path;\n\n    private LoginFormMongo loginForm;\n\n    private Set<String> identities;\n\n    private Set<String> oauth2Identities;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginFormMongo getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginFormMongo loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    public Set<String> getIdentities() {\n        return identities;\n    }\n\n    public void setIdentities(Set<String> identities) {\n        this.identities = identities;\n    }\n\n    public Set<String> getOauth2Identities() {\n        return oauth2Identities;\n    }\n\n    public void setOauth2Identities(Set<String> oauth2Identities) {\n        this.oauth2Identities = oauth2Identities;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        DomainMongo that = (DomainMongo) o;\n\n        return id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "package": "package io.gravitee.am.repository.mongodb.management.internal.model;",
        "tree_path": "DomainMongo",
        "name": "DomainMongo",
        "modifiers": "public",
        "superclass": "extends Auditable",
        "super_interfaces": null,
        "body": "{\n\n    @BsonId\n    private String id;\n\n    private String name;\n\n    private String description;\n\n    private boolean enabled;\n\n    private boolean master;\n\n    private String path;\n\n    private LoginFormMongo loginForm;\n\n    private Set<String> identities;\n\n    private Set<String> oauth2Identities;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginFormMongo getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginFormMongo loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    public Set<String> getIdentities() {\n        return identities;\n    }\n\n    public void setIdentities(Set<String> identities) {\n        this.identities = identities;\n    }\n\n    public Set<String> getOauth2Identities() {\n        return oauth2Identities;\n    }\n\n    public void setOauth2Identities(Set<String> oauth2Identities) {\n        this.oauth2Identities = oauth2Identities;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        DomainMongo that = (DomainMongo) o;\n\n        return id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 133,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public String getId() {\n    return id;\n}",
                "name": "getId",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return id;\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            },
            {
                "definition": "public void setId(String id) {\n    this.id = id;\n}",
                "name": "setId",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    this.id = id;\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            },
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "public String getDescription() {\n    return description;\n}",
                "name": "getDescription",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return description;\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            },
            {
                "definition": "public void setDescription(String description) {\n    this.description = description;\n}",
                "name": "setDescription",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "description"
                    }
                ],
                "body": "{\n    this.description = description;\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 69,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isMaster() {\n    return master;\n}",
                "name": "isMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return master;\n}",
                "start_point": {
                    "row": 71,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "public void setMaster(boolean master) {\n    this.master = master;\n}",
                "name": "setMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "master"
                    }
                ],
                "body": "{\n    this.master = master;\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 77,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 79,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 85,
                    "column": 5
                }
            },
            {
                "definition": "public String getPath() {\n    return path;\n}",
                "name": "getPath",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return path;\n}",
                "start_point": {
                    "row": 87,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            },
            {
                "definition": "public void setPath(String path) {\n    this.path = path;\n}",
                "name": "setPath",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "path"
                    }
                ],
                "body": "{\n    this.path = path;\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 93,
                    "column": 5
                }
            },
            {
                "definition": "public LoginFormMongo getLoginForm() {\n    return loginForm;\n}",
                "name": "getLoginForm",
                "modifiers": "public",
                "return_type": "LoginFormMongo",
                "parameters": [],
                "body": "{\n    return loginForm;\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 97,
                    "column": 5
                }
            },
            {
                "definition": "public void setLoginForm(LoginFormMongo loginForm) {\n    this.loginForm = loginForm;\n}",
                "name": "setLoginForm",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "LoginFormMongo",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    this.loginForm = loginForm;\n}",
                "start_point": {
                    "row": 99,
                    "column": 4
                },
                "end_point": {
                    "row": 101,
                    "column": 5
                }
            },
            {
                "definition": "public Set<String> getIdentities() {\n    return identities;\n}",
                "name": "getIdentities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return identities;\n}",
                "start_point": {
                    "row": 103,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "public void setIdentities(Set<String> identities) {\n    this.identities = identities;\n}",
                "name": "setIdentities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "identities"
                    }
                ],
                "body": "{\n    this.identities = identities;\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "public Set<String> getOauth2Identities() {\n    return oauth2Identities;\n}",
                "name": "getOauth2Identities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return oauth2Identities;\n}",
                "start_point": {
                    "row": 111,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            },
            {
                "definition": "public void setOauth2Identities(Set<String> oauth2Identities) {\n    this.oauth2Identities = oauth2Identities;\n}",
                "name": "setOauth2Identities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "oauth2Identities"
                    }
                ],
                "body": "{\n    this.oauth2Identities = oauth2Identities;\n}",
                "start_point": {
                    "row": 115,
                    "column": 4
                },
                "end_point": {
                    "row": 117,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DomainMongo that = (DomainMongo) o;\n\n    return id.equals(that.id);\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DomainMongo that = (DomainMongo) o;\n\n    return id.equals(that.id);\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    return id.hashCode();\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return id.hashCode();\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 132,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/main/java/io/gravitee/am/service/impl/DomainServiceImpl.java",
        "definition": "@Component\npublic class DomainServiceImpl implements DomainService {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(DomainServiceImpl.class);\n\n    @Autowired\n    private DomainRepository domainRepository;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private CertificateService certificateService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        LOGGER.debug(\"Find domain by ID: {}\", id);\n        return domainRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        LOGGER.debug(\"Find all domains\");\n        return domainRepository.findAll()\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        LOGGER.debug(\"Find domains by id in {}\", ids);\n        return domainRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> create(NewDomain newDomain) {\n        LOGGER.debug(\"Create a new domain: {}\", newDomain);\n        String id = generateContextPath(newDomain.getName());\n\n        return domainRepository.findById(id)\n                .isEmpty()\n                .flatMap(empty -> {\n                    if (!empty) {\n                        throw new DomainAlreadyExistsException(newDomain.getName());\n                    } else {\n                        Domain domain = new Domain();\n                        domain.setId(id);\n                        domain.setPath(id);\n                        domain.setName(newDomain.getName());\n                        domain.setDescription(newDomain.getDescription());\n                        domain.setEnabled(false);\n                        domain.setCreatedAt(new Date());\n                        domain.setUpdatedAt(domain.getCreatedAt());\n                        return domainRepository.create(domain);\n                    }\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n            });\n    }\n\n    @Override\n    public Single<Domain> update(String domainId, UpdateDomain updateDomain) {\n        LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(updateDomain.getPath());\n                        domain.setName(updateDomain.getName());\n                        domain.setDescription(updateDomain.getDescription());\n                        domain.setEnabled(updateDomain.isEnabled());\n                        domain.setIdentities(updateDomain.getIdentities());\n                        domain.setOauth2Identities(updateDomain.getOauth2Identities());\n                        // master flag is set programmatically (keep old value)\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> reload(String domainId) {\n        LOGGER.debug(\"Reload a domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n                        domain.setIdentities(oldDomain.getIdentities());\n                        domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> setMasterDomain(String domainId, boolean isMaster) {\n        LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(isMaster);\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n                        domain.setIdentities(oldDomain.getIdentities());\n                        domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String domainId) {\n        LOGGER.debug(\"Delete security domain {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(optDomain -> {\n                    if (!optDomain.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    }\n                    if (optDomain.get().isMaster()) {\n                        throw new DomainDeleteMasterException(domainId);\n                    }\n                    return Single.just(optDomain.get());\n                })\n                .flatMap(domain -> {\n                    // delete clients\n                    return clientService.findByDomain(domainId)\n                            .flatMap(clients -> Observable.fromIterable(clients)\n                                    .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete certificates\n                    return certificateService.findByDomain(domainId)\n                            .flatMap(certificates -> Observable.fromIterable(certificates)\n                                    .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete identity providers\n                    return identityProviderService.findByDomain(domainId)\n                            .flatMap(idps -> Observable.fromIterable(idps)\n                                    .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete roles\n                    return roleService.findByDomain(domainId)\n                            .flatMap(roles -> Observable.fromIterable(roles)\n                                    .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete users\n                    return userService.findByDomain(domainId)\n                            .flatMap(users -> Observable.fromIterable(users)\n                                    .flatMapSingle(u -> userService.delete(u.getId())).toList());\n                })\n                .flatMap(irrelevant -> domainRepository.delete(domainId))\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n                });\n    }\n\n    @Override\n    public Single<LoginForm> updateLoginForm(String domainId, UpdateLoginForm loginForm) {\n        LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        LoginForm form = new LoginForm();\n                        form.setEnabled(loginForm.isEnabled());\n                        form.setContent(loginForm.getContent());\n                        form.setAssets(loginForm.getAssets());\n\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(form);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain).map(domain1 -> form);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> deleteLoginForm(String domainId) {\n        LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(null);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n                });\n    }\n\n    private String generateContextPath(String domainName) {\n        String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n        Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n        domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n        return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n    }\n}",
        "package": "package io.gravitee.am.service.impl;",
        "tree_path": "DomainServiceImpl",
        "name": "DomainServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements DomainService",
        "body": "{\n\n    private final Logger LOGGER = LoggerFactory.getLogger(DomainServiceImpl.class);\n\n    @Autowired\n    private DomainRepository domainRepository;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private CertificateService certificateService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        LOGGER.debug(\"Find domain by ID: {}\", id);\n        return domainRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        LOGGER.debug(\"Find all domains\");\n        return domainRepository.findAll()\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        LOGGER.debug(\"Find domains by id in {}\", ids);\n        return domainRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> create(NewDomain newDomain) {\n        LOGGER.debug(\"Create a new domain: {}\", newDomain);\n        String id = generateContextPath(newDomain.getName());\n\n        return domainRepository.findById(id)\n                .isEmpty()\n                .flatMap(empty -> {\n                    if (!empty) {\n                        throw new DomainAlreadyExistsException(newDomain.getName());\n                    } else {\n                        Domain domain = new Domain();\n                        domain.setId(id);\n                        domain.setPath(id);\n                        domain.setName(newDomain.getName());\n                        domain.setDescription(newDomain.getDescription());\n                        domain.setEnabled(false);\n                        domain.setCreatedAt(new Date());\n                        domain.setUpdatedAt(domain.getCreatedAt());\n                        return domainRepository.create(domain);\n                    }\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n            });\n    }\n\n    @Override\n    public Single<Domain> update(String domainId, UpdateDomain updateDomain) {\n        LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(updateDomain.getPath());\n                        domain.setName(updateDomain.getName());\n                        domain.setDescription(updateDomain.getDescription());\n                        domain.setEnabled(updateDomain.isEnabled());\n                        domain.setIdentities(updateDomain.getIdentities());\n                        domain.setOauth2Identities(updateDomain.getOauth2Identities());\n                        // master flag is set programmatically (keep old value)\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> reload(String domainId) {\n        LOGGER.debug(\"Reload a domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n                        domain.setIdentities(oldDomain.getIdentities());\n                        domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> setMasterDomain(String domainId, boolean isMaster) {\n        LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(isMaster);\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n                        domain.setIdentities(oldDomain.getIdentities());\n                        domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String domainId) {\n        LOGGER.debug(\"Delete security domain {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(optDomain -> {\n                    if (!optDomain.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    }\n                    if (optDomain.get().isMaster()) {\n                        throw new DomainDeleteMasterException(domainId);\n                    }\n                    return Single.just(optDomain.get());\n                })\n                .flatMap(domain -> {\n                    // delete clients\n                    return clientService.findByDomain(domainId)\n                            .flatMap(clients -> Observable.fromIterable(clients)\n                                    .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete certificates\n                    return certificateService.findByDomain(domainId)\n                            .flatMap(certificates -> Observable.fromIterable(certificates)\n                                    .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete identity providers\n                    return identityProviderService.findByDomain(domainId)\n                            .flatMap(idps -> Observable.fromIterable(idps)\n                                    .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete roles\n                    return roleService.findByDomain(domainId)\n                            .flatMap(roles -> Observable.fromIterable(roles)\n                                    .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete users\n                    return userService.findByDomain(domainId)\n                            .flatMap(users -> Observable.fromIterable(users)\n                                    .flatMapSingle(u -> userService.delete(u.getId())).toList());\n                })\n                .flatMap(irrelevant -> domainRepository.delete(domainId))\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n                });\n    }\n\n    @Override\n    public Single<LoginForm> updateLoginForm(String domainId, UpdateLoginForm loginForm) {\n        LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        LoginForm form = new LoginForm();\n                        form.setEnabled(loginForm.isEnabled());\n                        form.setContent(loginForm.getContent());\n                        form.setAssets(loginForm.getAssets());\n\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(form);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain).map(domain1 -> form);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> deleteLoginForm(String domainId) {\n        LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(null);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n                });\n    }\n\n    private String generateContextPath(String domainName) {\n        String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n        Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n        domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n        return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n    }\n}",
        "start_point": {
            "row": 46,
            "column": 0
        },
        "end_point": {
            "row": 374,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Maybe<Domain> findById(String id) {\n    LOGGER.debug(\"Find domain by ID: {}\", id);\n    return domainRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n            });\n}",
                "name": "findById",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find domain by ID: {}\", id);\n    return domainRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n            });\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findAll() {\n    LOGGER.debug(\"Find all domains\");\n    return domainRepository.findAll()\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n            });\n}",
                "name": "findAll",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    LOGGER.debug(\"Find all domains\");\n    return domainRepository.findAll()\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n            });\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n    LOGGER.debug(\"Find domains by id in {}\", ids);\n    return domainRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n            });\n}",
                "name": "findByIdIn",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "ids"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find domains by id in {}\", ids);\n    return domainRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n            });\n}",
                "start_point": {
                    "row": 90,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> create(NewDomain newDomain) {\n    LOGGER.debug(\"Create a new domain: {}\", newDomain);\n    String id = generateContextPath(newDomain.getName());\n\n    return domainRepository.findById(id)\n            .isEmpty()\n            .flatMap(empty -> {\n                if (!empty) {\n                    throw new DomainAlreadyExistsException(newDomain.getName());\n                } else {\n                    Domain domain = new Domain();\n                    domain.setId(id);\n                    domain.setPath(id);\n                    domain.setName(newDomain.getName());\n                    domain.setDescription(newDomain.getDescription());\n                    domain.setEnabled(false);\n                    domain.setCreatedAt(new Date());\n                    domain.setUpdatedAt(domain.getCreatedAt());\n                    return domainRepository.create(domain);\n                }\n            })\n        .onErrorResumeNext(ex -> {\n            if (ex instanceof AbstractManagementException) {\n                return Single.error(ex);\n            }\n\n            LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n            return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n        });\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "NewDomain",
                        "name": "newDomain"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Create a new domain: {}\", newDomain);\n    String id = generateContextPath(newDomain.getName());\n\n    return domainRepository.findById(id)\n            .isEmpty()\n            .flatMap(empty -> {\n                if (!empty) {\n                    throw new DomainAlreadyExistsException(newDomain.getName());\n                } else {\n                    Domain domain = new Domain();\n                    domain.setId(id);\n                    domain.setPath(id);\n                    domain.setName(newDomain.getName());\n                    domain.setDescription(newDomain.getDescription());\n                    domain.setEnabled(false);\n                    domain.setCreatedAt(new Date());\n                    domain.setUpdatedAt(domain.getCreatedAt());\n                    return domainRepository.create(domain);\n                }\n            })\n        .onErrorResumeNext(ex -> {\n            if (ex instanceof AbstractManagementException) {\n                return Single.error(ex);\n            }\n\n            LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n            return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n        });\n}",
                "start_point": {
                    "row": 100,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> update(String domainId, UpdateDomain updateDomain) {\n    LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(updateDomain.getPath());\n                    domain.setName(updateDomain.getName());\n                    domain.setDescription(updateDomain.getDescription());\n                    domain.setEnabled(updateDomain.isEnabled());\n                    domain.setIdentities(updateDomain.getIdentities());\n                    domain.setOauth2Identities(updateDomain.getOauth2Identities());\n                    // master flag is set programmatically (keep old value)\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "name": "update",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    },
                    {
                        "type": "UpdateDomain",
                        "name": "updateDomain"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(updateDomain.getPath());\n                    domain.setName(updateDomain.getName());\n                    domain.setDescription(updateDomain.getDescription());\n                    domain.setEnabled(updateDomain.isEnabled());\n                    domain.setIdentities(updateDomain.getIdentities());\n                    domain.setOauth2Identities(updateDomain.getOauth2Identities());\n                    // master flag is set programmatically (keep old value)\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 132,
                    "column": 4
                },
                "end_point": {
                    "row": 170,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> reload(String domainId) {\n    LOGGER.debug(\"Reload a domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n                    domain.setIdentities(oldDomain.getIdentities());\n                    domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n            });\n}",
                "name": "reload",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Reload a domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n                    domain.setIdentities(oldDomain.getIdentities());\n                    domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 172,
                    "column": 4
                },
                "end_point": {
                    "row": 209,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> setMasterDomain(String domainId, boolean isMaster) {\n    LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(isMaster);\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n                    domain.setIdentities(oldDomain.getIdentities());\n                    domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n            });\n}",
                "name": "setMasterDomain",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    },
                    {
                        "type": "boolean",
                        "name": "isMaster"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(isMaster);\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n                    domain.setIdentities(oldDomain.getIdentities());\n                    domain.setOauth2Identities(oldDomain.getOauth2Identities());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 211,
                    "column": 4
                },
                "end_point": {
                    "row": 248,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Irrelevant> delete(String domainId) {\n    LOGGER.debug(\"Delete security domain {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(optDomain -> {\n                if (!optDomain.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                }\n                if (optDomain.get().isMaster()) {\n                    throw new DomainDeleteMasterException(domainId);\n                }\n                return Single.just(optDomain.get());\n            })\n            .flatMap(domain -> {\n                // delete clients\n                return clientService.findByDomain(domainId)\n                        .flatMap(clients -> Observable.fromIterable(clients)\n                                .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete certificates\n                return certificateService.findByDomain(domainId)\n                        .flatMap(certificates -> Observable.fromIterable(certificates)\n                                .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete identity providers\n                return identityProviderService.findByDomain(domainId)\n                        .flatMap(idps -> Observable.fromIterable(idps)\n                                .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete roles\n                return roleService.findByDomain(domainId)\n                        .flatMap(roles -> Observable.fromIterable(roles)\n                                .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete users\n                return userService.findByDomain(domainId)\n                        .flatMap(users -> Observable.fromIterable(users)\n                                .flatMapSingle(u -> userService.delete(u.getId())).toList());\n            })\n            .flatMap(irrelevant -> domainRepository.delete(domainId))\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n            });\n}",
                "name": "delete",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Delete security domain {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(optDomain -> {\n                if (!optDomain.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                }\n                if (optDomain.get().isMaster()) {\n                    throw new DomainDeleteMasterException(domainId);\n                }\n                return Single.just(optDomain.get());\n            })\n            .flatMap(domain -> {\n                // delete clients\n                return clientService.findByDomain(domainId)\n                        .flatMap(clients -> Observable.fromIterable(clients)\n                                .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete certificates\n                return certificateService.findByDomain(domainId)\n                        .flatMap(certificates -> Observable.fromIterable(certificates)\n                                .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete identity providers\n                return identityProviderService.findByDomain(domainId)\n                        .flatMap(idps -> Observable.fromIterable(idps)\n                                .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete roles\n                return roleService.findByDomain(domainId)\n                        .flatMap(roles -> Observable.fromIterable(roles)\n                                .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete users\n                return userService.findByDomain(domainId)\n                        .flatMap(users -> Observable.fromIterable(users)\n                                .flatMapSingle(u -> userService.delete(u.getId())).toList());\n            })\n            .flatMap(irrelevant -> domainRepository.delete(domainId))\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n            });\n}",
                "start_point": {
                    "row": 250,
                    "column": 4
                },
                "end_point": {
                    "row": 305,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<LoginForm> updateLoginForm(String domainId, UpdateLoginForm loginForm) {\n    LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    LoginForm form = new LoginForm();\n                    form.setEnabled(loginForm.isEnabled());\n                    form.setContent(loginForm.getContent());\n                    form.setAssets(loginForm.getAssets());\n\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(form);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain).map(domain1 -> form);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "name": "updateLoginForm",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    },
                    {
                        "type": "UpdateLoginForm",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    LoginForm form = new LoginForm();\n                    form.setEnabled(loginForm.isEnabled());\n                    form.setContent(loginForm.getContent());\n                    form.setAssets(loginForm.getAssets());\n\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(form);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain).map(domain1 -> form);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 307,
                    "column": 4
                },
                "end_point": {
                    "row": 338,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> deleteLoginForm(String domainId) {\n    LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(null);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n            });\n}",
                "name": "deleteLoginForm",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(null);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 340,
                    "column": 4
                },
                "end_point": {
                    "row": 366,
                    "column": 5
                }
            },
            {
                "definition": "private String generateContextPath(String domainName) {\n    String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n    Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n    domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n    return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n}",
                "name": "generateContextPath",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainName"
                    }
                ],
                "body": "{\n    String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n    Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n    domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n    return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n}",
                "start_point": {
                    "row": 368,
                    "column": 4
                },
                "end_point": {
                    "row": 373,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/main/java/io/gravitee/am/service/impl/RoleServiceImpl.java",
        "definition": "@Component\npublic class RoleServiceImpl implements RoleService {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(RoleServiceImpl.class);\n\n    @Autowired\n    private RoleRepository roleRepository;\n\n    @Override\n    public Single<Set<Role>> findByDomain(String domain) {\n        LOGGER.debug(\"Find roles by domain: {}\", domain);\n        return roleRepository.findByDomain(domain)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n                });\n    }\n\n    @Override\n    public Maybe<Role> findById(String id) {\n        LOGGER.debug(\"Find role by ID: {}\", id);\n        return roleRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Role>> findByIdIn(List<String> ids) {\n        LOGGER.debug(\"Find roles by ids: {}\", ids);\n        return roleRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n                });\n    }\n\n\n    @Override\n    public Single<Role> create(String domain, NewRole newRole) {\n        LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n        String roleId = UUID.toString(UUID.random());\n\n        // check if role name is unique\n        return checkRoleUniqueness(newRole.getName(), roleId, domain)\n                .flatMap(irrelevant -> {\n                    Role role = new Role();\n                    role.setId(roleId);\n                    role.setDomain(domain);\n                    role.setName(newRole.getName());\n                    role.setDescription(newRole.getDescription());\n                    role.setCreatedAt(new Date());\n                    role.setUpdatedAt(role.getCreatedAt());\n                    return roleRepository.create(role);\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n                });\n    }\n\n    @Override\n    public Single<Role> update(String domain, String id, UpdateRole updateRole) {\n        LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n        return roleRepository.findById(id)\n                .map(role -> Optional.of(role))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(roleOpt -> {\n                    if (!roleOpt.isPresent()) {\n                        throw new RoleNotFoundException(id);\n                    }\n                    return Single.just(roleOpt.get());\n                })\n                .flatMap(oldRole -> {\n                    // check if role name is unique\n                    return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                            .flatMap(irrelevant -> {\n                                oldRole.setName(updateRole.getName());\n                                oldRole.setDescription(updateRole.getDescription());\n                                oldRole.setPermissions(updateRole.getPermissions());\n                                oldRole.setUpdatedAt(new Date());\n                                return roleRepository.update(oldRole);\n                            });\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n                });\n\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String roleId) {\n        LOGGER.debug(\"Delete role {}\", roleId);\n        return roleRepository.findById(roleId)\n                .isEmpty()\n                    .flatMap(empty -> {\n                        if (empty) {\n                            throw new RoleNotFoundException(roleId);\n                        }\n                        return roleRepository.delete(roleId);\n                    })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                    return Single.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n                });\n    }\n\n    private Single<Irrelevant> checkRoleUniqueness(String roleName, String roleId, String domain) {\n\n        return roleRepository.findByDomain(domain)\n                .flatMap(roles -> {\n                    if (roles.stream()\n                            .filter(role -> !role.getId().equals(roleId))\n                            .anyMatch(role -> role.getName().equals(roleName))) {\n                        throw new RoleAlreadyExistsException(roleName);\n                    }\n                    return Single.just(Irrelevant.ROLE);\n                });\n    }\n\n}",
        "package": "package io.gravitee.am.service.impl;",
        "tree_path": "RoleServiceImpl",
        "name": "RoleServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements RoleService",
        "body": "{\n\n    private final Logger LOGGER = LoggerFactory.getLogger(RoleServiceImpl.class);\n\n    @Autowired\n    private RoleRepository roleRepository;\n\n    @Override\n    public Single<Set<Role>> findByDomain(String domain) {\n        LOGGER.debug(\"Find roles by domain: {}\", domain);\n        return roleRepository.findByDomain(domain)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n                });\n    }\n\n    @Override\n    public Maybe<Role> findById(String id) {\n        LOGGER.debug(\"Find role by ID: {}\", id);\n        return roleRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Role>> findByIdIn(List<String> ids) {\n        LOGGER.debug(\"Find roles by ids: {}\", ids);\n        return roleRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n                });\n    }\n\n\n    @Override\n    public Single<Role> create(String domain, NewRole newRole) {\n        LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n        String roleId = UUID.toString(UUID.random());\n\n        // check if role name is unique\n        return checkRoleUniqueness(newRole.getName(), roleId, domain)\n                .flatMap(irrelevant -> {\n                    Role role = new Role();\n                    role.setId(roleId);\n                    role.setDomain(domain);\n                    role.setName(newRole.getName());\n                    role.setDescription(newRole.getDescription());\n                    role.setCreatedAt(new Date());\n                    role.setUpdatedAt(role.getCreatedAt());\n                    return roleRepository.create(role);\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n                });\n    }\n\n    @Override\n    public Single<Role> update(String domain, String id, UpdateRole updateRole) {\n        LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n        return roleRepository.findById(id)\n                .map(role -> Optional.of(role))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(roleOpt -> {\n                    if (!roleOpt.isPresent()) {\n                        throw new RoleNotFoundException(id);\n                    }\n                    return Single.just(roleOpt.get());\n                })\n                .flatMap(oldRole -> {\n                    // check if role name is unique\n                    return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                            .flatMap(irrelevant -> {\n                                oldRole.setName(updateRole.getName());\n                                oldRole.setDescription(updateRole.getDescription());\n                                oldRole.setPermissions(updateRole.getPermissions());\n                                oldRole.setUpdatedAt(new Date());\n                                return roleRepository.update(oldRole);\n                            });\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n                });\n\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String roleId) {\n        LOGGER.debug(\"Delete role {}\", roleId);\n        return roleRepository.findById(roleId)\n                .isEmpty()\n                    .flatMap(empty -> {\n                        if (empty) {\n                            throw new RoleNotFoundException(roleId);\n                        }\n                        return roleRepository.delete(roleId);\n                    })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                    return Single.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n                });\n    }\n\n    private Single<Irrelevant> checkRoleUniqueness(String roleName, String roleId, String domain) {\n\n        return roleRepository.findByDomain(domain)\n                .flatMap(roles -> {\n                    if (roles.stream()\n                            .filter(role -> !role.getId().equals(roleId))\n                            .anyMatch(role -> role.getName().equals(roleName))) {\n                        throw new RoleAlreadyExistsException(roleName);\n                    }\n                    return Single.just(Irrelevant.ROLE);\n                });\n    }\n\n}",
        "start_point": {
            "row": 44,
            "column": 0
        },
        "end_point": {
            "row": 183,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Single<Set<Role>> findByDomain(String domain) {\n    LOGGER.debug(\"Find roles by domain: {}\", domain);\n    return roleRepository.findByDomain(domain)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n            });\n}",
                "name": "findByDomain",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find roles by domain: {}\", domain);\n    return roleRepository.findByDomain(domain)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 60,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Maybe<Role> findById(String id) {\n    LOGGER.debug(\"Find role by ID: {}\", id);\n    return roleRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n            });\n}",
                "name": "findById",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find role by ID: {}\", id);\n    return roleRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n            });\n}",
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Role>> findByIdIn(List<String> ids) {\n    LOGGER.debug(\"Find roles by ids: {}\", ids);\n    return roleRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n            });\n}",
                "name": "findByIdIn",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<String>",
                        "name": "ids"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find roles by ids: {}\", ids);\n    return roleRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n            });\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Role> create(String domain, NewRole newRole) {\n    LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n    String roleId = UUID.toString(UUID.random());\n\n    // check if role name is unique\n    return checkRoleUniqueness(newRole.getName(), roleId, domain)\n            .flatMap(irrelevant -> {\n                Role role = new Role();\n                role.setId(roleId);\n                role.setDomain(domain);\n                role.setName(newRole.getName());\n                role.setDescription(newRole.getDescription());\n                role.setCreatedAt(new Date());\n                role.setUpdatedAt(role.getCreatedAt());\n                return roleRepository.create(role);\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n            });\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    },
                    {
                        "type": "NewRole",
                        "name": "newRole"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n    String roleId = UUID.toString(UUID.random());\n\n    // check if role name is unique\n    return checkRoleUniqueness(newRole.getName(), roleId, domain)\n            .flatMap(irrelevant -> {\n                Role role = new Role();\n                role.setId(roleId);\n                role.setDomain(domain);\n                role.setName(newRole.getName());\n                role.setDescription(newRole.getDescription());\n                role.setCreatedAt(new Date());\n                role.setUpdatedAt(role.getCreatedAt());\n                return roleRepository.create(role);\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n            });\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 110,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Role> update(String domain, String id, UpdateRole updateRole) {\n    LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n    return roleRepository.findById(id)\n            .map(role -> Optional.of(role))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(roleOpt -> {\n                if (!roleOpt.isPresent()) {\n                    throw new RoleNotFoundException(id);\n                }\n                return Single.just(roleOpt.get());\n            })\n            .flatMap(oldRole -> {\n                // check if role name is unique\n                return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                        .flatMap(irrelevant -> {\n                            oldRole.setName(updateRole.getName());\n                            oldRole.setDescription(updateRole.getDescription());\n                            oldRole.setPermissions(updateRole.getPermissions());\n                            oldRole.setUpdatedAt(new Date());\n                            return roleRepository.update(oldRole);\n                        });\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n            });\n\n}",
                "name": "update",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    },
                    {
                        "type": "String",
                        "name": "id"
                    },
                    {
                        "type": "UpdateRole",
                        "name": "updateRole"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n    return roleRepository.findById(id)\n            .map(role -> Optional.of(role))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(roleOpt -> {\n                if (!roleOpt.isPresent()) {\n                    throw new RoleNotFoundException(id);\n                }\n                return Single.just(roleOpt.get());\n            })\n            .flatMap(oldRole -> {\n                // check if role name is unique\n                return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                        .flatMap(irrelevant -> {\n                            oldRole.setName(updateRole.getName());\n                            oldRole.setDescription(updateRole.getDescription());\n                            oldRole.setPermissions(updateRole.getPermissions());\n                            oldRole.setUpdatedAt(new Date());\n                            return roleRepository.update(oldRole);\n                        });\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n            });\n\n}",
                "start_point": {
                    "row": 112,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Irrelevant> delete(String roleId) {\n    LOGGER.debug(\"Delete role {}\", roleId);\n    return roleRepository.findById(roleId)\n            .isEmpty()\n                .flatMap(empty -> {\n                    if (empty) {\n                        throw new RoleNotFoundException(roleId);\n                    }\n                    return roleRepository.delete(roleId);\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                return Single.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n            });\n}",
                "name": "delete",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "roleId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Delete role {}\", roleId);\n    return roleRepository.findById(roleId)\n            .isEmpty()\n                .flatMap(empty -> {\n                    if (empty) {\n                        throw new RoleNotFoundException(roleId);\n                    }\n                    return roleRepository.delete(roleId);\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                return Single.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n            });\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 168,
                    "column": 5
                }
            },
            {
                "definition": "private Single<Irrelevant> checkRoleUniqueness(String roleName, String roleId, String domain) {\n\n    return roleRepository.findByDomain(domain)\n            .flatMap(roles -> {\n                if (roles.stream()\n                        .filter(role -> !role.getId().equals(roleId))\n                        .anyMatch(role -> role.getName().equals(roleName))) {\n                    throw new RoleAlreadyExistsException(roleName);\n                }\n                return Single.just(Irrelevant.ROLE);\n            });\n}",
                "name": "checkRoleUniqueness",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "roleName"
                    },
                    {
                        "type": "String",
                        "name": "roleId"
                    },
                    {
                        "type": "String",
                        "name": "domain"
                    }
                ],
                "body": "{\n\n    return roleRepository.findByDomain(domain)\n            .flatMap(roles -> {\n                if (roles.stream()\n                        .filter(role -> !role.getId().equals(roleId))\n                        .anyMatch(role -> role.getName().equals(roleName))) {\n                    throw new RoleAlreadyExistsException(roleName);\n                }\n                return Single.just(Irrelevant.ROLE);\n            });\n}",
                "start_point": {
                    "row": 170,
                    "column": 4
                },
                "end_point": {
                    "row": 181,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/main/java/io/gravitee/am/service/model/UpdateDomain.java",
        "definition": "public class UpdateDomain {\n\n    /**\n     * Domain name.\n     */\n    @NotNull\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    @NotNull\n    private boolean enabled;\n\n    /**\n     * Domain HTTP path.\n     */\n    private String path;\n\n    private Set<String> identities;\n\n    private Set<String> oauth2Identities;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public Set<String> getIdentities() {\n        return identities;\n    }\n\n    public void setIdentities(Set<String> identities) {\n        this.identities = identities;\n    }\n\n    public Set<String> getOauth2Identities() {\n        return oauth2Identities;\n    }\n\n    public void setOauth2Identities(Set<String> oauth2Identities) {\n        this.oauth2Identities = oauth2Identities;\n    }\n}",
        "package": "package io.gravitee.am.service.model;",
        "tree_path": "UpdateDomain",
        "name": "UpdateDomain",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * Domain name.\n     */\n    @NotNull\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    @NotNull\n    private boolean enabled;\n\n    /**\n     * Domain HTTP path.\n     */\n    private String path;\n\n    private Set<String> identities;\n\n    private Set<String> oauth2Identities;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public Set<String> getIdentities() {\n        return identities;\n    }\n\n    public void setIdentities(Set<String> identities) {\n        this.identities = identities;\n    }\n\n    public Set<String> getOauth2Identities() {\n        return oauth2Identities;\n    }\n\n    public void setOauth2Identities(Set<String> oauth2Identities) {\n        this.oauth2Identities = oauth2Identities;\n    }\n}",
        "start_point": {
            "row": 24,
            "column": 0
        },
        "end_point": {
            "row": 99,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "public String getDescription() {\n    return description;\n}",
                "name": "getDescription",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return description;\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 62,
                    "column": 5
                }
            },
            {
                "definition": "public void setDescription(String description) {\n    this.description = description;\n}",
                "name": "setDescription",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "description"
                    }
                ],
                "body": "{\n    this.description = description;\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 66,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            },
            {
                "definition": "public String getPath() {\n    return path;\n}",
                "name": "getPath",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return path;\n}",
                "start_point": {
                    "row": 76,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "public void setPath(String path) {\n    this.path = path;\n}",
                "name": "setPath",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "path"
                    }
                ],
                "body": "{\n    this.path = path;\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 82,
                    "column": 5
                }
            },
            {
                "definition": "public Set<String> getIdentities() {\n    return identities;\n}",
                "name": "getIdentities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return identities;\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 86,
                    "column": 5
                }
            },
            {
                "definition": "public void setIdentities(Set<String> identities) {\n    this.identities = identities;\n}",
                "name": "setIdentities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "identities"
                    }
                ],
                "body": "{\n    this.identities = identities;\n}",
                "start_point": {
                    "row": 88,
                    "column": 4
                },
                "end_point": {
                    "row": 90,
                    "column": 5
                }
            },
            {
                "definition": "public Set<String> getOauth2Identities() {\n    return oauth2Identities;\n}",
                "name": "getOauth2Identities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return oauth2Identities;\n}",
                "start_point": {
                    "row": 92,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "public void setOauth2Identities(Set<String> oauth2Identities) {\n    this.oauth2Identities = oauth2Identities;\n}",
                "name": "setOauth2Identities",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "oauth2Identities"
                    }
                ],
                "body": "{\n    this.oauth2Identities = oauth2Identities;\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/test/java/io/gravitee/am/service/RoleServiceTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class RoleServiceTest {\n\n    @InjectMocks\n    private RoleService roleService = new RoleServiceImpl();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private RoleRepository roleRepository;\n\n    private final static String DOMAIN = \"domain1\";\n\n    @Test\n    public void shouldFindById() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n        testObserver.awaitTerminalEvent();\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValueCount(1);\n    }\n\n    @Test\n    public void shouldFindById_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertNoValues();\n    }\n\n    @Test\n    public void shouldFindById_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n        TestObserver testObserver = new TestObserver();\n        roleService.findById(\"my-role\").subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByDomain() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByDomain_technicalException() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByIdsIn() {\n        when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByIdsIn_technicalException() {\n        when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldCreate() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_technicalException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_uniquenessException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleAlreadyExistsException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findById(\"my-role\");\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_technicalException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_uniquenessException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleAlreadyExistsException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_roleNotFound() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldDelete_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).delete(anyString());\n    }\n\n    @Test\n    public void shouldDelete_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldDelete() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n        TestObserver testObserver = roleService.delete( \"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).delete(\"my-role\");\n    }\n}",
        "package": "package io.gravitee.am.service;",
        "tree_path": "RoleServiceTest",
        "name": "RoleServiceTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private RoleService roleService = new RoleServiceImpl();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private RoleRepository roleRepository;\n\n    private final static String DOMAIN = \"domain1\";\n\n    @Test\n    public void shouldFindById() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n        testObserver.awaitTerminalEvent();\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValueCount(1);\n    }\n\n    @Test\n    public void shouldFindById_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertNoValues();\n    }\n\n    @Test\n    public void shouldFindById_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n        TestObserver testObserver = new TestObserver();\n        roleService.findById(\"my-role\").subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByDomain() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByDomain_technicalException() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByIdsIn() {\n        when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByIdsIn_technicalException() {\n        when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldCreate() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_technicalException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_uniquenessException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleAlreadyExistsException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findById(\"my-role\");\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_technicalException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_uniquenessException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleAlreadyExistsException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_roleNotFound() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldDelete_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).delete(anyString());\n    }\n\n    @Test\n    public void shouldDelete_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldDelete() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n        TestObserver testObserver = roleService.delete( \"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).delete(\"my-role\");\n    }\n}",
        "start_point": {
            "row": 49,
            "column": 0
        },
        "end_point": {
            "row": 296,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldFindById() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n    testObserver.awaitTerminalEvent();\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValueCount(1);\n}",
                "name": "shouldFindById",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n    testObserver.awaitTerminalEvent();\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValueCount(1);\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindById_notExistingRole() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertNoValues();\n}",
                "name": "shouldFindById_notExistingRole",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertNoValues();\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindById_technicalException() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n    TestObserver testObserver = new TestObserver();\n    roleService.findById(\"my-role\").subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldFindById_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n    TestObserver testObserver = new TestObserver();\n    roleService.findById(\"my-role\").subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByDomain() {\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "name": "shouldFindByDomain",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByDomain_technicalException() {\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldFindByDomain_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 116,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByIdsIn() {\n    when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "name": "shouldFindByIdsIn",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "start_point": {
                    "row": 118,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByIdsIn_technicalException() {\n    when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldFindByIdsIn_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldCreate() {\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).create(any(Role.class));\n}",
                "name": "shouldCreate",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).create(any(Role.class));\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldCreate_technicalException() {\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldCreate_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 168,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldCreate_uniquenessException() {\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleAlreadyExistsException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldCreate_uniquenessException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleAlreadyExistsException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 170,
                    "column": 4
                },
                "end_point": {
                    "row": 188,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findById(\"my-role\");\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).update(any(Role.class));\n}",
                "name": "shouldUpdate",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findById(\"my-role\");\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).update(any(Role.class));\n}",
                "start_point": {
                    "row": 190,
                    "column": 4
                },
                "end_point": {
                    "row": 206,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate_technicalException() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).update(any(Role.class));\n}",
                "name": "shouldUpdate_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).update(any(Role.class));\n}",
                "start_point": {
                    "row": 208,
                    "column": 4
                },
                "end_point": {
                    "row": 221,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate_uniquenessException() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleAlreadyExistsException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldUpdate_uniquenessException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleAlreadyExistsException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 223,
                    "column": 4
                },
                "end_point": {
                    "row": 242,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate_roleNotFound() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldUpdate_roleNotFound",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 244,
                    "column": 4
                },
                "end_point": {
                    "row": 258,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldDelete_notExistingRole() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).delete(anyString());\n}",
                "name": "shouldDelete_notExistingRole",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).delete(anyString());\n}",
                "start_point": {
                    "row": 260,
                    "column": 4
                },
                "end_point": {
                    "row": 270,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldDelete_technicalException() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldDelete_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 272,
                    "column": 4
                },
                "end_point": {
                    "row": 281,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldDelete() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n    TestObserver testObserver = roleService.delete( \"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).delete(\"my-role\");\n}",
                "name": "shouldDelete",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n    TestObserver testObserver = roleService.delete( \"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).delete(\"my-role\");\n}",
                "start_point": {
                    "row": 283,
                    "column": 4
                },
                "end_point": {
                    "row": 295,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/WebMvcConfiguration.java",
        "definition": "@Configuration\n@EnableWebMvc\n@Import(ThymeleafConfiguration.class)\npublic class WebMvcConfiguration extends WebMvcConfigurerAdapter {\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        LoginForm loginForm = domain.getLoginForm();\n        if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"file:\" + loginForm.getAssets());\n        } else {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"classpath:/assets/\");\n        }\n    }\n\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer.defaultContentType(MediaType.APPLICATION_JSON);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin;",
        "tree_path": "WebMvcConfiguration",
        "name": "WebMvcConfiguration",
        "modifiers": "@Configuration\n@EnableWebMvc\n@Import(ThymeleafConfiguration.class)\npublic",
        "superclass": "extends WebMvcConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        LoginForm loginForm = domain.getLoginForm();\n        if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"file:\" + loginForm.getAssets());\n        } else {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"classpath:/assets/\");\n        }\n    }\n\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer.defaultContentType(MediaType.APPLICATION_JSON);\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 60,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/WebMvcConfiguration.java",
        "methods": [
            {
                "definition": "@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    LoginForm loginForm = domain.getLoginForm();\n    if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"file:\" + loginForm.getAssets());\n    } else {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"classpath:/assets/\");\n    }\n}",
                "name": "addResourceHandlers",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ResourceHandlerRegistry",
                        "name": "registry"
                    }
                ],
                "body": "{\n    LoginForm loginForm = domain.getLoginForm();\n    if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"file:\" + loginForm.getAssets());\n    } else {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"classpath:/assets/\");\n    }\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n    configurer.defaultContentType(MediaType.APPLICATION_JSON);\n}",
                "name": "configureContentNegotiation",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ContentNegotiationConfigurer",
                        "name": "configurer"
                    }
                ],
                "body": "{\n    configurer.defaultContentType(MediaType.APPLICATION_JSON);\n}",
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 59,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/authentication/CustomSavedRequestAwareAuthenticationSuccessHandler.java",
        "definition": "public class CustomSavedRequestAwareAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {\n    protected final Logger logger = LoggerFactory.getLogger(CustomSavedRequestAwareAuthenticationSuccessHandler.class);\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private RequestCache requestCache = new HttpSessionRequestCache();\n\n    @Autowired\n    private JWTCookieGenerator jwtCookieGenerator;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n        if (savedRequest == null) {\n            if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n                super.onAuthenticationSuccess(request, response, authentication);\n\n                return;\n            } else {\n                // fetch saved request from user session\n                savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n            }\n        } else {\n            // Store the saved HTTP request itself for redirection after successful authentication\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        // store jwt authentication cookie to secure management restricted operations\n        Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authentication);\n        response.addCookie(jwtAuthenticationCookie);\n\n        String targetUrlParameter = getTargetUrlParameter();\n        if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n            requestCache.removeRequest(request, response);\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        }\n\n        clearAuthenticationAttributes(request);\n\n        // Use the DefaultSavedRequest URL\n        String targetUrl = savedRequest.getRedirectUrl();\n        logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n        getRedirectStrategy().sendRedirect(request, response, targetUrl);\n    }\n\n    private Cookie createJWTAuthenticationCookie(Authentication authentication) {\n        final User principal = (User) authentication.getPrincipal();\n        return jwtCookieGenerator.generate(principal);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.authentication;",
        "tree_path": "CustomSavedRequestAwareAuthenticationSuccessHandler",
        "name": "CustomSavedRequestAwareAuthenticationSuccessHandler",
        "modifiers": "public",
        "superclass": "extends SavedRequestAwareAuthenticationSuccessHandler",
        "super_interfaces": null,
        "body": "{\n    protected final Logger logger = LoggerFactory.getLogger(CustomSavedRequestAwareAuthenticationSuccessHandler.class);\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private RequestCache requestCache = new HttpSessionRequestCache();\n\n    @Autowired\n    private JWTCookieGenerator jwtCookieGenerator;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n        if (savedRequest == null) {\n            if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n                super.onAuthenticationSuccess(request, response, authentication);\n\n                return;\n            } else {\n                // fetch saved request from user session\n                savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n            }\n        } else {\n            // Store the saved HTTP request itself for redirection after successful authentication\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        // store jwt authentication cookie to secure management restricted operations\n        Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authentication);\n        response.addCookie(jwtAuthenticationCookie);\n\n        String targetUrlParameter = getTargetUrlParameter();\n        if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n            requestCache.removeRequest(request, response);\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        }\n\n        clearAuthenticationAttributes(request);\n\n        // Use the DefaultSavedRequest URL\n        String targetUrl = savedRequest.getRedirectUrl();\n        logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n        getRedirectStrategy().sendRedirect(request, response, targetUrl);\n    }\n\n    private Cookie createJWTAuthenticationCookie(Authentication authentication) {\n        final User principal = (User) authentication.getPrincipal();\n        return jwtCookieGenerator.generate(principal);\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 90,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/authentication/CustomSavedRequestAwareAuthenticationSuccessHandler.java",
        "methods": [
            {
                "definition": "@Override\npublic void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                    Authentication authentication) throws ServletException, IOException {\n    SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n    if (savedRequest == null) {\n        if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        } else {\n            // fetch saved request from user session\n            savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n        }\n    } else {\n        // Store the saved HTTP request itself for redirection after successful authentication\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    // store jwt authentication cookie to secure management restricted operations\n    Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authentication);\n    response.addCookie(jwtAuthenticationCookie);\n\n    String targetUrlParameter = getTargetUrlParameter();\n    if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n        requestCache.removeRequest(request, response);\n        super.onAuthenticationSuccess(request, response, authentication);\n\n        return;\n    }\n\n    clearAuthenticationAttributes(request);\n\n    // Use the DefaultSavedRequest URL\n    String targetUrl = savedRequest.getRedirectUrl();\n    logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n    getRedirectStrategy().sendRedirect(request, response, targetUrl);\n}",
                "name": "onAuthenticationSuccess",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n    if (savedRequest == null) {\n        if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        } else {\n            // fetch saved request from user session\n            savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n        }\n    } else {\n        // Store the saved HTTP request itself for redirection after successful authentication\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    // store jwt authentication cookie to secure management restricted operations\n    Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authentication);\n    response.addCookie(jwtAuthenticationCookie);\n\n    String targetUrlParameter = getTargetUrlParameter();\n    if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n        requestCache.removeRequest(request, response);\n        super.onAuthenticationSuccess(request, response, authentication);\n\n        return;\n    }\n\n    clearAuthenticationAttributes(request);\n\n    // Use the DefaultSavedRequest URL\n    String targetUrl = savedRequest.getRedirectUrl();\n    logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n    getRedirectStrategy().sendRedirect(request, response, targetUrl);\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "private Cookie createJWTAuthenticationCookie(Authentication authentication) {\n    final User principal = (User) authentication.getPrincipal();\n    return jwtCookieGenerator.generate(principal);\n}",
                "name": "createJWTAuthenticationCookie",
                "modifiers": "private",
                "return_type": "Cookie",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    final User principal = (User) authentication.getPrincipal();\n    return jwtCookieGenerator.generate(principal);\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/authentication/LoginUrlAuthenticationEntryPoint.java",
        "definition": "public class LoginUrlAuthenticationEntryPoint extends org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint {\n\n    public LoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n        super(loginFormUrl);\n    }\n\n    @Override\n    protected String buildRedirectUrlToLoginPage(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {\n        String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        return builder.toUriString();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.authentication;",
        "tree_path": "LoginUrlAuthenticationEntryPoint",
        "name": "LoginUrlAuthenticationEntryPoint",
        "modifiers": "public",
        "superclass": "extends org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint",
        "super_interfaces": null,
        "body": "{\n\n    public LoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n        super(loginFormUrl);\n    }\n\n    @Override\n    protected String buildRedirectUrlToLoginPage(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {\n        String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        return builder.toUriString();\n    }\n}",
        "start_point": {
            "row": 28,
            "column": 0
        },
        "end_point": {
            "row": 59,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/authentication/OAuth2LoginUrlAuthenticationEntryPoint.java",
        "methods": [
            {
                "definition": "public LoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n    super(loginFormUrl);\n}",
                "name": "LoginUrlAuthenticationEntryPoint",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "loginFormUrl"
                    }
                ],
                "body": "{\n    super(loginFormUrl);\n}",
                "constructor": true,
                "start_point": {
                    "row": 30,
                    "column": 4
                },
                "end_point": {
                    "row": 32,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected String buildRedirectUrlToLoginPage(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {\n    String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    return builder.toUriString();\n}",
                "name": "buildRedirectUrlToLoginPage",
                "modifiers": "@Override\n    protected",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "AuthenticationException",
                        "name": "authException"
                    }
                ],
                "body": "{\n    String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    return builder.toUriString();\n}",
                "start_point": {
                    "row": 34,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminContextFactory.java",
        "definition": "public class AdminContextFactory implements ServletContextFactory<Domain>, ApplicationContextAware {\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public boolean canHandle(Domain domain) {\n        return domain != null;\n    }\n\n    @Override\n    public ServletContext<Domain> create(Domain domain) {\n        SpringServletContext servletContext = AdminSpringServletContext.create(domain).build();\n        servletContext.setRootApplicationContext(applicationContext);\n\n        return servletContext;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.context;",
        "tree_path": "AdminContextFactory",
        "name": "AdminContextFactory",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements ServletContextFactory<Domain>, ApplicationContextAware",
        "body": "{\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public boolean canHandle(Domain domain) {\n        return domain != null;\n    }\n\n    @Override\n    public ServletContext<Domain> create(Domain domain) {\n        SpringServletContext servletContext = AdminSpringServletContext.create(domain).build();\n        servletContext.setRootApplicationContext(applicationContext);\n\n        return servletContext;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 50,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2ContextFactory.java",
        "methods": [
            {
                "definition": "@Override\npublic boolean canHandle(Domain domain) {\n    return domain != null;\n}",
                "name": "canHandle",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    return domain != null;\n}",
                "start_point": {
                    "row": 33,
                    "column": 4
                },
                "end_point": {
                    "row": 36,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic ServletContext<Domain> create(Domain domain) {\n    SpringServletContext servletContext = AdminSpringServletContext.create(domain).build();\n    servletContext.setRootApplicationContext(applicationContext);\n\n    return servletContext;\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    SpringServletContext servletContext = AdminSpringServletContext.create(domain).build();\n    servletContext.setRootApplicationContext(applicationContext);\n\n    return servletContext;\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n    this.applicationContext = applicationContext;\n}",
                "name": "setApplicationContext",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ApplicationContext",
                        "name": "applicationContext"
                    }
                ],
                "body": "{\n    this.applicationContext = applicationContext;\n}",
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminContextLoaderListener.java",
        "definition": "public class AdminContextLoaderListener extends ContextLoaderListener {\n\n    public AdminContextLoaderListener(WebApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public void contextInitialized(ServletContextEvent event) {\n        super.contextInitialized(event);\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent event) {\n        super.contextDestroyed(event);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.context;",
        "tree_path": "AdminContextLoaderListener",
        "name": "AdminContextLoaderListener",
        "modifiers": "public",
        "superclass": "extends ContextLoaderListener",
        "super_interfaces": null,
        "body": "{\n\n    public AdminContextLoaderListener(WebApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public void contextInitialized(ServletContextEvent event) {\n        super.contextInitialized(event);\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent event) {\n        super.contextDestroyed(event);\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 41,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2ContextLoaderListener.java",
        "methods": [
            {
                "definition": "public AdminContextLoaderListener(WebApplicationContext context) {\n    super(context);\n}",
                "name": "AdminContextLoaderListener",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "WebApplicationContext",
                        "name": "context"
                    }
                ],
                "body": "{\n    super(context);\n}",
                "constructor": true,
                "start_point": {
                    "row": 28,
                    "column": 4
                },
                "end_point": {
                    "row": 30,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void contextInitialized(ServletContextEvent event) {\n    super.contextInitialized(event);\n}",
                "name": "contextInitialized",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ServletContextEvent",
                        "name": "event"
                    }
                ],
                "body": "{\n    super.contextInitialized(event);\n}",
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 35,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void contextDestroyed(ServletContextEvent event) {\n    super.contextDestroyed(event);\n}",
                "name": "contextDestroyed",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ServletContextEvent",
                        "name": "event"
                    }
                ],
                "body": "{\n    super.contextDestroyed(event);\n}",
                "start_point": {
                    "row": 37,
                    "column": 4
                },
                "end_point": {
                    "row": 40,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminDomainBeanFactoryPostProcessor.java",
        "definition": "class AdminDomainBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    private final Domain domain;\n\n    AdminDomainBeanFactoryPostProcessor(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n        beanFactory.registerSingleton(\"domain\", domain);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.context;",
        "tree_path": "AdminDomainBeanFactoryPostProcessor",
        "name": "AdminDomainBeanFactoryPostProcessor",
        "modifiers": null,
        "superclass": null,
        "super_interfaces": "implements BeanFactoryPostProcessor",
        "body": "{\n\n    private final Domain domain;\n\n    AdminDomainBeanFactoryPostProcessor(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n        beanFactory.registerSingleton(\"domain\", domain);\n    }\n}",
        "start_point": {
            "row": 27,
            "column": 0
        },
        "end_point": {
            "row": 40,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2DomainBeanFactoryPostProcessor.java",
        "methods": [
            {
                "definition": "AdminDomainBeanFactoryPostProcessor(Domain domain) {\n    this.domain = domain;\n}",
                "name": "AdminDomainBeanFactoryPostProcessor",
                "modifiers": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    this.domain = domain;\n}",
                "constructor": true,
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 33,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n    DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n    beanFactory.registerSingleton(\"domain\", domain);\n}",
                "name": "postProcessBeanFactory",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ConfigurableListableBeanFactory",
                        "name": "configurableListableBeanFactory"
                    }
                ],
                "body": "{\n    DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n    beanFactory.registerSingleton(\"domain\", domain);\n}",
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 39,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminSpringServletContext.java",
        "definition": "public class AdminSpringServletContext extends SpringServletContext<Domain> {\n\n    private final Domain domain;\n\n    private AdminSpringServletContext(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public List<Servlet> servlets() {\n        return Collections.singletonList(new DispatcherServlet(applicationContext()));\n    }\n\n    @Override\n    public List<Filter> filters() {\n        return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n    }\n\n    @Override\n    public List<EventListener> listeners() {\n        return Collections.singletonList(new AdminContextLoaderListener(applicationContext()));\n    }\n\n    @Override\n    public Domain deployable() {\n        return domain;\n    }\n\n    @Override\n    protected Set<Class<?>> annotatedClasses() {\n        return new HashSet<>(Arrays.asList(AdminConfiguration.class));\n    }\n\n    @Override\n    protected Set<? extends BeanFactoryPostProcessor> beanFactoryPostProcessors() {\n        return Collections.singleton(new AdminDomainBeanFactoryPostProcessor((Domain) deployable()));\n    }\n\n    static Builder create(Domain domain) {\n        return new Builder(domain);\n    }\n\n    static class Builder {\n\n        private final Domain domain;\n\n        private Builder(Domain domain) {\n            this.domain = domain;\n        }\n\n        SpringServletContext<Domain> build() {\n            return new AdminSpringServletContext(domain);\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.context;",
        "tree_path": "AdminSpringServletContext",
        "name": "AdminSpringServletContext",
        "modifiers": "public",
        "superclass": "extends SpringServletContext<Domain>",
        "super_interfaces": null,
        "body": "{\n\n    private final Domain domain;\n\n    private AdminSpringServletContext(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public List<Servlet> servlets() {\n        return Collections.singletonList(new DispatcherServlet(applicationContext()));\n    }\n\n    @Override\n    public List<Filter> filters() {\n        return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n    }\n\n    @Override\n    public List<EventListener> listeners() {\n        return Collections.singletonList(new AdminContextLoaderListener(applicationContext()));\n    }\n\n    @Override\n    public Domain deployable() {\n        return domain;\n    }\n\n    @Override\n    protected Set<Class<?>> annotatedClasses() {\n        return new HashSet<>(Arrays.asList(AdminConfiguration.class));\n    }\n\n    @Override\n    protected Set<? extends BeanFactoryPostProcessor> beanFactoryPostProcessors() {\n        return Collections.singleton(new AdminDomainBeanFactoryPostProcessor((Domain) deployable()));\n    }\n\n    static Builder create(Domain domain) {\n        return new Builder(domain);\n    }\n\n    static class Builder {\n\n        private final Domain domain;\n\n        private Builder(Domain domain) {\n            this.domain = domain;\n        }\n\n        SpringServletContext<Domain> build() {\n            return new AdminSpringServletContext(domain);\n        }\n    }\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 86,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2SpringServletContext.java",
        "methods": [
            {
                "definition": "private AdminSpringServletContext(Domain domain) {\n    this.domain = domain;\n}",
                "name": "AdminSpringServletContext",
                "modifiers": "private",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    this.domain = domain;\n}",
                "constructor": true,
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 38,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic List<Servlet> servlets() {\n    return Collections.singletonList(new DispatcherServlet(applicationContext()));\n}",
                "name": "servlets",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singletonList(new DispatcherServlet(applicationContext()));\n}",
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic List<Filter> filters() {\n    return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n}",
                "name": "filters",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 48,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic List<EventListener> listeners() {\n    return Collections.singletonList(new AdminContextLoaderListener(applicationContext()));\n}",
                "name": "listeners",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singletonList(new AdminContextLoaderListener(applicationContext()));\n}",
                "start_point": {
                    "row": 50,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Domain deployable() {\n    return domain;\n}",
                "name": "deployable",
                "modifiers": "@Override\n    public",
                "return_type": "Domain",
                "parameters": [],
                "body": "{\n    return domain;\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected Set<Class<?>> annotatedClasses() {\n    return new HashSet<>(Arrays.asList(AdminConfiguration.class));\n}",
                "name": "annotatedClasses",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return new HashSet<>(Arrays.asList(AdminConfiguration.class));\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 63,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected Set<? extends BeanFactoryPostProcessor> beanFactoryPostProcessors() {\n    return Collections.singleton(new AdminDomainBeanFactoryPostProcessor((Domain) deployable()));\n}",
                "name": "beanFactoryPostProcessors",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singleton(new AdminDomainBeanFactoryPostProcessor((Domain) deployable()));\n}",
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "static Builder create(Domain domain) {\n    return new Builder(domain);\n}",
                "name": "create",
                "modifiers": "static",
                "return_type": "Builder",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    return new Builder(domain);\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 72,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminSpringServletContext.java",
        "definition": "static class Builder {\n\n    private final Domain domain;\n\n    private Builder(Domain domain) {\n        this.domain = domain;\n    }\n\n    SpringServletContext<Domain> build() {\n        return new AdminSpringServletContext(domain);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.context;",
        "tree_path": "AdminSpringServletContext.Builder",
        "name": "Builder",
        "modifiers": "static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final Domain domain;\n\n    private Builder(Domain domain) {\n        this.domain = domain;\n    }\n\n    SpringServletContext<Domain> build() {\n        return new AdminSpringServletContext(domain);\n    }\n}",
        "start_point": {
            "row": 74,
            "column": 4
        },
        "end_point": {
            "row": 85,
            "column": 5
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2SpringServletContext.java",
        "methods": [
            {
                "definition": "private Builder(Domain domain) {\n    this.domain = domain;\n}",
                "name": "Builder",
                "modifiers": "private",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    this.domain = domain;\n}",
                "constructor": true,
                "start_point": {
                    "row": 78,
                    "column": 8
                },
                "end_point": {
                    "row": 80,
                    "column": 9
                }
            },
            {
                "definition": "SpringServletContext<Domain> build() {\n    return new AdminSpringServletContext(domain);\n}",
                "name": "build",
                "modifiers": null,
                "return_type": null,
                "parameters": [],
                "body": "{\n    return new AdminSpringServletContext(domain);\n}",
                "start_point": {
                    "row": 82,
                    "column": 8
                },
                "end_point": {
                    "row": 84,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/controller/LoginController.java",
        "definition": "@Controller\npublic class LoginController {\n\n    private static final String LOGIN_VIEW = \"login\";\n    private static final List<String> socialProviders = Arrays.asList(\"github\", \"google\", \"twitter\", \"facebook\", \"bitbucket\");\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private static final String CLIENT_ID = \"client_id\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n    private static final String RESPONSE_TYPE = \"response_type\";\n    private static final String SCOPE = \"scope\";\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @RequestMapping(value = \"/login\")\n    public ModelAndView login(HttpServletRequest request) {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"domain\", domain);\n        Set<String> clientOAuth2Providers = domain.getOauth2Identities();\n        if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n            params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n                IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n                String identityProviderType = identityProvider.getType();\n                Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n                if (identityProviderSocialType.isPresent()) {\n                    identityProvider.setType(identityProviderSocialType.get());\n                }\n                return identityProvider;\n            }).collect(Collectors.toSet()));\n\n            Map<String, String> authorizeUrls = new HashMap<>();\n            clientOAuth2Providers.forEach(identity -> {\n                OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n                if (oAuth2AuthenticationProvider != null) {\n                    OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                    builder.queryParam(CLIENT_ID, configuration.getClientId());\n                    builder.queryParam(REDIRECT_URI, buildRedirectUri(request, identity));\n                    builder.queryParam(RESPONSE_TYPE, \"code\");\n                    if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                        builder.queryParam(SCOPE, String.join(\" \", configuration.getScopes()));\n                    }\n                    authorizeUrls.put(identity, builder.build(false).toUriString());\n                }\n            });\n            params.put(\"authorizeUrls\", authorizeUrls);\n        }\n\n        return new ModelAndView(LOGIN_VIEW, params);\n    }\n\n    @RequestMapping(value = \"/login/callback\")\n    public void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n        if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n            final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n            response.sendRedirect(savedRequest.getRedirectUrl());\n        } else {\n            response.sendRedirect(\"/login\");\n        }\n    }\n\n    private String buildRedirectUri(HttpServletRequest request, String identity) {\n        UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        } else {\n            builder.scheme(request.getScheme());\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        } else {\n            builder.host(request.getServerName());\n            if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n                builder.port(request.getServerPort());\n            }\n        }\n        // append context path\n        builder.path(request.getContextPath());\n        builder.pathSegment(\"login/callback\");\n\n        // append identity provider id\n        builder.queryParam(\"provider\", identity);\n\n        return builder.build().toUriString();\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.admin.controller;",
        "tree_path": "LoginController",
        "name": "LoginController",
        "modifiers": "@Controller\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private static final String LOGIN_VIEW = \"login\";\n    private static final List<String> socialProviders = Arrays.asList(\"github\", \"google\", \"twitter\", \"facebook\", \"bitbucket\");\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private static final String CLIENT_ID = \"client_id\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n    private static final String RESPONSE_TYPE = \"response_type\";\n    private static final String SCOPE = \"scope\";\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @RequestMapping(value = \"/login\")\n    public ModelAndView login(HttpServletRequest request) {\n        Map<String, Object> params = new HashMap<>();\n        params.put(\"domain\", domain);\n        Set<String> clientOAuth2Providers = domain.getOauth2Identities();\n        if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n            params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n                IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n                String identityProviderType = identityProvider.getType();\n                Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n                if (identityProviderSocialType.isPresent()) {\n                    identityProvider.setType(identityProviderSocialType.get());\n                }\n                return identityProvider;\n            }).collect(Collectors.toSet()));\n\n            Map<String, String> authorizeUrls = new HashMap<>();\n            clientOAuth2Providers.forEach(identity -> {\n                OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n                if (oAuth2AuthenticationProvider != null) {\n                    OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                    builder.queryParam(CLIENT_ID, configuration.getClientId());\n                    builder.queryParam(REDIRECT_URI, buildRedirectUri(request, identity));\n                    builder.queryParam(RESPONSE_TYPE, \"code\");\n                    if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                        builder.queryParam(SCOPE, String.join(\" \", configuration.getScopes()));\n                    }\n                    authorizeUrls.put(identity, builder.build(false).toUriString());\n                }\n            });\n            params.put(\"authorizeUrls\", authorizeUrls);\n        }\n\n        return new ModelAndView(LOGIN_VIEW, params);\n    }\n\n    @RequestMapping(value = \"/login/callback\")\n    public void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n        if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n            final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n            response.sendRedirect(savedRequest.getRedirectUrl());\n        } else {\n            response.sendRedirect(\"/login\");\n        }\n    }\n\n    private String buildRedirectUri(HttpServletRequest request, String identity) {\n        UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        } else {\n            builder.scheme(request.getScheme());\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        } else {\n            builder.host(request.getServerName());\n            if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n                builder.port(request.getServerPort());\n            }\n        }\n        // append context path\n        builder.path(request.getContextPath());\n        builder.pathSegment(\"login/callback\");\n\n        // append identity provider id\n        builder.queryParam(\"provider\", identity);\n\n        return builder.build().toUriString();\n    }\n\n}",
        "start_point": {
            "row": 42,
            "column": 0
        },
        "end_point": {
            "row": 142,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/controller/LoginController.java",
        "methods": [
            {
                "definition": "@RequestMapping(value = \"/login\")\npublic ModelAndView login(HttpServletRequest request) {\n    Map<String, Object> params = new HashMap<>();\n    params.put(\"domain\", domain);\n    Set<String> clientOAuth2Providers = domain.getOauth2Identities();\n    if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n        params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n            IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n            String identityProviderType = identityProvider.getType();\n            Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n            if (identityProviderSocialType.isPresent()) {\n                identityProvider.setType(identityProviderSocialType.get());\n            }\n            return identityProvider;\n        }).collect(Collectors.toSet()));\n\n        Map<String, String> authorizeUrls = new HashMap<>();\n        clientOAuth2Providers.forEach(identity -> {\n            OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n            if (oAuth2AuthenticationProvider != null) {\n                OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                builder.queryParam(CLIENT_ID, configuration.getClientId());\n                builder.queryParam(REDIRECT_URI, buildRedirectUri(request, identity));\n                builder.queryParam(RESPONSE_TYPE, \"code\");\n                if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                    builder.queryParam(SCOPE, String.join(\" \", configuration.getScopes()));\n                }\n                authorizeUrls.put(identity, builder.build(false).toUriString());\n            }\n        });\n        params.put(\"authorizeUrls\", authorizeUrls);\n    }\n\n    return new ModelAndView(LOGIN_VIEW, params);\n}",
                "name": "login",
                "modifiers": "@RequestMapping(value = \"/login\")\n    public",
                "return_type": "ModelAndView",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    }
                ],
                "body": "{\n    Map<String, Object> params = new HashMap<>();\n    params.put(\"domain\", domain);\n    Set<String> clientOAuth2Providers = domain.getOauth2Identities();\n    if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n        params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n            IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n            String identityProviderType = identityProvider.getType();\n            Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n            if (identityProviderSocialType.isPresent()) {\n                identityProvider.setType(identityProviderSocialType.get());\n            }\n            return identityProvider;\n        }).collect(Collectors.toSet()));\n\n        Map<String, String> authorizeUrls = new HashMap<>();\n        clientOAuth2Providers.forEach(identity -> {\n            OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n            if (oAuth2AuthenticationProvider != null) {\n                OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                builder.queryParam(CLIENT_ID, configuration.getClientId());\n                builder.queryParam(REDIRECT_URI, buildRedirectUri(request, identity));\n                builder.queryParam(RESPONSE_TYPE, \"code\");\n                if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                    builder.queryParam(SCOPE, String.join(\" \", configuration.getScopes()));\n                }\n                authorizeUrls.put(identity, builder.build(false).toUriString());\n            }\n        });\n        params.put(\"authorizeUrls\", authorizeUrls);\n    }\n\n    return new ModelAndView(LOGIN_VIEW, params);\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/login/callback\")\npublic void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n    if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n        final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n        response.sendRedirect(savedRequest.getRedirectUrl());\n    } else {\n        response.sendRedirect(\"/login\");\n    }\n}",
                "name": "loginCallback",
                "modifiers": "@RequestMapping(value = \"/login/callback\")\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "HttpSession",
                        "name": "session"
                    }
                ],
                "body": "{\n    if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n        final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n        response.sendRedirect(savedRequest.getRedirectUrl());\n    } else {\n        response.sendRedirect(\"/login\");\n    }\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 104,
                    "column": 5
                }
            },
            {
                "definition": "private String buildRedirectUri(HttpServletRequest request, String identity) {\n    UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    } else {\n        builder.scheme(request.getScheme());\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    } else {\n        builder.host(request.getServerName());\n        if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n            builder.port(request.getServerPort());\n        }\n    }\n    // append context path\n    builder.path(request.getContextPath());\n    builder.pathSegment(\"login/callback\");\n\n    // append identity provider id\n    builder.queryParam(\"provider\", identity);\n\n    return builder.build().toUriString();\n}",
                "name": "buildRedirectUri",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "String",
                        "name": "identity"
                    }
                ],
                "body": "{\n    UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    } else {\n        builder.scheme(request.getScheme());\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    } else {\n        builder.host(request.getServerName());\n        if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n            builder.port(request.getServerPort());\n        }\n    }\n    // append context path\n    builder.path(request.getContextPath());\n    builder.pathSegment(\"login/callback\");\n\n    // append identity provider id\n    builder.queryParam(\"provider\", identity);\n\n    return builder.build().toUriString();\n}",
                "start_point": {
                    "row": 106,
                    "column": 4
                },
                "end_point": {
                    "row": 140,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/filter/OAuth2ClientAuthenticationFilter.java",
        "definition": "public class OAuth2ClientAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\n\n    private final Logger logger = LoggerFactory.getLogger(OAuth2ClientAuthenticationFilter.class);\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    private static final String SOURCE = \"source\";\n    private static final String OAUTH2_IDENTIFIER = \"_oauth2_\";\n    private static final String PROVIDER_PARAMETER = \"provider\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private static final String errorPage = \"/oauth/error\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n\n    private AuthenticationEventPublisher authenticationEventPublisher;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Autowired\n    private JWTCookieGenerator jwtCookieGenerator;\n\n    public OAuth2ClientAuthenticationFilter(String defaultFilterProcessesUrl) {\n        super(defaultFilterProcessesUrl);\n        setAuthenticationManager(new NoopAuthenticationManager());\n        setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        // get oauth2 provider\n        String providerId = request.getParameter(PROVIDER_PARAMETER);\n        AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n        if (authenticationProvider == null) {\n            throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n        }\n\n        if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n            throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n        }\n\n        String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n        io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n        ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(REDIRECT_URI, buildRedirectUri(request)));\n        try {\n            User user = authenticationProvider.loadUserByUsername(provAuthentication);\n            if (user == null) {\n                logger.error(\"User is null, fail to authenticate user\");\n                throw new BadCredentialsException(\"User is null after authentication process\");\n            }\n\n            // set user identity provider source\n            Map<String, String> details = new LinkedHashMap<>();\n            details.put(SOURCE, providerId);\n            UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n            usernamePasswordAuthenticationToken.setDetails(details);\n            return usernamePasswordAuthenticationToken;\n        } catch (Exception ex) {\n            logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    @Override\n    protected final void successfulAuthentication(HttpServletRequest request,\n                                                  HttpServletResponse response, FilterChain chain, Authentication authResult)\n            throws IOException, ServletException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                    + authResult);\n        }\n\n        SecurityContextHolder.getContext().setAuthentication(authResult);\n\n        // Fire event\n        if (this.authenticationEventPublisher != null) {\n            authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n        }\n\n        // store jwt authentication cookie to secure management restricted operations\n        Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authResult);\n        response.addCookie(jwtAuthenticationCookie);\n\n        // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n        // for redirection after successful authentication\n        SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n        if (savedRequest != null && request.getSession(false) != null) {\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {\n        super.setApplicationEventPublisher(eventPublisher);\n        this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n    }\n\n    @Override\n    protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {\n        return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n    }\n\n    private Cookie createJWTAuthenticationCookie(Authentication authentication) {\n        final User principal = (User) authentication.getPrincipal();\n        return jwtCookieGenerator.generate(principal);\n    }\n\n    /**\n     * Determines if a user is already authenticated.\n     * @return\n     */\n    private boolean authenticated() {\n        Authentication authentication = SecurityContextHolder.getContext()\n                .getAuthentication();\n        return authentication != null && authentication.isAuthenticated()\n                && !(authentication instanceof AnonymousAuthenticationToken);\n    }\n\n    private String buildRedirectUri(HttpServletRequest request) {\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n        // append provider query param to avoid redirect mismatch exception\n        builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n        return builder.build(false).toUriString();\n    }\n\n\n    private static class NoopAuthenticationManager implements AuthenticationManager {\n\n        @Override\n        public Authentication authenticate(Authentication authentication)\n                throws AuthenticationException {\n            throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n        }\n\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.admin.filter;",
        "tree_path": "OAuth2ClientAuthenticationFilter",
        "name": "OAuth2ClientAuthenticationFilter",
        "modifiers": "public",
        "superclass": "extends AbstractAuthenticationProcessingFilter",
        "super_interfaces": null,
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(OAuth2ClientAuthenticationFilter.class);\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    private static final String SOURCE = \"source\";\n    private static final String OAUTH2_IDENTIFIER = \"_oauth2_\";\n    private static final String PROVIDER_PARAMETER = \"provider\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private static final String errorPage = \"/oauth/error\";\n    private static final String REDIRECT_URI = \"redirect_uri\";\n\n    private AuthenticationEventPublisher authenticationEventPublisher;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Autowired\n    private JWTCookieGenerator jwtCookieGenerator;\n\n    public OAuth2ClientAuthenticationFilter(String defaultFilterProcessesUrl) {\n        super(defaultFilterProcessesUrl);\n        setAuthenticationManager(new NoopAuthenticationManager());\n        setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n        // get oauth2 provider\n        String providerId = request.getParameter(PROVIDER_PARAMETER);\n        AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n        if (authenticationProvider == null) {\n            throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n        }\n\n        if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n            throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n        }\n\n        String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n        io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n        ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(REDIRECT_URI, buildRedirectUri(request)));\n        try {\n            User user = authenticationProvider.loadUserByUsername(provAuthentication);\n            if (user == null) {\n                logger.error(\"User is null, fail to authenticate user\");\n                throw new BadCredentialsException(\"User is null after authentication process\");\n            }\n\n            // set user identity provider source\n            Map<String, String> details = new LinkedHashMap<>();\n            details.put(SOURCE, providerId);\n            UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n            usernamePasswordAuthenticationToken.setDetails(details);\n            return usernamePasswordAuthenticationToken;\n        } catch (Exception ex) {\n            logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    @Override\n    protected final void successfulAuthentication(HttpServletRequest request,\n                                                  HttpServletResponse response, FilterChain chain, Authentication authResult)\n            throws IOException, ServletException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                    + authResult);\n        }\n\n        SecurityContextHolder.getContext().setAuthentication(authResult);\n\n        // Fire event\n        if (this.authenticationEventPublisher != null) {\n            authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n        }\n\n        // store jwt authentication cookie to secure management restricted operations\n        Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authResult);\n        response.addCookie(jwtAuthenticationCookie);\n\n        // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n        // for redirection after successful authentication\n        SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n        if (savedRequest != null && request.getSession(false) != null) {\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {\n        super.setApplicationEventPublisher(eventPublisher);\n        this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n    }\n\n    @Override\n    protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {\n        return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n    }\n\n    private Cookie createJWTAuthenticationCookie(Authentication authentication) {\n        final User principal = (User) authentication.getPrincipal();\n        return jwtCookieGenerator.generate(principal);\n    }\n\n    /**\n     * Determines if a user is already authenticated.\n     * @return\n     */\n    private boolean authenticated() {\n        Authentication authentication = SecurityContextHolder.getContext()\n                .getAuthentication();\n        return authentication != null && authentication.isAuthenticated()\n                && !(authentication instanceof AnonymousAuthenticationToken);\n    }\n\n    private String buildRedirectUri(HttpServletRequest request) {\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n        // append provider query param to avoid redirect mismatch exception\n        builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n        return builder.build(false).toUriString();\n    }\n\n\n    private static class NoopAuthenticationManager implements AuthenticationManager {\n\n        @Override\n        public Authentication authenticate(Authentication authentication)\n                throws AuthenticationException {\n            throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n        }\n\n    }\n\n}",
        "start_point": {
            "row": 52,
            "column": 0
        },
        "end_point": {
            "row": 193,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/filter/OAuth2ClientAuthenticationFilter.java",
        "methods": [
            {
                "definition": "public OAuth2ClientAuthenticationFilter(String defaultFilterProcessesUrl) {\n    super(defaultFilterProcessesUrl);\n    setAuthenticationManager(new NoopAuthenticationManager());\n    setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n}",
                "name": "OAuth2ClientAuthenticationFilter",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "defaultFilterProcessesUrl"
                    }
                ],
                "body": "{\n    super(defaultFilterProcessesUrl);\n    setAuthenticationManager(new NoopAuthenticationManager());\n    setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n}",
                "constructor": true,
                "start_point": {
                    "row": 74,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {\n    // get oauth2 provider\n    String providerId = request.getParameter(PROVIDER_PARAMETER);\n    AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n    if (authenticationProvider == null) {\n        throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n    }\n\n    if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n        throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n    }\n\n    String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n    ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(REDIRECT_URI, buildRedirectUri(request)));\n    try {\n        User user = authenticationProvider.loadUserByUsername(provAuthentication);\n        if (user == null) {\n            logger.error(\"User is null, fail to authenticate user\");\n            throw new BadCredentialsException(\"User is null after authentication process\");\n        }\n\n        // set user identity provider source\n        Map<String, String> details = new LinkedHashMap<>();\n        details.put(SOURCE, providerId);\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n        usernamePasswordAuthenticationToken.setDetails(details);\n        return usernamePasswordAuthenticationToken;\n    } catch (Exception ex) {\n        logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n        throw new BadCredentialsException(ex.getMessage(), ex);\n    }\n}",
                "name": "attemptAuthentication",
                "modifiers": "@Override\n    public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    // get oauth2 provider\n    String providerId = request.getParameter(PROVIDER_PARAMETER);\n    AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n    if (authenticationProvider == null) {\n        throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n    }\n\n    if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n        throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n    }\n\n    String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n    ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(REDIRECT_URI, buildRedirectUri(request)));\n    try {\n        User user = authenticationProvider.loadUserByUsername(provAuthentication);\n        if (user == null) {\n            logger.error(\"User is null, fail to authenticate user\");\n            throw new BadCredentialsException(\"User is null after authentication process\");\n        }\n\n        // set user identity provider source\n        Map<String, String> details = new LinkedHashMap<>();\n        details.put(SOURCE, providerId);\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n        usernamePasswordAuthenticationToken.setDetails(details);\n        return usernamePasswordAuthenticationToken;\n    } catch (Exception ex) {\n        logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n        throw new BadCredentialsException(ex.getMessage(), ex);\n    }\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 114,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected final void successfulAuthentication(HttpServletRequest request,\n                                              HttpServletResponse response, FilterChain chain, Authentication authResult)\n        throws IOException, ServletException {\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                + authResult);\n    }\n\n    SecurityContextHolder.getContext().setAuthentication(authResult);\n\n    // Fire event\n    if (this.authenticationEventPublisher != null) {\n        authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n    }\n\n    // store jwt authentication cookie to secure management restricted operations\n    Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authResult);\n    response.addCookie(jwtAuthenticationCookie);\n\n    // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n    // for redirection after successful authentication\n    SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n    if (savedRequest != null && request.getSession(false) != null) {\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    chain.doFilter(request, response);\n}",
                "name": "successfulAuthentication",
                "modifiers": "@Override\n    protected final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "FilterChain",
                        "name": "chain"
                    },
                    {
                        "type": "Authentication",
                        "name": "authResult"
                    }
                ],
                "body": "{\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                + authResult);\n    }\n\n    SecurityContextHolder.getContext().setAuthentication(authResult);\n\n    // Fire event\n    if (this.authenticationEventPublisher != null) {\n        authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n    }\n\n    // store jwt authentication cookie to secure management restricted operations\n    Cookie jwtAuthenticationCookie = createJWTAuthenticationCookie(authResult);\n    response.addCookie(jwtAuthenticationCookie);\n\n    // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n    // for redirection after successful authentication\n    SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n    if (savedRequest != null && request.getSession(false) != null) {\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    chain.doFilter(request, response);\n}",
                "start_point": {
                    "row": 116,
                    "column": 4
                },
                "end_point": {
                    "row": 145,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {\n    super.setApplicationEventPublisher(eventPublisher);\n    this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n}",
                "name": "setApplicationEventPublisher",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ApplicationEventPublisher",
                        "name": "eventPublisher"
                    }
                ],
                "body": "{\n    super.setApplicationEventPublisher(eventPublisher);\n    this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n}",
                "start_point": {
                    "row": 147,
                    "column": 4
                },
                "end_point": {
                    "row": 151,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {\n    return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n}",
                "name": "requiresAuthentication",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n}",
                "start_point": {
                    "row": 153,
                    "column": 4
                },
                "end_point": {
                    "row": 156,
                    "column": 5
                }
            },
            {
                "definition": "private Cookie createJWTAuthenticationCookie(Authentication authentication) {\n    final User principal = (User) authentication.getPrincipal();\n    return jwtCookieGenerator.generate(principal);\n}",
                "name": "createJWTAuthenticationCookie",
                "modifiers": "private",
                "return_type": "Cookie",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    final User principal = (User) authentication.getPrincipal();\n    return jwtCookieGenerator.generate(principal);\n}",
                "start_point": {
                    "row": 158,
                    "column": 4
                },
                "end_point": {
                    "row": 161,
                    "column": 5
                }
            },
            {
                "definition": "private boolean authenticated() {\n    Authentication authentication = SecurityContextHolder.getContext()\n            .getAuthentication();\n    return authentication != null && authentication.isAuthenticated()\n            && !(authentication instanceof AnonymousAuthenticationToken);\n}",
                "name": "authenticated",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    Authentication authentication = SecurityContextHolder.getContext()\n            .getAuthentication();\n    return authentication != null && authentication.isAuthenticated()\n            && !(authentication instanceof AnonymousAuthenticationToken);\n}",
                "start_point": {
                    "row": 167,
                    "column": 4
                },
                "end_point": {
                    "row": 172,
                    "column": 5
                }
            },
            {
                "definition": "private String buildRedirectUri(HttpServletRequest request) {\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n    // append provider query param to avoid redirect mismatch exception\n    builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n    return builder.build(false).toUriString();\n}",
                "name": "buildRedirectUri",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    }
                ],
                "body": "{\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n    // append provider query param to avoid redirect mismatch exception\n    builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n    return builder.build(false).toUriString();\n}",
                "start_point": {
                    "row": 174,
                    "column": 4
                },
                "end_point": {
                    "row": 180,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/filter/OAuth2ClientAuthenticationFilter.java",
        "definition": "private static class NoopAuthenticationManager implements AuthenticationManager {\n\n    @Override\n    public Authentication authenticate(Authentication authentication)\n            throws AuthenticationException {\n        throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.admin.filter;",
        "tree_path": "OAuth2ClientAuthenticationFilter.NoopAuthenticationManager",
        "name": "NoopAuthenticationManager",
        "modifiers": "private static",
        "superclass": null,
        "super_interfaces": "implements AuthenticationManager",
        "body": "{\n\n    @Override\n    public Authentication authenticate(Authentication authentication)\n            throws AuthenticationException {\n        throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n    }\n\n}",
        "start_point": {
            "row": 183,
            "column": 4
        },
        "end_point": {
            "row": 191,
            "column": 5
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/filter/OAuth2ClientAuthenticationFilter.java",
        "methods": [
            {
                "definition": "@Override\npublic Authentication authenticate(Authentication authentication)\n        throws AuthenticationException {\n    throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n}",
                "name": "authenticate",
                "modifiers": "@Override\n        public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n}",
                "start_point": {
                    "row": 185,
                    "column": 8
                },
                "end_point": {
                    "row": 189,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/handler/CookieClearingLogoutHandler.java",
        "definition": "public class CookieClearingLogoutHandler implements LogoutHandler {\n\n    @Override\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n        cookie.setPath(\"/\");\n        cookie.setMaxAge(0);\n        response.addCookie(cookie);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.handler;",
        "tree_path": "CookieClearingLogoutHandler",
        "name": "CookieClearingLogoutHandler",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements LogoutHandler",
        "body": "{\n\n    @Override\n    public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n        Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n        cookie.setPath(\"/\");\n        cookie.setMaxAge(0);\n        response.addCookie(cookie);\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 38,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/ExtensionGrantManager.java",
        "methods": [
            {
                "definition": "@Override\npublic void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) {\n    Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n    cookie.setPath(\"/\");\n    cookie.setMaxAge(0);\n    response.addCookie(cookie);\n}",
                "name": "logout",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    Cookie cookie = new Cookie(HttpHeaders.AUTHORIZATION, null);\n    cookie.setPath(\"/\");\n    cookie.setMaxAge(0);\n    response.addCookie(cookie);\n}",
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 37,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/handler/CustomLogoutSuccessHandler.java",
        "definition": "public class CustomLogoutSuccessHandler extends SimpleUrlLogoutSuccessHandler {\n\n    private static final String LOGOUT_URL_PARAMETER = \"target_url\";\n\n    @Override\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n        if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n            setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n        }\n        return super.determineTargetUrl(request, response);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.handler;",
        "tree_path": "CustomLogoutSuccessHandler",
        "name": "CustomLogoutSuccessHandler",
        "modifiers": "public",
        "superclass": "extends SimpleUrlLogoutSuccessHandler",
        "super_interfaces": null,
        "body": "{\n\n    private static final String LOGOUT_URL_PARAMETER = \"target_url\";\n\n    @Override\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n        if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n            setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n        }\n        return super.determineTargetUrl(request, response);\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 38,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/handler/CustomLogoutSuccessHandler.java",
        "methods": [
            {
                "definition": "@Override\nprotected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n    String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n    if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n        setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n    }\n    return super.determineTargetUrl(request, response);\n}",
                "name": "determineTargetUrl",
                "modifiers": "@Override\n    protected",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n    if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n        setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n    }\n    return super.determineTargetUrl(request, response);\n}",
                "start_point": {
                    "row": 30,
                    "column": 4
                },
                "end_point": {
                    "row": 37,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/provider/security/EndUserAuthentication.java",
        "definition": "public class EndUserAuthentication implements Authentication {\n\n    private final Object principal;\n    private final Object credentials;\n    private Map<String, Object> additionalInformation;\n\n    public EndUserAuthentication(Object principal, Object credentials) {\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    @Override\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public Map<String, Object> getAdditionalInformation() {\n        return additionalInformation;\n    }\n\n    public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n\n    @Override\n    public String toString() {\n        return principal.toString();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.provider.security;",
        "tree_path": "EndUserAuthentication",
        "name": "EndUserAuthentication",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements Authentication",
        "body": "{\n\n    private final Object principal;\n    private final Object credentials;\n    private Map<String, Object> additionalInformation;\n\n    public EndUserAuthentication(Object principal, Object credentials) {\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    @Override\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public Map<String, Object> getAdditionalInformation() {\n        return additionalInformation;\n    }\n\n    public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n\n    @Override\n    public String toString() {\n        return principal.toString();\n    }\n}",
        "start_point": {
            "row": 25,
            "column": 0
        },
        "end_point": {
            "row": 59,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/security/EndUserAuthentication.java",
        "methods": [
            {
                "definition": "public EndUserAuthentication(Object principal, Object credentials) {\n    this.principal = principal;\n    this.credentials = credentials;\n}",
                "name": "EndUserAuthentication",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "Object",
                        "name": "principal"
                    },
                    {
                        "type": "Object",
                        "name": "credentials"
                    }
                ],
                "body": "{\n    this.principal = principal;\n    this.credentials = credentials;\n}",
                "constructor": true,
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 34,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Object getCredentials() {\n    return credentials;\n}",
                "name": "getCredentials",
                "modifiers": "@Override\n    public",
                "return_type": "Object",
                "parameters": [],
                "body": "{\n    return credentials;\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 39,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Object getPrincipal() {\n    return principal;\n}",
                "name": "getPrincipal",
                "modifiers": "@Override\n    public",
                "return_type": "Object",
                "parameters": [],
                "body": "{\n    return principal;\n}",
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Map<String, Object> getAdditionalInformation() {\n    return additionalInformation;\n}",
                "name": "getAdditionalInformation",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return additionalInformation;\n}",
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            },
            {
                "definition": "public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n    this.additionalInformation = additionalInformation;\n}",
                "name": "setAdditionalInformation",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, Object>",
                        "name": "additionalInformation"
                    }
                ],
                "body": "{\n    this.additionalInformation = additionalInformation;\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    return principal.toString();\n}",
                "name": "toString",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return principal.toString();\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/security/impl/IdentityProviderManagerImpl.java",
        "definition": "public class IdentityProviderManagerImpl implements IdentityProviderManager, InitializingBean {\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(IdentityProviderManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderPluginManager identityProviderPluginManager;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    private Map<String, AuthenticationProvider> providers = new HashMap<>();\n    private Map<String, IdentityProvider> identities = new HashMap<>();\n\n    @Override\n    public AuthenticationProvider get(String id) {\n        return providers.get(id);\n    }\n\n    public IdentityProvider getIdentityProvider(String id) {\n        return identities.get(id);\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n        // TODO async call\n        List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n        identityProviders.forEach(identityProvider -> {\n            logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n            AuthenticationProvider authenticationProvider =\n                    identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                            identityProvider.getMappers(), identityProvider.getRoleMapper());\n            providers.put(identityProvider.getId(), authenticationProvider);\n            identities.put(identityProvider.getId(), identityProvider);\n        });\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.security.impl;",
        "tree_path": "IdentityProviderManagerImpl",
        "name": "IdentityProviderManagerImpl",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements IdentityProviderManager, InitializingBean",
        "body": "{\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(IdentityProviderManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderPluginManager identityProviderPluginManager;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    private Map<String, AuthenticationProvider> providers = new HashMap<>();\n    private Map<String, IdentityProvider> identities = new HashMap<>();\n\n    @Override\n    public AuthenticationProvider get(String id) {\n        return providers.get(id);\n    }\n\n    public IdentityProvider getIdentityProvider(String id) {\n        return identities.get(id);\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n        // TODO async call\n        List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n        identityProviders.forEach(identityProvider -> {\n            logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n            AuthenticationProvider authenticationProvider =\n                    identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                            identityProvider.getMappers(), identityProvider.getRoleMapper());\n            providers.put(identityProvider.getId(), authenticationProvider);\n            identities.put(identityProvider.getId(), identityProvider);\n        });\n    }\n}",
        "start_point": {
            "row": 36,
            "column": 0
        },
        "end_point": {
            "row": 80,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/impl/IdentityProviderManagerImpl.java",
        "methods": [
            {
                "definition": "@Override\npublic AuthenticationProvider get(String id) {\n    return providers.get(id);\n}",
                "name": "get",
                "modifiers": "@Override\n    public",
                "return_type": "AuthenticationProvider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return providers.get(id);\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "public IdentityProvider getIdentityProvider(String id) {\n    return identities.get(id);\n}",
                "name": "getIdentityProvider",
                "modifiers": "public",
                "return_type": "IdentityProvider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return identities.get(id);\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 62,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void afterPropertiesSet() throws Exception {\n    logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n    // TODO async call\n    List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n    identityProviders.forEach(identityProvider -> {\n        logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n        AuthenticationProvider authenticationProvider =\n                identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                        identityProvider.getMappers(), identityProvider.getRoleMapper());\n        providers.put(identityProvider.getId(), authenticationProvider);\n        identities.put(identityProvider.getId(), identityProvider);\n    });\n}",
                "name": "afterPropertiesSet",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n    // TODO async call\n    List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n    identityProviders.forEach(identityProvider -> {\n        logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n        AuthenticationProvider authenticationProvider =\n                identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                        identityProvider.getMappers(), identityProvider.getRoleMapper());\n        providers.put(identityProvider.getId(), authenticationProvider);\n        identities.put(identityProvider.getId(), identityProvider);\n    });\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/security/listener/AuthenticationSuccessListener.java",
        "definition": "public class AuthenticationSuccessListener implements ApplicationListener<AuthenticationSuccessEvent> {\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    private static final String SOURCE = \"source\";\n    private static final String CLIENT_ID = \"admin\";\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public void onApplicationEvent(AuthenticationSuccessEvent event) {\n        final User principal = (User) event.getAuthentication().getPrincipal();\n        Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n        try {\n            // TODO async call\n            io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n            UpdateUser updateUser = new UpdateUser();\n            if (details != null) {\n                updateUser.setSource(details.get(SOURCE));\n                updateUser.setClient(CLIENT_ID);\n            }\n            updateUser.setLoggedAt(new Date());\n            updateUser.setLoginsCount(user.getLoginsCount() + 1);\n            updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.update(domain.getId(), user.getId(), updateUser);\n        } catch (UserNotFoundException unfe) {\n            final NewUser newUser = new NewUser();\n            newUser.setUsername(principal.getUsername());\n            if (details != null) {\n                newUser.setSource(details.get(SOURCE));\n                newUser.setClient(CLIENT_ID);\n            }\n            newUser.setLoggedAt(new Date());\n            newUser.setLoginsCount(1l);\n            newUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.create(domain.getId(), newUser);\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.security.listener;",
        "tree_path": "AuthenticationSuccessListener",
        "name": "AuthenticationSuccessListener",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements ApplicationListener<AuthenticationSuccessEvent>",
        "body": "{\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    private static final String SOURCE = \"source\";\n    private static final String CLIENT_ID = \"admin\";\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public void onApplicationEvent(AuthenticationSuccessEvent event) {\n        final User principal = (User) event.getAuthentication().getPrincipal();\n        Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n        try {\n            // TODO async call\n            io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n            UpdateUser updateUser = new UpdateUser();\n            if (details != null) {\n                updateUser.setSource(details.get(SOURCE));\n                updateUser.setClient(CLIENT_ID);\n            }\n            updateUser.setLoggedAt(new Date());\n            updateUser.setLoginsCount(user.getLoginsCount() + 1);\n            updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.update(domain.getId(), user.getId(), updateUser);\n        } catch (UserNotFoundException unfe) {\n            final NewUser newUser = new NewUser();\n            newUser.setUsername(principal.getUsername());\n            if (details != null) {\n                newUser.setSource(details.get(SOURCE));\n                newUser.setClient(CLIENT_ID);\n            }\n            newUser.setLoggedAt(new Date());\n            newUser.setLoginsCount(1l);\n            newUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.create(domain.getId(), newUser);\n        }\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 78,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/listener/AuthenticationSuccessListener.java",
        "methods": [
            {
                "definition": "@Override\npublic void onApplicationEvent(AuthenticationSuccessEvent event) {\n    final User principal = (User) event.getAuthentication().getPrincipal();\n    Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n    try {\n        // TODO async call\n        io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n        UpdateUser updateUser = new UpdateUser();\n        if (details != null) {\n            updateUser.setSource(details.get(SOURCE));\n            updateUser.setClient(CLIENT_ID);\n        }\n        updateUser.setLoggedAt(new Date());\n        updateUser.setLoginsCount(user.getLoginsCount() + 1);\n        updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.update(domain.getId(), user.getId(), updateUser);\n    } catch (UserNotFoundException unfe) {\n        final NewUser newUser = new NewUser();\n        newUser.setUsername(principal.getUsername());\n        if (details != null) {\n            newUser.setSource(details.get(SOURCE));\n            newUser.setClient(CLIENT_ID);\n        }\n        newUser.setLoggedAt(new Date());\n        newUser.setLoginsCount(1l);\n        newUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.create(domain.getId(), newUser);\n    }\n}",
                "name": "onApplicationEvent",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthenticationSuccessEvent",
                        "name": "event"
                    }
                ],
                "body": "{\n    final User principal = (User) event.getAuthentication().getPrincipal();\n    Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n    try {\n        // TODO async call\n        io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n        UpdateUser updateUser = new UpdateUser();\n        if (details != null) {\n            updateUser.setSource(details.get(SOURCE));\n            updateUser.setClient(CLIENT_ID);\n        }\n        updateUser.setLoggedAt(new Date());\n        updateUser.setLoginsCount(user.getLoginsCount() + 1);\n        updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.update(domain.getId(), user.getId(), updateUser);\n    } catch (UserNotFoundException unfe) {\n        final NewUser newUser = new NewUser();\n        newUser.setUsername(principal.getUsername());\n        if (details != null) {\n            newUser.setSource(details.get(SOURCE));\n            newUser.setClient(CLIENT_ID);\n        }\n        newUser.setLoggedAt(new Date());\n        newUser.setLoginsCount(1l);\n        newUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.create(domain.getId(), newUser);\n    }\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 77,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/security/web/XForwardedAwareRedirectStrategy.java",
        "definition": "public class XForwardedAwareRedirectStrategy implements RedirectStrategy {\n\n    private final Logger logger = LoggerFactory.getLogger(XForwardedAwareRedirectStrategy.class);\n\n    private boolean contextRelative;\n\n    @Override\n    public void sendRedirect(HttpServletRequest request, HttpServletResponse response, String url) throws IOException {\n        String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Redirecting to '{}'\", redirectUrl);\n        }\n\n        response.sendRedirect(redirectUrl);\n    }\n\n    private String calculateRedirectUrl(String contextPath, String url) {\n        if (!UrlUtils.isAbsoluteUrl(url)) {\n            if (contextRelative) {\n                return url;\n            } else {\n                return contextPath + url;\n            }\n        }\n\n        // Full URL, including http(s)://\n\n        if (!contextRelative) {\n            return url;\n        }\n\n        // Calculate the relative URL from the fully qualified URL, minus the last\n        // occurrence of the scheme and base context.\n        url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n        url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n        if (url.length() > 1 && url.charAt(0) == '/') {\n            url = url.substring(1);\n        }\n\n        return url;\n    }\n\n    /**\n     * If <tt>true</tt>, causes any redirection URLs to be calculated minus the protocol\n     * and context path (defaults to <tt>false</tt>).\n     */\n    public void setContextRelative(boolean useRelativeContext) {\n        this.contextRelative = useRelativeContext;\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.admin.security.web;",
        "tree_path": "XForwardedAwareRedirectStrategy",
        "name": "XForwardedAwareRedirectStrategy",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements RedirectStrategy",
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(XForwardedAwareRedirectStrategy.class);\n\n    private boolean contextRelative;\n\n    @Override\n    public void sendRedirect(HttpServletRequest request, HttpServletResponse response, String url) throws IOException {\n        String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Redirecting to '{}'\", redirectUrl);\n        }\n\n        response.sendRedirect(redirectUrl);\n    }\n\n    private String calculateRedirectUrl(String contextPath, String url) {\n        if (!UrlUtils.isAbsoluteUrl(url)) {\n            if (contextRelative) {\n                return url;\n            } else {\n                return contextPath + url;\n            }\n        }\n\n        // Full URL, including http(s)://\n\n        if (!contextRelative) {\n            return url;\n        }\n\n        // Calculate the relative URL from the fully qualified URL, minus the last\n        // occurrence of the scheme and base context.\n        url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n        url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n        if (url.length() > 1 && url.charAt(0) == '/') {\n            url = url.substring(1);\n        }\n\n        return url;\n    }\n\n    /**\n     * If <tt>true</tt>, causes any redirection URLs to be calculated minus the protocol\n     * and context path (defaults to <tt>false</tt>).\n     */\n    public void setContextRelative(boolean useRelativeContext) {\n        this.contextRelative = useRelativeContext;\n    }\n\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 105,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/web/XForwardedAwareRedirectStrategy.java",
        "methods": [
            {
                "definition": "@Override\npublic void sendRedirect(HttpServletRequest request, HttpServletResponse response, String url) throws IOException {\n    String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Redirecting to '{}'\", redirectUrl);\n    }\n\n    response.sendRedirect(redirectUrl);\n}",
                "name": "sendRedirect",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "String",
                        "name": "url"
                    }
                ],
                "body": "{\n    String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Redirecting to '{}'\", redirectUrl);\n    }\n\n    response.sendRedirect(redirectUrl);\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "private String calculateRedirectUrl(String contextPath, String url) {\n    if (!UrlUtils.isAbsoluteUrl(url)) {\n        if (contextRelative) {\n            return url;\n        } else {\n            return contextPath + url;\n        }\n    }\n\n    // Full URL, including http(s)://\n\n    if (!contextRelative) {\n        return url;\n    }\n\n    // Calculate the relative URL from the fully qualified URL, minus the last\n    // occurrence of the scheme and base context.\n    url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n    url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n    if (url.length() > 1 && url.charAt(0) == '/') {\n        url = url.substring(1);\n    }\n\n    return url;\n}",
                "name": "calculateRedirectUrl",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "contextPath"
                    },
                    {
                        "type": "String",
                        "name": "url"
                    }
                ],
                "body": "{\n    if (!UrlUtils.isAbsoluteUrl(url)) {\n        if (contextRelative) {\n            return url;\n        } else {\n            return contextPath + url;\n        }\n    }\n\n    // Full URL, including http(s)://\n\n    if (!contextRelative) {\n        return url;\n    }\n\n    // Calculate the relative URL from the fully qualified URL, minus the last\n    // occurrence of the scheme and base context.\n    url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n    url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n    if (url.length() > 1 && url.charAt(0) == '/') {\n        url = url.substring(1);\n    }\n\n    return url;\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "public void setContextRelative(boolean useRelativeContext) {\n    this.contextRelative = useRelativeContext;\n}",
                "name": "setContextRelative",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "useRelativeContext"
                    }
                ],
                "body": "{\n    this.contextRelative = useRelativeContext;\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 103,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/spring/AdminConfiguration.java",
        "definition": "@Configuration\n@Import({\n        WebMvcConfiguration.class,\n        SecurityConfiguration.class\n})\npublic class AdminConfiguration {\n\n}",
        "package": "package io.gravitee.am.management.handlers.admin.spring;",
        "tree_path": "AdminConfiguration",
        "name": "AdminConfiguration",
        "modifiers": "@Configuration\n@Import({\n        WebMvcConfiguration.class,\n        SecurityConfiguration.class\n})\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n}",
        "start_point": {
            "row": 31,
            "column": 0
        },
        "end_point": {
            "row": 38,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/CustomAuthorizationServerEndpointsConfiguration.java",
        "methods": []
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/view/DomainBasedTemplateResolver.java",
        "definition": "public class DomainBasedTemplateResolver extends StringTemplateResolver {\n\n    @Autowired\n    private Domain domain;\n\n    public DomainBasedTemplateResolver() {\n        setTemplateMode(\"HTML\");\n    }\n\n    @Override\n    protected ITemplateResource computeTemplateResource(IEngineConfiguration configuration, String ownerTemplate, String template, Map<String, Object> templateResolutionAttributes) {\n        return new StringTemplateResource(domain.getLoginForm().getContent());\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.view;",
        "tree_path": "DomainBasedTemplateResolver",
        "name": "DomainBasedTemplateResolver",
        "modifiers": "public",
        "superclass": "extends StringTemplateResolver",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private Domain domain;\n\n    public DomainBasedTemplateResolver() {\n        setTemplateMode(\"HTML\");\n    }\n\n    @Override\n    protected ITemplateResource computeTemplateResource(IEngineConfiguration configuration, String ownerTemplate, String template, Map<String, Object> templateResolutionAttributes) {\n        return new StringTemplateResource(domain.getLoginForm().getContent());\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 43,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/view/DomainBasedTemplateResolver.java",
        "methods": [
            {
                "definition": "public DomainBasedTemplateResolver() {\n    setTemplateMode(\"HTML\");\n}",
                "name": "DomainBasedTemplateResolver",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    setTemplateMode(\"HTML\");\n}",
                "constructor": true,
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 37,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected ITemplateResource computeTemplateResource(IEngineConfiguration configuration, String ownerTemplate, String template, Map<String, Object> templateResolutionAttributes) {\n    return new StringTemplateResource(domain.getLoginForm().getContent());\n}",
                "name": "computeTemplateResource",
                "modifiers": "@Override\n    protected",
                "return_type": "ITemplateResource",
                "parameters": [
                    {
                        "type": "IEngineConfiguration",
                        "name": "configuration"
                    },
                    {
                        "type": "String",
                        "name": "ownerTemplate"
                    },
                    {
                        "type": "String",
                        "name": "template"
                    },
                    {
                        "type": "Map<String, Object>",
                        "name": "templateResolutionAttributes"
                    }
                ],
                "body": "{\n    return new StringTemplateResource(domain.getLoginForm().getContent());\n}",
                "start_point": {
                    "row": 39,
                    "column": 4
                },
                "end_point": {
                    "row": 42,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/view/ThymeleafConfiguration.java",
        "definition": "@Configuration\npublic class ThymeleafConfiguration {\n\n    @Bean\n    public ThymeleafTemplateResolverFactory getTemplateResolver() {\n        return new ThymeleafTemplateResolverFactory();\n    }\n\n    @Bean\n    public TemplateEngine getTemplateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setEnableSpringELCompiler(true);\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    @Bean\n    public ViewResolver getViewResolver(TemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setTemplateEngine(templateEngine);\n        viewResolver.setCharacterEncoding(\"UTF-8\");\n        return viewResolver;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.view;",
        "tree_path": "ThymeleafConfiguration",
        "name": "ThymeleafConfiguration",
        "modifiers": "@Configuration\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @Bean\n    public ThymeleafTemplateResolverFactory getTemplateResolver() {\n        return new ThymeleafTemplateResolverFactory();\n    }\n\n    @Bean\n    public TemplateEngine getTemplateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setEnableSpringELCompiler(true);\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    @Bean\n    public ViewResolver getViewResolver(TemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setTemplateEngine(templateEngine);\n        viewResolver.setCharacterEncoding(\"UTF-8\");\n        return viewResolver;\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 52,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/view/ThymeleafConfiguration.java",
        "methods": [
            {
                "definition": "@Bean\npublic ThymeleafTemplateResolverFactory getTemplateResolver() {\n    return new ThymeleafTemplateResolverFactory();\n}",
                "name": "getTemplateResolver",
                "modifiers": "@Bean\n    public",
                "return_type": "ThymeleafTemplateResolverFactory",
                "parameters": [],
                "body": "{\n    return new ThymeleafTemplateResolverFactory();\n}",
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 35,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic TemplateEngine getTemplateEngine(ITemplateResolver templateResolver) {\n    SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n    templateEngine.setEnableSpringELCompiler(true);\n    templateEngine.setTemplateResolver(templateResolver);\n    return templateEngine;\n}",
                "name": "getTemplateEngine",
                "modifiers": "@Bean\n    public",
                "return_type": "TemplateEngine",
                "parameters": [
                    {
                        "type": "ITemplateResolver",
                        "name": "templateResolver"
                    }
                ],
                "body": "{\n    SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n    templateEngine.setEnableSpringELCompiler(true);\n    templateEngine.setTemplateResolver(templateResolver);\n    return templateEngine;\n}",
                "start_point": {
                    "row": 37,
                    "column": 4
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic ViewResolver getViewResolver(TemplateEngine templateEngine) {\n    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n    viewResolver.setTemplateEngine(templateEngine);\n    viewResolver.setCharacterEncoding(\"UTF-8\");\n    return viewResolver;\n}",
                "name": "getViewResolver",
                "modifiers": "@Bean\n    public",
                "return_type": "ViewResolver",
                "parameters": [
                    {
                        "type": "TemplateEngine",
                        "name": "templateEngine"
                    }
                ],
                "body": "{\n    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n    viewResolver.setTemplateEngine(templateEngine);\n    viewResolver.setCharacterEncoding(\"UTF-8\");\n    return viewResolver;\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/view/ThymeleafTemplateResolverFactory.java",
        "definition": "public class ThymeleafTemplateResolverFactory extends AbstractAutowiringFactoryBean<ITemplateResolver> {\n\n    private final Logger logger = LoggerFactory.getLogger(ThymeleafTemplateResolverFactory.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    protected ITemplateResolver doCreateInstance() throws Exception {\n        if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n            logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n            return defaultTemplateResolver();\n        }\n\n        ITemplateResolver resolver = overrideTemplateResolver();\n\n        return (resolver != null) ? resolver : defaultTemplateResolver();\n    }\n\n    private ITemplateResolver overrideTemplateResolver() {\n        return new DomainBasedTemplateResolver();\n\n    }\n    private ITemplateResolver defaultTemplateResolver() {\n        ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n        templateResolver.setPrefix(\"/views/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(\"HTML\");\n        return templateResolver;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return ITemplateResolver.class;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.admin.view;",
        "tree_path": "ThymeleafTemplateResolverFactory",
        "name": "ThymeleafTemplateResolverFactory",
        "modifiers": "public",
        "superclass": "extends AbstractAutowiringFactoryBean<ITemplateResolver>",
        "super_interfaces": null,
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(ThymeleafTemplateResolverFactory.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    protected ITemplateResolver doCreateInstance() throws Exception {\n        if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n            logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n            return defaultTemplateResolver();\n        }\n\n        ITemplateResolver resolver = overrideTemplateResolver();\n\n        return (resolver != null) ? resolver : defaultTemplateResolver();\n    }\n\n    private ITemplateResolver overrideTemplateResolver() {\n        return new DomainBasedTemplateResolver();\n\n    }\n    private ITemplateResolver defaultTemplateResolver() {\n        ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n        templateResolver.setPrefix(\"/views/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(\"HTML\");\n        return templateResolver;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return ITemplateResolver.class;\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 64,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/view/ThymeleafTemplateResolverFactory.java",
        "methods": [
            {
                "definition": "@Override\nprotected ITemplateResolver doCreateInstance() throws Exception {\n    if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n        logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n        return defaultTemplateResolver();\n    }\n\n    ITemplateResolver resolver = overrideTemplateResolver();\n\n    return (resolver != null) ? resolver : defaultTemplateResolver();\n}",
                "name": "doCreateInstance",
                "modifiers": "@Override\n    protected",
                "return_type": "ITemplateResolver",
                "parameters": [],
                "body": "{\n    if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n        logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n        return defaultTemplateResolver();\n    }\n\n    ITemplateResolver resolver = overrideTemplateResolver();\n\n    return (resolver != null) ? resolver : defaultTemplateResolver();\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "private ITemplateResolver overrideTemplateResolver() {\n    return new DomainBasedTemplateResolver();\n\n}",
                "name": "overrideTemplateResolver",
                "modifiers": "private",
                "return_type": "ITemplateResolver",
                "parameters": [],
                "body": "{\n    return new DomainBasedTemplateResolver();\n\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "private ITemplateResolver defaultTemplateResolver() {\n    ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n    templateResolver.setPrefix(\"/views/\");\n    templateResolver.setSuffix(\".html\");\n    templateResolver.setTemplateMode(\"HTML\");\n    return templateResolver;\n}",
                "name": "defaultTemplateResolver",
                "modifiers": "private",
                "return_type": "ITemplateResolver",
                "parameters": [],
                "body": "{\n    ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n    templateResolver.setPrefix(\"/views/\");\n    templateResolver.setSuffix(\".html\");\n    templateResolver.setTemplateMode(\"HTML\");\n    return templateResolver;\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Class<?> getObjectType() {\n    return ITemplateResolver.class;\n}",
                "name": "getObjectType",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return ITemplateResolver.class;\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 63,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/test/java/io/gravitee/am/management/handlers/oauth2/listener/AuthenticationSuccessListenerTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class AuthenticationSuccessListenerTest {\n\n    @InjectMocks\n    private AuthenticationSuccessListener listener = new AuthenticationSuccessListener();\n\n    @Mock\n    private AuthenticationSuccessEvent eventMock;\n\n    @Mock\n    private Authentication authenticationMock;\n\n    @Mock\n    private User userDetailsMock;\n\n    @Mock\n    private UserService userServiceMock;\n\n    @Mock\n    private Domain domainMock;\n\n    @Mock\n    private io.gravitee.am.model.User repositoryUserMock;\n\n    @Test\n    public void shouldCreateUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n        verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n    }\n\n    @Test\n    public void shouldUpdatedUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(Maybe.just(repositoryUserMock));\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n        verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.listener;",
        "tree_path": "AuthenticationSuccessListenerTest",
        "name": "AuthenticationSuccessListenerTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private AuthenticationSuccessListener listener = new AuthenticationSuccessListener();\n\n    @Mock\n    private AuthenticationSuccessEvent eventMock;\n\n    @Mock\n    private Authentication authenticationMock;\n\n    @Mock\n    private User userDetailsMock;\n\n    @Mock\n    private UserService userServiceMock;\n\n    @Mock\n    private Domain domainMock;\n\n    @Mock\n    private io.gravitee.am.model.User repositoryUserMock;\n\n    @Test\n    public void shouldCreateUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n        verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n    }\n\n    @Test\n    public void shouldUpdatedUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(Maybe.just(repositoryUserMock));\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n        verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n    }\n}",
        "start_point": {
            "row": 40,
            "column": 0
        },
        "end_point": {
            "row": 89,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/test/java/io/gravitee/am/management/handlers/oauth2/listener/AuthenticationSuccessListenerTest.java",
        "methods": [
            {
                "definition": "@Test\npublic void shouldCreateUser() {\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n    verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n}",
                "name": "shouldCreateUser",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n    verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdatedUser() {\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(Maybe.just(repositoryUserMock));\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n    verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n}",
                "name": "shouldUpdatedUser",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(Maybe.just(repositoryUserMock));\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n    verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            }
        ]
    }
]