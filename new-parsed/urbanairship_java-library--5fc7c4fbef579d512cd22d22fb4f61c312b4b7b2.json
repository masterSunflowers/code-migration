[
    {
        "rev_path": "src/main/java/com/urbanairship/api/push/parse/notification/actions/ActionsReader.java",
        "definition": "public final class ActionsReader implements JsonObjectReader<Actions> {\n\n    private static final ObjectMapper MAPPER = PushObjectMapper.getInstance();\n\n    private interface OpenActionReader {\n        Action.OpenAction readOpen(JsonParser parser, JsonNode definition) throws IOException;\n    }\n\n    private final static Map<String, OpenActionReader> OPEN_ACTIONS = ImmutableMap.<String, OpenActionReader>builder()\n            .put(\"url\", new OpenActionReader() {\n                @Override\n                public Action.OpenAction readOpen(JsonParser parser, JsonNode definition) throws IOException {\n                    return getExternalURLData(definition);\n                }\n            })\n            .put(\"landing_page\", new OpenActionReader() {\n                @Override\n                public Action.OpenAction readOpen(JsonParser parser, JsonNode definition) {\n                    return getLandingPageData(definition);\n                }\n\n            })\n            .put(\"deep_link\", new OpenActionReader() {\n                @Override\n                public Action.OpenAction readOpen(JsonParser parser, JsonNode definition) throws IOException {\n                    JsonNode content = definition.path(\"content\");\n                    if (content.isMissingNode() || !content.isTextual()) {\n                        throw new APIParsingException(\"The content attribute must be present and it must be a string.\");\n                    }\n\n                    return new DeepLinkAction(content.getTextValue());\n                }\n            })\n            .build();\n    private Actions.Builder builder = new Actions.Builder();\n\n\n    private static JsonNode getContentEncoding(JsonNode content) {\n        JsonNode c1 = content.path(\"content-encoding\");\n        JsonNode c2 = content.path(\"content_encoding\");\n        if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n            throw new APIParsingException(\"A request cannot specify both content-encoding and content_encoding.\");\n        }\n\n        return c1.isMissingNode() ? c2 : c1;\n    }\n\n    private static JsonNode getContentType(JsonNode content) {\n        JsonNode c1 = content.path(\"content-type\");\n        JsonNode c2 = content.path(\"content_type\");\n        if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n            throw new APIParsingException(\"A request cannot specify both content-type and content_type.\");\n        }\n\n        return c1.isMissingNode() ? c2 : c1;\n    }\n\n    private static Action.OpenAction getLandingPageData(JsonNode definition) {\n        JsonNode content = definition.path(\"content\");\n        if (content.isMissingNode()) {\n            throw new APIParsingException(\"The content attribute must be present.\");\n        }\n\n        JsonNode body = content.path(\"body\");\n        JsonNode contentType = getContentType(content);\n        JsonNode contentEncoding = getContentEncoding(content);\n\n        if (body.isMissingNode() || !body.isTextual()) {\n            throw new APIParsingException(\"The content object must have a body attribute, and it must be a string value.\");\n        }\n\n        if (contentType.isMissingNode() || !contentType.isTextual()) {\n            throw new APIParsingException(\"The content object must have a content type attribute, and it must be a string value..\");\n        }\n\n        {\n            String typeSubtype = contentType.getTextValue().split(\";\")[0].trim().toLowerCase();\n            if (!LandingPageContent.ALLOWED_CONTENT_TYPES.contains(typeSubtype)) {\n                throw new APIParsingException(\"The content type '\" + typeSubtype + \"' is not allowed.\");\n            }\n        }\n\n        if (!contentEncoding.isMissingNode()) {\n            if (!contentEncoding.isTextual() || (!contentEncoding.getTextValue().equals(\"utf-8\") &&\n                    !contentEncoding.getTextValue().equals(\"base64\"))) {\n                throw new APIParsingException(\"The content encoding attribute must be either 'utf-8' or 'base64'\");\n\n            } else if (!contentEncoding.isMissingNode() && contentEncoding.getTextValue().equals(\"base64\") && !Base64.isBase64(body.getTextValue())) {\n                throw new APIParsingException(\"Content contains invalid data that is not valid for base64 encoding.\");\n            }\n        }\n\n        Optional<LandingPageContent.Encoding> optEncoding = contentEncoding.isMissingNode() ?\n                Optional.<LandingPageContent.Encoding>absent() :\n                Optional.of(contentEncoding.getTextValue().equals(\"base64\") ?\n                        LandingPageContent.Encoding.Base64 :\n                        LandingPageContent.Encoding.UTF8);\n\n        String bodyString = body.getTextValue();\n        if (bodyString != null) {\n            int max_size = optEncoding.isPresent() && optEncoding.get() == LandingPageContent.Encoding.Base64 ?\n                    LandingPageContent.MAX_BODY_SIZE_BASE64 : LandingPageContent.MAX_BODY_SIZE_BYTES;\n            if (bodyString.length() > max_size) {\n                throw new APIParsingException(\"Maximum upload size exceeded.\");\n            }\n        }\n\n        return new OpenLandingPageWithContentAction(LandingPageContent.newBuilder().setContentType(contentType.getTextValue())\n                .setBody(bodyString)\n                .setEncoding(optEncoding)\n                .build());\n    }\n\n    private static Action.OpenAction getExternalURLData(JsonNode def) {\n        JsonNode content = def.path(\"content\");\n        if (content.isMissingNode() || !content.isTextual()) {\n            throw new APIParsingException(\"The content attribute for an url action must be present and it must be a string.\");\n        }\n\n        URI url;\n        try {\n            url = new URI(content.getTextValue());\n        } catch (URISyntaxException e) {\n            throw new APIParsingException(\"The content attribute for a url action must be a URL.\");\n        }\n\n        if (!url.isAbsolute() || (!url.getScheme().equals(\"http\") && !url.getScheme().equals(\"https\"))) {\n            throw new APIParsingException(\"The url for a url action must use either 'http' or 'https'\");\n        }\n\n        return new OpenExternalURLAction(url);\n    }\n\n    private TagActionData getTagActionData(JsonParser parser, ActionType tagActionType) throws IOException {\n        TagActionData data = MAPPER.readValue(parser, TagActionData.class);\n        if (data == null) {\n            throw new APIParsingException(\"The value for '\" + ActionNameRegistry.INSTANCE.getFieldName(tagActionType) +\n                    \"' cannot be 'null' or the empty string.\");\n        }\n\n        return data;\n    }\n\n    public void readAddTags(JsonParser parser) throws IOException {\n        builder.addTags(new AddTagAction(getTagActionData(parser, ActionType.ADD_TAG)));\n    }\n\n    public void readAppDefined(JsonParser parser) throws IOException {\n        JsonNode jsonNode;\n        try {\n            jsonNode = parser.readValueAsTree();\n        } catch (JsonParseException ex) {\n            throw new APIParsingException(\"Invalid JSON found while parsing app_defined\");\n        }\n\n        if (!jsonNode.isObject()) {\n            throw new APIParsingException(\"The value for app_defined actions MUST be an object.\");\n        }\n\n        ObjectNode appDefinedObject = (ObjectNode) jsonNode;\n        if (!appDefinedObject.getFieldNames().hasNext()) {\n            throw new APIParsingException(\"The app_defined actions object MUST not be empty.\");\n        }\n\n        builder.addAppDefined(new AppDefinedAction(appDefinedObject));\n    }\n\n    public void readOpen(JsonParser parser) throws IOException {\n        JsonNode definition = parser.readValueAsTree();\n        JsonNode type = definition.path(\"type\");\n\n        if (type.isMissingNode() || !type.isTextual()) {\n            throw new APIParsingException(\"The open object MUST have a 'type' attribute.\");\n        }\n\n        OpenActionReader reader = OPEN_ACTIONS.get(type.getTextValue());\n        if (reader == null) {\n            throw new APIParsingException(\"The type attribute '\" + type.getTextValue() +\n                    \"' was not recognized.\");\n        }\n\n        Action.OpenAction action = reader.readOpen(parser, definition);\n        if (action == null) {\n            throw new APIParsingException(\"The open action cannot be null.\");\n        }\n\n        builder.setOpen(action);\n    }\n\n    public void readRemoveTags(JsonParser parser) throws IOException {\n        builder.removeTags(new RemoveTagAction(getTagActionData(parser, ActionType.REMOVE_TAG)));\n    }\n\n    public void readShare(JsonParser parser) throws IOException {\n        ShareAction action = parser.readValueAs(ShareAction.class);\n        if (StringUtils.isEmpty(action.getValue())) {\n            throw new APIParsingException(\"The share text may not be an empty string.\");\n        }\n        builder.setShare(action);\n    }\n\n    @Override\n    public Actions validateAndBuild() throws IOException {\n        return builder.build();\n    }\n}",
        "package": "package com.urbanairship.api.push.parse.notification.actions;",
        "tree_path": "ActionsReader",
        "name": "ActionsReader",
        "modifiers": "public final",
        "superclass": null,
        "super_interfaces": "implements JsonObjectReader<Actions>",
        "body": "{\n\n    private static final ObjectMapper MAPPER = PushObjectMapper.getInstance();\n\n    private interface OpenActionReader {\n        Action.OpenAction readOpen(JsonParser parser, JsonNode definition) throws IOException;\n    }\n\n    private final static Map<String, OpenActionReader> OPEN_ACTIONS = ImmutableMap.<String, OpenActionReader>builder()\n            .put(\"url\", new OpenActionReader() {\n                @Override\n                public Action.OpenAction readOpen(JsonParser parser, JsonNode definition) throws IOException {\n                    return getExternalURLData(definition);\n                }\n            })\n            .put(\"landing_page\", new OpenActionReader() {\n                @Override\n                public Action.OpenAction readOpen(JsonParser parser, JsonNode definition) {\n                    return getLandingPageData(definition);\n                }\n\n            })\n            .put(\"deep_link\", new OpenActionReader() {\n                @Override\n                public Action.OpenAction readOpen(JsonParser parser, JsonNode definition) throws IOException {\n                    JsonNode content = definition.path(\"content\");\n                    if (content.isMissingNode() || !content.isTextual()) {\n                        throw new APIParsingException(\"The content attribute must be present and it must be a string.\");\n                    }\n\n                    return new DeepLinkAction(content.getTextValue());\n                }\n            })\n            .build();\n    private Actions.Builder builder = new Actions.Builder();\n\n\n    private static JsonNode getContentEncoding(JsonNode content) {\n        JsonNode c1 = content.path(\"content-encoding\");\n        JsonNode c2 = content.path(\"content_encoding\");\n        if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n            throw new APIParsingException(\"A request cannot specify both content-encoding and content_encoding.\");\n        }\n\n        return c1.isMissingNode() ? c2 : c1;\n    }\n\n    private static JsonNode getContentType(JsonNode content) {\n        JsonNode c1 = content.path(\"content-type\");\n        JsonNode c2 = content.path(\"content_type\");\n        if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n            throw new APIParsingException(\"A request cannot specify both content-type and content_type.\");\n        }\n\n        return c1.isMissingNode() ? c2 : c1;\n    }\n\n    private static Action.OpenAction getLandingPageData(JsonNode definition) {\n        JsonNode content = definition.path(\"content\");\n        if (content.isMissingNode()) {\n            throw new APIParsingException(\"The content attribute must be present.\");\n        }\n\n        JsonNode body = content.path(\"body\");\n        JsonNode contentType = getContentType(content);\n        JsonNode contentEncoding = getContentEncoding(content);\n\n        if (body.isMissingNode() || !body.isTextual()) {\n            throw new APIParsingException(\"The content object must have a body attribute, and it must be a string value.\");\n        }\n\n        if (contentType.isMissingNode() || !contentType.isTextual()) {\n            throw new APIParsingException(\"The content object must have a content type attribute, and it must be a string value..\");\n        }\n\n        {\n            String typeSubtype = contentType.getTextValue().split(\";\")[0].trim().toLowerCase();\n            if (!LandingPageContent.ALLOWED_CONTENT_TYPES.contains(typeSubtype)) {\n                throw new APIParsingException(\"The content type '\" + typeSubtype + \"' is not allowed.\");\n            }\n        }\n\n        if (!contentEncoding.isMissingNode()) {\n            if (!contentEncoding.isTextual() || (!contentEncoding.getTextValue().equals(\"utf-8\") &&\n                    !contentEncoding.getTextValue().equals(\"base64\"))) {\n                throw new APIParsingException(\"The content encoding attribute must be either 'utf-8' or 'base64'\");\n\n            } else if (!contentEncoding.isMissingNode() && contentEncoding.getTextValue().equals(\"base64\") && !Base64.isBase64(body.getTextValue())) {\n                throw new APIParsingException(\"Content contains invalid data that is not valid for base64 encoding.\");\n            }\n        }\n\n        Optional<LandingPageContent.Encoding> optEncoding = contentEncoding.isMissingNode() ?\n                Optional.<LandingPageContent.Encoding>absent() :\n                Optional.of(contentEncoding.getTextValue().equals(\"base64\") ?\n                        LandingPageContent.Encoding.Base64 :\n                        LandingPageContent.Encoding.UTF8);\n\n        String bodyString = body.getTextValue();\n        if (bodyString != null) {\n            int max_size = optEncoding.isPresent() && optEncoding.get() == LandingPageContent.Encoding.Base64 ?\n                    LandingPageContent.MAX_BODY_SIZE_BASE64 : LandingPageContent.MAX_BODY_SIZE_BYTES;\n            if (bodyString.length() > max_size) {\n                throw new APIParsingException(\"Maximum upload size exceeded.\");\n            }\n        }\n\n        return new OpenLandingPageWithContentAction(LandingPageContent.newBuilder().setContentType(contentType.getTextValue())\n                .setBody(bodyString)\n                .setEncoding(optEncoding)\n                .build());\n    }\n\n    private static Action.OpenAction getExternalURLData(JsonNode def) {\n        JsonNode content = def.path(\"content\");\n        if (content.isMissingNode() || !content.isTextual()) {\n            throw new APIParsingException(\"The content attribute for an url action must be present and it must be a string.\");\n        }\n\n        URI url;\n        try {\n            url = new URI(content.getTextValue());\n        } catch (URISyntaxException e) {\n            throw new APIParsingException(\"The content attribute for a url action must be a URL.\");\n        }\n\n        if (!url.isAbsolute() || (!url.getScheme().equals(\"http\") && !url.getScheme().equals(\"https\"))) {\n            throw new APIParsingException(\"The url for a url action must use either 'http' or 'https'\");\n        }\n\n        return new OpenExternalURLAction(url);\n    }\n\n    private TagActionData getTagActionData(JsonParser parser, ActionType tagActionType) throws IOException {\n        TagActionData data = MAPPER.readValue(parser, TagActionData.class);\n        if (data == null) {\n            throw new APIParsingException(\"The value for '\" + ActionNameRegistry.INSTANCE.getFieldName(tagActionType) +\n                    \"' cannot be 'null' or the empty string.\");\n        }\n\n        return data;\n    }\n\n    public void readAddTags(JsonParser parser) throws IOException {\n        builder.addTags(new AddTagAction(getTagActionData(parser, ActionType.ADD_TAG)));\n    }\n\n    public void readAppDefined(JsonParser parser) throws IOException {\n        JsonNode jsonNode;\n        try {\n            jsonNode = parser.readValueAsTree();\n        } catch (JsonParseException ex) {\n            throw new APIParsingException(\"Invalid JSON found while parsing app_defined\");\n        }\n\n        if (!jsonNode.isObject()) {\n            throw new APIParsingException(\"The value for app_defined actions MUST be an object.\");\n        }\n\n        ObjectNode appDefinedObject = (ObjectNode) jsonNode;\n        if (!appDefinedObject.getFieldNames().hasNext()) {\n            throw new APIParsingException(\"The app_defined actions object MUST not be empty.\");\n        }\n\n        builder.addAppDefined(new AppDefinedAction(appDefinedObject));\n    }\n\n    public void readOpen(JsonParser parser) throws IOException {\n        JsonNode definition = parser.readValueAsTree();\n        JsonNode type = definition.path(\"type\");\n\n        if (type.isMissingNode() || !type.isTextual()) {\n            throw new APIParsingException(\"The open object MUST have a 'type' attribute.\");\n        }\n\n        OpenActionReader reader = OPEN_ACTIONS.get(type.getTextValue());\n        if (reader == null) {\n            throw new APIParsingException(\"The type attribute '\" + type.getTextValue() +\n                    \"' was not recognized.\");\n        }\n\n        Action.OpenAction action = reader.readOpen(parser, definition);\n        if (action == null) {\n            throw new APIParsingException(\"The open action cannot be null.\");\n        }\n\n        builder.setOpen(action);\n    }\n\n    public void readRemoveTags(JsonParser parser) throws IOException {\n        builder.removeTags(new RemoveTagAction(getTagActionData(parser, ActionType.REMOVE_TAG)));\n    }\n\n    public void readShare(JsonParser parser) throws IOException {\n        ShareAction action = parser.readValueAs(ShareAction.class);\n        if (StringUtils.isEmpty(action.getValue())) {\n            throw new APIParsingException(\"The share text may not be an empty string.\");\n        }\n        builder.setShare(action);\n    }\n\n    @Override\n    public Actions validateAndBuild() throws IOException {\n        return builder.build();\n    }\n}",
        "start_point": {
            "row": 37,
            "column": 0
        },
        "end_point": {
            "row": 242,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "private static JsonNode getContentEncoding(JsonNode content) {\n    JsonNode c1 = content.path(\"content-encoding\");\n    JsonNode c2 = content.path(\"content_encoding\");\n    if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n        throw new APIParsingException(\"A request cannot specify both content-encoding and content_encoding.\");\n    }\n\n    return c1.isMissingNode() ? c2 : c1;\n}",
                "name": "getContentEncoding",
                "modifiers": "private static",
                "return_type": "JsonNode",
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "content"
                    }
                ],
                "body": "{\n    JsonNode c1 = content.path(\"content-encoding\");\n    JsonNode c2 = content.path(\"content_encoding\");\n    if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n        throw new APIParsingException(\"A request cannot specify both content-encoding and content_encoding.\");\n    }\n\n    return c1.isMissingNode() ? c2 : c1;\n}",
                "start_point": {
                    "row": 74,
                    "column": 4
                },
                "end_point": {
                    "row": 82,
                    "column": 5
                }
            },
            {
                "definition": "private static JsonNode getContentType(JsonNode content) {\n    JsonNode c1 = content.path(\"content-type\");\n    JsonNode c2 = content.path(\"content_type\");\n    if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n        throw new APIParsingException(\"A request cannot specify both content-type and content_type.\");\n    }\n\n    return c1.isMissingNode() ? c2 : c1;\n}",
                "name": "getContentType",
                "modifiers": "private static",
                "return_type": "JsonNode",
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "content"
                    }
                ],
                "body": "{\n    JsonNode c1 = content.path(\"content-type\");\n    JsonNode c2 = content.path(\"content_type\");\n    if(! c1.isMissingNode() && ! c2.isMissingNode()) {\n        throw new APIParsingException(\"A request cannot specify both content-type and content_type.\");\n    }\n\n    return c1.isMissingNode() ? c2 : c1;\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 92,
                    "column": 5
                }
            },
            {
                "definition": "private static Action.OpenAction getLandingPageData(JsonNode definition) {\n    JsonNode content = definition.path(\"content\");\n    if (content.isMissingNode()) {\n        throw new APIParsingException(\"The content attribute must be present.\");\n    }\n\n    JsonNode body = content.path(\"body\");\n    JsonNode contentType = getContentType(content);\n    JsonNode contentEncoding = getContentEncoding(content);\n\n    if (body.isMissingNode() || !body.isTextual()) {\n        throw new APIParsingException(\"The content object must have a body attribute, and it must be a string value.\");\n    }\n\n    if (contentType.isMissingNode() || !contentType.isTextual()) {\n        throw new APIParsingException(\"The content object must have a content type attribute, and it must be a string value..\");\n    }\n\n    {\n        String typeSubtype = contentType.getTextValue().split(\";\")[0].trim().toLowerCase();\n        if (!LandingPageContent.ALLOWED_CONTENT_TYPES.contains(typeSubtype)) {\n            throw new APIParsingException(\"The content type '\" + typeSubtype + \"' is not allowed.\");\n        }\n    }\n\n    if (!contentEncoding.isMissingNode()) {\n        if (!contentEncoding.isTextual() || (!contentEncoding.getTextValue().equals(\"utf-8\") &&\n                !contentEncoding.getTextValue().equals(\"base64\"))) {\n            throw new APIParsingException(\"The content encoding attribute must be either 'utf-8' or 'base64'\");\n\n        } else if (!contentEncoding.isMissingNode() && contentEncoding.getTextValue().equals(\"base64\") && !Base64.isBase64(body.getTextValue())) {\n            throw new APIParsingException(\"Content contains invalid data that is not valid for base64 encoding.\");\n        }\n    }\n\n    Optional<LandingPageContent.Encoding> optEncoding = contentEncoding.isMissingNode() ?\n            Optional.<LandingPageContent.Encoding>absent() :\n            Optional.of(contentEncoding.getTextValue().equals(\"base64\") ?\n                    LandingPageContent.Encoding.Base64 :\n                    LandingPageContent.Encoding.UTF8);\n\n    String bodyString = body.getTextValue();\n    if (bodyString != null) {\n        int max_size = optEncoding.isPresent() && optEncoding.get() == LandingPageContent.Encoding.Base64 ?\n                LandingPageContent.MAX_BODY_SIZE_BASE64 : LandingPageContent.MAX_BODY_SIZE_BYTES;\n        if (bodyString.length() > max_size) {\n            throw new APIParsingException(\"Maximum upload size exceeded.\");\n        }\n    }\n\n    return new OpenLandingPageWithContentAction(LandingPageContent.newBuilder().setContentType(contentType.getTextValue())\n            .setBody(bodyString)\n            .setEncoding(optEncoding)\n            .build());\n}",
                "name": "getLandingPageData",
                "modifiers": "private static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "definition"
                    }
                ],
                "body": "{\n    JsonNode content = definition.path(\"content\");\n    if (content.isMissingNode()) {\n        throw new APIParsingException(\"The content attribute must be present.\");\n    }\n\n    JsonNode body = content.path(\"body\");\n    JsonNode contentType = getContentType(content);\n    JsonNode contentEncoding = getContentEncoding(content);\n\n    if (body.isMissingNode() || !body.isTextual()) {\n        throw new APIParsingException(\"The content object must have a body attribute, and it must be a string value.\");\n    }\n\n    if (contentType.isMissingNode() || !contentType.isTextual()) {\n        throw new APIParsingException(\"The content object must have a content type attribute, and it must be a string value..\");\n    }\n\n    {\n        String typeSubtype = contentType.getTextValue().split(\";\")[0].trim().toLowerCase();\n        if (!LandingPageContent.ALLOWED_CONTENT_TYPES.contains(typeSubtype)) {\n            throw new APIParsingException(\"The content type '\" + typeSubtype + \"' is not allowed.\");\n        }\n    }\n\n    if (!contentEncoding.isMissingNode()) {\n        if (!contentEncoding.isTextual() || (!contentEncoding.getTextValue().equals(\"utf-8\") &&\n                !contentEncoding.getTextValue().equals(\"base64\"))) {\n            throw new APIParsingException(\"The content encoding attribute must be either 'utf-8' or 'base64'\");\n\n        } else if (!contentEncoding.isMissingNode() && contentEncoding.getTextValue().equals(\"base64\") && !Base64.isBase64(body.getTextValue())) {\n            throw new APIParsingException(\"Content contains invalid data that is not valid for base64 encoding.\");\n        }\n    }\n\n    Optional<LandingPageContent.Encoding> optEncoding = contentEncoding.isMissingNode() ?\n            Optional.<LandingPageContent.Encoding>absent() :\n            Optional.of(contentEncoding.getTextValue().equals(\"base64\") ?\n                    LandingPageContent.Encoding.Base64 :\n                    LandingPageContent.Encoding.UTF8);\n\n    String bodyString = body.getTextValue();\n    if (bodyString != null) {\n        int max_size = optEncoding.isPresent() && optEncoding.get() == LandingPageContent.Encoding.Base64 ?\n                LandingPageContent.MAX_BODY_SIZE_BASE64 : LandingPageContent.MAX_BODY_SIZE_BYTES;\n        if (bodyString.length() > max_size) {\n            throw new APIParsingException(\"Maximum upload size exceeded.\");\n        }\n    }\n\n    return new OpenLandingPageWithContentAction(LandingPageContent.newBuilder().setContentType(contentType.getTextValue())\n            .setBody(bodyString)\n            .setEncoding(optEncoding)\n            .build());\n}",
                "start_point": {
                    "row": 94,
                    "column": 4
                },
                "end_point": {
                    "row": 148,
                    "column": 5
                }
            },
            {
                "definition": "private static Action.OpenAction getExternalURLData(JsonNode def) {\n    JsonNode content = def.path(\"content\");\n    if (content.isMissingNode() || !content.isTextual()) {\n        throw new APIParsingException(\"The content attribute for an url action must be present and it must be a string.\");\n    }\n\n    URI url;\n    try {\n        url = new URI(content.getTextValue());\n    } catch (URISyntaxException e) {\n        throw new APIParsingException(\"The content attribute for a url action must be a URL.\");\n    }\n\n    if (!url.isAbsolute() || (!url.getScheme().equals(\"http\") && !url.getScheme().equals(\"https\"))) {\n        throw new APIParsingException(\"The url for a url action must use either 'http' or 'https'\");\n    }\n\n    return new OpenExternalURLAction(url);\n}",
                "name": "getExternalURLData",
                "modifiers": "private static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "def"
                    }
                ],
                "body": "{\n    JsonNode content = def.path(\"content\");\n    if (content.isMissingNode() || !content.isTextual()) {\n        throw new APIParsingException(\"The content attribute for an url action must be present and it must be a string.\");\n    }\n\n    URI url;\n    try {\n        url = new URI(content.getTextValue());\n    } catch (URISyntaxException e) {\n        throw new APIParsingException(\"The content attribute for a url action must be a URL.\");\n    }\n\n    if (!url.isAbsolute() || (!url.getScheme().equals(\"http\") && !url.getScheme().equals(\"https\"))) {\n        throw new APIParsingException(\"The url for a url action must use either 'http' or 'https'\");\n    }\n\n    return new OpenExternalURLAction(url);\n}",
                "start_point": {
                    "row": 150,
                    "column": 4
                },
                "end_point": {
                    "row": 168,
                    "column": 5
                }
            },
            {
                "definition": "private TagActionData getTagActionData(JsonParser parser, ActionType tagActionType) throws IOException {\n    TagActionData data = MAPPER.readValue(parser, TagActionData.class);\n    if (data == null) {\n        throw new APIParsingException(\"The value for '\" + ActionNameRegistry.INSTANCE.getFieldName(tagActionType) +\n                \"' cannot be 'null' or the empty string.\");\n    }\n\n    return data;\n}",
                "name": "getTagActionData",
                "modifiers": "private",
                "return_type": "TagActionData",
                "parameters": [
                    {
                        "type": "JsonParser",
                        "name": "parser"
                    },
                    {
                        "type": "ActionType",
                        "name": "tagActionType"
                    }
                ],
                "body": "{\n    TagActionData data = MAPPER.readValue(parser, TagActionData.class);\n    if (data == null) {\n        throw new APIParsingException(\"The value for '\" + ActionNameRegistry.INSTANCE.getFieldName(tagActionType) +\n                \"' cannot be 'null' or the empty string.\");\n    }\n\n    return data;\n}",
                "start_point": {
                    "row": 170,
                    "column": 4
                },
                "end_point": {
                    "row": 178,
                    "column": 5
                }
            },
            {
                "definition": "public void readAddTags(JsonParser parser) throws IOException {\n    builder.addTags(new AddTagAction(getTagActionData(parser, ActionType.ADD_TAG)));\n}",
                "name": "readAddTags",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "JsonParser",
                        "name": "parser"
                    }
                ],
                "body": "{\n    builder.addTags(new AddTagAction(getTagActionData(parser, ActionType.ADD_TAG)));\n}",
                "start_point": {
                    "row": 180,
                    "column": 4
                },
                "end_point": {
                    "row": 182,
                    "column": 5
                }
            },
            {
                "definition": "public void readAppDefined(JsonParser parser) throws IOException {\n    JsonNode jsonNode;\n    try {\n        jsonNode = parser.readValueAsTree();\n    } catch (JsonParseException ex) {\n        throw new APIParsingException(\"Invalid JSON found while parsing app_defined\");\n    }\n\n    if (!jsonNode.isObject()) {\n        throw new APIParsingException(\"The value for app_defined actions MUST be an object.\");\n    }\n\n    ObjectNode appDefinedObject = (ObjectNode) jsonNode;\n    if (!appDefinedObject.getFieldNames().hasNext()) {\n        throw new APIParsingException(\"The app_defined actions object MUST not be empty.\");\n    }\n\n    builder.addAppDefined(new AppDefinedAction(appDefinedObject));\n}",
                "name": "readAppDefined",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "JsonParser",
                        "name": "parser"
                    }
                ],
                "body": "{\n    JsonNode jsonNode;\n    try {\n        jsonNode = parser.readValueAsTree();\n    } catch (JsonParseException ex) {\n        throw new APIParsingException(\"Invalid JSON found while parsing app_defined\");\n    }\n\n    if (!jsonNode.isObject()) {\n        throw new APIParsingException(\"The value for app_defined actions MUST be an object.\");\n    }\n\n    ObjectNode appDefinedObject = (ObjectNode) jsonNode;\n    if (!appDefinedObject.getFieldNames().hasNext()) {\n        throw new APIParsingException(\"The app_defined actions object MUST not be empty.\");\n    }\n\n    builder.addAppDefined(new AppDefinedAction(appDefinedObject));\n}",
                "start_point": {
                    "row": 184,
                    "column": 4
                },
                "end_point": {
                    "row": 202,
                    "column": 5
                }
            },
            {
                "definition": "public void readOpen(JsonParser parser) throws IOException {\n    JsonNode definition = parser.readValueAsTree();\n    JsonNode type = definition.path(\"type\");\n\n    if (type.isMissingNode() || !type.isTextual()) {\n        throw new APIParsingException(\"The open object MUST have a 'type' attribute.\");\n    }\n\n    OpenActionReader reader = OPEN_ACTIONS.get(type.getTextValue());\n    if (reader == null) {\n        throw new APIParsingException(\"The type attribute '\" + type.getTextValue() +\n                \"' was not recognized.\");\n    }\n\n    Action.OpenAction action = reader.readOpen(parser, definition);\n    if (action == null) {\n        throw new APIParsingException(\"The open action cannot be null.\");\n    }\n\n    builder.setOpen(action);\n}",
                "name": "readOpen",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "JsonParser",
                        "name": "parser"
                    }
                ],
                "body": "{\n    JsonNode definition = parser.readValueAsTree();\n    JsonNode type = definition.path(\"type\");\n\n    if (type.isMissingNode() || !type.isTextual()) {\n        throw new APIParsingException(\"The open object MUST have a 'type' attribute.\");\n    }\n\n    OpenActionReader reader = OPEN_ACTIONS.get(type.getTextValue());\n    if (reader == null) {\n        throw new APIParsingException(\"The type attribute '\" + type.getTextValue() +\n                \"' was not recognized.\");\n    }\n\n    Action.OpenAction action = reader.readOpen(parser, definition);\n    if (action == null) {\n        throw new APIParsingException(\"The open action cannot be null.\");\n    }\n\n    builder.setOpen(action);\n}",
                "start_point": {
                    "row": 204,
                    "column": 4
                },
                "end_point": {
                    "row": 224,
                    "column": 5
                }
            },
            {
                "definition": "public void readRemoveTags(JsonParser parser) throws IOException {\n    builder.removeTags(new RemoveTagAction(getTagActionData(parser, ActionType.REMOVE_TAG)));\n}",
                "name": "readRemoveTags",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "JsonParser",
                        "name": "parser"
                    }
                ],
                "body": "{\n    builder.removeTags(new RemoveTagAction(getTagActionData(parser, ActionType.REMOVE_TAG)));\n}",
                "start_point": {
                    "row": 226,
                    "column": 4
                },
                "end_point": {
                    "row": 228,
                    "column": 5
                }
            },
            {
                "definition": "public void readShare(JsonParser parser) throws IOException {\n    ShareAction action = parser.readValueAs(ShareAction.class);\n    if (StringUtils.isEmpty(action.getValue())) {\n        throw new APIParsingException(\"The share text may not be an empty string.\");\n    }\n    builder.setShare(action);\n}",
                "name": "readShare",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "JsonParser",
                        "name": "parser"
                    }
                ],
                "body": "{\n    ShareAction action = parser.readValueAs(ShareAction.class);\n    if (StringUtils.isEmpty(action.getValue())) {\n        throw new APIParsingException(\"The share text may not be an empty string.\");\n    }\n    builder.setShare(action);\n}",
                "start_point": {
                    "row": 230,
                    "column": 4
                },
                "end_point": {
                    "row": 236,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Actions validateAndBuild() throws IOException {\n    return builder.build();\n}",
                "name": "validateAndBuild",
                "modifiers": "@Override\n    public",
                "return_type": "Actions",
                "parameters": [],
                "body": "{\n    return builder.build();\n}",
                "start_point": {
                    "row": 238,
                    "column": 4
                },
                "end_point": {
                    "row": 241,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "src/main/java/com/urbanairship/api/reports/Base64ByteArray.java",
        "definition": "public final class Base64ByteArray {\n\n    public byte[] binary;\n\n    public Base64ByteArray(String value) {\n        Preconditions.checkArgument(Base64.isBase64(value));\n\n        this.binary = Base64.decode(value);\n    }\n\n    public byte[] getByteArray() {\n        return binary;\n    }\n\n    public String getBase64EncodedString() {\n        return new String(Base64.encode(binary));\n    }\n\n    @Override\n    public String toString() {\n        return new String(binary);\n    }\n\n    // Does not use Guava::Objects, gives inconsistent results with byte array\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        Base64ByteArray that = (Base64ByteArray) o;\n\n        return Arrays.equals(binary, that.binary);\n\n    }\n\n    @Override\n    public int hashCode() {\n        return binary != null ? Arrays.hashCode(binary) : 0;\n    }\n}",
        "package": "package com.urbanairship.api.reports;",
        "tree_path": "Base64ByteArray",
        "name": "Base64ByteArray",
        "modifiers": "public final",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    public byte[] binary;\n\n    public Base64ByteArray(String value) {\n        Preconditions.checkArgument(Base64.isBase64(value));\n\n        this.binary = Base64.decode(value);\n    }\n\n    public byte[] getByteArray() {\n        return binary;\n    }\n\n    public String getBase64EncodedString() {\n        return new String(Base64.encode(binary));\n    }\n\n    @Override\n    public String toString() {\n        return new String(binary);\n    }\n\n    // Does not use Guava::Objects, gives inconsistent results with byte array\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        Base64ByteArray that = (Base64ByteArray) o;\n\n        return Arrays.equals(binary, that.binary);\n\n    }\n\n    @Override\n    public int hashCode() {\n        return binary != null ? Arrays.hashCode(binary) : 0;\n    }\n}",
        "start_point": {
            "row": 11,
            "column": 0
        },
        "end_point": {
            "row": 54,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public Base64ByteArray(String value) {\n    Preconditions.checkArgument(Base64.isBase64(value));\n\n    this.binary = Base64.decode(value);\n}",
                "name": "Base64ByteArray",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    Preconditions.checkArgument(Base64.isBase64(value));\n\n    this.binary = Base64.decode(value);\n}",
                "constructor": true,
                "start_point": {
                    "row": 15,
                    "column": 4
                },
                "end_point": {
                    "row": 19,
                    "column": 5
                }
            },
            {
                "definition": "public byte[] getByteArray() {\n    return binary;\n}",
                "name": "getByteArray",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return binary;\n}",
                "start_point": {
                    "row": 21,
                    "column": 4
                },
                "end_point": {
                    "row": 23,
                    "column": 5
                }
            },
            {
                "definition": "public String getBase64EncodedString() {\n    return new String(Base64.encode(binary));\n}",
                "name": "getBase64EncodedString",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return new String(Base64.encode(binary));\n}",
                "start_point": {
                    "row": 25,
                    "column": 4
                },
                "end_point": {
                    "row": 27,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    return new String(binary);\n}",
                "name": "toString",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return new String(binary);\n}",
                "start_point": {
                    "row": 29,
                    "column": 4
                },
                "end_point": {
                    "row": 32,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n\n    Base64ByteArray that = (Base64ByteArray) o;\n\n    return Arrays.equals(binary, that.binary);\n\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) {\n        return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n        return false;\n    }\n\n    Base64ByteArray that = (Base64ByteArray) o;\n\n    return Arrays.equals(binary, that.binary);\n\n}",
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 48,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    return binary != null ? Arrays.hashCode(binary) : 0;\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return binary != null ? Arrays.hashCode(binary) : 0;\n}",
                "start_point": {
                    "row": 50,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "src/test/java/com/urbanairship/api/push/parse/notification/ParseActionsTest.java",
        "definition": "public class ParseActionsTest {\n\n    private ObjectMapper mapper;\n\n    @Before\n    public void setUp() {\n        mapper = PushObjectMapper.getInstance();\n    }\n\n    @Test\n    public void testAddTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    private <A extends Action> Optional<A> getAction(Actions actions, ActionType type, Class<A> klass) {\n        for (Action a : actions.allActions()) {\n            if (a.getActionType() == type && a.getClass() == klass) {\n                return Optional.of((A) a);\n            }\n        }\n\n        return Optional.absent();\n\n    }\n\n    @Test\n    public void testRemoveTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    @Test\n    public void testAddTag() throws Exception {\n        String tag = \"foo\";\n\n        AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testRemoveTag() throws Exception {\n        String tag = \"foo\";\n\n        RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testOpenExternal() throws Exception {\n        URI url = URI.create(\"http://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testOpenExternalHTTPS() throws IOException {\n        URI url = URI.create(\"https://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testBadOpenExternalWrongScheme() throws IOException {\n        URI u = URI.create(\"ftp://foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            String content = mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build());\n            mapper.readValue(content, Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalAbsolutePathNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"/foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testOpenLandingPage() throws Exception {\n\n        {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            assertNotNull(\"Could not round-trip open landing action.\", actions);\n            Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n            assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n            LandingPageContent actual = optOpen.get().getValue();\n            assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n            assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n            assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n        }\n\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            fail(\"Invalid Base64 content should have raised an exception.\");\n        } catch (APIParsingException ex) {\n            assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n        }\n    }\n\n    private void openLandingPageContentType(String contentTypeHeader, boolean good) throws Exception {\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"content\")\n                    .setContentType(contentTypeHeader)\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            if (!good) {\n                fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n            }\n        } catch (APIParsingException ex) {\n            if (good) {\n                fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n            } else {\n                assertNotNull(ex);\n            }\n        }\n    }\n\n    @Test\n    public void testOpenLandingPageContentTypeValidation() throws Exception {\n        ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n                \"text/html\",\n                \"Text/HTML\",\n                \"Text/HTML; charset=utf-8\",\n                \"Text/HTML ; charset=iso8859-1; something=else\",\n                \"application/x-rtf\",\n                \"image/jpeg\"\n        );\n\n        ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n                \"text/ html\",\n                \"Text/H TML\",\n                \"Text/XHTML; charset=utf-8\",\n                \"Text/FooHTML; charset=iso8859-1;;;;\",\n                \"application/x-treme\",\n                \"imagine/jpeg\",\n                \"undefined\",\n                \"halp\",\n                \"\"\n        );\n\n        for (String contentTypeHeader : validContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, true);\n        }\n\n        for (String contentTypeHeader : invalidContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, false);\n        }\n    }\n\n    private void openLandingPageBody(String body, LandingPageContent.Encoding encoding) throws Exception {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(body)\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(encoding))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n    }\n\n    @Test\n    public void testSmallBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = Base64.encodeBase64String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = Base64.encodeBase64String(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = Base64.encodeBase64String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testSmallTextBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = new String(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testAppDefined() throws Exception {\n        String appDefined = \"{\\n\" +\n                \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n                \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n                \"            }\\n\";\n        ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n        AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip app_defined action\", actions);\n        Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n        assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n        ObjectNode result = optAppDefined.get().getValue();\n\n        Iterator<String> fieldNames = expected.getFieldNames();\n        while (fieldNames.hasNext()) {\n            String fieldName = fieldNames.next();\n            assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                    result.path(fieldName).isMissingNode());\n            assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                    expected.path(fieldName), result.path(fieldName));\n        }\n\n        Iterator<String> resultFields = result.getFieldNames();\n        while (resultFields.hasNext()) {\n            String fieldName = resultFields.next();\n            assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                    expected.path(fieldName).isMissingNode());\n        }\n\n    }\n\n    @Test\n    public void testDeepLinkActionSerialization() throws Exception {\n        DeepLinkAction a = new DeepLinkAction(\"test\");\n        assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n    }\n\n    @Test\n    public void testShare() throws Exception {\n        String shareText = \"This is a share.\";\n\n        ShareAction shareAction = new ShareAction(shareText);\n\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip share action\", actions);\n        Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n        assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n        String shareData = optShareAction.get().getValue();\n        assertEquals(shareText, shareData);\n    }\n\n    @Test\n    public void testNonemptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n        mapper.readValue(json, Actions.class);\n    }\n\n    @Test\n    public void testEmptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n        try {\n            mapper.readValue(json, Actions.class);\n        } catch (APIParsingException exc) {\n            assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n        }\n    }\n}",
        "package": "package com.urbanairship.api.push.parse.notification;",
        "tree_path": "ParseActionsTest",
        "name": "ParseActionsTest",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private ObjectMapper mapper;\n\n    @Before\n    public void setUp() {\n        mapper = PushObjectMapper.getInstance();\n    }\n\n    @Test\n    public void testAddTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    private <A extends Action> Optional<A> getAction(Actions actions, ActionType type, Class<A> klass) {\n        for (Action a : actions.allActions()) {\n            if (a.getActionType() == type && a.getClass() == klass) {\n                return Optional.of((A) a);\n            }\n        }\n\n        return Optional.absent();\n\n    }\n\n    @Test\n    public void testRemoveTags() throws Exception {\n        ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n        RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n        String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n        Actions actions = mapper.readValue(content, Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n        Set<String> actualTags = tagData.getTagSet();\n        assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n        for (String tag : tags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n        }\n\n        for (String tag : actualTags) {\n            assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n        }\n    }\n\n    @Test\n    public void testAddTag() throws Exception {\n        String tag = \"foo\";\n\n        AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip add_tag action\", actions);\n        Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n        assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n        TagActionData tagData = optAddTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testRemoveTag() throws Exception {\n        String tag = \"foo\";\n\n        RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip remove_tag action\", actions);\n        Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n        assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n        TagActionData tagData = optRemoveTags.get().getValue();\n        assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n        String actualTag = tagData.getSingleTag();\n        assertEquals(\"Did not get expected tag.\", tag, actualTag);\n    }\n\n    @Test\n    public void testOpenExternal() throws Exception {\n        URI url = URI.create(\"http://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testOpenExternalHTTPS() throws IOException {\n        URI url = URI.create(\"https://foo.com\");\n        OpenExternalURLAction external = new OpenExternalURLAction(url);\n        String action = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        Actions actions = mapper.readValue(action, Actions.class);\n        assertNotNull(\"Could not round-trip open external URL action.\", actions);\n        Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n        assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n        assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n    }\n\n    @Test\n    public void testBadOpenExternalWrongScheme() throws IOException {\n        URI u = URI.create(\"ftp://foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            String content = mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build());\n            mapper.readValue(content, Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalAbsolutePathNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"/foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testBadOpenExternalNoScheme() throws java.io.IOException {\n        URI u = URI.create(\"foo.com\");\n        try {\n            OpenExternalURLAction external = new OpenExternalURLAction(u);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(external)\n                    .build()), Actions.class);\n            fail(\"URL should have caused exception: \" + u);\n        } catch (APIParsingException e) {\n            assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n        }\n    }\n\n    @Test\n    public void testOpenLandingPage() throws Exception {\n\n        {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            assertNotNull(\"Could not round-trip open landing action.\", actions);\n            Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n            assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n            LandingPageContent actual = optOpen.get().getValue();\n            assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n            assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n            assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n        }\n\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"\u26f8\")\n                    .setContentType(\"text/html\")\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            fail(\"Invalid Base64 content should have raised an exception.\");\n        } catch (APIParsingException ex) {\n            assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n        }\n    }\n\n    private void openLandingPageContentType(String contentTypeHeader, boolean good) throws Exception {\n        try {\n            LandingPageContent expected = LandingPageContent.newBuilder()\n                    .setBody(\"content\")\n                    .setContentType(contentTypeHeader)\n                    .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                    .build();\n            OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n            mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                    .setOpen(reference)\n                    .build()), Actions.class);\n            if (!good) {\n                fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n            }\n        } catch (APIParsingException ex) {\n            if (good) {\n                fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n            } else {\n                assertNotNull(ex);\n            }\n        }\n    }\n\n    @Test\n    public void testOpenLandingPageContentTypeValidation() throws Exception {\n        ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n                \"text/html\",\n                \"Text/HTML\",\n                \"Text/HTML; charset=utf-8\",\n                \"Text/HTML ; charset=iso8859-1; something=else\",\n                \"application/x-rtf\",\n                \"image/jpeg\"\n        );\n\n        ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n                \"text/ html\",\n                \"Text/H TML\",\n                \"Text/XHTML; charset=utf-8\",\n                \"Text/FooHTML; charset=iso8859-1;;;;\",\n                \"application/x-treme\",\n                \"imagine/jpeg\",\n                \"undefined\",\n                \"halp\",\n                \"\"\n        );\n\n        for (String contentTypeHeader : validContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, true);\n        }\n\n        for (String contentTypeHeader : invalidContentTypeHeaders) {\n            openLandingPageContentType(contentTypeHeader, false);\n        }\n    }\n\n    private void openLandingPageBody(String body, LandingPageContent.Encoding encoding) throws Exception {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(body)\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(encoding))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n    }\n\n    @Test\n    public void testSmallBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = Base64.encodeBase64String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = Base64.encodeBase64String(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeBinaryBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = Base64.encodeBase64String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n    }\n\n    @Test\n    public void testSmallTextBody() throws Exception {\n        byte[] bodyBytes = new byte[32 * 1024];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n        String bodyString = new String(bodyBytes);\n        assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test(expected = APIParsingException.class)\n    public void testTooLargeTextBody() throws Exception {\n        byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n        String bodyString = new String(bodyBytes);\n\n        openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n    }\n\n    @Test\n    public void testAppDefined() throws Exception {\n        String appDefined = \"{\\n\" +\n                \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n                \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n                \"            }\\n\";\n        ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n        AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip app_defined action\", actions);\n        Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n        assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n        ObjectNode result = optAppDefined.get().getValue();\n\n        Iterator<String> fieldNames = expected.getFieldNames();\n        while (fieldNames.hasNext()) {\n            String fieldName = fieldNames.next();\n            assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                    result.path(fieldName).isMissingNode());\n            assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                    expected.path(fieldName), result.path(fieldName));\n        }\n\n        Iterator<String> resultFields = result.getFieldNames();\n        while (resultFields.hasNext()) {\n            String fieldName = resultFields.next();\n            assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                    expected.path(fieldName).isMissingNode());\n        }\n\n    }\n\n    @Test\n    public void testDeepLinkActionSerialization() throws Exception {\n        DeepLinkAction a = new DeepLinkAction(\"test\");\n        assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n    }\n\n    @Test\n    public void testShare() throws Exception {\n        String shareText = \"This is a share.\";\n\n        ShareAction shareAction = new ShareAction(shareText);\n\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n        assertNotNull(\"Could not round-trip share action\", actions);\n        Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n        assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n        String shareData = optShareAction.get().getValue();\n        assertEquals(shareText, shareData);\n    }\n\n    @Test\n    public void testNonemptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n        mapper.readValue(json, Actions.class);\n    }\n\n    @Test\n    public void testEmptyShare() throws Exception {\n        String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n        try {\n            mapper.readValue(json, Actions.class);\n        } catch (APIParsingException exc) {\n            assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n        }\n    }\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 437,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Before\npublic void setUp() {\n    mapper = PushObjectMapper.getInstance();\n}",
                "name": "setUp",
                "modifiers": "@Before\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    mapper = PushObjectMapper.getInstance();\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 45,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testAddTags() throws Exception {\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "name": "testAddTags",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    AddTagAction addTags = new AddTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().addTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                }
            },
            {
                "definition": "private <A extends Action> Optional<A> getAction(Actions actions, ActionType type, Class<A> klass) {\n    for (Action a : actions.allActions()) {\n        if (a.getActionType() == type && a.getClass() == klass) {\n            return Optional.of((A) a);\n        }\n    }\n\n    return Optional.absent();\n\n}",
                "name": "getAction",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Actions",
                        "name": "actions"
                    },
                    {
                        "type": "ActionType",
                        "name": "type"
                    },
                    {
                        "type": "Class<A>",
                        "name": "klass"
                    }
                ],
                "body": "{\n    for (Action a : actions.allActions()) {\n        if (a.getActionType() == type && a.getClass() == klass) {\n            return Optional.of((A) a);\n        }\n    }\n\n    return Optional.absent();\n\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testRemoveTags() throws Exception {\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "name": "testRemoveTags",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    ArrayList<String> tags = Lists.newArrayList(\"foo\", \"bar\", \"baz\");\n\n    RemoveTagAction addTags = new RemoveTagAction(TagActionData.set(Sets.newHashSet(tags)));\n    String content = mapper.writeValueAsString(Actions.newBuilder().removeTags(addTags).build());\n    Actions actions = mapper.readValue(content, Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertFalse(\"Multiple tags should be present\", tagData.isSingle());\n    Set<String> actualTags = tagData.getTagSet();\n    assertEquals(\"Did not get 3 tags as expected\", tags.size(), actualTags.size());\n\n    for (String tag : tags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", actualTags.contains(tag));\n    }\n\n    for (String tag : actualTags) {\n        assertTrue(\"Tag \" + tag + \" not found in round-trip data\", tags.contains(tag));\n    }\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testAddTag() throws Exception {\n    String tag = \"foo\";\n\n    AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "name": "testAddTag",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String tag = \"foo\";\n\n    AddTagAction addTag = new AddTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip add_tag action\", actions);\n    Optional<AddTagAction> optAddTags = getAction(actions, ActionType.ADD_TAG, AddTagAction.class);\n    assertTrue(\"add_tag should be present\", optAddTags.isPresent());\n    TagActionData tagData = optAddTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 122,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testRemoveTag() throws Exception {\n    String tag = \"foo\";\n\n    RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "name": "testRemoveTag",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String tag = \"foo\";\n\n    RemoveTagAction addTag = new RemoveTagAction(TagActionData.single(tag));\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().removeTags(addTag).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip remove_tag action\", actions);\n    Optional<RemoveTagAction> optRemoveTags = getAction(actions, ActionType.REMOVE_TAG, RemoveTagAction.class);\n    assertTrue(\"remove_tag should be present\", optRemoveTags.isPresent());\n    TagActionData tagData = optRemoveTags.get().getValue();\n    assertTrue(\"Only a single tag should be present.\", tagData.isSingle());\n    String actualTag = tagData.getSingleTag();\n    assertEquals(\"Did not get expected tag.\", tag, actualTag);\n}",
                "start_point": {
                    "row": 124,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testOpenExternal() throws Exception {\n    URI url = URI.create(\"http://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "name": "testOpenExternal",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI url = URI.create(\"http://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 152,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testOpenExternalHTTPS() throws IOException {\n    URI url = URI.create(\"https://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "name": "testOpenExternalHTTPS",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI url = URI.create(\"https://foo.com\");\n    OpenExternalURLAction external = new OpenExternalURLAction(url);\n    String action = mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(external)\n            .build());\n    Actions actions = mapper.readValue(action, Actions.class);\n    assertNotNull(\"Could not round-trip open external URL action.\", actions);\n    Optional<OpenExternalURLAction> optOpen = getAction(actions, ActionType.OPEN_EXTERNAL_URL, OpenExternalURLAction.class);\n    assertTrue(\"External url open action should be present.\", optOpen.isPresent());\n    assertEquals(\"URL not round-tripped as expected.\", url, optOpen.get().getValue());\n}",
                "start_point": {
                    "row": 154,
                    "column": 4
                },
                "end_point": {
                    "row": 166,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testBadOpenExternalWrongScheme() throws IOException {\n    URI u = URI.create(\"ftp://foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        String content = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        mapper.readValue(content, Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "name": "testBadOpenExternalWrongScheme",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI u = URI.create(\"ftp://foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        String content = mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build());\n        mapper.readValue(content, Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 181,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testBadOpenExternalAbsolutePathNoScheme() throws java.io.IOException {\n    URI u = URI.create(\"/foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "name": "testBadOpenExternalAbsolutePathNoScheme",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI u = URI.create(\"/foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 183,
                    "column": 4
                },
                "end_point": {
                    "row": 195,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testBadOpenExternalNoScheme() throws java.io.IOException {\n    URI u = URI.create(\"foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "name": "testBadOpenExternalNoScheme",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    URI u = URI.create(\"foo.com\");\n    try {\n        OpenExternalURLAction external = new OpenExternalURLAction(u);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(external)\n                .build()), Actions.class);\n        fail(\"URL should have caused exception: \" + u);\n    } catch (APIParsingException e) {\n        assertEquals(\"The url for a url action must use either 'http' or 'https'\", e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 197,
                    "column": 4
                },
                "end_point": {
                    "row": 209,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testOpenLandingPage() throws Exception {\n\n    {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        assertNotNull(\"Could not round-trip open landing action.\", actions);\n        Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n        assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n        LandingPageContent actual = optOpen.get().getValue();\n        assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n        assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n        assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n    }\n\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        fail(\"Invalid Base64 content should have raised an exception.\");\n    } catch (APIParsingException ex) {\n        assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n    }\n}",
                "name": "testOpenLandingPage",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n\n    {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        assertNotNull(\"Could not round-trip open landing action.\", actions);\n        Optional<OpenLandingPageWithContentAction> optOpen = getAction(actions, ActionType.OPEN_LANDING_PAGE_WITH_CONTENT, OpenLandingPageWithContentAction.class);\n        assertTrue(\"Open landing page action should be present.\", optOpen.isPresent());\n        LandingPageContent actual = optOpen.get().getValue();\n        assertEquals(\"Body of content not round-tripped.\", expected.getBody(), actual.getBody());\n        assertEquals(\"Content-type not round-tripped.\", expected.getContentType(), actual.getContentType());\n        assertEquals(\"Content-encoding not round-tripped.\", expected.getEncoding().get(), actual.getEncoding().get());\n    }\n\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"\u26f8\")\n                .setContentType(\"text/html\")\n                .setEncoding(Optional.of(LandingPageContent.Encoding.Base64))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        fail(\"Invalid Base64 content should have raised an exception.\");\n    } catch (APIParsingException ex) {\n        assertEquals(\"Content contains invalid data that is not valid for base64 encoding.\", ex.getMessage());\n    }\n}",
                "start_point": {
                    "row": 211,
                    "column": 4
                },
                "end_point": {
                    "row": 247,
                    "column": 5
                }
            },
            {
                "definition": "private void openLandingPageContentType(String contentTypeHeader, boolean good) throws Exception {\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"content\")\n                .setContentType(contentTypeHeader)\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        if (!good) {\n            fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n        }\n    } catch (APIParsingException ex) {\n        if (good) {\n            fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n        } else {\n            assertNotNull(ex);\n        }\n    }\n}",
                "name": "openLandingPageContentType",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "contentTypeHeader"
                    },
                    {
                        "type": "boolean",
                        "name": "good"
                    }
                ],
                "body": "{\n    try {\n        LandingPageContent expected = LandingPageContent.newBuilder()\n                .setBody(\"content\")\n                .setContentType(contentTypeHeader)\n                .setEncoding(Optional.of(LandingPageContent.Encoding.UTF8))\n                .build();\n        OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n        mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n                .setOpen(reference)\n                .build()), Actions.class);\n        if (!good) {\n            fail(\"Bad content type should have raised an exception for: \" + contentTypeHeader);\n        }\n    } catch (APIParsingException ex) {\n        if (good) {\n            fail(\"Valid content type should not have raised an exception for: \" + contentTypeHeader);\n        } else {\n            assertNotNull(ex);\n        }\n    }\n}",
                "start_point": {
                    "row": 249,
                    "column": 4
                },
                "end_point": {
                    "row": 270,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testOpenLandingPageContentTypeValidation() throws Exception {\n    ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n            \"text/html\",\n            \"Text/HTML\",\n            \"Text/HTML; charset=utf-8\",\n            \"Text/HTML ; charset=iso8859-1; something=else\",\n            \"application/x-rtf\",\n            \"image/jpeg\"\n    );\n\n    ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n            \"text/ html\",\n            \"Text/H TML\",\n            \"Text/XHTML; charset=utf-8\",\n            \"Text/FooHTML; charset=iso8859-1;;;;\",\n            \"application/x-treme\",\n            \"imagine/jpeg\",\n            \"undefined\",\n            \"halp\",\n            \"\"\n    );\n\n    for (String contentTypeHeader : validContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, true);\n    }\n\n    for (String contentTypeHeader : invalidContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, false);\n    }\n}",
                "name": "testOpenLandingPageContentTypeValidation",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    ImmutableList<String> validContentTypeHeaders = ImmutableList.of(\n            \"text/html\",\n            \"Text/HTML\",\n            \"Text/HTML; charset=utf-8\",\n            \"Text/HTML ; charset=iso8859-1; something=else\",\n            \"application/x-rtf\",\n            \"image/jpeg\"\n    );\n\n    ImmutableList<String> invalidContentTypeHeaders = ImmutableList.of(\n            \"text/ html\",\n            \"Text/H TML\",\n            \"Text/XHTML; charset=utf-8\",\n            \"Text/FooHTML; charset=iso8859-1;;;;\",\n            \"application/x-treme\",\n            \"imagine/jpeg\",\n            \"undefined\",\n            \"halp\",\n            \"\"\n    );\n\n    for (String contentTypeHeader : validContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, true);\n    }\n\n    for (String contentTypeHeader : invalidContentTypeHeaders) {\n        openLandingPageContentType(contentTypeHeader, false);\n    }\n}",
                "start_point": {
                    "row": 272,
                    "column": 4
                },
                "end_point": {
                    "row": 302,
                    "column": 5
                }
            },
            {
                "definition": "private void openLandingPageBody(String body, LandingPageContent.Encoding encoding) throws Exception {\n    LandingPageContent expected = LandingPageContent.newBuilder()\n            .setBody(body)\n            .setContentType(\"text/html\")\n            .setEncoding(Optional.of(encoding))\n            .build();\n    OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n    mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(reference)\n            .build()), Actions.class);\n}",
                "name": "openLandingPageBody",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "body"
                    },
                    {
                        "type": "LandingPageContent.Encoding",
                        "name": "encoding"
                    }
                ],
                "body": "{\n    LandingPageContent expected = LandingPageContent.newBuilder()\n            .setBody(body)\n            .setContentType(\"text/html\")\n            .setEncoding(Optional.of(encoding))\n            .build();\n    OpenLandingPageWithContentAction reference = new OpenLandingPageWithContentAction(expected);\n    mapper.readValue(mapper.writeValueAsString(Actions.newBuilder()\n            .setOpen(reference)\n            .build()), Actions.class);\n}",
                "start_point": {
                    "row": 304,
                    "column": 4
                },
                "end_point": {
                    "row": 314,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testSmallBinaryBody() throws Exception {\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = Base64.encodeBase64String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "name": "testSmallBinaryBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = Base64.encodeBase64String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "start_point": {
                    "row": 316,
                    "column": 4
                },
                "end_point": {
                    "row": 322,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testLargeBinaryBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = Base64.encodeBase64String(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "name": "testLargeBinaryBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = Base64.encodeBase64String(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BASE64, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "start_point": {
                    "row": 324,
                    "column": 4
                },
                "end_point": {
                    "row": 331,
                    "column": 5
                }
            },
            {
                "definition": "@Test(expected = APIParsingException.class)\npublic void testTooLargeBinaryBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = Base64.encodeBase64String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "name": "testTooLargeBinaryBody",
                "modifiers": "@Test(expected = APIParsingException.class)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = Base64.encodeBase64String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.Base64);\n}",
                "start_point": {
                    "row": 333,
                    "column": 4
                },
                "end_point": {
                    "row": 339,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testSmallTextBody() throws Exception {\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "name": "testSmallTextBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[32 * 1024];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "start_point": {
                    "row": 341,
                    "column": 4
                },
                "end_point": {
                    "row": 347,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testLargeTextBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = new String(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "name": "testLargeTextBody",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES];\n    String bodyString = new String(bodyBytes);\n    assertEquals(LandingPageContent.MAX_BODY_SIZE_BYTES, bodyString.length());\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "start_point": {
                    "row": 349,
                    "column": 4
                },
                "end_point": {
                    "row": 356,
                    "column": 5
                }
            },
            {
                "definition": "@Test(expected = APIParsingException.class)\npublic void testTooLargeTextBody() throws Exception {\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "name": "testTooLargeTextBody",
                "modifiers": "@Test(expected = APIParsingException.class)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    byte[] bodyBytes = new byte[LandingPageContent.MAX_BODY_SIZE_BYTES + 24];\n    String bodyString = new String(bodyBytes);\n\n    openLandingPageBody(bodyString, LandingPageContent.Encoding.UTF8);\n}",
                "start_point": {
                    "row": 358,
                    "column": 4
                },
                "end_point": {
                    "row": 364,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testAppDefined() throws Exception {\n    String appDefined = \"{\\n\" +\n            \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n            \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n            \"            }\\n\";\n    ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n    AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip app_defined action\", actions);\n    Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n    assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n    ObjectNode result = optAppDefined.get().getValue();\n\n    Iterator<String> fieldNames = expected.getFieldNames();\n    while (fieldNames.hasNext()) {\n        String fieldName = fieldNames.next();\n        assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                result.path(fieldName).isMissingNode());\n        assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                expected.path(fieldName), result.path(fieldName));\n    }\n\n    Iterator<String> resultFields = result.getFieldNames();\n    while (resultFields.hasNext()) {\n        String fieldName = resultFields.next();\n        assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                expected.path(fieldName).isMissingNode());\n    }\n\n}",
                "name": "testAppDefined",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String appDefined = \"{\\n\" +\n            \"                \\\"field1\\\" : \\\"x\\\",\\n\" +\n            \"                \\\"field2\\\" : \\\"y\\\"\\n\" +\n            \"            }\\n\";\n    ObjectNode expected = (ObjectNode) mapper.readTree(appDefined);\n\n    AppDefinedAction appDefinedAction = new AppDefinedAction(expected);\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().addAppDefined(appDefinedAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip app_defined action\", actions);\n    Optional<AppDefinedAction> optAppDefined = getAction(actions, ActionType.APP_DEFINED, AppDefinedAction.class);\n    assertTrue(\"app_defined should be present\", optAppDefined.isPresent());\n\n    ObjectNode result = optAppDefined.get().getValue();\n\n    Iterator<String> fieldNames = expected.getFieldNames();\n    while (fieldNames.hasNext()) {\n        String fieldName = fieldNames.next();\n        assertFalse(\"Expected field name not present in app_defined object: \" + fieldName,\n                result.path(fieldName).isMissingNode());\n        assertEquals(\"Expected value not found for key \" + fieldName + \": \" + expected.path(fieldName).toString(),\n                expected.path(fieldName), result.path(fieldName));\n    }\n\n    Iterator<String> resultFields = result.getFieldNames();\n    while (resultFields.hasNext()) {\n        String fieldName = resultFields.next();\n        assertFalse(\"Unexpected field name in app_defined object: \" + fieldName,\n                expected.path(fieldName).isMissingNode());\n    }\n\n}",
                "start_point": {
                    "row": 366,
                    "column": 4
                },
                "end_point": {
                    "row": 399,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testDeepLinkActionSerialization() throws Exception {\n    DeepLinkAction a = new DeepLinkAction(\"test\");\n    assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n}",
                "name": "testDeepLinkActionSerialization",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    DeepLinkAction a = new DeepLinkAction(\"test\");\n    assertEquals(\"{\\\"type\\\":\\\"deep_link\\\",\\\"content\\\":\\\"test\\\"}\", mapper.writeValueAsString(a));\n}",
                "start_point": {
                    "row": 401,
                    "column": 4
                },
                "end_point": {
                    "row": 405,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testShare() throws Exception {\n    String shareText = \"This is a share.\";\n\n    ShareAction shareAction = new ShareAction(shareText);\n\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip share action\", actions);\n    Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n    assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n    String shareData = optShareAction.get().getValue();\n    assertEquals(shareText, shareData);\n}",
                "name": "testShare",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String shareText = \"This is a share.\";\n\n    ShareAction shareAction = new ShareAction(shareText);\n\n    Actions actions = mapper.readValue(mapper.writeValueAsString(Actions.newBuilder().setShare(shareAction).build()), Actions.class);\n\n    assertNotNull(\"Could not round-trip share action\", actions);\n    Optional<ShareAction> optShareAction = getAction(actions, ActionType.SHARE, ShareAction.class);\n    assertTrue(\"add_tag should be present\", optShareAction.isPresent());\n    String shareData = optShareAction.get().getValue();\n    assertEquals(shareText, shareData);\n}",
                "start_point": {
                    "row": 407,
                    "column": 4
                },
                "end_point": {
                    "row": 420,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testNonemptyShare() throws Exception {\n    String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n    mapper.readValue(json, Actions.class);\n}",
                "name": "testNonemptyShare",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String json = \"{ \\\"share\\\" : \\\"wha\\\" }\";\n    mapper.readValue(json, Actions.class);\n}",
                "start_point": {
                    "row": 422,
                    "column": 4
                },
                "end_point": {
                    "row": 426,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void testEmptyShare() throws Exception {\n    String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n    try {\n        mapper.readValue(json, Actions.class);\n    } catch (APIParsingException exc) {\n        assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n    }\n}",
                "name": "testEmptyShare",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    String json = \"{ \\\"share\\\" : \\\"\\\" }\";\n    try {\n        mapper.readValue(json, Actions.class);\n    } catch (APIParsingException exc) {\n        assertEquals(\"The share text may not be an empty string.\", exc.getMessage());\n    }\n}",
                "start_point": {
                    "row": 428,
                    "column": 4
                },
                "end_point": {
                    "row": 436,
                    "column": 5
                }
            }
        ]
    }
]