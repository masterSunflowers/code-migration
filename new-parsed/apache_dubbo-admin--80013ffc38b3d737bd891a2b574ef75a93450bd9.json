[
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/common/util/ConvertUtil.java",
        "definition": "public class ConvertUtil {\n    private ConvertUtil() {\n    }\n\n    public static Map<String, String> serviceName2Map(String serviceName) {\n        String group = null;\n        String version = null;\n        int i = serviceName.indexOf(\"/\");\n        if (i > 0) {\n            group = serviceName.substring(0, i);\n            serviceName = serviceName.substring(i + 1);\n        }\n        i = serviceName.lastIndexOf(\":\");\n        if (i > 0) {\n            version = serviceName.substring(i + 1);\n            serviceName = serviceName.substring(0, i);\n        }\n\n        Map<String, String> ret = new HashMap<String, String>();\n        if (!StringUtils.isEmpty(serviceName)) {\n            ret.put(Constants.INTERFACE_KEY, serviceName);\n        }\n        if (!StringUtils.isEmpty(version)) {\n            ret.put(Constants.VERSION_KEY, version);\n        }\n        if (!StringUtils.isEmpty(group)) {\n            ret.put(Constants.GROUP_KEY, group);\n        }\n\n        return ret;\n    }\n}",
        "package": "package org.apache.dubbo.admin.common.util;",
        "tree_path": "ConvertUtil",
        "name": "ConvertUtil",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    private ConvertUtil() {\n    }\n\n    public static Map<String, String> serviceName2Map(String serviceName) {\n        String group = null;\n        String version = null;\n        int i = serviceName.indexOf(\"/\");\n        if (i > 0) {\n            group = serviceName.substring(0, i);\n            serviceName = serviceName.substring(i + 1);\n        }\n        i = serviceName.lastIndexOf(\":\");\n        if (i > 0) {\n            version = serviceName.substring(i + 1);\n            serviceName = serviceName.substring(0, i);\n        }\n\n        Map<String, String> ret = new HashMap<String, String>();\n        if (!StringUtils.isEmpty(serviceName)) {\n            ret.put(Constants.INTERFACE_KEY, serviceName);\n        }\n        if (!StringUtils.isEmpty(version)) {\n            ret.put(Constants.VERSION_KEY, version);\n        }\n        if (!StringUtils.isEmpty(group)) {\n            ret.put(Constants.GROUP_KEY, group);\n        }\n\n        return ret;\n    }\n}",
        "start_point": {
            "row": 24,
            "column": 0
        },
        "end_point": {
            "row": 55,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "private ConvertUtil() {\n}",
                "name": "ConvertUtil",
                "modifiers": "private",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 25,
                    "column": 4
                },
                "end_point": {
                    "row": 26,
                    "column": 5
                }
            },
            {
                "definition": "public static Map<String, String> serviceName2Map(String serviceName) {\n    String group = null;\n    String version = null;\n    int i = serviceName.indexOf(\"/\");\n    if (i > 0) {\n        group = serviceName.substring(0, i);\n        serviceName = serviceName.substring(i + 1);\n    }\n    i = serviceName.lastIndexOf(\":\");\n    if (i > 0) {\n        version = serviceName.substring(i + 1);\n        serviceName = serviceName.substring(0, i);\n    }\n\n    Map<String, String> ret = new HashMap<String, String>();\n    if (!StringUtils.isEmpty(serviceName)) {\n        ret.put(Constants.INTERFACE_KEY, serviceName);\n    }\n    if (!StringUtils.isEmpty(version)) {\n        ret.put(Constants.VERSION_KEY, version);\n    }\n    if (!StringUtils.isEmpty(group)) {\n        ret.put(Constants.GROUP_KEY, group);\n    }\n\n    return ret;\n}",
                "name": "serviceName2Map",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "serviceName"
                    }
                ],
                "body": "{\n    String group = null;\n    String version = null;\n    int i = serviceName.indexOf(\"/\");\n    if (i > 0) {\n        group = serviceName.substring(0, i);\n        serviceName = serviceName.substring(i + 1);\n    }\n    i = serviceName.lastIndexOf(\":\");\n    if (i > 0) {\n        version = serviceName.substring(i + 1);\n        serviceName = serviceName.substring(0, i);\n    }\n\n    Map<String, String> ret = new HashMap<String, String>();\n    if (!StringUtils.isEmpty(serviceName)) {\n        ret.put(Constants.INTERFACE_KEY, serviceName);\n    }\n    if (!StringUtils.isEmpty(version)) {\n        ret.put(Constants.VERSION_KEY, version);\n    }\n    if (!StringUtils.isEmpty(group)) {\n        ret.put(Constants.GROUP_KEY, group);\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 28,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/common/util/OverrideUtils.java",
        "definition": "public class OverrideUtils {\n    public static List<Weight> overridesToWeights(List<Override> overrides) {\n        List<Weight> weights = new ArrayList<Weight>();\n        if (overrides == null) {\n            return weights;\n        }\n        for (Override o : overrides) {\n            if (StringUtils.isEmpty(o.getParams())) {\n                continue;\n            } else {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                for (Map.Entry<String, String> entry : params.entrySet()) {\n                    if (entry.getKey().equals(\"weight\")) {\n                        Weight weight = new Weight();\n                        weight.setAddress(o.getAddress());\n                        weight.setId(o.getId());\n                        weight.setHash(o.getHash());\n                        weight.setService(o.getService());\n                        weight.setWeight(Integer.valueOf(entry.getValue()));\n                        weights.add(weight);\n                    }\n                }\n            }\n        }\n        return weights;\n    }\n\n    public static Weight overrideToWeight(Override override) {\n        List<Weight> weights = OverrideUtils.overridesToWeights(Arrays.asList(override));\n        if (weights != null && weights.size() > 0) {\n            return overridesToWeights(Arrays.asList(override)).get(0);\n        }\n        return null;\n    }\n\n    public static Override weightToOverride(Weight weight) {\n        Override override = new Override();\n        override.setId(weight.getId());\n        override.setHash(weight.getHash());\n        override.setAddress(weight.getAddress());\n        override.setEnabled(true);\n        override.setParams(\"weight=\" + weight.getWeight());\n        override.setService(weight.getService());\n        return override;\n    }\n\n    public static List<LoadBalance> overridesToLoadBalances(List<Override> overrides) {\n        List<LoadBalance> loadBalances = new ArrayList<LoadBalance>();\n        if (overrides == null) {\n            return loadBalances;\n        }\n        for (Override o : overrides) {\n            if (StringUtils.isEmpty(o.getParams())) {\n                continue;\n            } else {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                for (Map.Entry<String, String> entry : params.entrySet()) {\n                    if (entry.getKey().endsWith(\"loadbalance\")) {\n                        LoadBalance loadBalance = new LoadBalance();\n                        String method = null;\n                        if (entry.getKey().endsWith(\".loadbalance\")) {\n                            method = entry.getKey().split(\".loadbalance\")[0];\n                        } else {\n                            method = \"*\";\n                        }\n\n                        loadBalance.setMethod(method);\n                        loadBalance.setId(o.getId());\n                        loadBalance.setHash(o.getHash());\n                        loadBalance.setService(o.getService());\n                        loadBalance.setStrategy(entry.getValue());\n                        loadBalances.add(loadBalance);\n\n                    }\n                }\n            }\n        }\n        return loadBalances;\n    }\n\n    public static LoadBalance overrideToLoadBalance(Override override) {\n        List<LoadBalance> loadBalances = OverrideUtils.overridesToLoadBalances(Arrays.asList(override));\n        if (loadBalances != null && loadBalances.size() > 0) {\n            return loadBalances.get(0);\n        }\n        return null;\n    }\n\n    public static Override loadBalanceToOverride(LoadBalance loadBalance) {\n        Override override = new Override();\n        override.setId(loadBalance.getId());\n        override.setHash(loadBalance.getHash());\n        override.setService(loadBalance.getService());\n        override.setEnabled(true);\n        String method = loadBalance.getMethod();\n        String strategy = loadBalance.getStrategy();\n        if (StringUtils.isEmpty(method) || method.equals(\"*\")) {\n            override.setParams(\"loadbalance=\" + strategy);\n        } else {\n            override.setParams(method + \".loadbalance=\" + strategy);\n        }\n        return override;\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.common.util;",
        "tree_path": "OverrideUtils",
        "name": "OverrideUtils",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    public static List<Weight> overridesToWeights(List<Override> overrides) {\n        List<Weight> weights = new ArrayList<Weight>();\n        if (overrides == null) {\n            return weights;\n        }\n        for (Override o : overrides) {\n            if (StringUtils.isEmpty(o.getParams())) {\n                continue;\n            } else {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                for (Map.Entry<String, String> entry : params.entrySet()) {\n                    if (entry.getKey().equals(\"weight\")) {\n                        Weight weight = new Weight();\n                        weight.setAddress(o.getAddress());\n                        weight.setId(o.getId());\n                        weight.setHash(o.getHash());\n                        weight.setService(o.getService());\n                        weight.setWeight(Integer.valueOf(entry.getValue()));\n                        weights.add(weight);\n                    }\n                }\n            }\n        }\n        return weights;\n    }\n\n    public static Weight overrideToWeight(Override override) {\n        List<Weight> weights = OverrideUtils.overridesToWeights(Arrays.asList(override));\n        if (weights != null && weights.size() > 0) {\n            return overridesToWeights(Arrays.asList(override)).get(0);\n        }\n        return null;\n    }\n\n    public static Override weightToOverride(Weight weight) {\n        Override override = new Override();\n        override.setId(weight.getId());\n        override.setHash(weight.getHash());\n        override.setAddress(weight.getAddress());\n        override.setEnabled(true);\n        override.setParams(\"weight=\" + weight.getWeight());\n        override.setService(weight.getService());\n        return override;\n    }\n\n    public static List<LoadBalance> overridesToLoadBalances(List<Override> overrides) {\n        List<LoadBalance> loadBalances = new ArrayList<LoadBalance>();\n        if (overrides == null) {\n            return loadBalances;\n        }\n        for (Override o : overrides) {\n            if (StringUtils.isEmpty(o.getParams())) {\n                continue;\n            } else {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                for (Map.Entry<String, String> entry : params.entrySet()) {\n                    if (entry.getKey().endsWith(\"loadbalance\")) {\n                        LoadBalance loadBalance = new LoadBalance();\n                        String method = null;\n                        if (entry.getKey().endsWith(\".loadbalance\")) {\n                            method = entry.getKey().split(\".loadbalance\")[0];\n                        } else {\n                            method = \"*\";\n                        }\n\n                        loadBalance.setMethod(method);\n                        loadBalance.setId(o.getId());\n                        loadBalance.setHash(o.getHash());\n                        loadBalance.setService(o.getService());\n                        loadBalance.setStrategy(entry.getValue());\n                        loadBalances.add(loadBalance);\n\n                    }\n                }\n            }\n        }\n        return loadBalances;\n    }\n\n    public static LoadBalance overrideToLoadBalance(Override override) {\n        List<LoadBalance> loadBalances = OverrideUtils.overridesToLoadBalances(Arrays.asList(override));\n        if (loadBalances != null && loadBalances.size() > 0) {\n            return loadBalances.get(0);\n        }\n        return null;\n    }\n\n    public static Override loadBalanceToOverride(LoadBalance loadBalance) {\n        Override override = new Override();\n        override.setId(loadBalance.getId());\n        override.setHash(loadBalance.getHash());\n        override.setService(loadBalance.getService());\n        override.setEnabled(true);\n        String method = loadBalance.getMethod();\n        String strategy = loadBalance.getStrategy();\n        if (StringUtils.isEmpty(method) || method.equals(\"*\")) {\n            override.setParams(\"loadbalance=\" + strategy);\n        } else {\n            override.setParams(method + \".loadbalance=\" + strategy);\n        }\n        return override;\n    }\n\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 136,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public static List<Weight> overridesToWeights(List<Override> overrides) {\n    List<Weight> weights = new ArrayList<Weight>();\n    if (overrides == null) {\n        return weights;\n    }\n    for (Override o : overrides) {\n        if (StringUtils.isEmpty(o.getParams())) {\n            continue;\n        } else {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                if (entry.getKey().equals(\"weight\")) {\n                    Weight weight = new Weight();\n                    weight.setAddress(o.getAddress());\n                    weight.setId(o.getId());\n                    weight.setHash(o.getHash());\n                    weight.setService(o.getService());\n                    weight.setWeight(Integer.valueOf(entry.getValue()));\n                    weights.add(weight);\n                }\n            }\n        }\n    }\n    return weights;\n}",
                "name": "overridesToWeights",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Override>",
                        "name": "overrides"
                    }
                ],
                "body": "{\n    List<Weight> weights = new ArrayList<Weight>();\n    if (overrides == null) {\n        return weights;\n    }\n    for (Override o : overrides) {\n        if (StringUtils.isEmpty(o.getParams())) {\n            continue;\n        } else {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                if (entry.getKey().equals(\"weight\")) {\n                    Weight weight = new Weight();\n                    weight.setAddress(o.getAddress());\n                    weight.setId(o.getId());\n                    weight.setHash(o.getHash());\n                    weight.setService(o.getService());\n                    weight.setWeight(Integer.valueOf(entry.getValue()));\n                    weights.add(weight);\n                }\n            }\n        }\n    }\n    return weights;\n}",
                "start_point": {
                    "row": 33,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "public static Weight overrideToWeight(Override override) {\n    List<Weight> weights = OverrideUtils.overridesToWeights(Arrays.asList(override));\n    if (weights != null && weights.size() > 0) {\n        return overridesToWeights(Arrays.asList(override)).get(0);\n    }\n    return null;\n}",
                "name": "overrideToWeight",
                "modifiers": "public static",
                "return_type": "Weight",
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    }
                ],
                "body": "{\n    List<Weight> weights = OverrideUtils.overridesToWeights(Arrays.asList(override));\n    if (weights != null && weights.size() > 0) {\n        return overridesToWeights(Arrays.asList(override)).get(0);\n    }\n    return null;\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            },
            {
                "definition": "public static Override weightToOverride(Weight weight) {\n    Override override = new Override();\n    override.setId(weight.getId());\n    override.setHash(weight.getHash());\n    override.setAddress(weight.getAddress());\n    override.setEnabled(true);\n    override.setParams(\"weight=\" + weight.getWeight());\n    override.setService(weight.getService());\n    return override;\n}",
                "name": "weightToOverride",
                "modifiers": "public static",
                "return_type": "Override",
                "parameters": [
                    {
                        "type": "Weight",
                        "name": "weight"
                    }
                ],
                "body": "{\n    Override override = new Override();\n    override.setId(weight.getId());\n    override.setHash(weight.getHash());\n    override.setAddress(weight.getAddress());\n    override.setEnabled(true);\n    override.setParams(\"weight=\" + weight.getWeight());\n    override.setService(weight.getService());\n    return override;\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 76,
                    "column": 5
                }
            },
            {
                "definition": "public static List<LoadBalance> overridesToLoadBalances(List<Override> overrides) {\n    List<LoadBalance> loadBalances = new ArrayList<LoadBalance>();\n    if (overrides == null) {\n        return loadBalances;\n    }\n    for (Override o : overrides) {\n        if (StringUtils.isEmpty(o.getParams())) {\n            continue;\n        } else {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                if (entry.getKey().endsWith(\"loadbalance\")) {\n                    LoadBalance loadBalance = new LoadBalance();\n                    String method = null;\n                    if (entry.getKey().endsWith(\".loadbalance\")) {\n                        method = entry.getKey().split(\".loadbalance\")[0];\n                    } else {\n                        method = \"*\";\n                    }\n\n                    loadBalance.setMethod(method);\n                    loadBalance.setId(o.getId());\n                    loadBalance.setHash(o.getHash());\n                    loadBalance.setService(o.getService());\n                    loadBalance.setStrategy(entry.getValue());\n                    loadBalances.add(loadBalance);\n\n                }\n            }\n        }\n    }\n    return loadBalances;\n}",
                "name": "overridesToLoadBalances",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Override>",
                        "name": "overrides"
                    }
                ],
                "body": "{\n    List<LoadBalance> loadBalances = new ArrayList<LoadBalance>();\n    if (overrides == null) {\n        return loadBalances;\n    }\n    for (Override o : overrides) {\n        if (StringUtils.isEmpty(o.getParams())) {\n            continue;\n        } else {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                if (entry.getKey().endsWith(\"loadbalance\")) {\n                    LoadBalance loadBalance = new LoadBalance();\n                    String method = null;\n                    if (entry.getKey().endsWith(\".loadbalance\")) {\n                        method = entry.getKey().split(\".loadbalance\")[0];\n                    } else {\n                        method = \"*\";\n                    }\n\n                    loadBalance.setMethod(method);\n                    loadBalance.setId(o.getId());\n                    loadBalance.setHash(o.getHash());\n                    loadBalance.setService(o.getService());\n                    loadBalance.setStrategy(entry.getValue());\n                    loadBalances.add(loadBalance);\n\n                }\n            }\n        }\n    }\n    return loadBalances;\n}",
                "start_point": {
                    "row": 78,
                    "column": 4
                },
                "end_point": {
                    "row": 110,
                    "column": 5
                }
            },
            {
                "definition": "public static LoadBalance overrideToLoadBalance(Override override) {\n    List<LoadBalance> loadBalances = OverrideUtils.overridesToLoadBalances(Arrays.asList(override));\n    if (loadBalances != null && loadBalances.size() > 0) {\n        return loadBalances.get(0);\n    }\n    return null;\n}",
                "name": "overrideToLoadBalance",
                "modifiers": "public static",
                "return_type": "LoadBalance",
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    }
                ],
                "body": "{\n    List<LoadBalance> loadBalances = OverrideUtils.overridesToLoadBalances(Arrays.asList(override));\n    if (loadBalances != null && loadBalances.size() > 0) {\n        return loadBalances.get(0);\n    }\n    return null;\n}",
                "start_point": {
                    "row": 112,
                    "column": 4
                },
                "end_point": {
                    "row": 118,
                    "column": 5
                }
            },
            {
                "definition": "public static Override loadBalanceToOverride(LoadBalance loadBalance) {\n    Override override = new Override();\n    override.setId(loadBalance.getId());\n    override.setHash(loadBalance.getHash());\n    override.setService(loadBalance.getService());\n    override.setEnabled(true);\n    String method = loadBalance.getMethod();\n    String strategy = loadBalance.getStrategy();\n    if (StringUtils.isEmpty(method) || method.equals(\"*\")) {\n        override.setParams(\"loadbalance=\" + strategy);\n    } else {\n        override.setParams(method + \".loadbalance=\" + strategy);\n    }\n    return override;\n}",
                "name": "loadBalanceToOverride",
                "modifiers": "public static",
                "return_type": "Override",
                "parameters": [
                    {
                        "type": "LoadBalance",
                        "name": "loadBalance"
                    }
                ],
                "body": "{\n    Override override = new Override();\n    override.setId(loadBalance.getId());\n    override.setHash(loadBalance.getHash());\n    override.setService(loadBalance.getService());\n    override.setEnabled(true);\n    String method = loadBalance.getMethod();\n    String strategy = loadBalance.getStrategy();\n    if (StringUtils.isEmpty(method) || method.equals(\"*\")) {\n        override.setParams(\"loadbalance=\" + strategy);\n    } else {\n        override.setParams(method + \".loadbalance=\" + strategy);\n    }\n    return override;\n}",
                "start_point": {
                    "row": 120,
                    "column": 4
                },
                "end_point": {
                    "row": 134,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/common/util/ParseUtils.java",
        "definition": "public class ParseUtils {\n\n    private static final ConcurrentMap<String, Pattern>\n        REPLACE_PARAMETER_PATTERNS = new ConcurrentHashMap<String, Pattern>();\n    public static String METHOD_SPLIT = \",\";\n    private static Pattern VARIABLE_PATTERN = Pattern.compile(\n            \"\\\\$\\\\s*\\\\{?\\\\s*([\\\\._0-9a-zA-Z]+)\\\\s*\\\\}?\");\n    private static Pattern QUERY_PATTERN = Pattern\n            .compile(\"([&=]?)\\\\s*([^&=\\\\s]+)\");\n\n    private ParseUtils() {\n    }\n\n    /**\n     * Execute interpolation (variable insertion).\n     *\n     * @param expression Expression string containing variables. Variable names in expressions can also be enclosed in <code> {} </ code>\u3002\n     * @param params Variable set. Variable names can include <code>. </ Code>, <code> _ </ code> characters.\n     * @return After the completion of the interpolation string. Such as: <code> <pre> xxx $ {name} zzz -> xxxjerryzzz </ pre> </ code> (where the variable name = \"jerry\")\n     * @throws IllegalStateException The variables used in the expression string are not in the variable set\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static String interpolate(String expression, Map<String, String> params) {\n        if (expression == null || expression.length() == 0) {\n            throw new IllegalArgumentException(\"glob pattern is empty!\");\n        }\n        if (expression.indexOf('$') < 0) {\n            return expression;\n        }\n        Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) { // match one by one\n            String key = matcher.group(1);\n            String value = params == null ? null : params.get(key);\n            if (value == null) {\n                value = \"\";\n            }\n            matcher.appendReplacement(sb, value);\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static List<String> interpolate(List<String> expressions, Map<String, String> params) {\n        List<String> ret = new ArrayList<String>();\n\n        if (null == expressions || expressions.isEmpty()) {\n            return ret;\n        }\n\n        for (String expr : expressions) {\n            ret.add(interpolate(expr, params));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Match Glob mode. The current implementation only supports <code>*</ code> and supports only one. Does not support <code>?</ Code>.\n     * @return For code or value of <code> null </ code>, return <code> false </ code> directly.\n     */\n    public static boolean isMatchGlobPattern(String pattern, String value) {\n        if (\"*\".equals(pattern))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                && (value == null || value.length() == 0))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                || (value == null || value.length() == 0))\n            return false;\n\n        int i = pattern.lastIndexOf('*');\n        // No asterisk found\n        if (i == -1) {\n            return value.equals(pattern);\n        }\n        // Asterisk at the end\n        else if (i == pattern.length() - 1) {\n            return value.startsWith(pattern.substring(0, i));\n        }\n        // Asterisk at the beginning\n        else if (i == 0) {\n            return value.endsWith(pattern.substring(i + 1));\n        }\n        // Asterisk in the middle of the string\n        else {\n            String prefix = pattern.substring(0, i);\n            String suffix = pattern.substring(i + 1);\n            return value.startsWith(prefix) && value.endsWith(suffix);\n        }\n    }\n\n    /**\n     * Whether to match Glob mode. Glob mode is the expression to be interpolated. Glob pattern has more than one, as long as matching a pattern, that match is successful.\n     *\n     * @param patternsNeedInterpolate Multiple Glob patterns to interpolate\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param interpolateParams Set of variables used for interpolation\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param value Glob mode value\n     */\n    public static boolean isMatchGlobPatternsNeedInterpolate(\n        Collection<String> patternsNeedInterpolate,\n        Map<String, String> interpolateParams, String value) {\n        if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n            for (String patternNeedItp : patternsNeedInterpolate) {\n                if (StringUtils.isEmpty(patternNeedItp)) {\n                    continue;\n                }\n                // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n                // FIXME ERROR!! Should be confirmed with Liang Fei!!\n                String pattern = interpolate(patternNeedItp, interpolateParams);\n                if (isMatchGlobPattern(pattern, value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns the entries in the collection that match the Glob pattern.\n     */\n    public static Set<String> filterByGlobPattern(String pattern, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (pattern == null || values == null) {\n            return ret;\n        }\n\n        for (String v : values) {\n            if (isMatchGlobPattern(pattern, v)) {\n                ret.add(v);\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Find the string that matches the Glob pattern. Multiple patterns, as long as a match pattern, it returns this string.\n     */\n    public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n            return ret;\n        }\n\n        for (String p : patterns) {\n            for (String v : values) {\n                if (isMatchGlobPattern(p, v)) {\n                    ret.add(v);\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Whether two Glob patterns have intersection.\n     */\n    public static boolean hasIntersection(String glob1, String glob2) {\n        if (null == glob1 || null == glob2) {\n            return false;\n        }\n\n        if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n            int index1 = glob1.indexOf(\"*\");\n            int index2 = glob2.indexOf(\"*\");\n\n            String s11 = glob1.substring(0, index1);\n            String s12 = glob1.substring(index1 + 1, glob1.length());\n\n            String s21 = glob2.substring(0, index2);\n            String s22 = glob2.substring(index2 + 1, glob2.length());\n\n            if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n            if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n            return true;\n        } else if (glob1.contains(\"*\")) {\n            return isMatchGlobPattern(glob1, glob2);\n        } else if (glob2.contains(\"*\")) {\n            return isMatchGlobPattern(glob2, glob1);\n        } else {\n            return glob1.equals(glob2);\n        }\n    }\n\n    /**\n     * Parse Query String into Map. For strings that have only Key, key3 = </ code> is ignored.\n     *\n     * @param keyPrefix In the output of the Map Key plus a unified prefix.\n     * @param query Query String\uff0cFor example: <code>key1=value1&key2=value2</code>\n     * @return When Query String is <code>key1=value1&key2=value2</code>, and prefix is <code>pre.</code>,\n     *         then <code>Map{pre.key1=value1, pre.key=value2}</code> will be returned.\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static Map<String, String> parseQuery(String keyPrefix, String query) {\n        if (query == null)\n            return new HashMap<String, String>();\n        if (keyPrefix == null)\n            keyPrefix = \"\";\n\n        Matcher matcher = QUERY_PATTERN.matcher(query);\n        Map<String, String> routeQuery = new HashMap<String, String>();\n        String key = null;\n        while (matcher.find()) { // Match one by one\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            if (separator == null || separator.length() == 0\n                    || \"&\".equals(separator)) {\n                if (key != null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                key = content;\n            } else if (\"=\".equals(separator)) {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                routeQuery.put(keyPrefix + key, content);\n                key = null;\n            } else {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n            }\n        }\n        /*if (key != null)\n        throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n                + \"\\\", The error in the end char: \" + key);*/\n        return routeQuery;\n    }\n\n    public static Map<String, String> parseQuery(String query) {\n        return parseQuery(\"\", query);\n    }\n\n    /**\n     * Replace the value of the url parameter.\n     */\n    public static String replaceParameter(String query, String key, String value) {\n        if (query == null || query.length() == 0) {\n            return key + \"=\" + value;\n        }\n        if (query.indexOf(key + \"=\") == -1) {\n            return query + \"&\" + key + \"=\" + value;\n        }\n        Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n        if (pattern == null) {\n            pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n        }\n        Matcher matcher = pattern.matcher(query);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static String appendParamToUri(String uri, String name, String value) {\n        if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n        if (uri.indexOf('?') != -1) {\n            uri += \"&\" + name + \"=\" + value;\n        } else {\n            uri += \"?\" + name + \"=\" + value;\n        }\n        return uri;\n    }\n\n    public static String appendParamsToUri(String uri, Map<String, String> params) {\n        StringBuilder buf = new StringBuilder(uri);\n        boolean first = (uri.indexOf('?') < 0);\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n                continue;\n            if (first) {\n                buf.append(\"?\");\n                first = false;\n            } else {\n                buf.append(\"&\");\n            }\n            buf.append(key);\n            buf.append(\"=\");\n            buf.append(value);\n        }\n        return buf.toString();\n    }\n\n    public static boolean matchEndStarPattern(String value, String pattern) {\n        if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n        String perfix = pattern.substring(0, pattern.length() - 1);\n        return value.startsWith(perfix);\n    }\n}",
        "package": "package org.apache.dubbo.admin.common.util;",
        "tree_path": "ParseUtils",
        "name": "ParseUtils",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private static final ConcurrentMap<String, Pattern>\n        REPLACE_PARAMETER_PATTERNS = new ConcurrentHashMap<String, Pattern>();\n    public static String METHOD_SPLIT = \",\";\n    private static Pattern VARIABLE_PATTERN = Pattern.compile(\n            \"\\\\$\\\\s*\\\\{?\\\\s*([\\\\._0-9a-zA-Z]+)\\\\s*\\\\}?\");\n    private static Pattern QUERY_PATTERN = Pattern\n            .compile(\"([&=]?)\\\\s*([^&=\\\\s]+)\");\n\n    private ParseUtils() {\n    }\n\n    /**\n     * Execute interpolation (variable insertion).\n     *\n     * @param expression Expression string containing variables. Variable names in expressions can also be enclosed in <code> {} </ code>\u3002\n     * @param params Variable set. Variable names can include <code>. </ Code>, <code> _ </ code> characters.\n     * @return After the completion of the interpolation string. Such as: <code> <pre> xxx $ {name} zzz -> xxxjerryzzz </ pre> </ code> (where the variable name = \"jerry\")\n     * @throws IllegalStateException The variables used in the expression string are not in the variable set\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static String interpolate(String expression, Map<String, String> params) {\n        if (expression == null || expression.length() == 0) {\n            throw new IllegalArgumentException(\"glob pattern is empty!\");\n        }\n        if (expression.indexOf('$') < 0) {\n            return expression;\n        }\n        Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) { // match one by one\n            String key = matcher.group(1);\n            String value = params == null ? null : params.get(key);\n            if (value == null) {\n                value = \"\";\n            }\n            matcher.appendReplacement(sb, value);\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static List<String> interpolate(List<String> expressions, Map<String, String> params) {\n        List<String> ret = new ArrayList<String>();\n\n        if (null == expressions || expressions.isEmpty()) {\n            return ret;\n        }\n\n        for (String expr : expressions) {\n            ret.add(interpolate(expr, params));\n        }\n\n        return ret;\n    }\n\n    /**\n     * Match Glob mode. The current implementation only supports <code>*</ code> and supports only one. Does not support <code>?</ Code>.\n     * @return For code or value of <code> null </ code>, return <code> false </ code> directly.\n     */\n    public static boolean isMatchGlobPattern(String pattern, String value) {\n        if (\"*\".equals(pattern))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                && (value == null || value.length() == 0))\n            return true;\n        if ((pattern == null || pattern.length() == 0)\n                || (value == null || value.length() == 0))\n            return false;\n\n        int i = pattern.lastIndexOf('*');\n        // No asterisk found\n        if (i == -1) {\n            return value.equals(pattern);\n        }\n        // Asterisk at the end\n        else if (i == pattern.length() - 1) {\n            return value.startsWith(pattern.substring(0, i));\n        }\n        // Asterisk at the beginning\n        else if (i == 0) {\n            return value.endsWith(pattern.substring(i + 1));\n        }\n        // Asterisk in the middle of the string\n        else {\n            String prefix = pattern.substring(0, i);\n            String suffix = pattern.substring(i + 1);\n            return value.startsWith(prefix) && value.endsWith(suffix);\n        }\n    }\n\n    /**\n     * Whether to match Glob mode. Glob mode is the expression to be interpolated. Glob pattern has more than one, as long as matching a pattern, that match is successful.\n     *\n     * @param patternsNeedInterpolate Multiple Glob patterns to interpolate\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param interpolateParams Set of variables used for interpolation\n    \u00a0\u00a0\u00a0\u00a0\u00a0* @param value Glob mode value\n     */\n    public static boolean isMatchGlobPatternsNeedInterpolate(\n        Collection<String> patternsNeedInterpolate,\n        Map<String, String> interpolateParams, String value) {\n        if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n            for (String patternNeedItp : patternsNeedInterpolate) {\n                if (StringUtils.isEmpty(patternNeedItp)) {\n                    continue;\n                }\n                // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n                // FIXME ERROR!! Should be confirmed with Liang Fei!!\n                String pattern = interpolate(patternNeedItp, interpolateParams);\n                if (isMatchGlobPattern(pattern, value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns the entries in the collection that match the Glob pattern.\n     */\n    public static Set<String> filterByGlobPattern(String pattern, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (pattern == null || values == null) {\n            return ret;\n        }\n\n        for (String v : values) {\n            if (isMatchGlobPattern(pattern, v)) {\n                ret.add(v);\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Find the string that matches the Glob pattern. Multiple patterns, as long as a match pattern, it returns this string.\n     */\n    public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values) {\n        Set<String> ret = new HashSet<String>();\n        if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n            return ret;\n        }\n\n        for (String p : patterns) {\n            for (String v : values) {\n                if (isMatchGlobPattern(p, v)) {\n                    ret.add(v);\n                }\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Whether two Glob patterns have intersection.\n     */\n    public static boolean hasIntersection(String glob1, String glob2) {\n        if (null == glob1 || null == glob2) {\n            return false;\n        }\n\n        if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n            int index1 = glob1.indexOf(\"*\");\n            int index2 = glob2.indexOf(\"*\");\n\n            String s11 = glob1.substring(0, index1);\n            String s12 = glob1.substring(index1 + 1, glob1.length());\n\n            String s21 = glob2.substring(0, index2);\n            String s22 = glob2.substring(index2 + 1, glob2.length());\n\n            if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n            if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n            return true;\n        } else if (glob1.contains(\"*\")) {\n            return isMatchGlobPattern(glob1, glob2);\n        } else if (glob2.contains(\"*\")) {\n            return isMatchGlobPattern(glob2, glob1);\n        } else {\n            return glob1.equals(glob2);\n        }\n    }\n\n    /**\n     * Parse Query String into Map. For strings that have only Key, key3 = </ code> is ignored.\n     *\n     * @param keyPrefix In the output of the Map Key plus a unified prefix.\n     * @param query Query String\uff0cFor example: <code>key1=value1&key2=value2</code>\n     * @return When Query String is <code>key1=value1&key2=value2</code>, and prefix is <code>pre.</code>,\n     *         then <code>Map{pre.key1=value1, pre.key=value2}</code> will be returned.\n     */\n    // FIXME Is it reasonable to throw an IllegalStateException??\n    public static Map<String, String> parseQuery(String keyPrefix, String query) {\n        if (query == null)\n            return new HashMap<String, String>();\n        if (keyPrefix == null)\n            keyPrefix = \"\";\n\n        Matcher matcher = QUERY_PATTERN.matcher(query);\n        Map<String, String> routeQuery = new HashMap<String, String>();\n        String key = null;\n        while (matcher.find()) { // Match one by one\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            if (separator == null || separator.length() == 0\n                    || \"&\".equals(separator)) {\n                if (key != null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                key = content;\n            } else if (\"=\".equals(separator)) {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n                routeQuery.put(keyPrefix + key, content);\n                key = null;\n            } else {\n                if (key == null)\n                    throw new IllegalStateException(\"Illegal query string \\\"\"\n                            + query + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\");\n            }\n        }\n        /*if (key != null)\n        throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n                + \"\\\", The error in the end char: \" + key);*/\n        return routeQuery;\n    }\n\n    public static Map<String, String> parseQuery(String query) {\n        return parseQuery(\"\", query);\n    }\n\n    /**\n     * Replace the value of the url parameter.\n     */\n    public static String replaceParameter(String query, String key, String value) {\n        if (query == null || query.length() == 0) {\n            return key + \"=\" + value;\n        }\n        if (query.indexOf(key + \"=\") == -1) {\n            return query + \"&\" + key + \"=\" + value;\n        }\n        Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n        if (pattern == null) {\n            pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n        }\n        Matcher matcher = pattern.matcher(query);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n        }\n        matcher.appendTail(sb);\n        return sb.toString();\n    }\n\n    public static String appendParamToUri(String uri, String name, String value) {\n        if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n        if (uri.indexOf('?') != -1) {\n            uri += \"&\" + name + \"=\" + value;\n        } else {\n            uri += \"?\" + name + \"=\" + value;\n        }\n        return uri;\n    }\n\n    public static String appendParamsToUri(String uri, Map<String, String> params) {\n        StringBuilder buf = new StringBuilder(uri);\n        boolean first = (uri.indexOf('?') < 0);\n        for (Map.Entry<String, String> entry : params.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n                continue;\n            if (first) {\n                buf.append(\"?\");\n                first = false;\n            } else {\n                buf.append(\"&\");\n            }\n            buf.append(key);\n            buf.append(\"=\");\n            buf.append(value);\n        }\n        return buf.toString();\n    }\n\n    public static boolean matchEndStarPattern(String value, String pattern) {\n        if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n        String perfix = pattern.substring(0, pattern.length() - 1);\n        return value.startsWith(perfix);\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 328,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "private ParseUtils() {\n}",
                "name": "ParseUtils",
                "modifiers": "private",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 41,
                    "column": 5
                }
            },
            {
                "definition": "public static String interpolate(String expression, Map<String, String> params) {\n    if (expression == null || expression.length() == 0) {\n        throw new IllegalArgumentException(\"glob pattern is empty!\");\n    }\n    if (expression.indexOf('$') < 0) {\n        return expression;\n    }\n    Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) { // match one by one\n        String key = matcher.group(1);\n        String value = params == null ? null : params.get(key);\n        if (value == null) {\n            value = \"\";\n        }\n        matcher.appendReplacement(sb, value);\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "name": "interpolate",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "expression"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "params"
                    }
                ],
                "body": "{\n    if (expression == null || expression.length() == 0) {\n        throw new IllegalArgumentException(\"glob pattern is empty!\");\n    }\n    if (expression.indexOf('$') < 0) {\n        return expression;\n    }\n    Matcher matcher = VARIABLE_PATTERN.matcher(expression);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) { // match one by one\n        String key = matcher.group(1);\n        String value = params == null ? null : params.get(key);\n        if (value == null) {\n            value = \"\";\n        }\n        matcher.appendReplacement(sb, value);\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "public static List<String> interpolate(List<String> expressions, Map<String, String> params) {\n    List<String> ret = new ArrayList<String>();\n\n    if (null == expressions || expressions.isEmpty()) {\n        return ret;\n    }\n\n    for (String expr : expressions) {\n        ret.add(interpolate(expr, params));\n    }\n\n    return ret;\n}",
                "name": "interpolate",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<String>",
                        "name": "expressions"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "params"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n\n    if (null == expressions || expressions.isEmpty()) {\n        return ret;\n    }\n\n    for (String expr : expressions) {\n        ret.add(interpolate(expr, params));\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 85,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean isMatchGlobPattern(String pattern, String value) {\n    if (\"*\".equals(pattern))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            && (value == null || value.length() == 0))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            || (value == null || value.length() == 0))\n        return false;\n\n    int i = pattern.lastIndexOf('*');\n    // No asterisk found\n    if (i == -1) {\n        return value.equals(pattern);\n    }\n    // Asterisk at the end\n    else if (i == pattern.length() - 1) {\n        return value.startsWith(pattern.substring(0, i));\n    }\n    // Asterisk at the beginning\n    else if (i == 0) {\n        return value.endsWith(pattern.substring(i + 1));\n    }\n    // Asterisk in the middle of the string\n    else {\n        String prefix = pattern.substring(0, i);\n        String suffix = pattern.substring(i + 1);\n        return value.startsWith(prefix) && value.endsWith(suffix);\n    }\n}",
                "name": "isMatchGlobPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "pattern"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (\"*\".equals(pattern))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            && (value == null || value.length() == 0))\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            || (value == null || value.length() == 0))\n        return false;\n\n    int i = pattern.lastIndexOf('*');\n    // No asterisk found\n    if (i == -1) {\n        return value.equals(pattern);\n    }\n    // Asterisk at the end\n    else if (i == pattern.length() - 1) {\n        return value.startsWith(pattern.substring(0, i));\n    }\n    // Asterisk at the beginning\n    else if (i == 0) {\n        return value.endsWith(pattern.substring(i + 1));\n    }\n    // Asterisk in the middle of the string\n    else {\n        String prefix = pattern.substring(0, i);\n        String suffix = pattern.substring(i + 1);\n        return value.startsWith(prefix) && value.endsWith(suffix);\n    }\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 120,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean isMatchGlobPatternsNeedInterpolate(\n    Collection<String> patternsNeedInterpolate,\n    Map<String, String> interpolateParams, String value) {\n    if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n        for (String patternNeedItp : patternsNeedInterpolate) {\n            if (StringUtils.isEmpty(patternNeedItp)) {\n                continue;\n            }\n            // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n            // FIXME ERROR!! Should be confirmed with Liang Fei!!\n            String pattern = interpolate(patternNeedItp, interpolateParams);\n            if (isMatchGlobPattern(pattern, value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
                "name": "isMatchGlobPatternsNeedInterpolate",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "patternsNeedInterpolate"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "interpolateParams"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (patternsNeedInterpolate != null && !patternsNeedInterpolate.isEmpty()) {\n        for (String patternNeedItp : patternsNeedInterpolate) {\n            if (StringUtils.isEmpty(patternNeedItp)) {\n                continue;\n            }\n            // FIXME ERROR!! The original implementation, here and only the first non-blank pattern comparison, return the corresponding result!\n            // FIXME ERROR!! Should be confirmed with Liang Fei!!\n            String pattern = interpolate(patternNeedItp, interpolateParams);\n            if (isMatchGlobPattern(pattern, value)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "public static Set<String> filterByGlobPattern(String pattern, Collection<String> values) {\n    Set<String> ret = new HashSet<String>();\n    if (pattern == null || values == null) {\n        return ret;\n    }\n\n    for (String v : values) {\n        if (isMatchGlobPattern(pattern, v)) {\n            ret.add(v);\n        }\n    }\n    return ret;\n}",
                "name": "filterByGlobPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "pattern"
                    },
                    {
                        "type": "Collection<String>",
                        "name": "values"
                    }
                ],
                "body": "{\n    Set<String> ret = new HashSet<String>();\n    if (pattern == null || values == null) {\n        return ret;\n    }\n\n    for (String v : values) {\n        if (isMatchGlobPattern(pattern, v)) {\n            ret.add(v);\n        }\n    }\n    return ret;\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 163,
                    "column": 5
                }
            },
            {
                "definition": "public static Set<String> filterByGlobPattern(Collection<String> patterns, Collection<String> values) {\n    Set<String> ret = new HashSet<String>();\n    if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n        return ret;\n    }\n\n    for (String p : patterns) {\n        for (String v : values) {\n            if (isMatchGlobPattern(p, v)) {\n                ret.add(v);\n            }\n        }\n    }\n    return ret;\n}",
                "name": "filterByGlobPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "patterns"
                    },
                    {
                        "type": "Collection<String>",
                        "name": "values"
                    }
                ],
                "body": "{\n    Set<String> ret = new HashSet<String>();\n    if (null == patterns || values == null || patterns.isEmpty() || values.isEmpty()) {\n        return ret;\n    }\n\n    for (String p : patterns) {\n        for (String v : values) {\n            if (isMatchGlobPattern(p, v)) {\n                ret.add(v);\n            }\n        }\n    }\n    return ret;\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 182,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean hasIntersection(String glob1, String glob2) {\n    if (null == glob1 || null == glob2) {\n        return false;\n    }\n\n    if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n        int index1 = glob1.indexOf(\"*\");\n        int index2 = glob2.indexOf(\"*\");\n\n        String s11 = glob1.substring(0, index1);\n        String s12 = glob1.substring(index1 + 1, glob1.length());\n\n        String s21 = glob2.substring(0, index2);\n        String s22 = glob2.substring(index2 + 1, glob2.length());\n\n        if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n        if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n        return true;\n    } else if (glob1.contains(\"*\")) {\n        return isMatchGlobPattern(glob1, glob2);\n    } else if (glob2.contains(\"*\")) {\n        return isMatchGlobPattern(glob2, glob1);\n    } else {\n        return glob1.equals(glob2);\n    }\n}",
                "name": "hasIntersection",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "glob1"
                    },
                    {
                        "type": "String",
                        "name": "glob2"
                    }
                ],
                "body": "{\n    if (null == glob1 || null == glob2) {\n        return false;\n    }\n\n    if (glob1.contains(\"*\") && glob2.contains(\"*\")) {\n        int index1 = glob1.indexOf(\"*\");\n        int index2 = glob2.indexOf(\"*\");\n\n        String s11 = glob1.substring(0, index1);\n        String s12 = glob1.substring(index1 + 1, glob1.length());\n\n        String s21 = glob2.substring(0, index2);\n        String s22 = glob2.substring(index2 + 1, glob2.length());\n\n        if (!s11.startsWith(s21) && !s21.startsWith(s11)) return false;\n        if (!s12.endsWith(s22) && !s22.endsWith(s12)) return false;\n        return true;\n    } else if (glob1.contains(\"*\")) {\n        return isMatchGlobPattern(glob1, glob2);\n    } else if (glob2.contains(\"*\")) {\n        return isMatchGlobPattern(glob2, glob1);\n    } else {\n        return glob1.equals(glob2);\n    }\n}",
                "start_point": {
                    "row": 187,
                    "column": 4
                },
                "end_point": {
                    "row": 212,
                    "column": 5
                }
            },
            {
                "definition": "public static Map<String, String> parseQuery(String keyPrefix, String query) {\n    if (query == null)\n        return new HashMap<String, String>();\n    if (keyPrefix == null)\n        keyPrefix = \"\";\n\n    Matcher matcher = QUERY_PATTERN.matcher(query);\n    Map<String, String> routeQuery = new HashMap<String, String>();\n    String key = null;\n    while (matcher.find()) { // Match one by one\n        String separator = matcher.group(1);\n        String content = matcher.group(2);\n        if (separator == null || separator.length() == 0\n                || \"&\".equals(separator)) {\n            if (key != null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            key = content;\n        } else if (\"=\".equals(separator)) {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            routeQuery.put(keyPrefix + key, content);\n            key = null;\n        } else {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n        }\n    }\n    /*if (key != null)\n    throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n            + \"\\\", The error in the end char: \" + key);*/\n    return routeQuery;\n}",
                "name": "parseQuery",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "keyPrefix"
                    },
                    {
                        "type": "String",
                        "name": "query"
                    }
                ],
                "body": "{\n    if (query == null)\n        return new HashMap<String, String>();\n    if (keyPrefix == null)\n        keyPrefix = \"\";\n\n    Matcher matcher = QUERY_PATTERN.matcher(query);\n    Map<String, String> routeQuery = new HashMap<String, String>();\n    String key = null;\n    while (matcher.find()) { // Match one by one\n        String separator = matcher.group(1);\n        String content = matcher.group(2);\n        if (separator == null || separator.length() == 0\n                || \"&\".equals(separator)) {\n            if (key != null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            key = content;\n        } else if (\"=\".equals(separator)) {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n            routeQuery.put(keyPrefix + key, content);\n            key = null;\n        } else {\n            if (key == null)\n                throw new IllegalStateException(\"Illegal query string \\\"\"\n                        + query + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\");\n        }\n    }\n    /*if (key != null)\n    throw new IllegalStateException(\"Illegal route rule \\\"\" + query\n            + \"\\\", The error in the end char: \" + key);*/\n    return routeQuery;\n}",
                "start_point": {
                    "row": 223,
                    "column": 4
                },
                "end_point": {
                    "row": 263,
                    "column": 5
                }
            },
            {
                "definition": "public static Map<String, String> parseQuery(String query) {\n    return parseQuery(\"\", query);\n}",
                "name": "parseQuery",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "query"
                    }
                ],
                "body": "{\n    return parseQuery(\"\", query);\n}",
                "start_point": {
                    "row": 265,
                    "column": 4
                },
                "end_point": {
                    "row": 267,
                    "column": 5
                }
            },
            {
                "definition": "public static String replaceParameter(String query, String key, String value) {\n    if (query == null || query.length() == 0) {\n        return key + \"=\" + value;\n    }\n    if (query.indexOf(key + \"=\") == -1) {\n        return query + \"&\" + key + \"=\" + value;\n    }\n    Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n    if (pattern == null) {\n        pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n    }\n    Matcher matcher = pattern.matcher(query);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) {\n        matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "name": "replaceParameter",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "query"
                    },
                    {
                        "type": "String",
                        "name": "key"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (query == null || query.length() == 0) {\n        return key + \"=\" + value;\n    }\n    if (query.indexOf(key + \"=\") == -1) {\n        return query + \"&\" + key + \"=\" + value;\n    }\n    Pattern pattern = REPLACE_PARAMETER_PATTERNS.get(key);\n    if (pattern == null) {\n        pattern = Pattern.compile(key.replaceAll(\"([^(_0-9A-Za-z)])\", \"\\\\\\\\$0\") + \"=[^&]+\");\n    }\n    Matcher matcher = pattern.matcher(query);\n    StringBuffer sb = new StringBuffer();\n    while (matcher.find()) {\n        matcher.appendReplacement(sb, (key + \"=\" + value).replace(\"$\", \"\\\\$\"));\n    }\n    matcher.appendTail(sb);\n    return sb.toString();\n}",
                "start_point": {
                    "row": 272,
                    "column": 4
                },
                "end_point": {
                    "row": 290,
                    "column": 5
                }
            },
            {
                "definition": "public static String appendParamToUri(String uri, String name, String value) {\n    if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n    if (uri.indexOf('?') != -1) {\n        uri += \"&\" + name + \"=\" + value;\n    } else {\n        uri += \"?\" + name + \"=\" + value;\n    }\n    return uri;\n}",
                "name": "appendParamToUri",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "uri"
                    },
                    {
                        "type": "String",
                        "name": "name"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    if (StringUtils.isEmpty(name) || StringUtils.isEmpty(value)) return uri;\n    if (uri.indexOf('?') != -1) {\n        uri += \"&\" + name + \"=\" + value;\n    } else {\n        uri += \"?\" + name + \"=\" + value;\n    }\n    return uri;\n}",
                "start_point": {
                    "row": 292,
                    "column": 4
                },
                "end_point": {
                    "row": 300,
                    "column": 5
                }
            },
            {
                "definition": "public static String appendParamsToUri(String uri, Map<String, String> params) {\n    StringBuilder buf = new StringBuilder(uri);\n    boolean first = (uri.indexOf('?') < 0);\n    for (Map.Entry<String, String> entry : params.entrySet()) {\n        String key = entry.getKey();\n        String value = entry.getValue();\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n            continue;\n        if (first) {\n            buf.append(\"?\");\n            first = false;\n        } else {\n            buf.append(\"&\");\n        }\n        buf.append(key);\n        buf.append(\"=\");\n        buf.append(value);\n    }\n    return buf.toString();\n}",
                "name": "appendParamsToUri",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "uri"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "params"
                    }
                ],
                "body": "{\n    StringBuilder buf = new StringBuilder(uri);\n    boolean first = (uri.indexOf('?') < 0);\n    for (Map.Entry<String, String> entry : params.entrySet()) {\n        String key = entry.getKey();\n        String value = entry.getValue();\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value))\n            continue;\n        if (first) {\n            buf.append(\"?\");\n            first = false;\n        } else {\n            buf.append(\"&\");\n        }\n        buf.append(key);\n        buf.append(\"=\");\n        buf.append(value);\n    }\n    return buf.toString();\n}",
                "start_point": {
                    "row": 302,
                    "column": 4
                },
                "end_point": {
                    "row": 321,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean matchEndStarPattern(String value, String pattern) {\n    if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n    String perfix = pattern.substring(0, pattern.length() - 1);\n    return value.startsWith(perfix);\n}",
                "name": "matchEndStarPattern",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "value"
                    },
                    {
                        "type": "String",
                        "name": "pattern"
                    }
                ],
                "body": "{\n    if (!pattern.endsWith(\"*\")) throw new IllegalArgumentException(\"not end star pattern!\");\n    String perfix = pattern.substring(0, pattern.length() - 1);\n    return value.startsWith(perfix);\n}",
                "start_point": {
                    "row": 323,
                    "column": 4
                },
                "end_point": {
                    "row": 327,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/common/util/RouteRule.java",
        "definition": "public class RouteRule {\n    @SuppressWarnings(\"unchecked\")\n    static RouteRule EMPTY = new RouteRule(Collections.EMPTY_MAP, Collections.EMPTY_MAP);\n    private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\");\n    private static Pattern CONDITION_SEPERATOR = Pattern.compile(\"(.*)=>(.*)\");\n    private static Pattern VALUE_LIST_SEPARATOR = Pattern.compile(\"\\\\s*,\\\\s*\");\n    final Map<String, MatchPair> whenCondition;\n    final Map<String, MatchPair> thenCondition;\n    private volatile String tostring = null;\n\n    // FIXME\n    private RouteRule(Map<String, MatchPair> when, Map<String, MatchPair> then) {\n        for (Map.Entry<String, MatchPair> entry : when.entrySet()) {\n            entry.getValue().freeze();\n        }\n        for (Map.Entry<String, MatchPair> entry : then.entrySet()) {\n            entry.getValue().freeze();\n        }\n\n        // NOTE: Both When Condition and Then Condition can be null\n        this.whenCondition = when;\n        this.thenCondition = then;\n    }\n\n    public static Map<String, MatchPair> parseRule(String rule)\n            throws ParseException {\n        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n        if (StringUtils.isBlank(rule)) {\n            return condition;\n        }\n        // K-V pair, contains matches part and mismatches part\n        MatchPair pair = null;\n        // V part has multiple values\n        Set<String> values = null;\n        final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n        while (matcher.find()) { // match one by one\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            // The expression starts\n            if (separator == null || separator.length() == 0) {\n                pair = new MatchPair();\n                condition.put(content, pair);\n            }\n            // The KV starts\n            else if (\"&\".equals(separator)) {\n                if (condition.get(content) == null) {\n                    pair = new MatchPair();\n                    condition.put(content, pair);\n                } else {\n                    condition.put(content, pair);\n                }\n\n            }\n            // The Value part of KV starts\n            else if (\"=\".equals(separator)) {\n                if (pair == null)\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n\n                values = pair.matches;\n                values.add(content);\n            }\n            // The Value part of KV starts\n            else if (\"!=\".equals(separator)) {\n                if (pair == null)\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n\n                values = pair.unmatches;\n                values.add(content);\n            }\n            // The Value part of KV has multiple values, separated by ','\n            else if (\",\".equals(separator)) { // separated by ','\n                if (values == null || values.size() == 0)\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                values.add(content);\n            } else {\n                throw new ParseException(\"Illegal route rule \\\"\" + rule\n                        + \"\\\", The error char '\" + separator + \"' at index \"\n                        + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start());\n            }\n        }\n        return condition;\n    }\n\n    /**\n     * Parse the RouteRule as a string into an object.\n     *\n     * @throws ParseException RouteRule string format is wrong. The following input conditions, RouteRule are illegal.\n     * <ul> <li> input is <code>null</code>\u3002\n     * <li> input is \"\" or \" \"\u3002\n     * <li> input Rule doesn't have a When Condition\n     * <li> input Rule doesn't have a Then Condition\n     * </ul>\n     */\n    public static RouteRule parse(Route route) throws ParseException {\n        if (route == null)\n            throw new ParseException(\"null route!\", 0);\n\n        if (route.getMatchRule() == null && route.getFilterRule() == null) {\n            return parse(route.getRule());\n        }\n\n        return parse(route == null ? null : route.getMatchRule(), route == null ? null : route.getFilterRule());\n    }\n\n    public static RouteRule parse(String whenRule, String thenRule) throws ParseException {\n        /*if (whenRule == null || whenRule.trim().length() == 0) {\n            throw new ParseException(\"Illegal route rule without when express\", 0);\n    \t}*/\n        if (thenRule == null || thenRule.trim().length() == 0) {\n            throw new ParseException(\"Illegal route rule without then express\", 0);\n        }\n        Map<String, MatchPair> when = parseRule(whenRule.trim());\n        Map<String, MatchPair> then = parseRule(thenRule.trim());\n        return new RouteRule(when, then);\n    }\n\n    public static RouteRule parse(String rule) throws ParseException {\n        if (StringUtils.isBlank(rule)) {\n            throw new ParseException(\"Illegal blank route rule\", 0);\n        }\n\n        final Matcher matcher = CONDITION_SEPERATOR.matcher(rule);\n        if (!matcher.matches()) throw new ParseException(\"condition seperator => not found!\", 0);\n\n        return parse(matcher.group(1), matcher.group(2));\n    }\n\n    /**\n     * @see #parse(String)\n     * @throws RuntimeException This is an wrapper exception for the {@link ParseException} thrown by the {@link #parse (String)} method.\n     */\n    public static RouteRule parseQuitely(Route route) {\n        try {\n            return parse(route);\n        } catch (ParseException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static Map<String, MatchPair> parseNameAndValueListString2Condition(Map<String, String> params, Map<String, String> notParams) {\n        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n\n        for (Entry<String, String> entry : params.entrySet()) {\n            String valueListString = entry.getValue();\n            if (StringUtils.isBlank(valueListString)) {\n                continue;\n            }\n            String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n            Set<String> set = new HashSet<String>();\n            for (String item : list) {\n                if (StringUtils.isBlank(item)) {\n                    continue;\n                }\n                set.add(item.trim());\n            }\n            if (set.isEmpty()) {\n                continue;\n            }\n\n            String key = entry.getKey();\n            MatchPair matchPair = condition.get(key);\n            if (null == matchPair) {\n                matchPair = new MatchPair();\n                condition.put(key, matchPair);\n            }\n\n            matchPair.matches = set;\n        }\n        for (Entry<String, String> entry : notParams.entrySet()) {\n            String valueListString = entry.getValue();\n            if (StringUtils.isBlank(valueListString)) {\n                continue;\n            }\n            String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n            Set<String> set = new HashSet<String>();\n            for (String item : list) {\n                if (StringUtils.isBlank(item)) {\n                    continue;\n                }\n                set.add(item.trim());\n            }\n            if (set.isEmpty()) {\n                continue;\n            }\n\n            String key = entry.getKey();\n            MatchPair matchPair = condition.get(key);\n            if (null == matchPair) {\n                matchPair = new MatchPair();\n                condition.put(key, matchPair);\n            }\n\n            matchPair.unmatches = set;\n        }\n\n        return condition;\n    }\n\n    public static RouteRule createFromNameAndValueListString(Map<String, String> whenParams, Map<String, String> notWhenParams,\n                                                             Map<String, String> thenParams, Map<String, String> notThenParams) {\n        Map<String, MatchPair> when = parseNameAndValueListString2Condition(whenParams, notWhenParams);\n        Map<String, MatchPair> then = parseNameAndValueListString2Condition(thenParams, notThenParams);\n\n        return new RouteRule(when, then);\n    }\n\n    public static RouteRule createFromCondition(Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition) {\n        return new RouteRule(whenCondition, thenCondition);\n    }\n\n    public static RouteRule copyWithRemove(RouteRule copy, Set<String> whenParams, Set<String> thenParams) {\n        Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n        for (Entry<String, MatchPair> entry : copy.getWhenCondition().entrySet()) {\n            if (whenParams == null || !whenParams.contains(entry.getKey())) {\n                when.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n        for (Entry<String, MatchPair> entry : copy.getThenCondition().entrySet()) {\n            if (thenParams == null || !thenParams.contains(entry.getKey())) {\n                then.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return new RouteRule(when, then);\n    }\n\n    /**\n     * Replace with the new condition value.\n     *\n     * @param copy Replace Base\n     * @param whenCondition WhenCondition to replace, if Base does not have an item, insert it directly.\n     * @param thenCondition ThenCondition to replace, if Base has no items, then insert directly.\n     * @return RouteRule after replacement\n     */\n    public static RouteRule copyWithReplace(RouteRule copy, Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition) {\n        if (null == copy) {\n            throw new NullPointerException(\"Argument copy is null!\");\n        }\n\n        Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n        when.putAll(copy.getWhenCondition());\n        if (whenCondition != null) {\n            when.putAll(whenCondition);\n        }\n\n        Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n        then.putAll(copy.getThenCondition());\n        if (thenCondition != null) {\n            then.putAll(thenCondition);\n        }\n\n        return new RouteRule(when, then);\n    }\n\n    // TODO ToString out of the current list is out of order, should we sort?\n    static void join(StringBuilder sb, Set<String> valueSet) {\n        boolean isFirst = true;\n        for (String s : valueSet) {\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(\",\");\n            }\n\n            sb.append(s);\n        }\n    }\n\n    /**\n     * Whether the sample passed the conditions.\n     * <p>\n     * If there is a Key in the KV for the sample, there is a corresponding MatchPair, and Value does not pass through MatchPair; {@code false} is returned; otherwise, {@code true} is returned.\n     *\n     * @see MatchPair#pass(String)\n     */\n    public static boolean matchCondition(Map<String, String> sample,\n                                         Map<String, MatchPair> condition) {\n        for (Map.Entry<String, String> entry : sample.entrySet()) {\n            String key = entry.getKey();\n\n            MatchPair pair = condition.get(key);\n            if (pair != null && !pair.pass(entry.getValue())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    // FIXME Remove such method calls\n    public static String join(Set<String> valueSet) {\n        StringBuilder sb = new StringBuilder(128);\n        join(sb, valueSet);\n        return sb.toString();\n    }\n\n    // TODO At present, the multiple Key of Condition is in disorder. Should we sort it?\n    public static void contidionToString(StringBuilder sb, Map<String, MatchPair> condition) {\n        boolean isFirst = true;\n        for (Entry<String, MatchPair> entry : condition.entrySet()) {\n            String keyName = entry.getKey();\n            MatchPair p = entry.getValue();\n\n            @SuppressWarnings(\"unchecked\")\n            Set<String>[] setArray = new Set[]{p.matches, p.unmatches};\n            String[] opArray = {\" = \", \" != \"};\n\n            for (int i = 0; i < setArray.length; ++i) {\n                if (setArray[i].isEmpty()) {\n                    continue;\n                }\n                if (isFirst) {\n                    isFirst = false;\n                } else {\n                    sb.append(\" & \");\n                }\n\n                sb.append(keyName);\n                sb.append(opArray[i]);\n                join(sb, setArray[i]);\n            }\n        }\n    }\n\n    public boolean isWhenContainValue(String key, String value) {\n        MatchPair matchPair = whenCondition.get(key);\n        if (null == matchPair) {\n            return false;\n        }\n\n        return matchPair.containeValue(value);\n    }\n\n    public boolean isThenContainValue(String key, String value) {\n        MatchPair matchPair = thenCondition.get(key);\n        if (null == matchPair) {\n            return false;\n        }\n\n        return matchPair.containeValue(value);\n    }\n\n    public boolean isContainValue(String key, String value) {\n        return isWhenContainValue(key, value) || isThenContainValue(key, value);\n    }\n\n    public Map<String, MatchPair> getWhenCondition() {\n        return whenCondition;\n    }\n\n    public Map<String, MatchPair> getThenCondition() {\n        return thenCondition;\n    }\n\n    public String getWhenConditionString() {\n        StringBuilder sb = new StringBuilder(512);\n        contidionToString(sb, whenCondition);\n        return sb.toString();\n    }\n\n    public String getThenConditionString() {\n        StringBuilder sb = new StringBuilder(512);\n        contidionToString(sb, thenCondition);\n        return sb.toString();\n    }\n\n    @Override\n    public String toString() {\n        if (tostring != null)\n            return tostring;\n        StringBuilder sb = new StringBuilder(512);\n        contidionToString(sb, whenCondition);\n        sb.append(\" => \");\n        contidionToString(sb, thenCondition);\n        return tostring = sb.toString();\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((thenCondition == null) ? 0 : thenCondition.hashCode());\n        result = prime * result + ((whenCondition == null) ? 0 : whenCondition.hashCode());\n        return result;\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        RouteRule other = (RouteRule) obj;\n        if (thenCondition == null) {\n            if (other.thenCondition != null)\n                return false;\n        } else if (!thenCondition.equals(other.thenCondition))\n            return false;\n        if (whenCondition == null) {\n            if (other.whenCondition != null)\n                return false;\n        } else if (!whenCondition.equals(other.whenCondition))\n            return false;\n        return true;\n    }\n\n    public static class MatchPair {\n        Set<String> matches = new HashSet<String>();\n        Set<String> unmatches = new HashSet<String>();\n        private volatile boolean freezed = false;\n\n        public MatchPair() {\n        }\n\n        public MatchPair(Set<String> matches, Set<String> unmatches) {\n            if (matches == null || unmatches == null) {\n                throw new IllegalArgumentException(\"argument of MatchPair is null!\");\n            }\n\n            this.matches = matches;\n            this.unmatches = unmatches;\n        }\n\n        public Set<String> getMatches() {\n            return matches;\n        }\n\n        public Set<String> getUnmatches() {\n            return unmatches;\n        }\n\n        public MatchPair copy() {\n            MatchPair ret = new MatchPair();\n            ret.matches.addAll(matches);\n            ret.unmatches.addAll(unmatches);\n            return ret;\n        }\n\n        void freeze() {\n            if (freezed) return;\n            synchronized (this) {\n                if (freezed) return;\n                matches = Collections.unmodifiableSet(matches);\n                unmatches = Collections.unmodifiableSet(unmatches);\n            }\n        }\n\n        public boolean containeValue(String value) {\n            return matches.contains(value) || unmatches.contains(value);\n        }\n\n        /**\n         * Whether a given value is matched by the {@link MatchPair}.\n         * return {@code false}, if\n         * <ol>\n         * <li>value is in unmatches\n         * <li>matches is not null, but value is not in matches.\n         * </ol>\n         * otherwise, return<code>true</code>\u3002\n         */\n        public boolean pass(String sample) {\n            if (unmatches.contains(sample)) return false;\n            if (matches.isEmpty()) return true;\n            return matches.contains(sample);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{matches=%s,unmatches=%s}\", matches.toString(), unmatches.toString());\n        }\n\n        // Automatic generation with Eclipse\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((matches == null) ? 0 : matches.hashCode());\n            result = prime * result + ((unmatches == null) ? 0 : unmatches.hashCode());\n            return result;\n        }\n\n        // Automatic generation with Eclipse\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            MatchPair other = (MatchPair) obj;\n            if (matches == null) {\n                if (other.matches != null)\n                    return false;\n            } else if (!matches.equals(other.matches))\n                return false;\n            if (unmatches == null) {\n                if (other.unmatches != null)\n                    return false;\n            } else if (!unmatches.equals(other.unmatches))\n                return false;\n            return true;\n        }\n    }\n}",
        "package": "package org.apache.dubbo.admin.common.util;",
        "tree_path": "RouteRule",
        "name": "RouteRule",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    @SuppressWarnings(\"unchecked\")\n    static RouteRule EMPTY = new RouteRule(Collections.EMPTY_MAP, Collections.EMPTY_MAP);\n    private static Pattern ROUTE_PATTERN = Pattern.compile(\"([&!=,]*)\\\\s*([^&!=,\\\\s]+)\");\n    private static Pattern CONDITION_SEPERATOR = Pattern.compile(\"(.*)=>(.*)\");\n    private static Pattern VALUE_LIST_SEPARATOR = Pattern.compile(\"\\\\s*,\\\\s*\");\n    final Map<String, MatchPair> whenCondition;\n    final Map<String, MatchPair> thenCondition;\n    private volatile String tostring = null;\n\n    // FIXME\n    private RouteRule(Map<String, MatchPair> when, Map<String, MatchPair> then) {\n        for (Map.Entry<String, MatchPair> entry : when.entrySet()) {\n            entry.getValue().freeze();\n        }\n        for (Map.Entry<String, MatchPair> entry : then.entrySet()) {\n            entry.getValue().freeze();\n        }\n\n        // NOTE: Both When Condition and Then Condition can be null\n        this.whenCondition = when;\n        this.thenCondition = then;\n    }\n\n    public static Map<String, MatchPair> parseRule(String rule)\n            throws ParseException {\n        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n        if (StringUtils.isBlank(rule)) {\n            return condition;\n        }\n        // K-V pair, contains matches part and mismatches part\n        MatchPair pair = null;\n        // V part has multiple values\n        Set<String> values = null;\n        final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n        while (matcher.find()) { // match one by one\n            String separator = matcher.group(1);\n            String content = matcher.group(2);\n            // The expression starts\n            if (separator == null || separator.length() == 0) {\n                pair = new MatchPair();\n                condition.put(content, pair);\n            }\n            // The KV starts\n            else if (\"&\".equals(separator)) {\n                if (condition.get(content) == null) {\n                    pair = new MatchPair();\n                    condition.put(content, pair);\n                } else {\n                    condition.put(content, pair);\n                }\n\n            }\n            // The Value part of KV starts\n            else if (\"=\".equals(separator)) {\n                if (pair == null)\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n\n                values = pair.matches;\n                values.add(content);\n            }\n            // The Value part of KV starts\n            else if (\"!=\".equals(separator)) {\n                if (pair == null)\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n\n                values = pair.unmatches;\n                values.add(content);\n            }\n            // The Value part of KV has multiple values, separated by ','\n            else if (\",\".equals(separator)) { // separated by ','\n                if (values == null || values.size() == 0)\n                    throw new ParseException(\"Illegal route rule \\\"\"\n                            + rule + \"\\\", The error char '\" + separator\n                            + \"' at index \" + matcher.start() + \" before \\\"\"\n                            + content + \"\\\".\", matcher.start());\n                values.add(content);\n            } else {\n                throw new ParseException(\"Illegal route rule \\\"\" + rule\n                        + \"\\\", The error char '\" + separator + \"' at index \"\n                        + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start());\n            }\n        }\n        return condition;\n    }\n\n    /**\n     * Parse the RouteRule as a string into an object.\n     *\n     * @throws ParseException RouteRule string format is wrong. The following input conditions, RouteRule are illegal.\n     * <ul> <li> input is <code>null</code>\u3002\n     * <li> input is \"\" or \" \"\u3002\n     * <li> input Rule doesn't have a When Condition\n     * <li> input Rule doesn't have a Then Condition\n     * </ul>\n     */\n    public static RouteRule parse(Route route) throws ParseException {\n        if (route == null)\n            throw new ParseException(\"null route!\", 0);\n\n        if (route.getMatchRule() == null && route.getFilterRule() == null) {\n            return parse(route.getRule());\n        }\n\n        return parse(route == null ? null : route.getMatchRule(), route == null ? null : route.getFilterRule());\n    }\n\n    public static RouteRule parse(String whenRule, String thenRule) throws ParseException {\n        /*if (whenRule == null || whenRule.trim().length() == 0) {\n            throw new ParseException(\"Illegal route rule without when express\", 0);\n    \t}*/\n        if (thenRule == null || thenRule.trim().length() == 0) {\n            throw new ParseException(\"Illegal route rule without then express\", 0);\n        }\n        Map<String, MatchPair> when = parseRule(whenRule.trim());\n        Map<String, MatchPair> then = parseRule(thenRule.trim());\n        return new RouteRule(when, then);\n    }\n\n    public static RouteRule parse(String rule) throws ParseException {\n        if (StringUtils.isBlank(rule)) {\n            throw new ParseException(\"Illegal blank route rule\", 0);\n        }\n\n        final Matcher matcher = CONDITION_SEPERATOR.matcher(rule);\n        if (!matcher.matches()) throw new ParseException(\"condition seperator => not found!\", 0);\n\n        return parse(matcher.group(1), matcher.group(2));\n    }\n\n    /**\n     * @see #parse(String)\n     * @throws RuntimeException This is an wrapper exception for the {@link ParseException} thrown by the {@link #parse (String)} method.\n     */\n    public static RouteRule parseQuitely(Route route) {\n        try {\n            return parse(route);\n        } catch (ParseException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static Map<String, MatchPair> parseNameAndValueListString2Condition(Map<String, String> params, Map<String, String> notParams) {\n        Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n\n        for (Entry<String, String> entry : params.entrySet()) {\n            String valueListString = entry.getValue();\n            if (StringUtils.isBlank(valueListString)) {\n                continue;\n            }\n            String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n            Set<String> set = new HashSet<String>();\n            for (String item : list) {\n                if (StringUtils.isBlank(item)) {\n                    continue;\n                }\n                set.add(item.trim());\n            }\n            if (set.isEmpty()) {\n                continue;\n            }\n\n            String key = entry.getKey();\n            MatchPair matchPair = condition.get(key);\n            if (null == matchPair) {\n                matchPair = new MatchPair();\n                condition.put(key, matchPair);\n            }\n\n            matchPair.matches = set;\n        }\n        for (Entry<String, String> entry : notParams.entrySet()) {\n            String valueListString = entry.getValue();\n            if (StringUtils.isBlank(valueListString)) {\n                continue;\n            }\n            String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n            Set<String> set = new HashSet<String>();\n            for (String item : list) {\n                if (StringUtils.isBlank(item)) {\n                    continue;\n                }\n                set.add(item.trim());\n            }\n            if (set.isEmpty()) {\n                continue;\n            }\n\n            String key = entry.getKey();\n            MatchPair matchPair = condition.get(key);\n            if (null == matchPair) {\n                matchPair = new MatchPair();\n                condition.put(key, matchPair);\n            }\n\n            matchPair.unmatches = set;\n        }\n\n        return condition;\n    }\n\n    public static RouteRule createFromNameAndValueListString(Map<String, String> whenParams, Map<String, String> notWhenParams,\n                                                             Map<String, String> thenParams, Map<String, String> notThenParams) {\n        Map<String, MatchPair> when = parseNameAndValueListString2Condition(whenParams, notWhenParams);\n        Map<String, MatchPair> then = parseNameAndValueListString2Condition(thenParams, notThenParams);\n\n        return new RouteRule(when, then);\n    }\n\n    public static RouteRule createFromCondition(Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition) {\n        return new RouteRule(whenCondition, thenCondition);\n    }\n\n    public static RouteRule copyWithRemove(RouteRule copy, Set<String> whenParams, Set<String> thenParams) {\n        Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n        for (Entry<String, MatchPair> entry : copy.getWhenCondition().entrySet()) {\n            if (whenParams == null || !whenParams.contains(entry.getKey())) {\n                when.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n        for (Entry<String, MatchPair> entry : copy.getThenCondition().entrySet()) {\n            if (thenParams == null || !thenParams.contains(entry.getKey())) {\n                then.put(entry.getKey(), entry.getValue());\n            }\n        }\n\n        return new RouteRule(when, then);\n    }\n\n    /**\n     * Replace with the new condition value.\n     *\n     * @param copy Replace Base\n     * @param whenCondition WhenCondition to replace, if Base does not have an item, insert it directly.\n     * @param thenCondition ThenCondition to replace, if Base has no items, then insert directly.\n     * @return RouteRule after replacement\n     */\n    public static RouteRule copyWithReplace(RouteRule copy, Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition) {\n        if (null == copy) {\n            throw new NullPointerException(\"Argument copy is null!\");\n        }\n\n        Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n        when.putAll(copy.getWhenCondition());\n        if (whenCondition != null) {\n            when.putAll(whenCondition);\n        }\n\n        Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n        then.putAll(copy.getThenCondition());\n        if (thenCondition != null) {\n            then.putAll(thenCondition);\n        }\n\n        return new RouteRule(when, then);\n    }\n\n    // TODO ToString out of the current list is out of order, should we sort?\n    static void join(StringBuilder sb, Set<String> valueSet) {\n        boolean isFirst = true;\n        for (String s : valueSet) {\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(\",\");\n            }\n\n            sb.append(s);\n        }\n    }\n\n    /**\n     * Whether the sample passed the conditions.\n     * <p>\n     * If there is a Key in the KV for the sample, there is a corresponding MatchPair, and Value does not pass through MatchPair; {@code false} is returned; otherwise, {@code true} is returned.\n     *\n     * @see MatchPair#pass(String)\n     */\n    public static boolean matchCondition(Map<String, String> sample,\n                                         Map<String, MatchPair> condition) {\n        for (Map.Entry<String, String> entry : sample.entrySet()) {\n            String key = entry.getKey();\n\n            MatchPair pair = condition.get(key);\n            if (pair != null && !pair.pass(entry.getValue())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    // FIXME Remove such method calls\n    public static String join(Set<String> valueSet) {\n        StringBuilder sb = new StringBuilder(128);\n        join(sb, valueSet);\n        return sb.toString();\n    }\n\n    // TODO At present, the multiple Key of Condition is in disorder. Should we sort it?\n    public static void contidionToString(StringBuilder sb, Map<String, MatchPair> condition) {\n        boolean isFirst = true;\n        for (Entry<String, MatchPair> entry : condition.entrySet()) {\n            String keyName = entry.getKey();\n            MatchPair p = entry.getValue();\n\n            @SuppressWarnings(\"unchecked\")\n            Set<String>[] setArray = new Set[]{p.matches, p.unmatches};\n            String[] opArray = {\" = \", \" != \"};\n\n            for (int i = 0; i < setArray.length; ++i) {\n                if (setArray[i].isEmpty()) {\n                    continue;\n                }\n                if (isFirst) {\n                    isFirst = false;\n                } else {\n                    sb.append(\" & \");\n                }\n\n                sb.append(keyName);\n                sb.append(opArray[i]);\n                join(sb, setArray[i]);\n            }\n        }\n    }\n\n    public boolean isWhenContainValue(String key, String value) {\n        MatchPair matchPair = whenCondition.get(key);\n        if (null == matchPair) {\n            return false;\n        }\n\n        return matchPair.containeValue(value);\n    }\n\n    public boolean isThenContainValue(String key, String value) {\n        MatchPair matchPair = thenCondition.get(key);\n        if (null == matchPair) {\n            return false;\n        }\n\n        return matchPair.containeValue(value);\n    }\n\n    public boolean isContainValue(String key, String value) {\n        return isWhenContainValue(key, value) || isThenContainValue(key, value);\n    }\n\n    public Map<String, MatchPair> getWhenCondition() {\n        return whenCondition;\n    }\n\n    public Map<String, MatchPair> getThenCondition() {\n        return thenCondition;\n    }\n\n    public String getWhenConditionString() {\n        StringBuilder sb = new StringBuilder(512);\n        contidionToString(sb, whenCondition);\n        return sb.toString();\n    }\n\n    public String getThenConditionString() {\n        StringBuilder sb = new StringBuilder(512);\n        contidionToString(sb, thenCondition);\n        return sb.toString();\n    }\n\n    @Override\n    public String toString() {\n        if (tostring != null)\n            return tostring;\n        StringBuilder sb = new StringBuilder(512);\n        contidionToString(sb, whenCondition);\n        sb.append(\" => \");\n        contidionToString(sb, thenCondition);\n        return tostring = sb.toString();\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((thenCondition == null) ? 0 : thenCondition.hashCode());\n        result = prime * result + ((whenCondition == null) ? 0 : whenCondition.hashCode());\n        return result;\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        RouteRule other = (RouteRule) obj;\n        if (thenCondition == null) {\n            if (other.thenCondition != null)\n                return false;\n        } else if (!thenCondition.equals(other.thenCondition))\n            return false;\n        if (whenCondition == null) {\n            if (other.whenCondition != null)\n                return false;\n        } else if (!whenCondition.equals(other.whenCondition))\n            return false;\n        return true;\n    }\n\n    public static class MatchPair {\n        Set<String> matches = new HashSet<String>();\n        Set<String> unmatches = new HashSet<String>();\n        private volatile boolean freezed = false;\n\n        public MatchPair() {\n        }\n\n        public MatchPair(Set<String> matches, Set<String> unmatches) {\n            if (matches == null || unmatches == null) {\n                throw new IllegalArgumentException(\"argument of MatchPair is null!\");\n            }\n\n            this.matches = matches;\n            this.unmatches = unmatches;\n        }\n\n        public Set<String> getMatches() {\n            return matches;\n        }\n\n        public Set<String> getUnmatches() {\n            return unmatches;\n        }\n\n        public MatchPair copy() {\n            MatchPair ret = new MatchPair();\n            ret.matches.addAll(matches);\n            ret.unmatches.addAll(unmatches);\n            return ret;\n        }\n\n        void freeze() {\n            if (freezed) return;\n            synchronized (this) {\n                if (freezed) return;\n                matches = Collections.unmodifiableSet(matches);\n                unmatches = Collections.unmodifiableSet(unmatches);\n            }\n        }\n\n        public boolean containeValue(String value) {\n            return matches.contains(value) || unmatches.contains(value);\n        }\n\n        /**\n         * Whether a given value is matched by the {@link MatchPair}.\n         * return {@code false}, if\n         * <ol>\n         * <li>value is in unmatches\n         * <li>matches is not null, but value is not in matches.\n         * </ol>\n         * otherwise, return<code>true</code>\u3002\n         */\n        public boolean pass(String sample) {\n            if (unmatches.contains(sample)) return false;\n            if (matches.isEmpty()) return true;\n            return matches.contains(sample);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"{matches=%s,unmatches=%s}\", matches.toString(), unmatches.toString());\n        }\n\n        // Automatic generation with Eclipse\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + ((matches == null) ? 0 : matches.hashCode());\n            result = prime * result + ((unmatches == null) ? 0 : unmatches.hashCode());\n            return result;\n        }\n\n        // Automatic generation with Eclipse\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            MatchPair other = (MatchPair) obj;\n            if (matches == null) {\n                if (other.matches != null)\n                    return false;\n            } else if (!matches.equals(other.matches))\n                return false;\n            if (unmatches == null) {\n                if (other.unmatches != null)\n                    return false;\n            } else if (!unmatches.equals(other.unmatches))\n                return false;\n            return true;\n        }\n    }\n}",
        "start_point": {
            "row": 43,
            "column": 0
        },
        "end_point": {
            "row": 562,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "private RouteRule(Map<String, MatchPair> when, Map<String, MatchPair> then) {\n    for (Map.Entry<String, MatchPair> entry : when.entrySet()) {\n        entry.getValue().freeze();\n    }\n    for (Map.Entry<String, MatchPair> entry : then.entrySet()) {\n        entry.getValue().freeze();\n    }\n\n    // NOTE: Both When Condition and Then Condition can be null\n    this.whenCondition = when;\n    this.thenCondition = then;\n}",
                "name": "RouteRule",
                "modifiers": "private",
                "parameters": [
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "when"
                    },
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "then"
                    }
                ],
                "body": "{\n    for (Map.Entry<String, MatchPair> entry : when.entrySet()) {\n        entry.getValue().freeze();\n    }\n    for (Map.Entry<String, MatchPair> entry : then.entrySet()) {\n        entry.getValue().freeze();\n    }\n\n    // NOTE: Both When Condition and Then Condition can be null\n    this.whenCondition = when;\n    this.thenCondition = then;\n}",
                "constructor": true,
                "start_point": {
                    "row": 54,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            },
            {
                "definition": "public static Map<String, MatchPair> parseRule(String rule)\n        throws ParseException {\n    Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n    if (StringUtils.isBlank(rule)) {\n        return condition;\n    }\n    // K-V pair, contains matches part and mismatches part\n    MatchPair pair = null;\n    // V part has multiple values\n    Set<String> values = null;\n    final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n    while (matcher.find()) { // match one by one\n        String separator = matcher.group(1);\n        String content = matcher.group(2);\n        // The expression starts\n        if (separator == null || separator.length() == 0) {\n            pair = new MatchPair();\n            condition.put(content, pair);\n        }\n        // The KV starts\n        else if (\"&\".equals(separator)) {\n            if (condition.get(content) == null) {\n                pair = new MatchPair();\n                condition.put(content, pair);\n            } else {\n                condition.put(content, pair);\n            }\n\n        }\n        // The Value part of KV starts\n        else if (\"=\".equals(separator)) {\n            if (pair == null)\n                throw new ParseException(\"Illegal route rule \\\"\"\n                        + rule + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\", matcher.start());\n\n            values = pair.matches;\n            values.add(content);\n        }\n        // The Value part of KV starts\n        else if (\"!=\".equals(separator)) {\n            if (pair == null)\n                throw new ParseException(\"Illegal route rule \\\"\"\n                        + rule + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\", matcher.start());\n\n            values = pair.unmatches;\n            values.add(content);\n        }\n        // The Value part of KV has multiple values, separated by ','\n        else if (\",\".equals(separator)) { // separated by ','\n            if (values == null || values.size() == 0)\n                throw new ParseException(\"Illegal route rule \\\"\"\n                        + rule + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\", matcher.start());\n            values.add(content);\n        } else {\n            throw new ParseException(\"Illegal route rule \\\"\" + rule\n                    + \"\\\", The error char '\" + separator + \"' at index \"\n                    + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start());\n        }\n    }\n    return condition;\n}",
                "name": "parseRule",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "rule"
                    }
                ],
                "body": "{\n    Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n    if (StringUtils.isBlank(rule)) {\n        return condition;\n    }\n    // K-V pair, contains matches part and mismatches part\n    MatchPair pair = null;\n    // V part has multiple values\n    Set<String> values = null;\n    final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n    while (matcher.find()) { // match one by one\n        String separator = matcher.group(1);\n        String content = matcher.group(2);\n        // The expression starts\n        if (separator == null || separator.length() == 0) {\n            pair = new MatchPair();\n            condition.put(content, pair);\n        }\n        // The KV starts\n        else if (\"&\".equals(separator)) {\n            if (condition.get(content) == null) {\n                pair = new MatchPair();\n                condition.put(content, pair);\n            } else {\n                condition.put(content, pair);\n            }\n\n        }\n        // The Value part of KV starts\n        else if (\"=\".equals(separator)) {\n            if (pair == null)\n                throw new ParseException(\"Illegal route rule \\\"\"\n                        + rule + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\", matcher.start());\n\n            values = pair.matches;\n            values.add(content);\n        }\n        // The Value part of KV starts\n        else if (\"!=\".equals(separator)) {\n            if (pair == null)\n                throw new ParseException(\"Illegal route rule \\\"\"\n                        + rule + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\", matcher.start());\n\n            values = pair.unmatches;\n            values.add(content);\n        }\n        // The Value part of KV has multiple values, separated by ','\n        else if (\",\".equals(separator)) { // separated by ','\n            if (values == null || values.size() == 0)\n                throw new ParseException(\"Illegal route rule \\\"\"\n                        + rule + \"\\\", The error char '\" + separator\n                        + \"' at index \" + matcher.start() + \" before \\\"\"\n                        + content + \"\\\".\", matcher.start());\n            values.add(content);\n        } else {\n            throw new ParseException(\"Illegal route rule \\\"\" + rule\n                    + \"\\\", The error char '\" + separator + \"' at index \"\n                    + matcher.start() + \" before \\\"\" + content + \"\\\".\", matcher.start());\n        }\n    }\n    return condition;\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 133,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule parse(Route route) throws ParseException {\n    if (route == null)\n        throw new ParseException(\"null route!\", 0);\n\n    if (route.getMatchRule() == null && route.getFilterRule() == null) {\n        return parse(route.getRule());\n    }\n\n    return parse(route == null ? null : route.getMatchRule(), route == null ? null : route.getFilterRule());\n}",
                "name": "parse",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "Route",
                        "name": "route"
                    }
                ],
                "body": "{\n    if (route == null)\n        throw new ParseException(\"null route!\", 0);\n\n    if (route.getMatchRule() == null && route.getFilterRule() == null) {\n        return parse(route.getRule());\n    }\n\n    return parse(route == null ? null : route.getMatchRule(), route == null ? null : route.getFilterRule());\n}",
                "start_point": {
                    "row": 145,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule parse(String whenRule, String thenRule) throws ParseException {\n    /*if (whenRule == null || whenRule.trim().length() == 0) {\n        throw new ParseException(\"Illegal route rule without when express\", 0);\n\t}*/\n    if (thenRule == null || thenRule.trim().length() == 0) {\n        throw new ParseException(\"Illegal route rule without then express\", 0);\n    }\n    Map<String, MatchPair> when = parseRule(whenRule.trim());\n    Map<String, MatchPair> then = parseRule(thenRule.trim());\n    return new RouteRule(when, then);\n}",
                "name": "parse",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "String",
                        "name": "whenRule"
                    },
                    {
                        "type": "String",
                        "name": "thenRule"
                    }
                ],
                "body": "{\n    /*if (whenRule == null || whenRule.trim().length() == 0) {\n        throw new ParseException(\"Illegal route rule without when express\", 0);\n\t}*/\n    if (thenRule == null || thenRule.trim().length() == 0) {\n        throw new ParseException(\"Illegal route rule without then express\", 0);\n    }\n    Map<String, MatchPair> when = parseRule(whenRule.trim());\n    Map<String, MatchPair> then = parseRule(thenRule.trim());\n    return new RouteRule(when, then);\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 166,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule parse(String rule) throws ParseException {\n    if (StringUtils.isBlank(rule)) {\n        throw new ParseException(\"Illegal blank route rule\", 0);\n    }\n\n    final Matcher matcher = CONDITION_SEPERATOR.matcher(rule);\n    if (!matcher.matches()) throw new ParseException(\"condition seperator => not found!\", 0);\n\n    return parse(matcher.group(1), matcher.group(2));\n}",
                "name": "parse",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "String",
                        "name": "rule"
                    }
                ],
                "body": "{\n    if (StringUtils.isBlank(rule)) {\n        throw new ParseException(\"Illegal blank route rule\", 0);\n    }\n\n    final Matcher matcher = CONDITION_SEPERATOR.matcher(rule);\n    if (!matcher.matches()) throw new ParseException(\"condition seperator => not found!\", 0);\n\n    return parse(matcher.group(1), matcher.group(2));\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 177,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule parseQuitely(Route route) {\n    try {\n        return parse(route);\n    } catch (ParseException e) {\n        throw new RuntimeException(e);\n    }\n}",
                "name": "parseQuitely",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "Route",
                        "name": "route"
                    }
                ],
                "body": "{\n    try {\n        return parse(route);\n    } catch (ParseException e) {\n        throw new RuntimeException(e);\n    }\n}",
                "start_point": {
                    "row": 183,
                    "column": 4
                },
                "end_point": {
                    "row": 189,
                    "column": 5
                }
            },
            {
                "definition": "static Map<String, MatchPair> parseNameAndValueListString2Condition(Map<String, String> params, Map<String, String> notParams) {\n    Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n\n    for (Entry<String, String> entry : params.entrySet()) {\n        String valueListString = entry.getValue();\n        if (StringUtils.isBlank(valueListString)) {\n            continue;\n        }\n        String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n        Set<String> set = new HashSet<String>();\n        for (String item : list) {\n            if (StringUtils.isBlank(item)) {\n                continue;\n            }\n            set.add(item.trim());\n        }\n        if (set.isEmpty()) {\n            continue;\n        }\n\n        String key = entry.getKey();\n        MatchPair matchPair = condition.get(key);\n        if (null == matchPair) {\n            matchPair = new MatchPair();\n            condition.put(key, matchPair);\n        }\n\n        matchPair.matches = set;\n    }\n    for (Entry<String, String> entry : notParams.entrySet()) {\n        String valueListString = entry.getValue();\n        if (StringUtils.isBlank(valueListString)) {\n            continue;\n        }\n        String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n        Set<String> set = new HashSet<String>();\n        for (String item : list) {\n            if (StringUtils.isBlank(item)) {\n                continue;\n            }\n            set.add(item.trim());\n        }\n        if (set.isEmpty()) {\n            continue;\n        }\n\n        String key = entry.getKey();\n        MatchPair matchPair = condition.get(key);\n        if (null == matchPair) {\n            matchPair = new MatchPair();\n            condition.put(key, matchPair);\n        }\n\n        matchPair.unmatches = set;\n    }\n\n    return condition;\n}",
                "name": "parseNameAndValueListString2Condition",
                "modifiers": "static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, String>",
                        "name": "params"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "notParams"
                    }
                ],
                "body": "{\n    Map<String, MatchPair> condition = new HashMap<String, MatchPair>();\n\n    for (Entry<String, String> entry : params.entrySet()) {\n        String valueListString = entry.getValue();\n        if (StringUtils.isBlank(valueListString)) {\n            continue;\n        }\n        String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n        Set<String> set = new HashSet<String>();\n        for (String item : list) {\n            if (StringUtils.isBlank(item)) {\n                continue;\n            }\n            set.add(item.trim());\n        }\n        if (set.isEmpty()) {\n            continue;\n        }\n\n        String key = entry.getKey();\n        MatchPair matchPair = condition.get(key);\n        if (null == matchPair) {\n            matchPair = new MatchPair();\n            condition.put(key, matchPair);\n        }\n\n        matchPair.matches = set;\n    }\n    for (Entry<String, String> entry : notParams.entrySet()) {\n        String valueListString = entry.getValue();\n        if (StringUtils.isBlank(valueListString)) {\n            continue;\n        }\n        String[] list = VALUE_LIST_SEPARATOR.split(valueListString);\n        Set<String> set = new HashSet<String>();\n        for (String item : list) {\n            if (StringUtils.isBlank(item)) {\n                continue;\n            }\n            set.add(item.trim());\n        }\n        if (set.isEmpty()) {\n            continue;\n        }\n\n        String key = entry.getKey();\n        MatchPair matchPair = condition.get(key);\n        if (null == matchPair) {\n            matchPair = new MatchPair();\n            condition.put(key, matchPair);\n        }\n\n        matchPair.unmatches = set;\n    }\n\n    return condition;\n}",
                "start_point": {
                    "row": 191,
                    "column": 4
                },
                "end_point": {
                    "row": 248,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule createFromNameAndValueListString(Map<String, String> whenParams, Map<String, String> notWhenParams,\n                                                         Map<String, String> thenParams, Map<String, String> notThenParams) {\n    Map<String, MatchPair> when = parseNameAndValueListString2Condition(whenParams, notWhenParams);\n    Map<String, MatchPair> then = parseNameAndValueListString2Condition(thenParams, notThenParams);\n\n    return new RouteRule(when, then);\n}",
                "name": "createFromNameAndValueListString",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "Map<String, String>",
                        "name": "whenParams"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "notWhenParams"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "thenParams"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "notThenParams"
                    }
                ],
                "body": "{\n    Map<String, MatchPair> when = parseNameAndValueListString2Condition(whenParams, notWhenParams);\n    Map<String, MatchPair> then = parseNameAndValueListString2Condition(thenParams, notThenParams);\n\n    return new RouteRule(when, then);\n}",
                "start_point": {
                    "row": 250,
                    "column": 4
                },
                "end_point": {
                    "row": 256,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule createFromCondition(Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition) {\n    return new RouteRule(whenCondition, thenCondition);\n}",
                "name": "createFromCondition",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "whenCondition"
                    },
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "thenCondition"
                    }
                ],
                "body": "{\n    return new RouteRule(whenCondition, thenCondition);\n}",
                "start_point": {
                    "row": 258,
                    "column": 4
                },
                "end_point": {
                    "row": 260,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule copyWithRemove(RouteRule copy, Set<String> whenParams, Set<String> thenParams) {\n    Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n    for (Entry<String, MatchPair> entry : copy.getWhenCondition().entrySet()) {\n        if (whenParams == null || !whenParams.contains(entry.getKey())) {\n            when.put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n    for (Entry<String, MatchPair> entry : copy.getThenCondition().entrySet()) {\n        if (thenParams == null || !thenParams.contains(entry.getKey())) {\n            then.put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    return new RouteRule(when, then);\n}",
                "name": "copyWithRemove",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "RouteRule",
                        "name": "copy"
                    },
                    {
                        "type": "Set<String>",
                        "name": "whenParams"
                    },
                    {
                        "type": "Set<String>",
                        "name": "thenParams"
                    }
                ],
                "body": "{\n    Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n    for (Entry<String, MatchPair> entry : copy.getWhenCondition().entrySet()) {\n        if (whenParams == null || !whenParams.contains(entry.getKey())) {\n            when.put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n    for (Entry<String, MatchPair> entry : copy.getThenCondition().entrySet()) {\n        if (thenParams == null || !thenParams.contains(entry.getKey())) {\n            then.put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    return new RouteRule(when, then);\n}",
                "start_point": {
                    "row": 262,
                    "column": 4
                },
                "end_point": {
                    "row": 278,
                    "column": 5
                }
            },
            {
                "definition": "public static RouteRule copyWithReplace(RouteRule copy, Map<String, MatchPair> whenCondition, Map<String, MatchPair> thenCondition) {\n    if (null == copy) {\n        throw new NullPointerException(\"Argument copy is null!\");\n    }\n\n    Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n    when.putAll(copy.getWhenCondition());\n    if (whenCondition != null) {\n        when.putAll(whenCondition);\n    }\n\n    Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n    then.putAll(copy.getThenCondition());\n    if (thenCondition != null) {\n        then.putAll(thenCondition);\n    }\n\n    return new RouteRule(when, then);\n}",
                "name": "copyWithReplace",
                "modifiers": "public static",
                "return_type": "RouteRule",
                "parameters": [
                    {
                        "type": "RouteRule",
                        "name": "copy"
                    },
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "whenCondition"
                    },
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "thenCondition"
                    }
                ],
                "body": "{\n    if (null == copy) {\n        throw new NullPointerException(\"Argument copy is null!\");\n    }\n\n    Map<String, MatchPair> when = new HashMap<String, MatchPair>();\n    when.putAll(copy.getWhenCondition());\n    if (whenCondition != null) {\n        when.putAll(whenCondition);\n    }\n\n    Map<String, MatchPair> then = new HashMap<String, MatchPair>();\n    then.putAll(copy.getThenCondition());\n    if (thenCondition != null) {\n        then.putAll(thenCondition);\n    }\n\n    return new RouteRule(when, then);\n}",
                "start_point": {
                    "row": 288,
                    "column": 4
                },
                "end_point": {
                    "row": 306,
                    "column": 5
                }
            },
            {
                "definition": "static void join(StringBuilder sb, Set<String> valueSet) {\n    boolean isFirst = true;\n    for (String s : valueSet) {\n        if (isFirst) {\n            isFirst = false;\n        } else {\n            sb.append(\",\");\n        }\n\n        sb.append(s);\n    }\n}",
                "name": "join",
                "modifiers": "static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "StringBuilder",
                        "name": "sb"
                    },
                    {
                        "type": "Set<String>",
                        "name": "valueSet"
                    }
                ],
                "body": "{\n    boolean isFirst = true;\n    for (String s : valueSet) {\n        if (isFirst) {\n            isFirst = false;\n        } else {\n            sb.append(\",\");\n        }\n\n        sb.append(s);\n    }\n}",
                "start_point": {
                    "row": 309,
                    "column": 4
                },
                "end_point": {
                    "row": 320,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean matchCondition(Map<String, String> sample,\n                                     Map<String, MatchPair> condition) {\n    for (Map.Entry<String, String> entry : sample.entrySet()) {\n        String key = entry.getKey();\n\n        MatchPair pair = condition.get(key);\n        if (pair != null && !pair.pass(entry.getValue())) {\n            return false;\n        }\n    }\n    return true;\n}",
                "name": "matchCondition",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, String>",
                        "name": "sample"
                    },
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "condition"
                    }
                ],
                "body": "{\n    for (Map.Entry<String, String> entry : sample.entrySet()) {\n        String key = entry.getKey();\n\n        MatchPair pair = condition.get(key);\n        if (pair != null && !pair.pass(entry.getValue())) {\n            return false;\n        }\n    }\n    return true;\n}",
                "start_point": {
                    "row": 329,
                    "column": 4
                },
                "end_point": {
                    "row": 340,
                    "column": 5
                }
            },
            {
                "definition": "public static String join(Set<String> valueSet) {\n    StringBuilder sb = new StringBuilder(128);\n    join(sb, valueSet);\n    return sb.toString();\n}",
                "name": "join",
                "modifiers": "public static",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "valueSet"
                    }
                ],
                "body": "{\n    StringBuilder sb = new StringBuilder(128);\n    join(sb, valueSet);\n    return sb.toString();\n}",
                "start_point": {
                    "row": 344,
                    "column": 4
                },
                "end_point": {
                    "row": 348,
                    "column": 5
                }
            },
            {
                "definition": "public static void contidionToString(StringBuilder sb, Map<String, MatchPair> condition) {\n    boolean isFirst = true;\n    for (Entry<String, MatchPair> entry : condition.entrySet()) {\n        String keyName = entry.getKey();\n        MatchPair p = entry.getValue();\n\n        @SuppressWarnings(\"unchecked\")\n        Set<String>[] setArray = new Set[]{p.matches, p.unmatches};\n        String[] opArray = {\" = \", \" != \"};\n\n        for (int i = 0; i < setArray.length; ++i) {\n            if (setArray[i].isEmpty()) {\n                continue;\n            }\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(\" & \");\n            }\n\n            sb.append(keyName);\n            sb.append(opArray[i]);\n            join(sb, setArray[i]);\n        }\n    }\n}",
                "name": "contidionToString",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "StringBuilder",
                        "name": "sb"
                    },
                    {
                        "type": "Map<String, MatchPair>",
                        "name": "condition"
                    }
                ],
                "body": "{\n    boolean isFirst = true;\n    for (Entry<String, MatchPair> entry : condition.entrySet()) {\n        String keyName = entry.getKey();\n        MatchPair p = entry.getValue();\n\n        @SuppressWarnings(\"unchecked\")\n        Set<String>[] setArray = new Set[]{p.matches, p.unmatches};\n        String[] opArray = {\" = \", \" != \"};\n\n        for (int i = 0; i < setArray.length; ++i) {\n            if (setArray[i].isEmpty()) {\n                continue;\n            }\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(\" & \");\n            }\n\n            sb.append(keyName);\n            sb.append(opArray[i]);\n            join(sb, setArray[i]);\n        }\n    }\n}",
                "start_point": {
                    "row": 351,
                    "column": 4
                },
                "end_point": {
                    "row": 376,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isWhenContainValue(String key, String value) {\n    MatchPair matchPair = whenCondition.get(key);\n    if (null == matchPair) {\n        return false;\n    }\n\n    return matchPair.containeValue(value);\n}",
                "name": "isWhenContainValue",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "key"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    MatchPair matchPair = whenCondition.get(key);\n    if (null == matchPair) {\n        return false;\n    }\n\n    return matchPair.containeValue(value);\n}",
                "start_point": {
                    "row": 378,
                    "column": 4
                },
                "end_point": {
                    "row": 385,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isThenContainValue(String key, String value) {\n    MatchPair matchPair = thenCondition.get(key);\n    if (null == matchPair) {\n        return false;\n    }\n\n    return matchPair.containeValue(value);\n}",
                "name": "isThenContainValue",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "key"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    MatchPair matchPair = thenCondition.get(key);\n    if (null == matchPair) {\n        return false;\n    }\n\n    return matchPair.containeValue(value);\n}",
                "start_point": {
                    "row": 387,
                    "column": 4
                },
                "end_point": {
                    "row": 394,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isContainValue(String key, String value) {\n    return isWhenContainValue(key, value) || isThenContainValue(key, value);\n}",
                "name": "isContainValue",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "key"
                    },
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    return isWhenContainValue(key, value) || isThenContainValue(key, value);\n}",
                "start_point": {
                    "row": 396,
                    "column": 4
                },
                "end_point": {
                    "row": 398,
                    "column": 5
                }
            },
            {
                "definition": "public Map<String, MatchPair> getWhenCondition() {\n    return whenCondition;\n}",
                "name": "getWhenCondition",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return whenCondition;\n}",
                "start_point": {
                    "row": 400,
                    "column": 4
                },
                "end_point": {
                    "row": 402,
                    "column": 5
                }
            },
            {
                "definition": "public Map<String, MatchPair> getThenCondition() {\n    return thenCondition;\n}",
                "name": "getThenCondition",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return thenCondition;\n}",
                "start_point": {
                    "row": 404,
                    "column": 4
                },
                "end_point": {
                    "row": 406,
                    "column": 5
                }
            },
            {
                "definition": "public String getWhenConditionString() {\n    StringBuilder sb = new StringBuilder(512);\n    contidionToString(sb, whenCondition);\n    return sb.toString();\n}",
                "name": "getWhenConditionString",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    StringBuilder sb = new StringBuilder(512);\n    contidionToString(sb, whenCondition);\n    return sb.toString();\n}",
                "start_point": {
                    "row": 408,
                    "column": 4
                },
                "end_point": {
                    "row": 412,
                    "column": 5
                }
            },
            {
                "definition": "public String getThenConditionString() {\n    StringBuilder sb = new StringBuilder(512);\n    contidionToString(sb, thenCondition);\n    return sb.toString();\n}",
                "name": "getThenConditionString",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    StringBuilder sb = new StringBuilder(512);\n    contidionToString(sb, thenCondition);\n    return sb.toString();\n}",
                "start_point": {
                    "row": 414,
                    "column": 4
                },
                "end_point": {
                    "row": 418,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    if (tostring != null)\n        return tostring;\n    StringBuilder sb = new StringBuilder(512);\n    contidionToString(sb, whenCondition);\n    sb.append(\" => \");\n    contidionToString(sb, thenCondition);\n    return tostring = sb.toString();\n}",
                "name": "toString",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    if (tostring != null)\n        return tostring;\n    StringBuilder sb = new StringBuilder(512);\n    contidionToString(sb, whenCondition);\n    sb.append(\" => \");\n    contidionToString(sb, thenCondition);\n    return tostring = sb.toString();\n}",
                "start_point": {
                    "row": 420,
                    "column": 4
                },
                "end_point": {
                    "row": 429,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((thenCondition == null) ? 0 : thenCondition.hashCode());\n    result = prime * result + ((whenCondition == null) ? 0 : whenCondition.hashCode());\n    return result;\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((thenCondition == null) ? 0 : thenCondition.hashCode());\n    result = prime * result + ((whenCondition == null) ? 0 : whenCondition.hashCode());\n    return result;\n}",
                "start_point": {
                    "row": 432,
                    "column": 4
                },
                "end_point": {
                    "row": 439,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    RouteRule other = (RouteRule) obj;\n    if (thenCondition == null) {\n        if (other.thenCondition != null)\n            return false;\n    } else if (!thenCondition.equals(other.thenCondition))\n        return false;\n    if (whenCondition == null) {\n        if (other.whenCondition != null)\n            return false;\n    } else if (!whenCondition.equals(other.whenCondition))\n        return false;\n    return true;\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "obj"
                    }
                ],
                "body": "{\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    RouteRule other = (RouteRule) obj;\n    if (thenCondition == null) {\n        if (other.thenCondition != null)\n            return false;\n    } else if (!thenCondition.equals(other.thenCondition))\n        return false;\n    if (whenCondition == null) {\n        if (other.whenCondition != null)\n            return false;\n    } else if (!whenCondition.equals(other.whenCondition))\n        return false;\n    return true;\n}",
                "start_point": {
                    "row": 442,
                    "column": 4
                },
                "end_point": {
                    "row": 462,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/common/util/RouteRule.java",
        "definition": "public static class MatchPair {\n    Set<String> matches = new HashSet<String>();\n    Set<String> unmatches = new HashSet<String>();\n    private volatile boolean freezed = false;\n\n    public MatchPair() {\n    }\n\n    public MatchPair(Set<String> matches, Set<String> unmatches) {\n        if (matches == null || unmatches == null) {\n            throw new IllegalArgumentException(\"argument of MatchPair is null!\");\n        }\n\n        this.matches = matches;\n        this.unmatches = unmatches;\n    }\n\n    public Set<String> getMatches() {\n        return matches;\n    }\n\n    public Set<String> getUnmatches() {\n        return unmatches;\n    }\n\n    public MatchPair copy() {\n        MatchPair ret = new MatchPair();\n        ret.matches.addAll(matches);\n        ret.unmatches.addAll(unmatches);\n        return ret;\n    }\n\n    void freeze() {\n        if (freezed) return;\n        synchronized (this) {\n            if (freezed) return;\n            matches = Collections.unmodifiableSet(matches);\n            unmatches = Collections.unmodifiableSet(unmatches);\n        }\n    }\n\n    public boolean containeValue(String value) {\n        return matches.contains(value) || unmatches.contains(value);\n    }\n\n    /**\n     * Whether a given value is matched by the {@link MatchPair}.\n     * return {@code false}, if\n     * <ol>\n     * <li>value is in unmatches\n     * <li>matches is not null, but value is not in matches.\n     * </ol>\n     * otherwise, return<code>true</code>\u3002\n     */\n    public boolean pass(String sample) {\n        if (unmatches.contains(sample)) return false;\n        if (matches.isEmpty()) return true;\n        return matches.contains(sample);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"{matches=%s,unmatches=%s}\", matches.toString(), unmatches.toString());\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((matches == null) ? 0 : matches.hashCode());\n        result = prime * result + ((unmatches == null) ? 0 : unmatches.hashCode());\n        return result;\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        MatchPair other = (MatchPair) obj;\n        if (matches == null) {\n            if (other.matches != null)\n                return false;\n        } else if (!matches.equals(other.matches))\n            return false;\n        if (unmatches == null) {\n            if (other.unmatches != null)\n                return false;\n        } else if (!unmatches.equals(other.unmatches))\n            return false;\n        return true;\n    }\n}",
        "package": "package org.apache.dubbo.admin.common.util;",
        "tree_path": "RouteRule.MatchPair",
        "name": "MatchPair",
        "modifiers": "public static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    Set<String> matches = new HashSet<String>();\n    Set<String> unmatches = new HashSet<String>();\n    private volatile boolean freezed = false;\n\n    public MatchPair() {\n    }\n\n    public MatchPair(Set<String> matches, Set<String> unmatches) {\n        if (matches == null || unmatches == null) {\n            throw new IllegalArgumentException(\"argument of MatchPair is null!\");\n        }\n\n        this.matches = matches;\n        this.unmatches = unmatches;\n    }\n\n    public Set<String> getMatches() {\n        return matches;\n    }\n\n    public Set<String> getUnmatches() {\n        return unmatches;\n    }\n\n    public MatchPair copy() {\n        MatchPair ret = new MatchPair();\n        ret.matches.addAll(matches);\n        ret.unmatches.addAll(unmatches);\n        return ret;\n    }\n\n    void freeze() {\n        if (freezed) return;\n        synchronized (this) {\n            if (freezed) return;\n            matches = Collections.unmodifiableSet(matches);\n            unmatches = Collections.unmodifiableSet(unmatches);\n        }\n    }\n\n    public boolean containeValue(String value) {\n        return matches.contains(value) || unmatches.contains(value);\n    }\n\n    /**\n     * Whether a given value is matched by the {@link MatchPair}.\n     * return {@code false}, if\n     * <ol>\n     * <li>value is in unmatches\n     * <li>matches is not null, but value is not in matches.\n     * </ol>\n     * otherwise, return<code>true</code>\u3002\n     */\n    public boolean pass(String sample) {\n        if (unmatches.contains(sample)) return false;\n        if (matches.isEmpty()) return true;\n        return matches.contains(sample);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"{matches=%s,unmatches=%s}\", matches.toString(), unmatches.toString());\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((matches == null) ? 0 : matches.hashCode());\n        result = prime * result + ((unmatches == null) ? 0 : unmatches.hashCode());\n        return result;\n    }\n\n    // Automatic generation with Eclipse\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        MatchPair other = (MatchPair) obj;\n        if (matches == null) {\n            if (other.matches != null)\n                return false;\n        } else if (!matches.equals(other.matches))\n            return false;\n        if (unmatches == null) {\n            if (other.unmatches != null)\n                return false;\n        } else if (!unmatches.equals(other.unmatches))\n            return false;\n        return true;\n    }\n}",
        "start_point": {
            "row": 464,
            "column": 4
        },
        "end_point": {
            "row": 561,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public MatchPair() {\n}",
                "name": "MatchPair",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 469,
                    "column": 8
                },
                "end_point": {
                    "row": 470,
                    "column": 9
                }
            },
            {
                "definition": "public MatchPair(Set<String> matches, Set<String> unmatches) {\n    if (matches == null || unmatches == null) {\n        throw new IllegalArgumentException(\"argument of MatchPair is null!\");\n    }\n\n    this.matches = matches;\n    this.unmatches = unmatches;\n}",
                "name": "MatchPair",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "Set<String>",
                        "name": "matches"
                    },
                    {
                        "type": "Set<String>",
                        "name": "unmatches"
                    }
                ],
                "body": "{\n    if (matches == null || unmatches == null) {\n        throw new IllegalArgumentException(\"argument of MatchPair is null!\");\n    }\n\n    this.matches = matches;\n    this.unmatches = unmatches;\n}",
                "constructor": true,
                "start_point": {
                    "row": 472,
                    "column": 8
                },
                "end_point": {
                    "row": 479,
                    "column": 9
                }
            },
            {
                "definition": "public Set<String> getMatches() {\n    return matches;\n}",
                "name": "getMatches",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return matches;\n}",
                "start_point": {
                    "row": 481,
                    "column": 8
                },
                "end_point": {
                    "row": 483,
                    "column": 9
                }
            },
            {
                "definition": "public Set<String> getUnmatches() {\n    return unmatches;\n}",
                "name": "getUnmatches",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return unmatches;\n}",
                "start_point": {
                    "row": 485,
                    "column": 8
                },
                "end_point": {
                    "row": 487,
                    "column": 9
                }
            },
            {
                "definition": "public MatchPair copy() {\n    MatchPair ret = new MatchPair();\n    ret.matches.addAll(matches);\n    ret.unmatches.addAll(unmatches);\n    return ret;\n}",
                "name": "copy",
                "modifiers": "public",
                "return_type": "MatchPair",
                "parameters": [],
                "body": "{\n    MatchPair ret = new MatchPair();\n    ret.matches.addAll(matches);\n    ret.unmatches.addAll(unmatches);\n    return ret;\n}",
                "start_point": {
                    "row": 489,
                    "column": 8
                },
                "end_point": {
                    "row": 494,
                    "column": 9
                }
            },
            {
                "definition": "void freeze() {\n    if (freezed) return;\n    synchronized (this) {\n        if (freezed) return;\n        matches = Collections.unmodifiableSet(matches);\n        unmatches = Collections.unmodifiableSet(unmatches);\n    }\n}",
                "name": "freeze",
                "modifiers": null,
                "return_type": null,
                "parameters": [],
                "body": "{\n    if (freezed) return;\n    synchronized (this) {\n        if (freezed) return;\n        matches = Collections.unmodifiableSet(matches);\n        unmatches = Collections.unmodifiableSet(unmatches);\n    }\n}",
                "start_point": {
                    "row": 496,
                    "column": 8
                },
                "end_point": {
                    "row": 503,
                    "column": 9
                }
            },
            {
                "definition": "public boolean containeValue(String value) {\n    return matches.contains(value) || unmatches.contains(value);\n}",
                "name": "containeValue",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "value"
                    }
                ],
                "body": "{\n    return matches.contains(value) || unmatches.contains(value);\n}",
                "start_point": {
                    "row": 505,
                    "column": 8
                },
                "end_point": {
                    "row": 507,
                    "column": 9
                }
            },
            {
                "definition": "public boolean pass(String sample) {\n    if (unmatches.contains(sample)) return false;\n    if (matches.isEmpty()) return true;\n    return matches.contains(sample);\n}",
                "name": "pass",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "sample"
                    }
                ],
                "body": "{\n    if (unmatches.contains(sample)) return false;\n    if (matches.isEmpty()) return true;\n    return matches.contains(sample);\n}",
                "start_point": {
                    "row": 518,
                    "column": 8
                },
                "end_point": {
                    "row": 522,
                    "column": 9
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    return String.format(\"{matches=%s,unmatches=%s}\", matches.toString(), unmatches.toString());\n}",
                "name": "toString",
                "modifiers": "@Override\n        public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return String.format(\"{matches=%s,unmatches=%s}\", matches.toString(), unmatches.toString());\n}",
                "start_point": {
                    "row": 524,
                    "column": 8
                },
                "end_point": {
                    "row": 527,
                    "column": 9
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((matches == null) ? 0 : matches.hashCode());\n    result = prime * result + ((unmatches == null) ? 0 : unmatches.hashCode());\n    return result;\n}",
                "name": "hashCode",
                "modifiers": "@Override\n        public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((matches == null) ? 0 : matches.hashCode());\n    result = prime * result + ((unmatches == null) ? 0 : unmatches.hashCode());\n    return result;\n}",
                "start_point": {
                    "row": 530,
                    "column": 8
                },
                "end_point": {
                    "row": 537,
                    "column": 9
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    MatchPair other = (MatchPair) obj;\n    if (matches == null) {\n        if (other.matches != null)\n            return false;\n    } else if (!matches.equals(other.matches))\n        return false;\n    if (unmatches == null) {\n        if (other.unmatches != null)\n            return false;\n    } else if (!unmatches.equals(other.unmatches))\n        return false;\n    return true;\n}",
                "name": "equals",
                "modifiers": "@Override\n        public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "obj"
                    }
                ],
                "body": "{\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    MatchPair other = (MatchPair) obj;\n    if (matches == null) {\n        if (other.matches != null)\n            return false;\n    } else if (!matches.equals(other.matches))\n        return false;\n    if (unmatches == null) {\n        if (other.unmatches != null)\n            return false;\n    } else if (!unmatches.equals(other.unmatches))\n        return false;\n    return true;\n}",
                "start_point": {
                    "row": 540,
                    "column": 8
                },
                "end_point": {
                    "row": 560,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/common/util/SyncUtils.java",
        "definition": "public class SyncUtils {\n\n    public static final String SERVICE_FILTER_KEY = \".service\";\n\n    public static final String ADDRESS_FILTER_KEY = \".address\";\n\n    public static final String ID_FILTER_KEY = \".id\";\n\n    public static Provider url2Provider(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (url == null)\n            return null;\n\n        Provider p = new Provider();\n        p.setHash(id);\n        p.setService(url.getServiceKey());\n        p.setAddress(url.getAddress());\n        p.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n        p.setUrl(url.toIdentityString());\n        p.setParameters(url.toParameterString());\n\n        p.setDynamic(url.getParameter(\"dynamic\", true));\n        p.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n        p.setWeight(url.getParameter(Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT));\n        p.setUsername(url.getParameter(\"owner\"));\n\n        return p;\n    }\n\n    public static List<Provider> url2ProviderList(Map<String, URL> ps) {\n        List<Provider> ret = new ArrayList<>();\n        for (Map.Entry<String, URL> entry : ps.entrySet()) {\n            ret.add(url2Provider(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return ret;\n    }\n\n    public static Consumer url2Consumer(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (null == url)\n            return null;\n\n        Consumer c = new Consumer();\n        c.setHash(id);\n        c.setService(url.getServiceKey());\n        c.setAddress(url.getHost());\n        c.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n        c.setParameters(url.toParameterString());\n\n        return c;\n    }\n\n    public static List<Consumer> url2ConsumerList(Map<String, URL> cs) {\n        List<Consumer> list = new ArrayList<Consumer>();\n        if (cs == null) return list;\n        for (Map.Entry<String, URL> entry : cs.entrySet()) {\n            list.add(url2Consumer(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return list;\n    }\n\n    public static Route url2Route(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (null == url)\n            return null;\n\n        Route r = new Route();\n        r.setHash(id);\n        r.setName(url.getParameter(\"name\"));\n        r.setService(url.getServiceKey());\n        r.setPriority(url.getParameter(Constants.PRIORITY_KEY, 0));\n        r.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n        r.setForce(url.getParameter(Constants.FORCE_KEY, false));\n        r.setDynamic(url.getParameter(Constants.DYNAMIC_KEY, false));\n        r.setRuntime(url.getParameter(Constants.RUNTIME_KEY, false));\n        r.setRule(url.getParameterAndDecoded(Constants.RULE_KEY));\n        return r;\n    }\n\n    public static List<Route> url2RouteList(Map<String, URL> cs) {\n        List<Route> list = new ArrayList<Route>();\n        if (cs == null) return list;\n        for (Map.Entry<String, URL> entry : cs.entrySet()) {\n            list.add(url2Route(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return list;\n    }\n\n    public static Override url2Override(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (null == url)\n            return null;\n\n        Override o = new Override();\n        o.setHash(id);\n\n        Map<String, String> parameters = new HashMap<String, String>(url.getParameters());\n\n        o.setService(url.getServiceKey());\n        parameters.remove(Constants.INTERFACE_KEY);\n        parameters.remove(Constants.GROUP_KEY);\n        parameters.remove(Constants.VERSION_KEY);\n        parameters.remove(Constants.APPLICATION_KEY);\n        parameters.remove(Constants.CATEGORY_KEY);\n        parameters.remove(Constants.DYNAMIC_KEY);\n        parameters.remove(Constants.ENABLED_KEY);\n\n        o.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n\n        String host = url.getHost();\n        boolean anyhost = url.getParameter(Constants.ANYHOST_VALUE, false);\n        if (!anyhost || !\"0.0.0.0\".equals(host)) {\n            o.setAddress(url.getAddress());\n        }\n\n        o.setApplication(url.getParameter(Constants.APPLICATION_KEY, url.getUsername()));\n        parameters.remove(Constants.VERSION_KEY);\n\n        o.setParams(StringUtils.toQueryString(parameters));\n\n        return o;\n    }\n\n    // Map<category, Map<servicename, Map<Long, URL>>>\n    public static <SM extends Map<String, Map<String, URL>>> Map<String, URL> filterFromCategory(Map<String, SM> urls, Map<String, String> filter) {\n        String c = (String) filter.get(Constants.CATEGORY_KEY);\n        if (c == null) throw new IllegalArgumentException(\"no category\");\n\n        filter.remove(Constants.CATEGORY_KEY);\n        return filterFromService(urls.get(c), filter);\n    }\n\n    public static List<Override> url2OverrideList(Map<String, URL> cs) {\n        List<Override>\n            list = new ArrayList<Override>();\n        if (cs == null) return list;\n        for (Map.Entry<String, URL> entry : cs.entrySet()) {\n            list.add(url2Override(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return list;\n    }\n\n\n    // Map<servicename, Map<Long, URL>>\n    public static Map<String, URL> filterFromService(Map<String, Map<String, URL>> urls, Map<String, String> filter) {\n        Map<String, URL> ret = new HashMap<>();\n        if (urls == null) return ret;\n\n        String s = (String) filter.remove(SERVICE_FILTER_KEY);\n        if (s == null) {\n            for (Map.Entry<String, Map<String, URL>> entry : urls.entrySet()) {\n                filterFromUrls(entry.getValue(), ret, filter);\n            }\n        } else {\n            Map<String, URL> map = urls.get(s);\n            filterFromUrls(map, ret, filter);\n        }\n\n        return ret;\n    }\n\n    // Map<Long, URL>\n    static void filterFromUrls(Map<String, URL> from, Map<String, URL> to, Map<String, String> filter) {\n        if (from == null || from.isEmpty()) return;\n\n        for (Map.Entry<String, URL> entry : from.entrySet()) {\n            URL url = entry.getValue();\n\n            boolean match = true;\n            for (Map.Entry<String, String> e : filter.entrySet()) {\n                String key = e.getKey();\n                String value = e.getValue();\n\n                if (ADDRESS_FILTER_KEY.equals(key)) {\n                    if (!value.equals(url.getIp())) {\n                        match = false;\n                        break;\n                    }\n                } else {\n                    if (!value.equals(url.getParameter(key))) {\n                        match = false;\n                        break;\n                    }\n                }\n            }\n\n            if (match) {\n                to.put(entry.getKey(), url);\n            }\n        }\n    }\n\n    public static <SM extends Map<String, Map<String, URL>>> Pair<String, URL> filterFromCategory(Map<String, SM> urls, String category, String id) {\n        SM services = urls.get(category);\n        if (services == null) return null;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : services.entrySet()) {\n            Map<String, URL> u = e1.getValue();\n            if (u.containsKey(id)) return new Pair<>(id, u.get(id));\n        }\n        return null;\n    }\n}",
        "package": "package org.apache.dubbo.admin.common.util;",
        "tree_path": "SyncUtils",
        "name": "SyncUtils",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    public static final String SERVICE_FILTER_KEY = \".service\";\n\n    public static final String ADDRESS_FILTER_KEY = \".address\";\n\n    public static final String ID_FILTER_KEY = \".id\";\n\n    public static Provider url2Provider(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (url == null)\n            return null;\n\n        Provider p = new Provider();\n        p.setHash(id);\n        p.setService(url.getServiceKey());\n        p.setAddress(url.getAddress());\n        p.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n        p.setUrl(url.toIdentityString());\n        p.setParameters(url.toParameterString());\n\n        p.setDynamic(url.getParameter(\"dynamic\", true));\n        p.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n        p.setWeight(url.getParameter(Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT));\n        p.setUsername(url.getParameter(\"owner\"));\n\n        return p;\n    }\n\n    public static List<Provider> url2ProviderList(Map<String, URL> ps) {\n        List<Provider> ret = new ArrayList<>();\n        for (Map.Entry<String, URL> entry : ps.entrySet()) {\n            ret.add(url2Provider(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return ret;\n    }\n\n    public static Consumer url2Consumer(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (null == url)\n            return null;\n\n        Consumer c = new Consumer();\n        c.setHash(id);\n        c.setService(url.getServiceKey());\n        c.setAddress(url.getHost());\n        c.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n        c.setParameters(url.toParameterString());\n\n        return c;\n    }\n\n    public static List<Consumer> url2ConsumerList(Map<String, URL> cs) {\n        List<Consumer> list = new ArrayList<Consumer>();\n        if (cs == null) return list;\n        for (Map.Entry<String, URL> entry : cs.entrySet()) {\n            list.add(url2Consumer(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return list;\n    }\n\n    public static Route url2Route(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (null == url)\n            return null;\n\n        Route r = new Route();\n        r.setHash(id);\n        r.setName(url.getParameter(\"name\"));\n        r.setService(url.getServiceKey());\n        r.setPriority(url.getParameter(Constants.PRIORITY_KEY, 0));\n        r.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n        r.setForce(url.getParameter(Constants.FORCE_KEY, false));\n        r.setDynamic(url.getParameter(Constants.DYNAMIC_KEY, false));\n        r.setRuntime(url.getParameter(Constants.RUNTIME_KEY, false));\n        r.setRule(url.getParameterAndDecoded(Constants.RULE_KEY));\n        return r;\n    }\n\n    public static List<Route> url2RouteList(Map<String, URL> cs) {\n        List<Route> list = new ArrayList<Route>();\n        if (cs == null) return list;\n        for (Map.Entry<String, URL> entry : cs.entrySet()) {\n            list.add(url2Route(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return list;\n    }\n\n    public static Override url2Override(Pair<String, URL> pair) {\n        if (pair == null) {\n            return null;\n        }\n\n        String id = pair.getKey();\n        URL url = pair.getValue();\n\n        if (null == url)\n            return null;\n\n        Override o = new Override();\n        o.setHash(id);\n\n        Map<String, String> parameters = new HashMap<String, String>(url.getParameters());\n\n        o.setService(url.getServiceKey());\n        parameters.remove(Constants.INTERFACE_KEY);\n        parameters.remove(Constants.GROUP_KEY);\n        parameters.remove(Constants.VERSION_KEY);\n        parameters.remove(Constants.APPLICATION_KEY);\n        parameters.remove(Constants.CATEGORY_KEY);\n        parameters.remove(Constants.DYNAMIC_KEY);\n        parameters.remove(Constants.ENABLED_KEY);\n\n        o.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n\n        String host = url.getHost();\n        boolean anyhost = url.getParameter(Constants.ANYHOST_VALUE, false);\n        if (!anyhost || !\"0.0.0.0\".equals(host)) {\n            o.setAddress(url.getAddress());\n        }\n\n        o.setApplication(url.getParameter(Constants.APPLICATION_KEY, url.getUsername()));\n        parameters.remove(Constants.VERSION_KEY);\n\n        o.setParams(StringUtils.toQueryString(parameters));\n\n        return o;\n    }\n\n    // Map<category, Map<servicename, Map<Long, URL>>>\n    public static <SM extends Map<String, Map<String, URL>>> Map<String, URL> filterFromCategory(Map<String, SM> urls, Map<String, String> filter) {\n        String c = (String) filter.get(Constants.CATEGORY_KEY);\n        if (c == null) throw new IllegalArgumentException(\"no category\");\n\n        filter.remove(Constants.CATEGORY_KEY);\n        return filterFromService(urls.get(c), filter);\n    }\n\n    public static List<Override> url2OverrideList(Map<String, URL> cs) {\n        List<Override>\n            list = new ArrayList<Override>();\n        if (cs == null) return list;\n        for (Map.Entry<String, URL> entry : cs.entrySet()) {\n            list.add(url2Override(new Pair<>(entry.getKey(), entry.getValue())));\n        }\n        return list;\n    }\n\n\n    // Map<servicename, Map<Long, URL>>\n    public static Map<String, URL> filterFromService(Map<String, Map<String, URL>> urls, Map<String, String> filter) {\n        Map<String, URL> ret = new HashMap<>();\n        if (urls == null) return ret;\n\n        String s = (String) filter.remove(SERVICE_FILTER_KEY);\n        if (s == null) {\n            for (Map.Entry<String, Map<String, URL>> entry : urls.entrySet()) {\n                filterFromUrls(entry.getValue(), ret, filter);\n            }\n        } else {\n            Map<String, URL> map = urls.get(s);\n            filterFromUrls(map, ret, filter);\n        }\n\n        return ret;\n    }\n\n    // Map<Long, URL>\n    static void filterFromUrls(Map<String, URL> from, Map<String, URL> to, Map<String, String> filter) {\n        if (from == null || from.isEmpty()) return;\n\n        for (Map.Entry<String, URL> entry : from.entrySet()) {\n            URL url = entry.getValue();\n\n            boolean match = true;\n            for (Map.Entry<String, String> e : filter.entrySet()) {\n                String key = e.getKey();\n                String value = e.getValue();\n\n                if (ADDRESS_FILTER_KEY.equals(key)) {\n                    if (!value.equals(url.getIp())) {\n                        match = false;\n                        break;\n                    }\n                } else {\n                    if (!value.equals(url.getParameter(key))) {\n                        match = false;\n                        break;\n                    }\n                }\n            }\n\n            if (match) {\n                to.put(entry.getKey(), url);\n            }\n        }\n    }\n\n    public static <SM extends Map<String, Map<String, URL>>> Pair<String, URL> filterFromCategory(Map<String, SM> urls, String category, String id) {\n        SM services = urls.get(category);\n        if (services == null) return null;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : services.entrySet()) {\n            Map<String, URL> u = e1.getValue();\n            if (u.containsKey(id)) return new Pair<>(id, u.get(id));\n        }\n        return null;\n    }\n}",
        "start_point": {
            "row": 31,
            "column": 0
        },
        "end_point": {
            "row": 257,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public static Provider url2Provider(Pair<String, URL> pair) {\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (url == null)\n        return null;\n\n    Provider p = new Provider();\n    p.setHash(id);\n    p.setService(url.getServiceKey());\n    p.setAddress(url.getAddress());\n    p.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n    p.setUrl(url.toIdentityString());\n    p.setParameters(url.toParameterString());\n\n    p.setDynamic(url.getParameter(\"dynamic\", true));\n    p.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n    p.setWeight(url.getParameter(Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT));\n    p.setUsername(url.getParameter(\"owner\"));\n\n    return p;\n}",
                "name": "url2Provider",
                "modifiers": "public static",
                "return_type": "Provider",
                "parameters": [
                    {
                        "type": "Pair<String, URL>",
                        "name": "pair"
                    }
                ],
                "body": "{\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (url == null)\n        return null;\n\n    Provider p = new Provider();\n    p.setHash(id);\n    p.setService(url.getServiceKey());\n    p.setAddress(url.getAddress());\n    p.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n    p.setUrl(url.toIdentityString());\n    p.setParameters(url.toParameterString());\n\n    p.setDynamic(url.getParameter(\"dynamic\", true));\n    p.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n    p.setWeight(url.getParameter(Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT));\n    p.setUsername(url.getParameter(\"owner\"));\n\n    return p;\n}",
                "start_point": {
                    "row": 39,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            },
            {
                "definition": "public static List<Provider> url2ProviderList(Map<String, URL> ps) {\n    List<Provider> ret = new ArrayList<>();\n    for (Map.Entry<String, URL> entry : ps.entrySet()) {\n        ret.add(url2Provider(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return ret;\n}",
                "name": "url2ProviderList",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, URL>",
                        "name": "ps"
                    }
                ],
                "body": "{\n    List<Provider> ret = new ArrayList<>();\n    for (Map.Entry<String, URL> entry : ps.entrySet()) {\n        ret.add(url2Provider(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return ret;\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 72,
                    "column": 5
                }
            },
            {
                "definition": "public static Consumer url2Consumer(Pair<String, URL> pair) {\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (null == url)\n        return null;\n\n    Consumer c = new Consumer();\n    c.setHash(id);\n    c.setService(url.getServiceKey());\n    c.setAddress(url.getHost());\n    c.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n    c.setParameters(url.toParameterString());\n\n    return c;\n}",
                "name": "url2Consumer",
                "modifiers": "public static",
                "return_type": "Consumer",
                "parameters": [
                    {
                        "type": "Pair<String, URL>",
                        "name": "pair"
                    }
                ],
                "body": "{\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (null == url)\n        return null;\n\n    Consumer c = new Consumer();\n    c.setHash(id);\n    c.setService(url.getServiceKey());\n    c.setAddress(url.getHost());\n    c.setApplication(url.getParameter(Constants.APPLICATION_KEY));\n    c.setParameters(url.toParameterString());\n\n    return c;\n}",
                "start_point": {
                    "row": 74,
                    "column": 4
                },
                "end_point": {
                    "row": 93,
                    "column": 5
                }
            },
            {
                "definition": "public static List<Consumer> url2ConsumerList(Map<String, URL> cs) {\n    List<Consumer> list = new ArrayList<Consumer>();\n    if (cs == null) return list;\n    for (Map.Entry<String, URL> entry : cs.entrySet()) {\n        list.add(url2Consumer(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return list;\n}",
                "name": "url2ConsumerList",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, URL>",
                        "name": "cs"
                    }
                ],
                "body": "{\n    List<Consumer> list = new ArrayList<Consumer>();\n    if (cs == null) return list;\n    for (Map.Entry<String, URL> entry : cs.entrySet()) {\n        list.add(url2Consumer(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return list;\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "public static Route url2Route(Pair<String, URL> pair) {\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (null == url)\n        return null;\n\n    Route r = new Route();\n    r.setHash(id);\n    r.setName(url.getParameter(\"name\"));\n    r.setService(url.getServiceKey());\n    r.setPriority(url.getParameter(Constants.PRIORITY_KEY, 0));\n    r.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n    r.setForce(url.getParameter(Constants.FORCE_KEY, false));\n    r.setDynamic(url.getParameter(Constants.DYNAMIC_KEY, false));\n    r.setRuntime(url.getParameter(Constants.RUNTIME_KEY, false));\n    r.setRule(url.getParameterAndDecoded(Constants.RULE_KEY));\n    return r;\n}",
                "name": "url2Route",
                "modifiers": "public static",
                "return_type": "Route",
                "parameters": [
                    {
                        "type": "Pair<String, URL>",
                        "name": "pair"
                    }
                ],
                "body": "{\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (null == url)\n        return null;\n\n    Route r = new Route();\n    r.setHash(id);\n    r.setName(url.getParameter(\"name\"));\n    r.setService(url.getServiceKey());\n    r.setPriority(url.getParameter(Constants.PRIORITY_KEY, 0));\n    r.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n    r.setForce(url.getParameter(Constants.FORCE_KEY, false));\n    r.setDynamic(url.getParameter(Constants.DYNAMIC_KEY, false));\n    r.setRuntime(url.getParameter(Constants.RUNTIME_KEY, false));\n    r.setRule(url.getParameterAndDecoded(Constants.RULE_KEY));\n    return r;\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 126,
                    "column": 5
                }
            },
            {
                "definition": "public static List<Route> url2RouteList(Map<String, URL> cs) {\n    List<Route> list = new ArrayList<Route>();\n    if (cs == null) return list;\n    for (Map.Entry<String, URL> entry : cs.entrySet()) {\n        list.add(url2Route(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return list;\n}",
                "name": "url2RouteList",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, URL>",
                        "name": "cs"
                    }
                ],
                "body": "{\n    List<Route> list = new ArrayList<Route>();\n    if (cs == null) return list;\n    for (Map.Entry<String, URL> entry : cs.entrySet()) {\n        list.add(url2Route(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return list;\n}",
                "start_point": {
                    "row": 128,
                    "column": 4
                },
                "end_point": {
                    "row": 135,
                    "column": 5
                }
            },
            {
                "definition": "public static Override url2Override(Pair<String, URL> pair) {\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (null == url)\n        return null;\n\n    Override o = new Override();\n    o.setHash(id);\n\n    Map<String, String> parameters = new HashMap<String, String>(url.getParameters());\n\n    o.setService(url.getServiceKey());\n    parameters.remove(Constants.INTERFACE_KEY);\n    parameters.remove(Constants.GROUP_KEY);\n    parameters.remove(Constants.VERSION_KEY);\n    parameters.remove(Constants.APPLICATION_KEY);\n    parameters.remove(Constants.CATEGORY_KEY);\n    parameters.remove(Constants.DYNAMIC_KEY);\n    parameters.remove(Constants.ENABLED_KEY);\n\n    o.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n\n    String host = url.getHost();\n    boolean anyhost = url.getParameter(Constants.ANYHOST_VALUE, false);\n    if (!anyhost || !\"0.0.0.0\".equals(host)) {\n        o.setAddress(url.getAddress());\n    }\n\n    o.setApplication(url.getParameter(Constants.APPLICATION_KEY, url.getUsername()));\n    parameters.remove(Constants.VERSION_KEY);\n\n    o.setParams(StringUtils.toQueryString(parameters));\n\n    return o;\n}",
                "name": "url2Override",
                "modifiers": "public static",
                "return_type": "Override",
                "parameters": [
                    {
                        "type": "Pair<String, URL>",
                        "name": "pair"
                    }
                ],
                "body": "{\n    if (pair == null) {\n        return null;\n    }\n\n    String id = pair.getKey();\n    URL url = pair.getValue();\n\n    if (null == url)\n        return null;\n\n    Override o = new Override();\n    o.setHash(id);\n\n    Map<String, String> parameters = new HashMap<String, String>(url.getParameters());\n\n    o.setService(url.getServiceKey());\n    parameters.remove(Constants.INTERFACE_KEY);\n    parameters.remove(Constants.GROUP_KEY);\n    parameters.remove(Constants.VERSION_KEY);\n    parameters.remove(Constants.APPLICATION_KEY);\n    parameters.remove(Constants.CATEGORY_KEY);\n    parameters.remove(Constants.DYNAMIC_KEY);\n    parameters.remove(Constants.ENABLED_KEY);\n\n    o.setEnabled(url.getParameter(Constants.ENABLED_KEY, true));\n\n    String host = url.getHost();\n    boolean anyhost = url.getParameter(Constants.ANYHOST_VALUE, false);\n    if (!anyhost || !\"0.0.0.0\".equals(host)) {\n        o.setAddress(url.getAddress());\n    }\n\n    o.setApplication(url.getParameter(Constants.APPLICATION_KEY, url.getUsername()));\n    parameters.remove(Constants.VERSION_KEY);\n\n    o.setParams(StringUtils.toQueryString(parameters));\n\n    return o;\n}",
                "start_point": {
                    "row": 137,
                    "column": 4
                },
                "end_point": {
                    "row": 176,
                    "column": 5
                }
            },
            {
                "definition": "public static <SM extends Map<String, Map<String, URL>>> Map<String, URL> filterFromCategory(Map<String, SM> urls, Map<String, String> filter) {\n    String c = (String) filter.get(Constants.CATEGORY_KEY);\n    if (c == null) throw new IllegalArgumentException(\"no category\");\n\n    filter.remove(Constants.CATEGORY_KEY);\n    return filterFromService(urls.get(c), filter);\n}",
                "name": "filterFromCategory",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, SM>",
                        "name": "urls"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "filter"
                    }
                ],
                "body": "{\n    String c = (String) filter.get(Constants.CATEGORY_KEY);\n    if (c == null) throw new IllegalArgumentException(\"no category\");\n\n    filter.remove(Constants.CATEGORY_KEY);\n    return filterFromService(urls.get(c), filter);\n}",
                "start_point": {
                    "row": 179,
                    "column": 4
                },
                "end_point": {
                    "row": 185,
                    "column": 5
                }
            },
            {
                "definition": "public static List<Override> url2OverrideList(Map<String, URL> cs) {\n    List<Override>\n        list = new ArrayList<Override>();\n    if (cs == null) return list;\n    for (Map.Entry<String, URL> entry : cs.entrySet()) {\n        list.add(url2Override(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return list;\n}",
                "name": "url2OverrideList",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, URL>",
                        "name": "cs"
                    }
                ],
                "body": "{\n    List<Override>\n        list = new ArrayList<Override>();\n    if (cs == null) return list;\n    for (Map.Entry<String, URL> entry : cs.entrySet()) {\n        list.add(url2Override(new Pair<>(entry.getKey(), entry.getValue())));\n    }\n    return list;\n}",
                "start_point": {
                    "row": 187,
                    "column": 4
                },
                "end_point": {
                    "row": 195,
                    "column": 5
                }
            },
            {
                "definition": "public static Map<String, URL> filterFromService(Map<String, Map<String, URL>> urls, Map<String, String> filter) {\n    Map<String, URL> ret = new HashMap<>();\n    if (urls == null) return ret;\n\n    String s = (String) filter.remove(SERVICE_FILTER_KEY);\n    if (s == null) {\n        for (Map.Entry<String, Map<String, URL>> entry : urls.entrySet()) {\n            filterFromUrls(entry.getValue(), ret, filter);\n        }\n    } else {\n        Map<String, URL> map = urls.get(s);\n        filterFromUrls(map, ret, filter);\n    }\n\n    return ret;\n}",
                "name": "filterFromService",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, Map<String, URL>>",
                        "name": "urls"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "filter"
                    }
                ],
                "body": "{\n    Map<String, URL> ret = new HashMap<>();\n    if (urls == null) return ret;\n\n    String s = (String) filter.remove(SERVICE_FILTER_KEY);\n    if (s == null) {\n        for (Map.Entry<String, Map<String, URL>> entry : urls.entrySet()) {\n            filterFromUrls(entry.getValue(), ret, filter);\n        }\n    } else {\n        Map<String, URL> map = urls.get(s);\n        filterFromUrls(map, ret, filter);\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 199,
                    "column": 4
                },
                "end_point": {
                    "row": 214,
                    "column": 5
                }
            },
            {
                "definition": "static void filterFromUrls(Map<String, URL> from, Map<String, URL> to, Map<String, String> filter) {\n    if (from == null || from.isEmpty()) return;\n\n    for (Map.Entry<String, URL> entry : from.entrySet()) {\n        URL url = entry.getValue();\n\n        boolean match = true;\n        for (Map.Entry<String, String> e : filter.entrySet()) {\n            String key = e.getKey();\n            String value = e.getValue();\n\n            if (ADDRESS_FILTER_KEY.equals(key)) {\n                if (!value.equals(url.getIp())) {\n                    match = false;\n                    break;\n                }\n            } else {\n                if (!value.equals(url.getParameter(key))) {\n                    match = false;\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            to.put(entry.getKey(), url);\n        }\n    }\n}",
                "name": "filterFromUrls",
                "modifiers": "static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, URL>",
                        "name": "from"
                    },
                    {
                        "type": "Map<String, URL>",
                        "name": "to"
                    },
                    {
                        "type": "Map<String, String>",
                        "name": "filter"
                    }
                ],
                "body": "{\n    if (from == null || from.isEmpty()) return;\n\n    for (Map.Entry<String, URL> entry : from.entrySet()) {\n        URL url = entry.getValue();\n\n        boolean match = true;\n        for (Map.Entry<String, String> e : filter.entrySet()) {\n            String key = e.getKey();\n            String value = e.getValue();\n\n            if (ADDRESS_FILTER_KEY.equals(key)) {\n                if (!value.equals(url.getIp())) {\n                    match = false;\n                    break;\n                }\n            } else {\n                if (!value.equals(url.getParameter(key))) {\n                    match = false;\n                    break;\n                }\n            }\n        }\n\n        if (match) {\n            to.put(entry.getKey(), url);\n        }\n    }\n}",
                "start_point": {
                    "row": 217,
                    "column": 4
                },
                "end_point": {
                    "row": 245,
                    "column": 5
                }
            },
            {
                "definition": "public static <SM extends Map<String, Map<String, URL>>> Pair<String, URL> filterFromCategory(Map<String, SM> urls, String category, String id) {\n    SM services = urls.get(category);\n    if (services == null) return null;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : services.entrySet()) {\n        Map<String, URL> u = e1.getValue();\n        if (u.containsKey(id)) return new Pair<>(id, u.get(id));\n    }\n    return null;\n}",
                "name": "filterFromCategory",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, SM>",
                        "name": "urls"
                    },
                    {
                        "type": "String",
                        "name": "category"
                    },
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    SM services = urls.get(category);\n    if (services == null) return null;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : services.entrySet()) {\n        Map<String, URL> u = e1.getValue();\n        if (u.containsKey(id)) return new Pair<>(id, u.get(id));\n    }\n    return null;\n}",
                "start_point": {
                    "row": 247,
                    "column": 4
                },
                "end_point": {
                    "row": 256,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/controller/AccessesController.java",
        "definition": "@RestController\n@RequestMapping(\"/api/{env}/rules/access\")\npublic class AccessesController {\n    private static final Logger logger = LoggerFactory.getLogger(AccessesController.class);\n\n    private final RouteService routeService;\n\n    @Autowired\n    public AccessesController(RouteService routeService) {\n        this.routeService = routeService;\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<AccessDTO> searchAccess(@RequestParam(required = false) String service, @PathVariable String env) throws ParseException {\n        List<AccessDTO> result = new ArrayList<>();\n        List<Route> routes = new ArrayList<>();\n        if (StringUtils.isNotBlank(service)) {\n            Route route = routeService.getBlackwhitelistRouteByService(service.trim());\n            if (route != null) {\n                routes.add(route);\n            }\n        } else {\n            routes = routeService.findAllForceRoute();\n        }\n\n        for (Route route : routes) {\n            // Match WhiteBlackList Route\n            if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n                AccessDTO accessDTO = new AccessDTO();\n                accessDTO.setId(route.getHash());\n                accessDTO.setService(route.getService());\n                Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n                for (String key : when.keySet()) {\n                    accessDTO.setWhitelist(when.get(key).getUnmatches());\n                    accessDTO.setBlacklist(when.get(key).getMatches());\n                }\n                result.add(accessDTO);\n            }\n        }\n        return result;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public AccessDTO detailAccess(@PathVariable String id, @PathVariable String env) throws ParseException {\n        Route route = routeService.findRoute(id);\n        if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n            AccessDTO accessDTO = new AccessDTO();\n            accessDTO.setId(route.getHash());\n            accessDTO.setService(route.getService());\n            Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n            for (String key : when.keySet()) {\n                accessDTO.setWhitelist(when.get(key).getUnmatches());\n                accessDTO.setBlacklist(when.get(key).getMatches());\n            }\n            return accessDTO;\n        } else {\n            return null;\n        }\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n    public void deleteAccess(@PathVariable String id, @PathVariable String env) {\n        routeService.deleteRoute(id);\n    }\n\n    @RequestMapping(method = RequestMethod.POST)\n    @ResponseStatus(HttpStatus.CREATED)\n    public void createAccess(@RequestBody AccessDTO accessDTO, @PathVariable String env) {\n        if (StringUtils.isBlank(accessDTO.getService())) {\n            throw new ParamValidationException(\"Service is required.\");\n        }\n        if (accessDTO.getBlacklist() == null && accessDTO.getWhitelist() == null) {\n            throw new ParamValidationException(\"One of Blacklist/Whitelist is required.\");\n        }\n\n        Route route = routeService.getBlackwhitelistRouteByService(accessDTO.getService());\n\n        if (route != null) {\n            throw new ParamValidationException(accessDTO.getService() + \" is existed.\");\n        }\n\n        route = new Route();\n        route.setService(accessDTO.getService());\n        route.setForce(true);\n        route.setName(accessDTO.getService() + \" \" + AccessDTO.KEY_BLACK_WHITE_LIST);\n        route.setFilterRule(\"false\");\n        route.setEnabled(true);\n\n        Map<String, RouteRule.MatchPair> when = new HashMap<>();\n        RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n        when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n        if (accessDTO.getWhitelist() != null) {\n            matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n        }\n        if (accessDTO.getBlacklist() != null) {\n            matchPair.getMatches().addAll(accessDTO.getBlacklist());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        RouteRule.contidionToString(sb, when);\n        route.setMatchRule(sb.toString());\n        routeService.createRoute(route);\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\n    public void updateAccess(@PathVariable String id, @RequestBody AccessDTO accessDTO, @PathVariable String env) {\n        Route route = routeService.findRoute(id);\n        if (Objects.isNull(route)) {\n            throw new ResourceNotFoundException(\"Unknown ID!\");\n        }\n        Map<String, RouteRule.MatchPair> when = new HashMap<>();\n        RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n        when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n        if (accessDTO.getWhitelist() != null) {\n            matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n        }\n        if (accessDTO.getBlacklist() != null) {\n            matchPair.getMatches().addAll(accessDTO.getBlacklist());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        RouteRule.contidionToString(sb, when);\n        route.setMatchRule(sb.toString());\n\n        routeService.updateRoute(route);\n    }\n}",
        "package": "package org.apache.dubbo.admin.controller;",
        "tree_path": "AccessesController",
        "name": "AccessesController",
        "modifiers": "@RestController\n@RequestMapping(\"/api/{env}/rules/access\")\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    private static final Logger logger = LoggerFactory.getLogger(AccessesController.class);\n\n    private final RouteService routeService;\n\n    @Autowired\n    public AccessesController(RouteService routeService) {\n        this.routeService = routeService;\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<AccessDTO> searchAccess(@RequestParam(required = false) String service, @PathVariable String env) throws ParseException {\n        List<AccessDTO> result = new ArrayList<>();\n        List<Route> routes = new ArrayList<>();\n        if (StringUtils.isNotBlank(service)) {\n            Route route = routeService.getBlackwhitelistRouteByService(service.trim());\n            if (route != null) {\n                routes.add(route);\n            }\n        } else {\n            routes = routeService.findAllForceRoute();\n        }\n\n        for (Route route : routes) {\n            // Match WhiteBlackList Route\n            if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n                AccessDTO accessDTO = new AccessDTO();\n                accessDTO.setId(route.getHash());\n                accessDTO.setService(route.getService());\n                Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n                for (String key : when.keySet()) {\n                    accessDTO.setWhitelist(when.get(key).getUnmatches());\n                    accessDTO.setBlacklist(when.get(key).getMatches());\n                }\n                result.add(accessDTO);\n            }\n        }\n        return result;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public AccessDTO detailAccess(@PathVariable String id, @PathVariable String env) throws ParseException {\n        Route route = routeService.findRoute(id);\n        if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n            AccessDTO accessDTO = new AccessDTO();\n            accessDTO.setId(route.getHash());\n            accessDTO.setService(route.getService());\n            Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n            for (String key : when.keySet()) {\n                accessDTO.setWhitelist(when.get(key).getUnmatches());\n                accessDTO.setBlacklist(when.get(key).getMatches());\n            }\n            return accessDTO;\n        } else {\n            return null;\n        }\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n    public void deleteAccess(@PathVariable String id, @PathVariable String env) {\n        routeService.deleteRoute(id);\n    }\n\n    @RequestMapping(method = RequestMethod.POST)\n    @ResponseStatus(HttpStatus.CREATED)\n    public void createAccess(@RequestBody AccessDTO accessDTO, @PathVariable String env) {\n        if (StringUtils.isBlank(accessDTO.getService())) {\n            throw new ParamValidationException(\"Service is required.\");\n        }\n        if (accessDTO.getBlacklist() == null && accessDTO.getWhitelist() == null) {\n            throw new ParamValidationException(\"One of Blacklist/Whitelist is required.\");\n        }\n\n        Route route = routeService.getBlackwhitelistRouteByService(accessDTO.getService());\n\n        if (route != null) {\n            throw new ParamValidationException(accessDTO.getService() + \" is existed.\");\n        }\n\n        route = new Route();\n        route.setService(accessDTO.getService());\n        route.setForce(true);\n        route.setName(accessDTO.getService() + \" \" + AccessDTO.KEY_BLACK_WHITE_LIST);\n        route.setFilterRule(\"false\");\n        route.setEnabled(true);\n\n        Map<String, RouteRule.MatchPair> when = new HashMap<>();\n        RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n        when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n        if (accessDTO.getWhitelist() != null) {\n            matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n        }\n        if (accessDTO.getBlacklist() != null) {\n            matchPair.getMatches().addAll(accessDTO.getBlacklist());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        RouteRule.contidionToString(sb, when);\n        route.setMatchRule(sb.toString());\n        routeService.createRoute(route);\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\n    public void updateAccess(@PathVariable String id, @RequestBody AccessDTO accessDTO, @PathVariable String env) {\n        Route route = routeService.findRoute(id);\n        if (Objects.isNull(route)) {\n            throw new ResourceNotFoundException(\"Unknown ID!\");\n        }\n        Map<String, RouteRule.MatchPair> when = new HashMap<>();\n        RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n        when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n        if (accessDTO.getWhitelist() != null) {\n            matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n        }\n        if (accessDTO.getBlacklist() != null) {\n            matchPair.getMatches().addAll(accessDTO.getBlacklist());\n        }\n\n        StringBuilder sb = new StringBuilder();\n        RouteRule.contidionToString(sb, when);\n        route.setMatchRule(sb.toString());\n\n        routeService.updateRoute(route);\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 162,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Autowired\npublic AccessesController(RouteService routeService) {\n    this.routeService = routeService;\n}",
                "name": "AccessesController",
                "modifiers": "@Autowired\n    public",
                "parameters": [
                    {
                        "type": "RouteService",
                        "name": "routeService"
                    }
                ],
                "body": "{\n    this.routeService = routeService;\n}",
                "constructor": true,
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(method = RequestMethod.GET)\npublic List<AccessDTO> searchAccess(@RequestParam(required = false) String service, @PathVariable String env) throws ParseException {\n    List<AccessDTO> result = new ArrayList<>();\n    List<Route> routes = new ArrayList<>();\n    if (StringUtils.isNotBlank(service)) {\n        Route route = routeService.getBlackwhitelistRouteByService(service.trim());\n        if (route != null) {\n            routes.add(route);\n        }\n    } else {\n        routes = routeService.findAllForceRoute();\n    }\n\n    for (Route route : routes) {\n        // Match WhiteBlackList Route\n        if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n            AccessDTO accessDTO = new AccessDTO();\n            accessDTO.setId(route.getHash());\n            accessDTO.setService(route.getService());\n            Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n            for (String key : when.keySet()) {\n                accessDTO.setWhitelist(when.get(key).getUnmatches());\n                accessDTO.setBlacklist(when.get(key).getMatches());\n            }\n            result.add(accessDTO);\n        }\n    }\n    return result;\n}",
                "name": "searchAccess",
                "modifiers": "@RequestMapping(method = RequestMethod.GET)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@RequestParam(required = false)",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    List<AccessDTO> result = new ArrayList<>();\n    List<Route> routes = new ArrayList<>();\n    if (StringUtils.isNotBlank(service)) {\n        Route route = routeService.getBlackwhitelistRouteByService(service.trim());\n        if (route != null) {\n            routes.add(route);\n        }\n    } else {\n        routes = routeService.findAllForceRoute();\n    }\n\n    for (Route route : routes) {\n        // Match WhiteBlackList Route\n        if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n            AccessDTO accessDTO = new AccessDTO();\n            accessDTO.setId(route.getHash());\n            accessDTO.setService(route.getService());\n            Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n            for (String key : when.keySet()) {\n                accessDTO.setWhitelist(when.get(key).getUnmatches());\n                accessDTO.setBlacklist(when.get(key).getMatches());\n            }\n            result.add(accessDTO);\n        }\n    }\n    return result;\n}",
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\npublic AccessDTO detailAccess(@PathVariable String id, @PathVariable String env) throws ParseException {\n    Route route = routeService.findRoute(id);\n    if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n        AccessDTO accessDTO = new AccessDTO();\n        accessDTO.setId(route.getHash());\n        accessDTO.setService(route.getService());\n        Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n        for (String key : when.keySet()) {\n            accessDTO.setWhitelist(when.get(key).getUnmatches());\n            accessDTO.setBlacklist(when.get(key).getMatches());\n        }\n        return accessDTO;\n    } else {\n        return null;\n    }\n}",
                "name": "detailAccess",
                "modifiers": "@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public",
                "return_type": "AccessDTO",
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    Route route = routeService.findRoute(id);\n    if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n        AccessDTO accessDTO = new AccessDTO();\n        accessDTO.setId(route.getHash());\n        accessDTO.setService(route.getService());\n        Map<String, RouteRule.MatchPair> when = RouteRule.parseRule(route.getMatchRule());\n        for (String key : when.keySet()) {\n            accessDTO.setWhitelist(when.get(key).getUnmatches());\n            accessDTO.setBlacklist(when.get(key).getMatches());\n        }\n        return accessDTO;\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 76,
                    "column": 4
                },
                "end_point": {
                    "row": 92,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\npublic void deleteAccess(@PathVariable String id, @PathVariable String env) {\n    routeService.deleteRoute(id);\n}",
                "name": "deleteAccess",
                "modifiers": "@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    routeService.deleteRoute(id);\n}",
                "start_point": {
                    "row": 94,
                    "column": 4
                },
                "end_point": {
                    "row": 97,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(method = RequestMethod.POST)\n@ResponseStatus(HttpStatus.CREATED)\npublic void createAccess(@RequestBody AccessDTO accessDTO, @PathVariable String env) {\n    if (StringUtils.isBlank(accessDTO.getService())) {\n        throw new ParamValidationException(\"Service is required.\");\n    }\n    if (accessDTO.getBlacklist() == null && accessDTO.getWhitelist() == null) {\n        throw new ParamValidationException(\"One of Blacklist/Whitelist is required.\");\n    }\n\n    Route route = routeService.getBlackwhitelistRouteByService(accessDTO.getService());\n\n    if (route != null) {\n        throw new ParamValidationException(accessDTO.getService() + \" is existed.\");\n    }\n\n    route = new Route();\n    route.setService(accessDTO.getService());\n    route.setForce(true);\n    route.setName(accessDTO.getService() + \" \" + AccessDTO.KEY_BLACK_WHITE_LIST);\n    route.setFilterRule(\"false\");\n    route.setEnabled(true);\n\n    Map<String, RouteRule.MatchPair> when = new HashMap<>();\n    RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n    when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n    if (accessDTO.getWhitelist() != null) {\n        matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n    }\n    if (accessDTO.getBlacklist() != null) {\n        matchPair.getMatches().addAll(accessDTO.getBlacklist());\n    }\n\n    StringBuilder sb = new StringBuilder();\n    RouteRule.contidionToString(sb, when);\n    route.setMatchRule(sb.toString());\n    routeService.createRoute(route);\n}",
                "name": "createAccess",
                "modifiers": "@RequestMapping(method = RequestMethod.POST)\n    @ResponseStatus(HttpStatus.CREATED)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@RequestBody",
                        "name": "AccessDTO"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    if (StringUtils.isBlank(accessDTO.getService())) {\n        throw new ParamValidationException(\"Service is required.\");\n    }\n    if (accessDTO.getBlacklist() == null && accessDTO.getWhitelist() == null) {\n        throw new ParamValidationException(\"One of Blacklist/Whitelist is required.\");\n    }\n\n    Route route = routeService.getBlackwhitelistRouteByService(accessDTO.getService());\n\n    if (route != null) {\n        throw new ParamValidationException(accessDTO.getService() + \" is existed.\");\n    }\n\n    route = new Route();\n    route.setService(accessDTO.getService());\n    route.setForce(true);\n    route.setName(accessDTO.getService() + \" \" + AccessDTO.KEY_BLACK_WHITE_LIST);\n    route.setFilterRule(\"false\");\n    route.setEnabled(true);\n\n    Map<String, RouteRule.MatchPair> when = new HashMap<>();\n    RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n    when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n    if (accessDTO.getWhitelist() != null) {\n        matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n    }\n    if (accessDTO.getBlacklist() != null) {\n        matchPair.getMatches().addAll(accessDTO.getBlacklist());\n    }\n\n    StringBuilder sb = new StringBuilder();\n    RouteRule.contidionToString(sb, when);\n    route.setMatchRule(sb.toString());\n    routeService.createRoute(route);\n}",
                "start_point": {
                    "row": 99,
                    "column": 4
                },
                "end_point": {
                    "row": 137,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\npublic void updateAccess(@PathVariable String id, @RequestBody AccessDTO accessDTO, @PathVariable String env) {\n    Route route = routeService.findRoute(id);\n    if (Objects.isNull(route)) {\n        throw new ResourceNotFoundException(\"Unknown ID!\");\n    }\n    Map<String, RouteRule.MatchPair> when = new HashMap<>();\n    RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n    when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n    if (accessDTO.getWhitelist() != null) {\n        matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n    }\n    if (accessDTO.getBlacklist() != null) {\n        matchPair.getMatches().addAll(accessDTO.getBlacklist());\n    }\n\n    StringBuilder sb = new StringBuilder();\n    RouteRule.contidionToString(sb, when);\n    route.setMatchRule(sb.toString());\n\n    routeService.updateRoute(route);\n}",
                "name": "updateAccess",
                "modifiers": "@RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@RequestBody",
                        "name": "AccessDTO"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    Route route = routeService.findRoute(id);\n    if (Objects.isNull(route)) {\n        throw new ResourceNotFoundException(\"Unknown ID!\");\n    }\n    Map<String, RouteRule.MatchPair> when = new HashMap<>();\n    RouteRule.MatchPair matchPair = new RouteRule.MatchPair(new HashSet<>(), new HashSet<>());\n    when.put(Route.KEY_CONSUMER_HOST, matchPair);\n\n    if (accessDTO.getWhitelist() != null) {\n        matchPair.getUnmatches().addAll(accessDTO.getWhitelist());\n    }\n    if (accessDTO.getBlacklist() != null) {\n        matchPair.getMatches().addAll(accessDTO.getBlacklist());\n    }\n\n    StringBuilder sb = new StringBuilder();\n    RouteRule.contidionToString(sb, when);\n    route.setMatchRule(sb.toString());\n\n    routeService.updateRoute(route);\n}",
                "start_point": {
                    "row": 139,
                    "column": 4
                },
                "end_point": {
                    "row": 161,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/controller/OverridesController.java",
        "definition": "@RestController\n@RequestMapping(\"/api/{env}/rules/override\")\npublic class OverridesController {\n\n    private final OverrideService overrideService;\n\n    @Autowired\n    public OverridesController(OverrideService overrideService) {\n        this.overrideService = overrideService;\n    }\n\n    @RequestMapping(method = RequestMethod.POST)\n    @ResponseStatus(HttpStatus.CREATED)\n    public boolean createOverride(@RequestBody OverrideDTO overrideDTO, @PathVariable String env) {\n        String serviceName = overrideDTO.getService();\n        if (StringUtils.isEmpty(serviceName)) {\n            throw new ParamValidationException(\"serviceName is Empty!\");\n        }\n        Override override = new Override();\n        override.setService(serviceName);\n        override.setApplication(overrideDTO.getApplication());\n        override.setAddress(overrideDTO.getAddress());\n        override.setEnabled(overrideDTO.isEnabled());\n        overrideDTOToParams(override, overrideDTO);\n        overrideService.saveOverride(override);\n        return true;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\n    public boolean updateOverride(@PathVariable String id, @RequestBody OverrideDTO overrideDTO, @PathVariable String env) {\n        Override old = overrideService.findById(id);\n        if (old == null) {\n            throw new ResourceNotFoundException(\"Unknown ID!\");\n        }\n        Override override = new Override();\n        override.setService(overrideDTO.getService());\n        override.setApplication(overrideDTO.getApplication());\n        override.setAddress(overrideDTO.getAddress());\n        override.setEnabled(overrideDTO.isEnabled());\n        overrideDTOToParams(override, overrideDTO);\n        override.setHash(id);\n        overrideService.updateOverride(override);\n        return true;\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<OverrideDTO> searchOverride(@RequestParam(required = false) String service, @PathVariable String env) {\n        List<Override> overrides;\n        if (StringUtils.isEmpty(service)) {\n            overrides = overrideService.findAll();\n        } else {\n            overrides = overrideService.findByService(service);\n        }\n        List<OverrideDTO> result = new ArrayList<>();\n        for (Override override : overrides) {\n            OverrideDTO overrideDTO = new OverrideDTO();\n            overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n            overrideDTO.setApplication(override.getApplication());\n            overrideDTO.setEnabled(override.isEnabled());\n            overrideDTO.setService(override.getService());\n            overrideDTO.setId(override.getHash());\n            paramsToOverrideDTO(override, overrideDTO);\n            result.add(overrideDTO);\n        }\n        return result;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public OverrideDTO detailOverride(@PathVariable String id, @PathVariable String env) {\n        Override override = overrideService.findById(id);\n        if (override == null) {\n            throw new ResourceNotFoundException(\"Unknown ID!\");\n        }\n        OverrideDTO overrideDTO = new OverrideDTO();\n        overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n        overrideDTO.setApplication(override.getApplication());\n        overrideDTO.setEnabled(override.isEnabled());\n        overrideDTO.setService(override.getService());\n        paramsToOverrideDTO(override, overrideDTO);\n        return overrideDTO;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n    public boolean deleteOverride(@PathVariable String id, @PathVariable String env) {\n        overrideService.deleteOverride(id);\n        return true;\n    }\n\n    @RequestMapping(value = \"/enable/{id}\", method = RequestMethod.PUT)\n    public boolean enableRoute(@PathVariable String id, @PathVariable String env) {\n\n        overrideService.enableOverride(id);\n        return true;\n    }\n\n    @RequestMapping(value = \"/disable/{id}\", method = RequestMethod.PUT)\n    public boolean disableRoute(@PathVariable String id, @PathVariable String env) {\n\n        overrideService.disableOverride(id);\n        return true;\n    }\n\n    private void overrideDTOToParams(Override override, OverrideDTO overrideDTO) {\n        Map<Object, String>[] mocks = overrideDTO.getMock();\n        Map<String, Object>[] parameters = overrideDTO.getParameters();\n        StringBuilder params = new StringBuilder();\n        if (mocks != null) {\n            for (Map<Object, String> mock : mocks) {\n                for (Map.Entry<Object, String> entry : mock.entrySet()) {\n                    String key;\n                    if (entry.getKey().equals(\"0\")) {\n                        key = \"mock\";\n                    } else {\n                        key = entry.getKey() + \".mock\";\n                    }\n                    String value = key + \"=\" + URL.encode(entry.getValue());\n                    params.append(value).append(\"&\");\n                }\n            }\n        }\n\n        if (parameters != null) {\n            for (Map<String, Object> param : parameters) {\n                for (Map.Entry<String, Object> entry : param.entrySet()) {\n                    String value = entry.getKey() + \"=\" + entry.getValue();\n                    params.append(value).append(\"&\");\n                }\n            }\n        }\n        if (StringUtils.isNotEmpty(params)) {\n            int length = params.length();\n            if (params.charAt(length - 1) == '&') {\n                params.deleteCharAt(length - 1);\n            }\n        }\n        override.setParams(params.toString());\n    }\n\n    private void paramsToOverrideDTO(Override override, OverrideDTO overrideDTO) {\n        String params = override.getParams();\n        if (StringUtils.isNotEmpty(params)) {\n            List<Map<Object, String>> mock = new ArrayList<>();\n            List<Map<String, Object>> parameters = new ArrayList<>();\n            String[] pair = params.split(\"&\");\n            for (String p : pair) {\n                String key = p.split(\"=\")[0];\n                if (key.contains(\"mock\")) {\n                    //mock\n                    String value = URL.decode(p.split(\"=\")[1]);\n                    Map<Object, String> item = new HashMap<>();\n                    if (key.contains(\".\")) {\n                        //single method mock\n                        key = key.split(\"\\\\.\")[0];\n                        item.put(key, value);\n                    } else {\n                        item.put(0, value);\n                    }\n                    mock.add(item);\n                } else {\n                    //parameter\n                    String value = p.split(\"=\")[1];\n                    Map<String, Object> item = new HashMap<>();\n                    item.put(key, value);\n                    parameters.add(item);\n                }\n            }\n            Map<Object, String>[] mockArray = new Map[mock.size()];\n            overrideDTO.setMock(mock.toArray(mockArray));\n            Map<String, Object>[] paramArray = new Map[parameters.size()];\n            overrideDTO.setParameters(parameters.toArray(paramArray));\n        }\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.controller;",
        "tree_path": "OverridesController",
        "name": "OverridesController",
        "modifiers": "@RestController\n@RequestMapping(\"/api/{env}/rules/override\")\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final OverrideService overrideService;\n\n    @Autowired\n    public OverridesController(OverrideService overrideService) {\n        this.overrideService = overrideService;\n    }\n\n    @RequestMapping(method = RequestMethod.POST)\n    @ResponseStatus(HttpStatus.CREATED)\n    public boolean createOverride(@RequestBody OverrideDTO overrideDTO, @PathVariable String env) {\n        String serviceName = overrideDTO.getService();\n        if (StringUtils.isEmpty(serviceName)) {\n            throw new ParamValidationException(\"serviceName is Empty!\");\n        }\n        Override override = new Override();\n        override.setService(serviceName);\n        override.setApplication(overrideDTO.getApplication());\n        override.setAddress(overrideDTO.getAddress());\n        override.setEnabled(overrideDTO.isEnabled());\n        overrideDTOToParams(override, overrideDTO);\n        overrideService.saveOverride(override);\n        return true;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\n    public boolean updateOverride(@PathVariable String id, @RequestBody OverrideDTO overrideDTO, @PathVariable String env) {\n        Override old = overrideService.findById(id);\n        if (old == null) {\n            throw new ResourceNotFoundException(\"Unknown ID!\");\n        }\n        Override override = new Override();\n        override.setService(overrideDTO.getService());\n        override.setApplication(overrideDTO.getApplication());\n        override.setAddress(overrideDTO.getAddress());\n        override.setEnabled(overrideDTO.isEnabled());\n        overrideDTOToParams(override, overrideDTO);\n        override.setHash(id);\n        overrideService.updateOverride(override);\n        return true;\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public List<OverrideDTO> searchOverride(@RequestParam(required = false) String service, @PathVariable String env) {\n        List<Override> overrides;\n        if (StringUtils.isEmpty(service)) {\n            overrides = overrideService.findAll();\n        } else {\n            overrides = overrideService.findByService(service);\n        }\n        List<OverrideDTO> result = new ArrayList<>();\n        for (Override override : overrides) {\n            OverrideDTO overrideDTO = new OverrideDTO();\n            overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n            overrideDTO.setApplication(override.getApplication());\n            overrideDTO.setEnabled(override.isEnabled());\n            overrideDTO.setService(override.getService());\n            overrideDTO.setId(override.getHash());\n            paramsToOverrideDTO(override, overrideDTO);\n            result.add(overrideDTO);\n        }\n        return result;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public OverrideDTO detailOverride(@PathVariable String id, @PathVariable String env) {\n        Override override = overrideService.findById(id);\n        if (override == null) {\n            throw new ResourceNotFoundException(\"Unknown ID!\");\n        }\n        OverrideDTO overrideDTO = new OverrideDTO();\n        overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n        overrideDTO.setApplication(override.getApplication());\n        overrideDTO.setEnabled(override.isEnabled());\n        overrideDTO.setService(override.getService());\n        paramsToOverrideDTO(override, overrideDTO);\n        return overrideDTO;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n    public boolean deleteOverride(@PathVariable String id, @PathVariable String env) {\n        overrideService.deleteOverride(id);\n        return true;\n    }\n\n    @RequestMapping(value = \"/enable/{id}\", method = RequestMethod.PUT)\n    public boolean enableRoute(@PathVariable String id, @PathVariable String env) {\n\n        overrideService.enableOverride(id);\n        return true;\n    }\n\n    @RequestMapping(value = \"/disable/{id}\", method = RequestMethod.PUT)\n    public boolean disableRoute(@PathVariable String id, @PathVariable String env) {\n\n        overrideService.disableOverride(id);\n        return true;\n    }\n\n    private void overrideDTOToParams(Override override, OverrideDTO overrideDTO) {\n        Map<Object, String>[] mocks = overrideDTO.getMock();\n        Map<String, Object>[] parameters = overrideDTO.getParameters();\n        StringBuilder params = new StringBuilder();\n        if (mocks != null) {\n            for (Map<Object, String> mock : mocks) {\n                for (Map.Entry<Object, String> entry : mock.entrySet()) {\n                    String key;\n                    if (entry.getKey().equals(\"0\")) {\n                        key = \"mock\";\n                    } else {\n                        key = entry.getKey() + \".mock\";\n                    }\n                    String value = key + \"=\" + URL.encode(entry.getValue());\n                    params.append(value).append(\"&\");\n                }\n            }\n        }\n\n        if (parameters != null) {\n            for (Map<String, Object> param : parameters) {\n                for (Map.Entry<String, Object> entry : param.entrySet()) {\n                    String value = entry.getKey() + \"=\" + entry.getValue();\n                    params.append(value).append(\"&\");\n                }\n            }\n        }\n        if (StringUtils.isNotEmpty(params)) {\n            int length = params.length();\n            if (params.charAt(length - 1) == '&') {\n                params.deleteCharAt(length - 1);\n            }\n        }\n        override.setParams(params.toString());\n    }\n\n    private void paramsToOverrideDTO(Override override, OverrideDTO overrideDTO) {\n        String params = override.getParams();\n        if (StringUtils.isNotEmpty(params)) {\n            List<Map<Object, String>> mock = new ArrayList<>();\n            List<Map<String, Object>> parameters = new ArrayList<>();\n            String[] pair = params.split(\"&\");\n            for (String p : pair) {\n                String key = p.split(\"=\")[0];\n                if (key.contains(\"mock\")) {\n                    //mock\n                    String value = URL.decode(p.split(\"=\")[1]);\n                    Map<Object, String> item = new HashMap<>();\n                    if (key.contains(\".\")) {\n                        //single method mock\n                        key = key.split(\"\\\\.\")[0];\n                        item.put(key, value);\n                    } else {\n                        item.put(0, value);\n                    }\n                    mock.add(item);\n                } else {\n                    //parameter\n                    String value = p.split(\"=\")[1];\n                    Map<String, Object> item = new HashMap<>();\n                    item.put(key, value);\n                    parameters.add(item);\n                }\n            }\n            Map<Object, String>[] mockArray = new Map[mock.size()];\n            overrideDTO.setMock(mock.toArray(mockArray));\n            Map<String, Object>[] paramArray = new Map[parameters.size()];\n            overrideDTO.setParameters(parameters.toArray(paramArray));\n        }\n    }\n\n}",
        "start_point": {
            "row": 35,
            "column": 0
        },
        "end_point": {
            "row": 208,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Autowired\npublic OverridesController(OverrideService overrideService) {\n    this.overrideService = overrideService;\n}",
                "name": "OverridesController",
                "modifiers": "@Autowired\n    public",
                "parameters": [
                    {
                        "type": "OverrideService",
                        "name": "overrideService"
                    }
                ],
                "body": "{\n    this.overrideService = overrideService;\n}",
                "constructor": true,
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(method = RequestMethod.POST)\n@ResponseStatus(HttpStatus.CREATED)\npublic boolean createOverride(@RequestBody OverrideDTO overrideDTO, @PathVariable String env) {\n    String serviceName = overrideDTO.getService();\n    if (StringUtils.isEmpty(serviceName)) {\n        throw new ParamValidationException(\"serviceName is Empty!\");\n    }\n    Override override = new Override();\n    override.setService(serviceName);\n    override.setApplication(overrideDTO.getApplication());\n    override.setAddress(overrideDTO.getAddress());\n    override.setEnabled(overrideDTO.isEnabled());\n    overrideDTOToParams(override, overrideDTO);\n    overrideService.saveOverride(override);\n    return true;\n}",
                "name": "createOverride",
                "modifiers": "@RequestMapping(method = RequestMethod.POST)\n    @ResponseStatus(HttpStatus.CREATED)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@RequestBody",
                        "name": "OverrideDTO"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    String serviceName = overrideDTO.getService();\n    if (StringUtils.isEmpty(serviceName)) {\n        throw new ParamValidationException(\"serviceName is Empty!\");\n    }\n    Override override = new Override();\n    override.setService(serviceName);\n    override.setApplication(overrideDTO.getApplication());\n    override.setAddress(overrideDTO.getAddress());\n    override.setEnabled(overrideDTO.isEnabled());\n    overrideDTOToParams(override, overrideDTO);\n    overrideService.saveOverride(override);\n    return true;\n}",
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\npublic boolean updateOverride(@PathVariable String id, @RequestBody OverrideDTO overrideDTO, @PathVariable String env) {\n    Override old = overrideService.findById(id);\n    if (old == null) {\n        throw new ResourceNotFoundException(\"Unknown ID!\");\n    }\n    Override override = new Override();\n    override.setService(overrideDTO.getService());\n    override.setApplication(overrideDTO.getApplication());\n    override.setAddress(overrideDTO.getAddress());\n    override.setEnabled(overrideDTO.isEnabled());\n    overrideDTOToParams(override, overrideDTO);\n    override.setHash(id);\n    overrideService.updateOverride(override);\n    return true;\n}",
                "name": "updateOverride",
                "modifiers": "@RequestMapping(value = \"/{id}\", method = RequestMethod.PUT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@RequestBody",
                        "name": "OverrideDTO"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    Override old = overrideService.findById(id);\n    if (old == null) {\n        throw new ResourceNotFoundException(\"Unknown ID!\");\n    }\n    Override override = new Override();\n    override.setService(overrideDTO.getService());\n    override.setApplication(overrideDTO.getApplication());\n    override.setAddress(overrideDTO.getAddress());\n    override.setEnabled(overrideDTO.isEnabled());\n    overrideDTOToParams(override, overrideDTO);\n    override.setHash(id);\n    overrideService.updateOverride(override);\n    return true;\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(method = RequestMethod.GET)\npublic List<OverrideDTO> searchOverride(@RequestParam(required = false) String service, @PathVariable String env) {\n    List<Override> overrides;\n    if (StringUtils.isEmpty(service)) {\n        overrides = overrideService.findAll();\n    } else {\n        overrides = overrideService.findByService(service);\n    }\n    List<OverrideDTO> result = new ArrayList<>();\n    for (Override override : overrides) {\n        OverrideDTO overrideDTO = new OverrideDTO();\n        overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n        overrideDTO.setApplication(override.getApplication());\n        overrideDTO.setEnabled(override.isEnabled());\n        overrideDTO.setService(override.getService());\n        overrideDTO.setId(override.getHash());\n        paramsToOverrideDTO(override, overrideDTO);\n        result.add(overrideDTO);\n    }\n    return result;\n}",
                "name": "searchOverride",
                "modifiers": "@RequestMapping(method = RequestMethod.GET)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@RequestParam(required = false)",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    List<Override> overrides;\n    if (StringUtils.isEmpty(service)) {\n        overrides = overrideService.findAll();\n    } else {\n        overrides = overrideService.findByService(service);\n    }\n    List<OverrideDTO> result = new ArrayList<>();\n    for (Override override : overrides) {\n        OverrideDTO overrideDTO = new OverrideDTO();\n        overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n        overrideDTO.setApplication(override.getApplication());\n        overrideDTO.setEnabled(override.isEnabled());\n        overrideDTO.setService(override.getService());\n        overrideDTO.setId(override.getHash());\n        paramsToOverrideDTO(override, overrideDTO);\n        result.add(overrideDTO);\n    }\n    return result;\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 100,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\npublic OverrideDTO detailOverride(@PathVariable String id, @PathVariable String env) {\n    Override override = overrideService.findById(id);\n    if (override == null) {\n        throw new ResourceNotFoundException(\"Unknown ID!\");\n    }\n    OverrideDTO overrideDTO = new OverrideDTO();\n    overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n    overrideDTO.setApplication(override.getApplication());\n    overrideDTO.setEnabled(override.isEnabled());\n    overrideDTO.setService(override.getService());\n    paramsToOverrideDTO(override, overrideDTO);\n    return overrideDTO;\n}",
                "name": "detailOverride",
                "modifiers": "@RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public",
                "return_type": "OverrideDTO",
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    Override override = overrideService.findById(id);\n    if (override == null) {\n        throw new ResourceNotFoundException(\"Unknown ID!\");\n    }\n    OverrideDTO overrideDTO = new OverrideDTO();\n    overrideDTO.setAddress(override.getAddress().split(\":\")[0]);\n    overrideDTO.setApplication(override.getApplication());\n    overrideDTO.setEnabled(override.isEnabled());\n    overrideDTO.setService(override.getService());\n    paramsToOverrideDTO(override, overrideDTO);\n    return overrideDTO;\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 115,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\npublic boolean deleteOverride(@PathVariable String id, @PathVariable String env) {\n    overrideService.deleteOverride(id);\n    return true;\n}",
                "name": "deleteOverride",
                "modifiers": "@RequestMapping(value = \"/{id}\", method = RequestMethod.DELETE)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    overrideService.deleteOverride(id);\n    return true;\n}",
                "start_point": {
                    "row": 117,
                    "column": 4
                },
                "end_point": {
                    "row": 121,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/enable/{id}\", method = RequestMethod.PUT)\npublic boolean enableRoute(@PathVariable String id, @PathVariable String env) {\n\n    overrideService.enableOverride(id);\n    return true;\n}",
                "name": "enableRoute",
                "modifiers": "@RequestMapping(value = \"/enable/{id}\", method = RequestMethod.PUT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n\n    overrideService.enableOverride(id);\n    return true;\n}",
                "start_point": {
                    "row": 123,
                    "column": 4
                },
                "end_point": {
                    "row": 128,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/disable/{id}\", method = RequestMethod.PUT)\npublic boolean disableRoute(@PathVariable String id, @PathVariable String env) {\n\n    overrideService.disableOverride(id);\n    return true;\n}",
                "name": "disableRoute",
                "modifiers": "@RequestMapping(value = \"/disable/{id}\", method = RequestMethod.PUT)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n\n    overrideService.disableOverride(id);\n    return true;\n}",
                "start_point": {
                    "row": 130,
                    "column": 4
                },
                "end_point": {
                    "row": 135,
                    "column": 5
                }
            },
            {
                "definition": "private void overrideDTOToParams(Override override, OverrideDTO overrideDTO) {\n    Map<Object, String>[] mocks = overrideDTO.getMock();\n    Map<String, Object>[] parameters = overrideDTO.getParameters();\n    StringBuilder params = new StringBuilder();\n    if (mocks != null) {\n        for (Map<Object, String> mock : mocks) {\n            for (Map.Entry<Object, String> entry : mock.entrySet()) {\n                String key;\n                if (entry.getKey().equals(\"0\")) {\n                    key = \"mock\";\n                } else {\n                    key = entry.getKey() + \".mock\";\n                }\n                String value = key + \"=\" + URL.encode(entry.getValue());\n                params.append(value).append(\"&\");\n            }\n        }\n    }\n\n    if (parameters != null) {\n        for (Map<String, Object> param : parameters) {\n            for (Map.Entry<String, Object> entry : param.entrySet()) {\n                String value = entry.getKey() + \"=\" + entry.getValue();\n                params.append(value).append(\"&\");\n            }\n        }\n    }\n    if (StringUtils.isNotEmpty(params)) {\n        int length = params.length();\n        if (params.charAt(length - 1) == '&') {\n            params.deleteCharAt(length - 1);\n        }\n    }\n    override.setParams(params.toString());\n}",
                "name": "overrideDTOToParams",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    },
                    {
                        "type": "OverrideDTO",
                        "name": "overrideDTO"
                    }
                ],
                "body": "{\n    Map<Object, String>[] mocks = overrideDTO.getMock();\n    Map<String, Object>[] parameters = overrideDTO.getParameters();\n    StringBuilder params = new StringBuilder();\n    if (mocks != null) {\n        for (Map<Object, String> mock : mocks) {\n            for (Map.Entry<Object, String> entry : mock.entrySet()) {\n                String key;\n                if (entry.getKey().equals(\"0\")) {\n                    key = \"mock\";\n                } else {\n                    key = entry.getKey() + \".mock\";\n                }\n                String value = key + \"=\" + URL.encode(entry.getValue());\n                params.append(value).append(\"&\");\n            }\n        }\n    }\n\n    if (parameters != null) {\n        for (Map<String, Object> param : parameters) {\n            for (Map.Entry<String, Object> entry : param.entrySet()) {\n                String value = entry.getKey() + \"=\" + entry.getValue();\n                params.append(value).append(\"&\");\n            }\n        }\n    }\n    if (StringUtils.isNotEmpty(params)) {\n        int length = params.length();\n        if (params.charAt(length - 1) == '&') {\n            params.deleteCharAt(length - 1);\n        }\n    }\n    override.setParams(params.toString());\n}",
                "start_point": {
                    "row": 137,
                    "column": 4
                },
                "end_point": {
                    "row": 171,
                    "column": 5
                }
            },
            {
                "definition": "private void paramsToOverrideDTO(Override override, OverrideDTO overrideDTO) {\n    String params = override.getParams();\n    if (StringUtils.isNotEmpty(params)) {\n        List<Map<Object, String>> mock = new ArrayList<>();\n        List<Map<String, Object>> parameters = new ArrayList<>();\n        String[] pair = params.split(\"&\");\n        for (String p : pair) {\n            String key = p.split(\"=\")[0];\n            if (key.contains(\"mock\")) {\n                //mock\n                String value = URL.decode(p.split(\"=\")[1]);\n                Map<Object, String> item = new HashMap<>();\n                if (key.contains(\".\")) {\n                    //single method mock\n                    key = key.split(\"\\\\.\")[0];\n                    item.put(key, value);\n                } else {\n                    item.put(0, value);\n                }\n                mock.add(item);\n            } else {\n                //parameter\n                String value = p.split(\"=\")[1];\n                Map<String, Object> item = new HashMap<>();\n                item.put(key, value);\n                parameters.add(item);\n            }\n        }\n        Map<Object, String>[] mockArray = new Map[mock.size()];\n        overrideDTO.setMock(mock.toArray(mockArray));\n        Map<String, Object>[] paramArray = new Map[parameters.size()];\n        overrideDTO.setParameters(parameters.toArray(paramArray));\n    }\n}",
                "name": "paramsToOverrideDTO",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    },
                    {
                        "type": "OverrideDTO",
                        "name": "overrideDTO"
                    }
                ],
                "body": "{\n    String params = override.getParams();\n    if (StringUtils.isNotEmpty(params)) {\n        List<Map<Object, String>> mock = new ArrayList<>();\n        List<Map<String, Object>> parameters = new ArrayList<>();\n        String[] pair = params.split(\"&\");\n        for (String p : pair) {\n            String key = p.split(\"=\")[0];\n            if (key.contains(\"mock\")) {\n                //mock\n                String value = URL.decode(p.split(\"=\")[1]);\n                Map<Object, String> item = new HashMap<>();\n                if (key.contains(\".\")) {\n                    //single method mock\n                    key = key.split(\"\\\\.\")[0];\n                    item.put(key, value);\n                } else {\n                    item.put(0, value);\n                }\n                mock.add(item);\n            } else {\n                //parameter\n                String value = p.split(\"=\")[1];\n                Map<String, Object> item = new HashMap<>();\n                item.put(key, value);\n                parameters.add(item);\n            }\n        }\n        Map<Object, String>[] mockArray = new Map[mock.size()];\n        overrideDTO.setMock(mock.toArray(mockArray));\n        Map<String, Object>[] paramArray = new Map[parameters.size()];\n        overrideDTO.setParameters(parameters.toArray(paramArray));\n    }\n}",
                "start_point": {
                    "row": 173,
                    "column": 4
                },
                "end_point": {
                    "row": 206,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/controller/ServiceController.java",
        "definition": "@RestController\n@RequestMapping(\"/api/{env}/service\")\npublic class ServiceController {\n\n    private final ProviderService providerService;\n    private final ConsumerService consumerService;\n\n    @Autowired\n    public ServiceController(ProviderService providerService, ConsumerService consumerService) {\n        this.providerService = providerService;\n        this.consumerService = consumerService;\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public Set<ServiceDTO> searchService(@RequestParam String pattern,\n                                         @RequestParam String filter,@PathVariable String env) {\n\n        List<Provider> providers = new ArrayList<>();\n        if (!filter.contains(\"*\") && !filter.contains(\"?\")) {\n            if (pattern.equals(\"ip\")) {\n                providers = providerService.findByAddress(filter);\n            } else if (pattern.equals(\"serviceName\")) {\n                providers = providerService.findByService(filter);\n            } else if (pattern.equals(\"application\")) {\n                providers = providerService.findByApplication(filter);\n            }\n        } else {\n            List<String> candidates = Collections.emptyList();\n            if (pattern.equals(\"serviceName\")) {\n               candidates = providerService.findServices();\n            } else if (pattern.equals(\"application\")) {\n                candidates = providerService.findApplications();\n            }\n            filter = filter.toLowerCase().replace(\".\", \"\\\\.\");\n            if (filter.startsWith(\"*\")) {\n                filter = \".\" + filter;\n            }\n            Pattern regex = Pattern.compile(filter);\n            for (String candidate : candidates) {\n                Matcher matcher = regex.matcher(candidate);\n                if (matcher.matches() || matcher.lookingAt()) {\n                    if (pattern.equals(\"serviceName\")) {\n                        providers.addAll(providerService.findByService(candidate));\n                    } else {\n                        providers.addAll(providerService.findByApplication(candidate));\n                    }\n                }\n            }\n        }\n\n        Set<ServiceDTO> result = new TreeSet<>();\n        for (Provider provider : providers) {\n            Map<String, String> map = StringUtils.parseQueryString(provider.getParameters());\n            String app = provider.getApplication();\n            String service = map.get(Constants.INTERFACE_KEY);\n            String group = map.get(Constants.GROUP_KEY);\n            String version = map.get(Constants.VERSION_KEY);\n            ServiceDTO s = new ServiceDTO();\n            s.setAppName(app);\n            s.setService(service);\n            s.setGroup(group);\n            s.setVersion(version);\n            result.add(s);\n        }\n        return result;\n    }\n\n    @RequestMapping(value = \"/{service}\", method = RequestMethod.GET)\n    public ServiceDetailDTO serviceDetail(@PathVariable String service, @PathVariable String env) {\n        service = service.replace(\"*\", \"/\");\n        List<Provider> providers = providerService.findByService(service);\n\n        List<Consumer> consumers = consumerService.findByService(service);\n\n        ServiceDetailDTO serviceDetailDTO = new ServiceDetailDTO();\n        serviceDetailDTO.setConsumers(consumers);\n        serviceDetailDTO.setProviders(providers);\n        return serviceDetailDTO;\n    }\n}",
        "package": "package org.apache.dubbo.admin.controller;",
        "tree_path": "ServiceController",
        "name": "ServiceController",
        "modifiers": "@RestController\n@RequestMapping(\"/api/{env}/service\")\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final ProviderService providerService;\n    private final ConsumerService consumerService;\n\n    @Autowired\n    public ServiceController(ProviderService providerService, ConsumerService consumerService) {\n        this.providerService = providerService;\n        this.consumerService = consumerService;\n    }\n\n    @RequestMapping(method = RequestMethod.GET)\n    public Set<ServiceDTO> searchService(@RequestParam String pattern,\n                                         @RequestParam String filter,@PathVariable String env) {\n\n        List<Provider> providers = new ArrayList<>();\n        if (!filter.contains(\"*\") && !filter.contains(\"?\")) {\n            if (pattern.equals(\"ip\")) {\n                providers = providerService.findByAddress(filter);\n            } else if (pattern.equals(\"serviceName\")) {\n                providers = providerService.findByService(filter);\n            } else if (pattern.equals(\"application\")) {\n                providers = providerService.findByApplication(filter);\n            }\n        } else {\n            List<String> candidates = Collections.emptyList();\n            if (pattern.equals(\"serviceName\")) {\n               candidates = providerService.findServices();\n            } else if (pattern.equals(\"application\")) {\n                candidates = providerService.findApplications();\n            }\n            filter = filter.toLowerCase().replace(\".\", \"\\\\.\");\n            if (filter.startsWith(\"*\")) {\n                filter = \".\" + filter;\n            }\n            Pattern regex = Pattern.compile(filter);\n            for (String candidate : candidates) {\n                Matcher matcher = regex.matcher(candidate);\n                if (matcher.matches() || matcher.lookingAt()) {\n                    if (pattern.equals(\"serviceName\")) {\n                        providers.addAll(providerService.findByService(candidate));\n                    } else {\n                        providers.addAll(providerService.findByApplication(candidate));\n                    }\n                }\n            }\n        }\n\n        Set<ServiceDTO> result = new TreeSet<>();\n        for (Provider provider : providers) {\n            Map<String, String> map = StringUtils.parseQueryString(provider.getParameters());\n            String app = provider.getApplication();\n            String service = map.get(Constants.INTERFACE_KEY);\n            String group = map.get(Constants.GROUP_KEY);\n            String version = map.get(Constants.VERSION_KEY);\n            ServiceDTO s = new ServiceDTO();\n            s.setAppName(app);\n            s.setService(service);\n            s.setGroup(group);\n            s.setVersion(version);\n            result.add(s);\n        }\n        return result;\n    }\n\n    @RequestMapping(value = \"/{service}\", method = RequestMethod.GET)\n    public ServiceDetailDTO serviceDetail(@PathVariable String service, @PathVariable String env) {\n        service = service.replace(\"*\", \"/\");\n        List<Provider> providers = providerService.findByService(service);\n\n        List<Consumer> consumers = consumerService.findByService(service);\n\n        ServiceDetailDTO serviceDetailDTO = new ServiceDetailDTO();\n        serviceDetailDTO.setConsumers(consumers);\n        serviceDetailDTO.setProviders(providers);\n        return serviceDetailDTO;\n    }\n}",
        "start_point": {
            "row": 35,
            "column": 0
        },
        "end_point": {
            "row": 114,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Autowired\npublic ServiceController(ProviderService providerService, ConsumerService consumerService) {\n    this.providerService = providerService;\n    this.consumerService = consumerService;\n}",
                "name": "ServiceController",
                "modifiers": "@Autowired\n    public",
                "parameters": [
                    {
                        "type": "ProviderService",
                        "name": "providerService"
                    },
                    {
                        "type": "ConsumerService",
                        "name": "consumerService"
                    }
                ],
                "body": "{\n    this.providerService = providerService;\n    this.consumerService = consumerService;\n}",
                "constructor": true,
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(method = RequestMethod.GET)\npublic Set<ServiceDTO> searchService(@RequestParam String pattern,\n                                     @RequestParam String filter,@PathVariable String env) {\n\n    List<Provider> providers = new ArrayList<>();\n    if (!filter.contains(\"*\") && !filter.contains(\"?\")) {\n        if (pattern.equals(\"ip\")) {\n            providers = providerService.findByAddress(filter);\n        } else if (pattern.equals(\"serviceName\")) {\n            providers = providerService.findByService(filter);\n        } else if (pattern.equals(\"application\")) {\n            providers = providerService.findByApplication(filter);\n        }\n    } else {\n        List<String> candidates = Collections.emptyList();\n        if (pattern.equals(\"serviceName\")) {\n           candidates = providerService.findServices();\n        } else if (pattern.equals(\"application\")) {\n            candidates = providerService.findApplications();\n        }\n        filter = filter.toLowerCase().replace(\".\", \"\\\\.\");\n        if (filter.startsWith(\"*\")) {\n            filter = \".\" + filter;\n        }\n        Pattern regex = Pattern.compile(filter);\n        for (String candidate : candidates) {\n            Matcher matcher = regex.matcher(candidate);\n            if (matcher.matches() || matcher.lookingAt()) {\n                if (pattern.equals(\"serviceName\")) {\n                    providers.addAll(providerService.findByService(candidate));\n                } else {\n                    providers.addAll(providerService.findByApplication(candidate));\n                }\n            }\n        }\n    }\n\n    Set<ServiceDTO> result = new TreeSet<>();\n    for (Provider provider : providers) {\n        Map<String, String> map = StringUtils.parseQueryString(provider.getParameters());\n        String app = provider.getApplication();\n        String service = map.get(Constants.INTERFACE_KEY);\n        String group = map.get(Constants.GROUP_KEY);\n        String version = map.get(Constants.VERSION_KEY);\n        ServiceDTO s = new ServiceDTO();\n        s.setAppName(app);\n        s.setService(service);\n        s.setGroup(group);\n        s.setVersion(version);\n        result.add(s);\n    }\n    return result;\n}",
                "name": "searchService",
                "modifiers": "@RequestMapping(method = RequestMethod.GET)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@RequestParam",
                        "name": "String"
                    },
                    {
                        "type": "@RequestParam",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n\n    List<Provider> providers = new ArrayList<>();\n    if (!filter.contains(\"*\") && !filter.contains(\"?\")) {\n        if (pattern.equals(\"ip\")) {\n            providers = providerService.findByAddress(filter);\n        } else if (pattern.equals(\"serviceName\")) {\n            providers = providerService.findByService(filter);\n        } else if (pattern.equals(\"application\")) {\n            providers = providerService.findByApplication(filter);\n        }\n    } else {\n        List<String> candidates = Collections.emptyList();\n        if (pattern.equals(\"serviceName\")) {\n           candidates = providerService.findServices();\n        } else if (pattern.equals(\"application\")) {\n            candidates = providerService.findApplications();\n        }\n        filter = filter.toLowerCase().replace(\".\", \"\\\\.\");\n        if (filter.startsWith(\"*\")) {\n            filter = \".\" + filter;\n        }\n        Pattern regex = Pattern.compile(filter);\n        for (String candidate : candidates) {\n            Matcher matcher = regex.matcher(candidate);\n            if (matcher.matches() || matcher.lookingAt()) {\n                if (pattern.equals(\"serviceName\")) {\n                    providers.addAll(providerService.findByService(candidate));\n                } else {\n                    providers.addAll(providerService.findByApplication(candidate));\n                }\n            }\n        }\n    }\n\n    Set<ServiceDTO> result = new TreeSet<>();\n    for (Provider provider : providers) {\n        Map<String, String> map = StringUtils.parseQueryString(provider.getParameters());\n        String app = provider.getApplication();\n        String service = map.get(Constants.INTERFACE_KEY);\n        String group = map.get(Constants.GROUP_KEY);\n        String version = map.get(Constants.VERSION_KEY);\n        ServiceDTO s = new ServiceDTO();\n        s.setAppName(app);\n        s.setService(service);\n        s.setGroup(group);\n        s.setVersion(version);\n        result.add(s);\n    }\n    return result;\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 100,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/{service}\", method = RequestMethod.GET)\npublic ServiceDetailDTO serviceDetail(@PathVariable String service, @PathVariable String env) {\n    service = service.replace(\"*\", \"/\");\n    List<Provider> providers = providerService.findByService(service);\n\n    List<Consumer> consumers = consumerService.findByService(service);\n\n    ServiceDetailDTO serviceDetailDTO = new ServiceDetailDTO();\n    serviceDetailDTO.setConsumers(consumers);\n    serviceDetailDTO.setProviders(providers);\n    return serviceDetailDTO;\n}",
                "name": "serviceDetail",
                "modifiers": "@RequestMapping(value = \"/{service}\", method = RequestMethod.GET)\n    public",
                "return_type": "ServiceDetailDTO",
                "parameters": [
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    },
                    {
                        "type": "@PathVariable",
                        "name": "String"
                    }
                ],
                "body": "{\n    service = service.replace(\"*\", \"/\");\n    List<Provider> providers = providerService.findByService(service);\n\n    List<Consumer> consumers = consumerService.findByService(service);\n\n    ServiceDetailDTO serviceDetailDTO = new ServiceDetailDTO();\n    serviceDetailDTO.setConsumers(consumers);\n    serviceDetailDTO.setProviders(providers);\n    return serviceDetailDTO;\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/handler/CustomExceptionHandler.java",
        "definition": "@ControllerAdvice(annotations = ResponseBody.class)\npublic class CustomExceptionHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(CustomExceptionHandler.class);\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    @ExceptionHandler(value = Exception.class)\n    public CommonResponse commonExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[SystemException]Exception:\", e);\n        return commonResponse.fail(\"System Error, please try again later! Message:\" + e.getMessage());\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.SERVICE_UNAVAILABLE)\n    @ExceptionHandler(value = ServiceException.class)\n    public CommonResponse serviceExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[ServiceException]Exception:\", e);\n        return commonResponse.fail(\"ServiceException, message:\" + e.getMessage());\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.UNAUTHORIZED)\n    @ExceptionHandler(value = PermissionDeniedException.class)\n    public CommonResponse permissionDeniedExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[PermissionDeniedException]Exception:\", e);\n        return commonResponse.fail(\"Permission Denied!\");\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler(value = {ParamValidationException.class})\n    public CommonResponse paramValidationExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[ParamValidationException]Exception:\", e);\n        return commonResponse.fail(\"Parameter validation failure! Message:\" + e.getMessage());\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    @ExceptionHandler(value = {ResourceNotFoundException.class})\n    public CommonResponse resourceNotFoundExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[ResourceNotFoundException]Exception:\", e);\n        return commonResponse.fail(\"Resource not found! Message:\" + e.getMessage());\n    }\n}",
        "package": "package org.apache.dubbo.admin.handler;",
        "tree_path": "CustomExceptionHandler",
        "name": "CustomExceptionHandler",
        "modifiers": "@ControllerAdvice(annotations = ResponseBody.class)\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(CustomExceptionHandler.class);\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    @ExceptionHandler(value = Exception.class)\n    public CommonResponse commonExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[SystemException]Exception:\", e);\n        return commonResponse.fail(\"System Error, please try again later! Message:\" + e.getMessage());\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.SERVICE_UNAVAILABLE)\n    @ExceptionHandler(value = ServiceException.class)\n    public CommonResponse serviceExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[ServiceException]Exception:\", e);\n        return commonResponse.fail(\"ServiceException, message:\" + e.getMessage());\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.UNAUTHORIZED)\n    @ExceptionHandler(value = PermissionDeniedException.class)\n    public CommonResponse permissionDeniedExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[PermissionDeniedException]Exception:\", e);\n        return commonResponse.fail(\"Permission Denied!\");\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler(value = {ParamValidationException.class})\n    public CommonResponse paramValidationExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[ParamValidationException]Exception:\", e);\n        return commonResponse.fail(\"Parameter validation failure! Message:\" + e.getMessage());\n    }\n\n    @ResponseBody\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    @ExceptionHandler(value = {ResourceNotFoundException.class})\n    public CommonResponse resourceNotFoundExceptionHandle(Exception e) {\n        CommonResponse commonResponse = CommonResponse.createCommonResponse();\n        logger.error(\"[ResourceNotFoundException]Exception:\", e);\n        return commonResponse.fail(\"Resource not found! Message:\" + e.getMessage());\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 83,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@ResponseBody\n@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n@ExceptionHandler(value = Exception.class)\npublic CommonResponse commonExceptionHandle(Exception e) {\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[SystemException]Exception:\", e);\n    return commonResponse.fail(\"System Error, please try again later! Message:\" + e.getMessage());\n}",
                "name": "commonExceptionHandle",
                "modifiers": "@ResponseBody\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    @ExceptionHandler(value = Exception.class)\n    public",
                "return_type": "CommonResponse",
                "parameters": [
                    {
                        "type": "Exception",
                        "name": "e"
                    }
                ],
                "body": "{\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[SystemException]Exception:\", e);\n    return commonResponse.fail(\"System Error, please try again later! Message:\" + e.getMessage());\n}",
                "start_point": {
                    "row": 39,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "@ResponseBody\n@ResponseStatus(HttpStatus.SERVICE_UNAVAILABLE)\n@ExceptionHandler(value = ServiceException.class)\npublic CommonResponse serviceExceptionHandle(Exception e) {\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[ServiceException]Exception:\", e);\n    return commonResponse.fail(\"ServiceException, message:\" + e.getMessage());\n}",
                "name": "serviceExceptionHandle",
                "modifiers": "@ResponseBody\n    @ResponseStatus(HttpStatus.SERVICE_UNAVAILABLE)\n    @ExceptionHandler(value = ServiceException.class)\n    public",
                "return_type": "CommonResponse",
                "parameters": [
                    {
                        "type": "Exception",
                        "name": "e"
                    }
                ],
                "body": "{\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[ServiceException]Exception:\", e);\n    return commonResponse.fail(\"ServiceException, message:\" + e.getMessage());\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 55,
                    "column": 5
                }
            },
            {
                "definition": "@ResponseBody\n@ResponseStatus(HttpStatus.UNAUTHORIZED)\n@ExceptionHandler(value = PermissionDeniedException.class)\npublic CommonResponse permissionDeniedExceptionHandle(Exception e) {\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[PermissionDeniedException]Exception:\", e);\n    return commonResponse.fail(\"Permission Denied!\");\n}",
                "name": "permissionDeniedExceptionHandle",
                "modifiers": "@ResponseBody\n    @ResponseStatus(HttpStatus.UNAUTHORIZED)\n    @ExceptionHandler(value = PermissionDeniedException.class)\n    public",
                "return_type": "CommonResponse",
                "parameters": [
                    {
                        "type": "Exception",
                        "name": "e"
                    }
                ],
                "body": "{\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[PermissionDeniedException]Exception:\", e);\n    return commonResponse.fail(\"Permission Denied!\");\n}",
                "start_point": {
                    "row": 57,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            },
            {
                "definition": "@ResponseBody\n@ResponseStatus(HttpStatus.BAD_REQUEST)\n@ExceptionHandler(value = {ParamValidationException.class})\npublic CommonResponse paramValidationExceptionHandle(Exception e) {\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[ParamValidationException]Exception:\", e);\n    return commonResponse.fail(\"Parameter validation failure! Message:\" + e.getMessage());\n}",
                "name": "paramValidationExceptionHandle",
                "modifiers": "@ResponseBody\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    @ExceptionHandler(value = {ParamValidationException.class})\n    public",
                "return_type": "CommonResponse",
                "parameters": [
                    {
                        "type": "Exception",
                        "name": "e"
                    }
                ],
                "body": "{\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[ParamValidationException]Exception:\", e);\n    return commonResponse.fail(\"Parameter validation failure! Message:\" + e.getMessage());\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "@ResponseBody\n@ResponseStatus(HttpStatus.NOT_FOUND)\n@ExceptionHandler(value = {ResourceNotFoundException.class})\npublic CommonResponse resourceNotFoundExceptionHandle(Exception e) {\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[ResourceNotFoundException]Exception:\", e);\n    return commonResponse.fail(\"Resource not found! Message:\" + e.getMessage());\n}",
                "name": "resourceNotFoundExceptionHandle",
                "modifiers": "@ResponseBody\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    @ExceptionHandler(value = {ResourceNotFoundException.class})\n    public",
                "return_type": "CommonResponse",
                "parameters": [
                    {
                        "type": "Exception",
                        "name": "e"
                    }
                ],
                "body": "{\n    CommonResponse commonResponse = CommonResponse.createCommonResponse();\n    logger.error(\"[ResourceNotFoundException]Exception:\", e);\n    return commonResponse.fail(\"Resource not found! Message:\" + e.getMessage());\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 82,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/model/domain/Consumer.java",
        "definition": "public class Consumer extends Entity {\n\n    private static final long serialVersionUID = -1140894843784583237L;\n\n    private String service; /* The name of the service referenced by the consumer */\n\n    private String parameters;\n\n    private String result;    /*route result*/\n\n    private String address; /* address of consumer */\n\n    private String registry; /* Consumer connected registry address */\n\n    private String application; /* application name */\n\n    private String username;      /* user name of consumer */\n\n    private String statistics;    /* Service call statistics */\n\n    private Date collected;  /* Date statistics was recorded */\n\n    private Override override;\n\n    private List<Override> overrides;\n\n    private List<Route> routes;\n\n    private List<Provider> providers;\n\n    private Date expired;\n\n    private long alived;    /*Time to live in milliseconds*/\n\n    public Consumer() {\n    }\n\n    public Consumer(Long id) {\n        super(id);\n    }\n\n    public String getService() {\n        return service;\n    }\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n    public String getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(String parameters) {\n        this.parameters = parameters;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String getRegistry() {\n        return registry;\n    }\n\n    public void setRegistry(String registry) {\n        this.registry = registry;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getStatistics() {\n        return statistics;\n    }\n\n    public void setStatistics(String statistics) {\n        this.statistics = statistics;\n    }\n\n    public Date getCollected() {\n        return collected;\n    }\n\n    public void setCollected(Date collected) {\n        this.collected = collected;\n    }\n\n    public String getResult() {\n        return result;\n    }\n\n    public void setResult(String result) {\n        this.result = result;\n    }\n\n    public String getApplication() {\n        return application;\n    }\n\n    public void setApplication(String application) {\n        this.application = application;\n    }\n\n    public Date getExpired() {\n        return expired;\n    }\n\n\n    public void setExpired(Date expired) {\n        this.expired = expired;\n    }\n\n\n    public long getAlived() {\n        return alived;\n    }\n\n\n    public void setAlived(long alived) {\n        this.alived = alived;\n    }\n\n    public Override getOverride() {\n        return override;\n    }\n\n    public void setOverride(Override override) {\n        this.override = override;\n    }\n\n    public List<Override> getOverrides() {\n        return overrides;\n    }\n\n    public void setOverrides(List<Override> overrides) {\n        this.overrides = overrides;\n    }\n\n    public List<Route> getRoutes() {\n        return routes;\n    }\n\n    public void setRoutes(List<Route> routes) {\n        this.routes = routes;\n    }\n\n    public List<Provider> getProviders() {\n        return providers;\n    }\n\n    public void setProviders(List<Provider> providers) {\n        this.providers = providers;\n    }\n\n    public String toString() {\n        return \"Consumer [service=\" + service + \", parameters=\" + parameters + \", result=\" + result\n                + \", address=\" + address + \", registry=\" + registry + \", application=\"\n                + application + \", username=\" + username + \", statistics=\" + statistics\n                + \", collected=\" + collected + \", routes=\" + routes + \", overrides=\" + overrides\n                + \", expired=\" + expired + \", alived=\" + alived + \"]\";\n    }\n\n    public URL toUrl() {\n        String group = null;\n        String version = null;\n        String path = service;\n        int i = path.indexOf(\"/\");\n        if (i > 0) {\n            group = path.substring(0, i);\n            path = path.substring(i + 1);\n        }\n        i = path.lastIndexOf(\":\");\n        if (i > 0) {\n            version = path.substring(i + 1);\n            path = path.substring(0, i);\n        }\n        Map<String, String> param = StringUtils.parseQueryString(parameters);\n        param.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        if (group != null) {\n            param.put(Constants.GROUP_KEY, group);\n        }\n        if (version != null) {\n            param.put(Constants.VERSION_KEY, version);\n        }\n        return URL.valueOf(Constants.CONSUMER_PROTOCOL + \"://\" + address + \"/\" + path\n                + \"?\" + StringUtils.toQueryString(param));\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.model.domain;",
        "tree_path": "Consumer",
        "name": "Consumer",
        "modifiers": "public",
        "superclass": "extends Entity",
        "super_interfaces": null,
        "body": "{\n\n    private static final long serialVersionUID = -1140894843784583237L;\n\n    private String service; /* The name of the service referenced by the consumer */\n\n    private String parameters;\n\n    private String result;    /*route result*/\n\n    private String address; /* address of consumer */\n\n    private String registry; /* Consumer connected registry address */\n\n    private String application; /* application name */\n\n    private String username;      /* user name of consumer */\n\n    private String statistics;    /* Service call statistics */\n\n    private Date collected;  /* Date statistics was recorded */\n\n    private Override override;\n\n    private List<Override> overrides;\n\n    private List<Route> routes;\n\n    private List<Provider> providers;\n\n    private Date expired;\n\n    private long alived;    /*Time to live in milliseconds*/\n\n    public Consumer() {\n    }\n\n    public Consumer(Long id) {\n        super(id);\n    }\n\n    public String getService() {\n        return service;\n    }\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n    public String getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(String parameters) {\n        this.parameters = parameters;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String getRegistry() {\n        return registry;\n    }\n\n    public void setRegistry(String registry) {\n        this.registry = registry;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getStatistics() {\n        return statistics;\n    }\n\n    public void setStatistics(String statistics) {\n        this.statistics = statistics;\n    }\n\n    public Date getCollected() {\n        return collected;\n    }\n\n    public void setCollected(Date collected) {\n        this.collected = collected;\n    }\n\n    public String getResult() {\n        return result;\n    }\n\n    public void setResult(String result) {\n        this.result = result;\n    }\n\n    public String getApplication() {\n        return application;\n    }\n\n    public void setApplication(String application) {\n        this.application = application;\n    }\n\n    public Date getExpired() {\n        return expired;\n    }\n\n\n    public void setExpired(Date expired) {\n        this.expired = expired;\n    }\n\n\n    public long getAlived() {\n        return alived;\n    }\n\n\n    public void setAlived(long alived) {\n        this.alived = alived;\n    }\n\n    public Override getOverride() {\n        return override;\n    }\n\n    public void setOverride(Override override) {\n        this.override = override;\n    }\n\n    public List<Override> getOverrides() {\n        return overrides;\n    }\n\n    public void setOverrides(List<Override> overrides) {\n        this.overrides = overrides;\n    }\n\n    public List<Route> getRoutes() {\n        return routes;\n    }\n\n    public void setRoutes(List<Route> routes) {\n        this.routes = routes;\n    }\n\n    public List<Provider> getProviders() {\n        return providers;\n    }\n\n    public void setProviders(List<Provider> providers) {\n        this.providers = providers;\n    }\n\n    public String toString() {\n        return \"Consumer [service=\" + service + \", parameters=\" + parameters + \", result=\" + result\n                + \", address=\" + address + \", registry=\" + registry + \", application=\"\n                + application + \", username=\" + username + \", statistics=\" + statistics\n                + \", collected=\" + collected + \", routes=\" + routes + \", overrides=\" + overrides\n                + \", expired=\" + expired + \", alived=\" + alived + \"]\";\n    }\n\n    public URL toUrl() {\n        String group = null;\n        String version = null;\n        String path = service;\n        int i = path.indexOf(\"/\");\n        if (i > 0) {\n            group = path.substring(0, i);\n            path = path.substring(i + 1);\n        }\n        i = path.lastIndexOf(\":\");\n        if (i > 0) {\n            version = path.substring(i + 1);\n            path = path.substring(0, i);\n        }\n        Map<String, String> param = StringUtils.parseQueryString(parameters);\n        param.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        if (group != null) {\n            param.put(Constants.GROUP_KEY, group);\n        }\n        if (version != null) {\n            param.put(Constants.VERSION_KEY, version);\n        }\n        return URL.valueOf(Constants.CONSUMER_PROTOCOL + \"://\" + address + \"/\" + path\n                + \"?\" + StringUtils.toQueryString(param));\n    }\n\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 228,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public Consumer() {\n}",
                "name": "Consumer",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            },
            {
                "definition": "public Consumer(Long id) {\n    super(id);\n}",
                "name": "Consumer",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "Long",
                        "name": "id"
                    }
                ],
                "body": "{\n    super(id);\n}",
                "constructor": true,
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 69,
                    "column": 5
                }
            },
            {
                "definition": "public String getService() {\n    return service;\n}",
                "name": "getService",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return service;\n}",
                "start_point": {
                    "row": 71,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "public void setService(String service) {\n    this.service = service;\n}",
                "name": "setService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    this.service = service;\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 77,
                    "column": 5
                }
            },
            {
                "definition": "public String getParameters() {\n    return parameters;\n}",
                "name": "getParameters",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return parameters;\n}",
                "start_point": {
                    "row": 79,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "public void setParameters(String parameters) {\n    this.parameters = parameters;\n}",
                "name": "setParameters",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "parameters"
                    }
                ],
                "body": "{\n    this.parameters = parameters;\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 85,
                    "column": 5
                }
            },
            {
                "definition": "public String getAddress() {\n    return address;\n}",
                "name": "getAddress",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return address;\n}",
                "start_point": {
                    "row": 87,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            },
            {
                "definition": "public void setAddress(String address) {\n    this.address = address;\n}",
                "name": "setAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    this.address = address;\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 93,
                    "column": 5
                }
            },
            {
                "definition": "public String getRegistry() {\n    return registry;\n}",
                "name": "getRegistry",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return registry;\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 97,
                    "column": 5
                }
            },
            {
                "definition": "public void setRegistry(String registry) {\n    this.registry = registry;\n}",
                "name": "setRegistry",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "registry"
                    }
                ],
                "body": "{\n    this.registry = registry;\n}",
                "start_point": {
                    "row": 99,
                    "column": 4
                },
                "end_point": {
                    "row": 101,
                    "column": 5
                }
            },
            {
                "definition": "public String getUsername() {\n    return username;\n}",
                "name": "getUsername",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return username;\n}",
                "start_point": {
                    "row": 103,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "public void setUsername(String username) {\n    this.username = username;\n}",
                "name": "setUsername",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    this.username = username;\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "public String getStatistics() {\n    return statistics;\n}",
                "name": "getStatistics",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return statistics;\n}",
                "start_point": {
                    "row": 111,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            },
            {
                "definition": "public void setStatistics(String statistics) {\n    this.statistics = statistics;\n}",
                "name": "setStatistics",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "statistics"
                    }
                ],
                "body": "{\n    this.statistics = statistics;\n}",
                "start_point": {
                    "row": 115,
                    "column": 4
                },
                "end_point": {
                    "row": 117,
                    "column": 5
                }
            },
            {
                "definition": "public Date getCollected() {\n    return collected;\n}",
                "name": "getCollected",
                "modifiers": "public",
                "return_type": "Date",
                "parameters": [],
                "body": "{\n    return collected;\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 121,
                    "column": 5
                }
            },
            {
                "definition": "public void setCollected(Date collected) {\n    this.collected = collected;\n}",
                "name": "setCollected",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Date",
                        "name": "collected"
                    }
                ],
                "body": "{\n    this.collected = collected;\n}",
                "start_point": {
                    "row": 123,
                    "column": 4
                },
                "end_point": {
                    "row": 125,
                    "column": 5
                }
            },
            {
                "definition": "public String getResult() {\n    return result;\n}",
                "name": "getResult",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return result;\n}",
                "start_point": {
                    "row": 127,
                    "column": 4
                },
                "end_point": {
                    "row": 129,
                    "column": 5
                }
            },
            {
                "definition": "public void setResult(String result) {\n    this.result = result;\n}",
                "name": "setResult",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "result"
                    }
                ],
                "body": "{\n    this.result = result;\n}",
                "start_point": {
                    "row": 131,
                    "column": 4
                },
                "end_point": {
                    "row": 133,
                    "column": 5
                }
            },
            {
                "definition": "public String getApplication() {\n    return application;\n}",
                "name": "getApplication",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return application;\n}",
                "start_point": {
                    "row": 135,
                    "column": 4
                },
                "end_point": {
                    "row": 137,
                    "column": 5
                }
            },
            {
                "definition": "public void setApplication(String application) {\n    this.application = application;\n}",
                "name": "setApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    this.application = application;\n}",
                "start_point": {
                    "row": 139,
                    "column": 4
                },
                "end_point": {
                    "row": 141,
                    "column": 5
                }
            },
            {
                "definition": "public Date getExpired() {\n    return expired;\n}",
                "name": "getExpired",
                "modifiers": "public",
                "return_type": "Date",
                "parameters": [],
                "body": "{\n    return expired;\n}",
                "start_point": {
                    "row": 143,
                    "column": 4
                },
                "end_point": {
                    "row": 145,
                    "column": 5
                }
            },
            {
                "definition": "public void setExpired(Date expired) {\n    this.expired = expired;\n}",
                "name": "setExpired",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Date",
                        "name": "expired"
                    }
                ],
                "body": "{\n    this.expired = expired;\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 150,
                    "column": 5
                }
            },
            {
                "definition": "public long getAlived() {\n    return alived;\n}",
                "name": "getAlived",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return alived;\n}",
                "start_point": {
                    "row": 153,
                    "column": 4
                },
                "end_point": {
                    "row": 155,
                    "column": 5
                }
            },
            {
                "definition": "public void setAlived(long alived) {\n    this.alived = alived;\n}",
                "name": "setAlived",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "long",
                        "name": "alived"
                    }
                ],
                "body": "{\n    this.alived = alived;\n}",
                "start_point": {
                    "row": 158,
                    "column": 4
                },
                "end_point": {
                    "row": 160,
                    "column": 5
                }
            },
            {
                "definition": "public Override getOverride() {\n    return override;\n}",
                "name": "getOverride",
                "modifiers": "public",
                "return_type": "Override",
                "parameters": [],
                "body": "{\n    return override;\n}",
                "start_point": {
                    "row": 162,
                    "column": 4
                },
                "end_point": {
                    "row": 164,
                    "column": 5
                }
            },
            {
                "definition": "public void setOverride(Override override) {\n    this.override = override;\n}",
                "name": "setOverride",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    }
                ],
                "body": "{\n    this.override = override;\n}",
                "start_point": {
                    "row": 166,
                    "column": 4
                },
                "end_point": {
                    "row": 168,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> getOverrides() {\n    return overrides;\n}",
                "name": "getOverrides",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return overrides;\n}",
                "start_point": {
                    "row": 170,
                    "column": 4
                },
                "end_point": {
                    "row": 172,
                    "column": 5
                }
            },
            {
                "definition": "public void setOverrides(List<Override> overrides) {\n    this.overrides = overrides;\n}",
                "name": "setOverrides",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Override>",
                        "name": "overrides"
                    }
                ],
                "body": "{\n    this.overrides = overrides;\n}",
                "start_point": {
                    "row": 174,
                    "column": 4
                },
                "end_point": {
                    "row": 176,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> getRoutes() {\n    return routes;\n}",
                "name": "getRoutes",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return routes;\n}",
                "start_point": {
                    "row": 178,
                    "column": 4
                },
                "end_point": {
                    "row": 180,
                    "column": 5
                }
            },
            {
                "definition": "public void setRoutes(List<Route> routes) {\n    this.routes = routes;\n}",
                "name": "setRoutes",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Route>",
                        "name": "routes"
                    }
                ],
                "body": "{\n    this.routes = routes;\n}",
                "start_point": {
                    "row": 182,
                    "column": 4
                },
                "end_point": {
                    "row": 184,
                    "column": 5
                }
            },
            {
                "definition": "public List<Provider> getProviders() {\n    return providers;\n}",
                "name": "getProviders",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return providers;\n}",
                "start_point": {
                    "row": 186,
                    "column": 4
                },
                "end_point": {
                    "row": 188,
                    "column": 5
                }
            },
            {
                "definition": "public void setProviders(List<Provider> providers) {\n    this.providers = providers;\n}",
                "name": "setProviders",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Provider>",
                        "name": "providers"
                    }
                ],
                "body": "{\n    this.providers = providers;\n}",
                "start_point": {
                    "row": 190,
                    "column": 4
                },
                "end_point": {
                    "row": 192,
                    "column": 5
                }
            },
            {
                "definition": "public String toString() {\n    return \"Consumer [service=\" + service + \", parameters=\" + parameters + \", result=\" + result\n            + \", address=\" + address + \", registry=\" + registry + \", application=\"\n            + application + \", username=\" + username + \", statistics=\" + statistics\n            + \", collected=\" + collected + \", routes=\" + routes + \", overrides=\" + overrides\n            + \", expired=\" + expired + \", alived=\" + alived + \"]\";\n}",
                "name": "toString",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"Consumer [service=\" + service + \", parameters=\" + parameters + \", result=\" + result\n            + \", address=\" + address + \", registry=\" + registry + \", application=\"\n            + application + \", username=\" + username + \", statistics=\" + statistics\n            + \", collected=\" + collected + \", routes=\" + routes + \", overrides=\" + overrides\n            + \", expired=\" + expired + \", alived=\" + alived + \"]\";\n}",
                "start_point": {
                    "row": 194,
                    "column": 4
                },
                "end_point": {
                    "row": 200,
                    "column": 5
                }
            },
            {
                "definition": "public URL toUrl() {\n    String group = null;\n    String version = null;\n    String path = service;\n    int i = path.indexOf(\"/\");\n    if (i > 0) {\n        group = path.substring(0, i);\n        path = path.substring(i + 1);\n    }\n    i = path.lastIndexOf(\":\");\n    if (i > 0) {\n        version = path.substring(i + 1);\n        path = path.substring(0, i);\n    }\n    Map<String, String> param = StringUtils.parseQueryString(parameters);\n    param.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    if (group != null) {\n        param.put(Constants.GROUP_KEY, group);\n    }\n    if (version != null) {\n        param.put(Constants.VERSION_KEY, version);\n    }\n    return URL.valueOf(Constants.CONSUMER_PROTOCOL + \"://\" + address + \"/\" + path\n            + \"?\" + StringUtils.toQueryString(param));\n}",
                "name": "toUrl",
                "modifiers": "public",
                "return_type": "URL",
                "parameters": [],
                "body": "{\n    String group = null;\n    String version = null;\n    String path = service;\n    int i = path.indexOf(\"/\");\n    if (i > 0) {\n        group = path.substring(0, i);\n        path = path.substring(i + 1);\n    }\n    i = path.lastIndexOf(\":\");\n    if (i > 0) {\n        version = path.substring(i + 1);\n        path = path.substring(0, i);\n    }\n    Map<String, String> param = StringUtils.parseQueryString(parameters);\n    param.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    if (group != null) {\n        param.put(Constants.GROUP_KEY, group);\n    }\n    if (version != null) {\n        param.put(Constants.VERSION_KEY, version);\n    }\n    return URL.valueOf(Constants.CONSUMER_PROTOCOL + \"://\" + address + \"/\" + path\n            + \"?\" + StringUtils.toQueryString(param));\n}",
                "start_point": {
                    "row": 202,
                    "column": 4
                },
                "end_point": {
                    "row": 226,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/model/domain/Override.java",
        "definition": "public class Override extends Entity {\n\n    private static final long serialVersionUID = 114828505391757846L;\n\n    private String service;\n\n    private String params;\n\n    private String application;\n\n    private String address;\n\n    private String username;\n\n    private boolean enabled;\n\n    public Override() {\n    }\n\n    public Override(long id) {\n        super(id);\n    }\n\n    public String getService() {\n        return service;\n    }\n\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n\n    public String getParams() {\n        return params;\n    }\n\n\n    public void setParams(String params) {\n        this.params = params;\n    }\n\n\n    public String getApplication() {\n        return application;\n    }\n\n\n    public void setApplication(String application) {\n        this.application = application;\n    }\n\n\n    public String getAddress() {\n        return address;\n    }\n\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String toString() {\n        return \"Override [service=\" + service + \", params=\" + params + \", application=\"\n                + application + \", address=\" + address + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n    }\n\n    public boolean isDefault() {\n        return (getAddress() == null || getAddress().length() == 0 || Constants.ANY_VALUE.equals(getAddress()) || Constants.ANYHOST_VALUE.equals(getAddress()))\n                && (getApplication() == null || getApplication().length() == 0 || Constants.ANY_VALUE.equals(getApplication()));\n    }\n\n    public boolean isMatch(String service, String address, String application) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && service.equals(getService())\n                && (address == null || getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(address))\n                && (application == null || getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(application));\n    }\n\n    public boolean isUniqueMatch(Provider provider) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && provider.getService().equals(getService())\n                && provider.getAddress().equals(getAddress());\n    }\n\n    public boolean isMatch(Provider provider) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && provider.getService().equals(getService())\n                && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(provider.getAddress()))\n                && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(provider.getApplication()));\n    }\n\n    public boolean isUniqueMatch(Consumer consumer) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && consumer.getService().equals(getService())\n                && consumer.getAddress().equals(getAddress());\n    }\n\n    public boolean isMatch(Consumer consumer) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && consumer.getService().equals(getService())\n                && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(consumer.getAddress()))\n                && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(consumer.getApplication()));\n    }\n\n    public Map<String, String> toParametersMap() {\n        Map<String, String> map = StringUtils.parseQueryString(getParams());\n        map.remove(Constants.INTERFACE_KEY);\n        map.remove(Constants.GROUP_KEY);\n        map.remove(Constants.VERSION_KEY);\n        map.remove(Constants.APPLICATION_KEY);\n        map.remove(Constants.CATEGORY_KEY);\n        map.remove(Constants.DYNAMIC_KEY);\n        map.remove(Constants.ENABLED_KEY);\n        return map;\n    }\n\n    public URL toUrl() {\n        String group = null;\n        String version = null;\n        String path = service;\n        int i = path.indexOf(\"/\");\n        if (i > 0) {\n            group = path.substring(0, i);\n            path = path.substring(i + 1);\n        }\n        i = path.lastIndexOf(\":\");\n        if (i > 0) {\n            version = path.substring(i + 1);\n            path = path.substring(0, i);\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(Constants.OVERRIDE_PROTOCOL);\n        sb.append(\"://\");\n        if (!StringUtils.isBlank(address) && !Constants.ANY_VALUE.equals(address)) {\n            sb.append(address);\n        } else {\n            sb.append(Constants.ANYHOST_VALUE);\n        }\n        sb.append(\"/\");\n        sb.append(path);\n        sb.append(\"?\");\n        Map<String, String> param = StringUtils.parseQueryString(params);\n        param.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n        param.put(Constants.ENABLED_KEY, String.valueOf(isEnabled()));\n        param.put(Constants.DYNAMIC_KEY, \"false\");\n        if (!StringUtils.isBlank(application) && !Constants.ANY_VALUE.equals(application)) {\n            param.put(Constants.APPLICATION_KEY, application);\n        }\n        if (group != null) {\n            param.put(Constants.GROUP_KEY, group);\n        }\n        if (version != null) {\n            param.put(Constants.VERSION_KEY, version);\n        }\n        sb.append(StringUtils.toQueryString(param));\n        return URL.valueOf(sb.toString());\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.model.domain;",
        "tree_path": "Override",
        "name": "Override",
        "modifiers": "public",
        "superclass": "extends Entity",
        "super_interfaces": null,
        "body": "{\n\n    private static final long serialVersionUID = 114828505391757846L;\n\n    private String service;\n\n    private String params;\n\n    private String application;\n\n    private String address;\n\n    private String username;\n\n    private boolean enabled;\n\n    public Override() {\n    }\n\n    public Override(long id) {\n        super(id);\n    }\n\n    public String getService() {\n        return service;\n    }\n\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n\n    public String getParams() {\n        return params;\n    }\n\n\n    public void setParams(String params) {\n        this.params = params;\n    }\n\n\n    public String getApplication() {\n        return application;\n    }\n\n\n    public void setApplication(String application) {\n        this.application = application;\n    }\n\n\n    public String getAddress() {\n        return address;\n    }\n\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String toString() {\n        return \"Override [service=\" + service + \", params=\" + params + \", application=\"\n                + application + \", address=\" + address + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n    }\n\n    public boolean isDefault() {\n        return (getAddress() == null || getAddress().length() == 0 || Constants.ANY_VALUE.equals(getAddress()) || Constants.ANYHOST_VALUE.equals(getAddress()))\n                && (getApplication() == null || getApplication().length() == 0 || Constants.ANY_VALUE.equals(getApplication()));\n    }\n\n    public boolean isMatch(String service, String address, String application) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && service.equals(getService())\n                && (address == null || getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(address))\n                && (application == null || getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(application));\n    }\n\n    public boolean isUniqueMatch(Provider provider) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && provider.getService().equals(getService())\n                && provider.getAddress().equals(getAddress());\n    }\n\n    public boolean isMatch(Provider provider) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && provider.getService().equals(getService())\n                && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(provider.getAddress()))\n                && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(provider.getApplication()));\n    }\n\n    public boolean isUniqueMatch(Consumer consumer) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && consumer.getService().equals(getService())\n                && consumer.getAddress().equals(getAddress());\n    }\n\n    public boolean isMatch(Consumer consumer) {\n        return isEnabled() && getParams() != null && getParams().length() > 0\n                && consumer.getService().equals(getService())\n                && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(consumer.getAddress()))\n                && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(consumer.getApplication()));\n    }\n\n    public Map<String, String> toParametersMap() {\n        Map<String, String> map = StringUtils.parseQueryString(getParams());\n        map.remove(Constants.INTERFACE_KEY);\n        map.remove(Constants.GROUP_KEY);\n        map.remove(Constants.VERSION_KEY);\n        map.remove(Constants.APPLICATION_KEY);\n        map.remove(Constants.CATEGORY_KEY);\n        map.remove(Constants.DYNAMIC_KEY);\n        map.remove(Constants.ENABLED_KEY);\n        return map;\n    }\n\n    public URL toUrl() {\n        String group = null;\n        String version = null;\n        String path = service;\n        int i = path.indexOf(\"/\");\n        if (i > 0) {\n            group = path.substring(0, i);\n            path = path.substring(i + 1);\n        }\n        i = path.lastIndexOf(\":\");\n        if (i > 0) {\n            version = path.substring(i + 1);\n            path = path.substring(0, i);\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(Constants.OVERRIDE_PROTOCOL);\n        sb.append(\"://\");\n        if (!StringUtils.isBlank(address) && !Constants.ANY_VALUE.equals(address)) {\n            sb.append(address);\n        } else {\n            sb.append(Constants.ANYHOST_VALUE);\n        }\n        sb.append(\"/\");\n        sb.append(path);\n        sb.append(\"?\");\n        Map<String, String> param = StringUtils.parseQueryString(params);\n        param.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n        param.put(Constants.ENABLED_KEY, String.valueOf(isEnabled()));\n        param.put(Constants.DYNAMIC_KEY, \"false\");\n        if (!StringUtils.isBlank(application) && !Constants.ANY_VALUE.equals(application)) {\n            param.put(Constants.APPLICATION_KEY, application);\n        }\n        if (group != null) {\n            param.put(Constants.GROUP_KEY, group);\n        }\n        if (version != null) {\n            param.put(Constants.VERSION_KEY, version);\n        }\n        sb.append(StringUtils.toQueryString(param));\n        return URL.valueOf(sb.toString());\n    }\n\n}",
        "start_point": {
            "row": 24,
            "column": 0
        },
        "end_point": {
            "row": 201,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public Override() {\n}",
                "name": "Override",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 41,
                    "column": 5
                }
            },
            {
                "definition": "public Override(long id) {\n    super(id);\n}",
                "name": "Override",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "long",
                        "name": "id"
                    }
                ],
                "body": "{\n    super(id);\n}",
                "constructor": true,
                "start_point": {
                    "row": 43,
                    "column": 4
                },
                "end_point": {
                    "row": 45,
                    "column": 5
                }
            },
            {
                "definition": "public String getService() {\n    return service;\n}",
                "name": "getService",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return service;\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            },
            {
                "definition": "public void setService(String service) {\n    this.service = service;\n}",
                "name": "setService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    this.service = service;\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "public String getParams() {\n    return params;\n}",
                "name": "getParams",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return params;\n}",
                "start_point": {
                    "row": 57,
                    "column": 4
                },
                "end_point": {
                    "row": 59,
                    "column": 5
                }
            },
            {
                "definition": "public void setParams(String params) {\n    this.params = params;\n}",
                "name": "setParams",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "params"
                    }
                ],
                "body": "{\n    this.params = params;\n}",
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            },
            {
                "definition": "public String getApplication() {\n    return application;\n}",
                "name": "getApplication",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return application;\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 69,
                    "column": 5
                }
            },
            {
                "definition": "public void setApplication(String application) {\n    this.application = application;\n}",
                "name": "setApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    this.application = application;\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            },
            {
                "definition": "public String getAddress() {\n    return address;\n}",
                "name": "getAddress",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return address;\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "public void setAddress(String address) {\n    this.address = address;\n}",
                "name": "setAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    this.address = address;\n}",
                "start_point": {
                    "row": 82,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "public String getUsername() {\n    return username;\n}",
                "name": "getUsername",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return username;\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            },
            {
                "definition": "public void setUsername(String username) {\n    this.username = username;\n}",
                "name": "setUsername",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    this.username = username;\n}",
                "start_point": {
                    "row": 90,
                    "column": 4
                },
                "end_point": {
                    "row": 92,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 97,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 100,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "public String toString() {\n    return \"Override [service=\" + service + \", params=\" + params + \", application=\"\n            + application + \", address=\" + address + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n}",
                "name": "toString",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"Override [service=\" + service + \", params=\" + params + \", application=\"\n            + application + \", address=\" + address + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isDefault() {\n    return (getAddress() == null || getAddress().length() == 0 || Constants.ANY_VALUE.equals(getAddress()) || Constants.ANYHOST_VALUE.equals(getAddress()))\n            && (getApplication() == null || getApplication().length() == 0 || Constants.ANY_VALUE.equals(getApplication()));\n}",
                "name": "isDefault",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return (getAddress() == null || getAddress().length() == 0 || Constants.ANY_VALUE.equals(getAddress()) || Constants.ANYHOST_VALUE.equals(getAddress()))\n            && (getApplication() == null || getApplication().length() == 0 || Constants.ANY_VALUE.equals(getApplication()));\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 112,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isMatch(String service, String address, String application) {\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && service.equals(getService())\n            && (address == null || getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(address))\n            && (application == null || getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(application));\n}",
                "name": "isMatch",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    },
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && service.equals(getService())\n            && (address == null || getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(address))\n            && (application == null || getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(application));\n}",
                "start_point": {
                    "row": 114,
                    "column": 4
                },
                "end_point": {
                    "row": 119,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isUniqueMatch(Provider provider) {\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && provider.getService().equals(getService())\n            && provider.getAddress().equals(getAddress());\n}",
                "name": "isUniqueMatch",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Provider",
                        "name": "provider"
                    }
                ],
                "body": "{\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && provider.getService().equals(getService())\n            && provider.getAddress().equals(getAddress());\n}",
                "start_point": {
                    "row": 121,
                    "column": 4
                },
                "end_point": {
                    "row": 125,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isMatch(Provider provider) {\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && provider.getService().equals(getService())\n            && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(provider.getAddress()))\n            && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(provider.getApplication()));\n}",
                "name": "isMatch",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Provider",
                        "name": "provider"
                    }
                ],
                "body": "{\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && provider.getService().equals(getService())\n            && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(provider.getAddress()))\n            && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(provider.getApplication()));\n}",
                "start_point": {
                    "row": 127,
                    "column": 4
                },
                "end_point": {
                    "row": 132,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isUniqueMatch(Consumer consumer) {\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && consumer.getService().equals(getService())\n            && consumer.getAddress().equals(getAddress());\n}",
                "name": "isUniqueMatch",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Consumer",
                        "name": "consumer"
                    }
                ],
                "body": "{\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && consumer.getService().equals(getService())\n            && consumer.getAddress().equals(getAddress());\n}",
                "start_point": {
                    "row": 134,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isMatch(Consumer consumer) {\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && consumer.getService().equals(getService())\n            && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(consumer.getAddress()))\n            && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(consumer.getApplication()));\n}",
                "name": "isMatch",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Consumer",
                        "name": "consumer"
                    }
                ],
                "body": "{\n    return isEnabled() && getParams() != null && getParams().length() > 0\n            && consumer.getService().equals(getService())\n            && (getAddress() == null || getAddress().length() == 0 || getAddress().equals(Constants.ANY_VALUE) || getAddress().equals(Constants.ANYHOST_VALUE) || getAddress().equals(consumer.getAddress()))\n            && (getApplication() == null || getApplication().length() == 0 || getApplication().equals(Constants.ANY_VALUE) || getApplication().equals(consumer.getApplication()));\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 145,
                    "column": 5
                }
            },
            {
                "definition": "public Map<String, String> toParametersMap() {\n    Map<String, String> map = StringUtils.parseQueryString(getParams());\n    map.remove(Constants.INTERFACE_KEY);\n    map.remove(Constants.GROUP_KEY);\n    map.remove(Constants.VERSION_KEY);\n    map.remove(Constants.APPLICATION_KEY);\n    map.remove(Constants.CATEGORY_KEY);\n    map.remove(Constants.DYNAMIC_KEY);\n    map.remove(Constants.ENABLED_KEY);\n    return map;\n}",
                "name": "toParametersMap",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    Map<String, String> map = StringUtils.parseQueryString(getParams());\n    map.remove(Constants.INTERFACE_KEY);\n    map.remove(Constants.GROUP_KEY);\n    map.remove(Constants.VERSION_KEY);\n    map.remove(Constants.APPLICATION_KEY);\n    map.remove(Constants.CATEGORY_KEY);\n    map.remove(Constants.DYNAMIC_KEY);\n    map.remove(Constants.ENABLED_KEY);\n    return map;\n}",
                "start_point": {
                    "row": 147,
                    "column": 4
                },
                "end_point": {
                    "row": 157,
                    "column": 5
                }
            },
            {
                "definition": "public URL toUrl() {\n    String group = null;\n    String version = null;\n    String path = service;\n    int i = path.indexOf(\"/\");\n    if (i > 0) {\n        group = path.substring(0, i);\n        path = path.substring(i + 1);\n    }\n    i = path.lastIndexOf(\":\");\n    if (i > 0) {\n        version = path.substring(i + 1);\n        path = path.substring(0, i);\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(Constants.OVERRIDE_PROTOCOL);\n    sb.append(\"://\");\n    if (!StringUtils.isBlank(address) && !Constants.ANY_VALUE.equals(address)) {\n        sb.append(address);\n    } else {\n        sb.append(Constants.ANYHOST_VALUE);\n    }\n    sb.append(\"/\");\n    sb.append(path);\n    sb.append(\"?\");\n    Map<String, String> param = StringUtils.parseQueryString(params);\n    param.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n    param.put(Constants.ENABLED_KEY, String.valueOf(isEnabled()));\n    param.put(Constants.DYNAMIC_KEY, \"false\");\n    if (!StringUtils.isBlank(application) && !Constants.ANY_VALUE.equals(application)) {\n        param.put(Constants.APPLICATION_KEY, application);\n    }\n    if (group != null) {\n        param.put(Constants.GROUP_KEY, group);\n    }\n    if (version != null) {\n        param.put(Constants.VERSION_KEY, version);\n    }\n    sb.append(StringUtils.toQueryString(param));\n    return URL.valueOf(sb.toString());\n}",
                "name": "toUrl",
                "modifiers": "public",
                "return_type": "URL",
                "parameters": [],
                "body": "{\n    String group = null;\n    String version = null;\n    String path = service;\n    int i = path.indexOf(\"/\");\n    if (i > 0) {\n        group = path.substring(0, i);\n        path = path.substring(i + 1);\n    }\n    i = path.lastIndexOf(\":\");\n    if (i > 0) {\n        version = path.substring(i + 1);\n        path = path.substring(0, i);\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(Constants.OVERRIDE_PROTOCOL);\n    sb.append(\"://\");\n    if (!StringUtils.isBlank(address) && !Constants.ANY_VALUE.equals(address)) {\n        sb.append(address);\n    } else {\n        sb.append(Constants.ANYHOST_VALUE);\n    }\n    sb.append(\"/\");\n    sb.append(path);\n    sb.append(\"?\");\n    Map<String, String> param = StringUtils.parseQueryString(params);\n    param.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n    param.put(Constants.ENABLED_KEY, String.valueOf(isEnabled()));\n    param.put(Constants.DYNAMIC_KEY, \"false\");\n    if (!StringUtils.isBlank(application) && !Constants.ANY_VALUE.equals(application)) {\n        param.put(Constants.APPLICATION_KEY, application);\n    }\n    if (group != null) {\n        param.put(Constants.GROUP_KEY, group);\n    }\n    if (version != null) {\n        param.put(Constants.VERSION_KEY, version);\n    }\n    sb.append(StringUtils.toQueryString(param));\n    return URL.valueOf(sb.toString());\n}",
                "start_point": {
                    "row": 159,
                    "column": 4
                },
                "end_point": {
                    "row": 199,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/model/domain/Provider.java",
        "definition": "public class Provider extends Entity {\n\n    private static final long serialVersionUID = 5981342400350878171L;\n\n    private String service;/* The name of the service provided by the provider */\n\n    private String url; /* Provider's address for service */\n\n    private String parameters; /* Provider provides service parameters */\n\n    private String address; /* Provider address */\n\n    private String registry;/* The provider's registry address */\n\n    private boolean dynamic;          /* provider was registered dynamically */\n\n    private boolean enabled;          /* provider enabled or not */\n\n    private int weight;          /* provider weight */\n\n    private String application; /* application name */\n\n    private String username;      /* operator */\n\n    private Date expired;   /* time to expire */\n\n    private long alived;    /* time to live in milliseconds */\n\n    private Override override;\n\n    private List<Override> overrides;\n\n    public Provider() {\n    }\n\n    public Provider(Long id) {\n        super(id);\n    }\n\n    public String getService() {\n        return service;\n    }\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(String parameters) {\n        this.parameters = parameters;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String getRegistry() {\n        return registry;\n    }\n\n    public void setRegistry(String registry) {\n        this.registry = registry;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getApplication() {\n        return application;\n    }\n\n    public void setApplication(String application) {\n        this.application = application;\n    }\n\n    public boolean isDynamic() {\n        return dynamic;\n    }\n\n    public void setDynamic(boolean dynamic) {\n        this.dynamic = dynamic;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n\n    public Date getExpired() {\n        return expired;\n    }\n\n\n    public void setExpired(Date expired) {\n        this.expired = expired;\n    }\n\n    public long getAlived() {\n        return alived;\n    }\n\n    public void setAlived(long aliveSeconds) {\n        this.alived = aliveSeconds;\n    }\n\n    public int getWeight() {\n        return weight;\n    }\n\n    public void setWeight(int weight) {\n        this.weight = weight;\n    }\n\n    public Override getOverride() {\n        return override;\n    }\n\n    public void setOverride(Override override) {\n        this.override = override;\n    }\n\n    public List<Override> getOverrides() {\n        return overrides;\n    }\n\n    public void setOverrides(List<Override> overrides) {\n        this.overrides = overrides;\n    }\n\n    public URL toUrl() {\n        Map<String, String> serviceName2Map = ConvertUtil.serviceName2Map(getService());\n        /*if(!serviceName2Map.containsKey(Constants.INTERFACE_KEY)) {\n            throw new IllegalArgumentException(\"No interface info\");\n        }\n        if(!serviceName2Map.containsKey(Constants.VERSION_KEY)) {\n            throw new IllegalArgumentException(\"No version info\");\n        }*/\n\n        String u = getUrl();\n        URL url = URL.valueOf(u + \"?\" + getParameters());\n\n        url = url.addParameters(serviceName2Map);\n\n        boolean dynamic = isDynamic();\n        if (!dynamic) {\n            url = url.addParameter(Constants.DYNAMIC_KEY, false);\n        }\n        boolean enabled = isEnabled();\n        if (enabled != url.getParameter(\"enabled\", true)) {\n            if (enabled) {\n                url = url.removeParameter(\"enabled\");\n            } else {\n                url = url.addParameter(\"enabled\", false);\n            }\n        }\n\n        return url;\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.model.domain;",
        "tree_path": "Provider",
        "name": "Provider",
        "modifiers": "public",
        "superclass": "extends Entity",
        "super_interfaces": null,
        "body": "{\n\n    private static final long serialVersionUID = 5981342400350878171L;\n\n    private String service;/* The name of the service provided by the provider */\n\n    private String url; /* Provider's address for service */\n\n    private String parameters; /* Provider provides service parameters */\n\n    private String address; /* Provider address */\n\n    private String registry;/* The provider's registry address */\n\n    private boolean dynamic;          /* provider was registered dynamically */\n\n    private boolean enabled;          /* provider enabled or not */\n\n    private int weight;          /* provider weight */\n\n    private String application; /* application name */\n\n    private String username;      /* operator */\n\n    private Date expired;   /* time to expire */\n\n    private long alived;    /* time to live in milliseconds */\n\n    private Override override;\n\n    private List<Override> overrides;\n\n    public Provider() {\n    }\n\n    public Provider(Long id) {\n        super(id);\n    }\n\n    public String getService() {\n        return service;\n    }\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n    public String getUrl() {\n        return url;\n    }\n\n    public void setUrl(String url) {\n        this.url = url;\n    }\n\n    public String getParameters() {\n        return parameters;\n    }\n\n    public void setParameters(String parameters) {\n        this.parameters = parameters;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n\n    public String getRegistry() {\n        return registry;\n    }\n\n    public void setRegistry(String registry) {\n        this.registry = registry;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getApplication() {\n        return application;\n    }\n\n    public void setApplication(String application) {\n        this.application = application;\n    }\n\n    public boolean isDynamic() {\n        return dynamic;\n    }\n\n    public void setDynamic(boolean dynamic) {\n        this.dynamic = dynamic;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n\n    public Date getExpired() {\n        return expired;\n    }\n\n\n    public void setExpired(Date expired) {\n        this.expired = expired;\n    }\n\n    public long getAlived() {\n        return alived;\n    }\n\n    public void setAlived(long aliveSeconds) {\n        this.alived = aliveSeconds;\n    }\n\n    public int getWeight() {\n        return weight;\n    }\n\n    public void setWeight(int weight) {\n        this.weight = weight;\n    }\n\n    public Override getOverride() {\n        return override;\n    }\n\n    public void setOverride(Override override) {\n        this.override = override;\n    }\n\n    public List<Override> getOverrides() {\n        return overrides;\n    }\n\n    public void setOverrides(List<Override> overrides) {\n        this.overrides = overrides;\n    }\n\n    public URL toUrl() {\n        Map<String, String> serviceName2Map = ConvertUtil.serviceName2Map(getService());\n        /*if(!serviceName2Map.containsKey(Constants.INTERFACE_KEY)) {\n            throw new IllegalArgumentException(\"No interface info\");\n        }\n        if(!serviceName2Map.containsKey(Constants.VERSION_KEY)) {\n            throw new IllegalArgumentException(\"No version info\");\n        }*/\n\n        String u = getUrl();\n        URL url = URL.valueOf(u + \"?\" + getParameters());\n\n        url = url.addParameters(serviceName2Map);\n\n        boolean dynamic = isDynamic();\n        if (!dynamic) {\n            url = url.addParameter(Constants.DYNAMIC_KEY, false);\n        }\n        boolean enabled = isEnabled();\n        if (enabled != url.getParameter(\"enabled\", true)) {\n            if (enabled) {\n                url = url.removeParameter(\"enabled\");\n            } else {\n                url = url.addParameter(\"enabled\", false);\n            }\n        }\n\n        return url;\n    }\n\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 213,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public Provider() {\n}",
                "name": "Provider",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 63,
                    "column": 5
                }
            },
            {
                "definition": "public Provider(Long id) {\n    super(id);\n}",
                "name": "Provider",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "Long",
                        "name": "id"
                    }
                ],
                "body": "{\n    super(id);\n}",
                "constructor": true,
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 67,
                    "column": 5
                }
            },
            {
                "definition": "public String getService() {\n    return service;\n}",
                "name": "getService",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return service;\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "public void setService(String service) {\n    this.service = service;\n}",
                "name": "setService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    this.service = service;\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "public String getUrl() {\n    return url;\n}",
                "name": "getUrl",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return url;\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "public void setUrl(String url) {\n    this.url = url;\n}",
                "name": "setUrl",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "url"
                    }
                ],
                "body": "{\n    this.url = url;\n}",
                "start_point": {
                    "row": 81,
                    "column": 4
                },
                "end_point": {
                    "row": 83,
                    "column": 5
                }
            },
            {
                "definition": "public String getParameters() {\n    return parameters;\n}",
                "name": "getParameters",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return parameters;\n}",
                "start_point": {
                    "row": 85,
                    "column": 4
                },
                "end_point": {
                    "row": 87,
                    "column": 5
                }
            },
            {
                "definition": "public void setParameters(String parameters) {\n    this.parameters = parameters;\n}",
                "name": "setParameters",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "parameters"
                    }
                ],
                "body": "{\n    this.parameters = parameters;\n}",
                "start_point": {
                    "row": 89,
                    "column": 4
                },
                "end_point": {
                    "row": 91,
                    "column": 5
                }
            },
            {
                "definition": "public String getAddress() {\n    return address;\n}",
                "name": "getAddress",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return address;\n}",
                "start_point": {
                    "row": 93,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "public void setAddress(String address) {\n    this.address = address;\n}",
                "name": "setAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    this.address = address;\n}",
                "start_point": {
                    "row": 97,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            },
            {
                "definition": "public String getRegistry() {\n    return registry;\n}",
                "name": "getRegistry",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return registry;\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 103,
                    "column": 5
                }
            },
            {
                "definition": "public void setRegistry(String registry) {\n    this.registry = registry;\n}",
                "name": "setRegistry",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "registry"
                    }
                ],
                "body": "{\n    this.registry = registry;\n}",
                "start_point": {
                    "row": 105,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "public String getUsername() {\n    return username;\n}",
                "name": "getUsername",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return username;\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "public void setUsername(String username) {\n    this.username = username;\n}",
                "name": "setUsername",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    this.username = username;\n}",
                "start_point": {
                    "row": 113,
                    "column": 4
                },
                "end_point": {
                    "row": 115,
                    "column": 5
                }
            },
            {
                "definition": "public String getApplication() {\n    return application;\n}",
                "name": "getApplication",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return application;\n}",
                "start_point": {
                    "row": 117,
                    "column": 4
                },
                "end_point": {
                    "row": 119,
                    "column": 5
                }
            },
            {
                "definition": "public void setApplication(String application) {\n    this.application = application;\n}",
                "name": "setApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    this.application = application;\n}",
                "start_point": {
                    "row": 121,
                    "column": 4
                },
                "end_point": {
                    "row": 123,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isDynamic() {\n    return dynamic;\n}",
                "name": "isDynamic",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return dynamic;\n}",
                "start_point": {
                    "row": 125,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "public void setDynamic(boolean dynamic) {\n    this.dynamic = dynamic;\n}",
                "name": "setDynamic",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "dynamic"
                    }
                ],
                "body": "{\n    this.dynamic = dynamic;\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 131,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 133,
                    "column": 4
                },
                "end_point": {
                    "row": 135,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 137,
                    "column": 4
                },
                "end_point": {
                    "row": 139,
                    "column": 5
                }
            },
            {
                "definition": "public Date getExpired() {\n    return expired;\n}",
                "name": "getExpired",
                "modifiers": "public",
                "return_type": "Date",
                "parameters": [],
                "body": "{\n    return expired;\n}",
                "start_point": {
                    "row": 142,
                    "column": 4
                },
                "end_point": {
                    "row": 144,
                    "column": 5
                }
            },
            {
                "definition": "public void setExpired(Date expired) {\n    this.expired = expired;\n}",
                "name": "setExpired",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Date",
                        "name": "expired"
                    }
                ],
                "body": "{\n    this.expired = expired;\n}",
                "start_point": {
                    "row": 147,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            },
            {
                "definition": "public long getAlived() {\n    return alived;\n}",
                "name": "getAlived",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return alived;\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 153,
                    "column": 5
                }
            },
            {
                "definition": "public void setAlived(long aliveSeconds) {\n    this.alived = aliveSeconds;\n}",
                "name": "setAlived",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "long",
                        "name": "aliveSeconds"
                    }
                ],
                "body": "{\n    this.alived = aliveSeconds;\n}",
                "start_point": {
                    "row": 155,
                    "column": 4
                },
                "end_point": {
                    "row": 157,
                    "column": 5
                }
            },
            {
                "definition": "public int getWeight() {\n    return weight;\n}",
                "name": "getWeight",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return weight;\n}",
                "start_point": {
                    "row": 159,
                    "column": 4
                },
                "end_point": {
                    "row": 161,
                    "column": 5
                }
            },
            {
                "definition": "public void setWeight(int weight) {\n    this.weight = weight;\n}",
                "name": "setWeight",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "int",
                        "name": "weight"
                    }
                ],
                "body": "{\n    this.weight = weight;\n}",
                "start_point": {
                    "row": 163,
                    "column": 4
                },
                "end_point": {
                    "row": 165,
                    "column": 5
                }
            },
            {
                "definition": "public Override getOverride() {\n    return override;\n}",
                "name": "getOverride",
                "modifiers": "public",
                "return_type": "Override",
                "parameters": [],
                "body": "{\n    return override;\n}",
                "start_point": {
                    "row": 167,
                    "column": 4
                },
                "end_point": {
                    "row": 169,
                    "column": 5
                }
            },
            {
                "definition": "public void setOverride(Override override) {\n    this.override = override;\n}",
                "name": "setOverride",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    }
                ],
                "body": "{\n    this.override = override;\n}",
                "start_point": {
                    "row": 171,
                    "column": 4
                },
                "end_point": {
                    "row": 173,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> getOverrides() {\n    return overrides;\n}",
                "name": "getOverrides",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return overrides;\n}",
                "start_point": {
                    "row": 175,
                    "column": 4
                },
                "end_point": {
                    "row": 177,
                    "column": 5
                }
            },
            {
                "definition": "public void setOverrides(List<Override> overrides) {\n    this.overrides = overrides;\n}",
                "name": "setOverrides",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Override>",
                        "name": "overrides"
                    }
                ],
                "body": "{\n    this.overrides = overrides;\n}",
                "start_point": {
                    "row": 179,
                    "column": 4
                },
                "end_point": {
                    "row": 181,
                    "column": 5
                }
            },
            {
                "definition": "public URL toUrl() {\n    Map<String, String> serviceName2Map = ConvertUtil.serviceName2Map(getService());\n    /*if(!serviceName2Map.containsKey(Constants.INTERFACE_KEY)) {\n        throw new IllegalArgumentException(\"No interface info\");\n    }\n    if(!serviceName2Map.containsKey(Constants.VERSION_KEY)) {\n        throw new IllegalArgumentException(\"No version info\");\n    }*/\n\n    String u = getUrl();\n    URL url = URL.valueOf(u + \"?\" + getParameters());\n\n    url = url.addParameters(serviceName2Map);\n\n    boolean dynamic = isDynamic();\n    if (!dynamic) {\n        url = url.addParameter(Constants.DYNAMIC_KEY, false);\n    }\n    boolean enabled = isEnabled();\n    if (enabled != url.getParameter(\"enabled\", true)) {\n        if (enabled) {\n            url = url.removeParameter(\"enabled\");\n        } else {\n            url = url.addParameter(\"enabled\", false);\n        }\n    }\n\n    return url;\n}",
                "name": "toUrl",
                "modifiers": "public",
                "return_type": "URL",
                "parameters": [],
                "body": "{\n    Map<String, String> serviceName2Map = ConvertUtil.serviceName2Map(getService());\n    /*if(!serviceName2Map.containsKey(Constants.INTERFACE_KEY)) {\n        throw new IllegalArgumentException(\"No interface info\");\n    }\n    if(!serviceName2Map.containsKey(Constants.VERSION_KEY)) {\n        throw new IllegalArgumentException(\"No version info\");\n    }*/\n\n    String u = getUrl();\n    URL url = URL.valueOf(u + \"?\" + getParameters());\n\n    url = url.addParameters(serviceName2Map);\n\n    boolean dynamic = isDynamic();\n    if (!dynamic) {\n        url = url.addParameter(Constants.DYNAMIC_KEY, false);\n    }\n    boolean enabled = isEnabled();\n    if (enabled != url.getParameter(\"enabled\", true)) {\n        if (enabled) {\n            url = url.removeParameter(\"enabled\");\n        } else {\n            url = url.addParameter(\"enabled\", false);\n        }\n    }\n\n    return url;\n}",
                "start_point": {
                    "row": 183,
                    "column": 4
                },
                "end_point": {
                    "row": 211,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/model/domain/Route.java",
        "definition": "public class Route extends Entity {\n\n    public static final String ALL_METHOD = \"*\";\n    public static final String KEY_METHOD = \"method\";\n\n    // WHEN KEY\n    public static final String KEY_CONSUMER_APPLICATION = \"consumer.application\";\n    public static final String KEY_CONSUMER_GROUP = \"consumer.cluster\";\n    public static final String KEY_CONSUMER_VERSION = \"consumer.version\";\n    public static final String KEY_CONSUMER_HOST = \"host\";\n    public static final String KEY_CONSUMER_METHODS = \"consumer.methods\";\n    public static final String KEY_PROVIDER_APPLICATION = \"provider.application\";\n\n    // THEN KEY\n    public static final String KEY_PROVIDER_GROUP = \"provider.cluster\";\n    public static final String KEY_PROVIDER_PROTOCOL = \"provider.protocol\";\n    public static final String KEY_PROVIDER_VERSION = \"provider.version\";\n    public static final String KEY_PROVIDER_HOST = \"provider.host\";\n    public static final String KEY_PROVIDER_PORT = \"provider.port\";\n    private static final long serialVersionUID = -7630589008164140656L;\n    private long parentId; //default 0\n\n    private String name;\n\n    private String service;\n\n    private String rule;\n\n    private String matchRule;\n\n    private String filterRule;\n\n    private int priority;\n\n    private String username;\n\n    private boolean enabled;\n\n    private boolean force;\n\n    private boolean dynamic;\n\n    private boolean runtime;\n\n    private List<Route> children;\n\n    public Route() {\n    }\n\n    public Route(Long id) {\n        super(id);\n    }\n\n    public int getPriority() {\n        return priority;\n    }\n\n    public void setPriority(int priority) {\n        this.priority = priority;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public long getParentId() {\n        return parentId;\n    }\n\n    public void setParentId(long parentId) {\n        this.parentId = parentId;\n    }\n\n    public List<Route> getChildren() {\n        return children;\n    }\n\n    public void setChildren(List<Route> subRules) {\n        this.children = subRules;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public boolean isDynamic() {\n        return dynamic;\n    }\n\n    public void setDynamic(boolean dynamic) {\n        this.dynamic = dynamic;\n    }\n\n    public boolean isRuntime() {\n        return runtime;\n    }\n\n    public void setRuntime(boolean runtime) {\n        this.runtime = runtime;\n    }\n\n    public boolean isForce() {\n        return force;\n    }\n\n    public void setForce(boolean force) {\n        this.force = force;\n    }\n\n    public String getService() {\n        return service;\n    }\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n    public String getRule() {\n        return rule;\n    }\n\n    public void setRule(String rule) {\n        this.rule = rule.trim();\n        String[] rules = rule.split(\"=>\");\n        if (rules.length != 2) {\n            if (rule.endsWith(\"=>\")) {\n                this.matchRule = rules[0].trim();\n                this.filterRule = \"\";\n            } else {\n                throw new IllegalArgumentException(\"Illegal Route Condition Rule\");\n            }\n        } else {\n            this.matchRule = rules[0].trim();\n            this.filterRule = rules[1].trim();\n        }\n    }\n\n    public String getMatchRule() {\n        return matchRule;\n    }\n\n    public void setMatchRule(String matchRule) {\n        if (matchRule != null) {\n            this.matchRule = matchRule.trim();\n        } else {\n            this.matchRule = matchRule;\n        }\n    }\n\n    public String getFilterRule() {\n        return filterRule;\n    }\n\n    public void setFilterRule(String filterRule) {\n        if (filterRule != null) {\n            this.filterRule = filterRule.trim();\n        } else {\n            this.filterRule = filterRule;\n        }\n    }\n\n    @java.lang.Override\n    public String toString() {\n        return \"Route [parentId=\" + parentId + \", name=\" + name\n                + \", serviceName=\" + service + \", matchRule=\" + matchRule\n                + \", filterRule=\" + filterRule + \", priority=\" + priority\n                + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n    }\n\n    public URL toUrl() {\n        String group = null;\n        String version = null;\n        String path = service;\n        int i = path.indexOf(\"/\");\n        if (i > 0) {\n            group = path.substring(0, i);\n            path = path.substring(i + 1);\n        }\n        i = path.lastIndexOf(\":\");\n        if (i > 0) {\n            version = path.substring(i + 1);\n            path = path.substring(0, i);\n        }\n        return URL.valueOf(Constants.ROUTE_PROTOCOL + \"://\" + Constants.ANYHOST_VALUE + \"/\" + path\n                + \"?\" + Constants.CATEGORY_KEY + \"=\" + Constants.ROUTERS_CATEGORY\n                + \"&router=condition&runtime=\" + isRuntime() + \"&enabled=\" + isEnabled() + \"&priority=\" + getPriority() + \"&force=\" + isForce() + \"&dynamic=\" + isDynamic()\n                + \"&name=\" + getName() + \"&\" + Constants.RULE_KEY + \"=\" + URL.encode(getMatchRule() + \" => \" + getFilterRule())\n                + (group == null ? \"\" : \"&\" + Constants.GROUP_KEY + \"=\" + group)\n                + (version == null ? \"\" : \"&\" + Constants.VERSION_KEY + \"=\" + version));\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.model.domain;",
        "tree_path": "Route",
        "name": "Route",
        "modifiers": "public",
        "superclass": "extends Entity",
        "super_interfaces": null,
        "body": "{\n\n    public static final String ALL_METHOD = \"*\";\n    public static final String KEY_METHOD = \"method\";\n\n    // WHEN KEY\n    public static final String KEY_CONSUMER_APPLICATION = \"consumer.application\";\n    public static final String KEY_CONSUMER_GROUP = \"consumer.cluster\";\n    public static final String KEY_CONSUMER_VERSION = \"consumer.version\";\n    public static final String KEY_CONSUMER_HOST = \"host\";\n    public static final String KEY_CONSUMER_METHODS = \"consumer.methods\";\n    public static final String KEY_PROVIDER_APPLICATION = \"provider.application\";\n\n    // THEN KEY\n    public static final String KEY_PROVIDER_GROUP = \"provider.cluster\";\n    public static final String KEY_PROVIDER_PROTOCOL = \"provider.protocol\";\n    public static final String KEY_PROVIDER_VERSION = \"provider.version\";\n    public static final String KEY_PROVIDER_HOST = \"provider.host\";\n    public static final String KEY_PROVIDER_PORT = \"provider.port\";\n    private static final long serialVersionUID = -7630589008164140656L;\n    private long parentId; //default 0\n\n    private String name;\n\n    private String service;\n\n    private String rule;\n\n    private String matchRule;\n\n    private String filterRule;\n\n    private int priority;\n\n    private String username;\n\n    private boolean enabled;\n\n    private boolean force;\n\n    private boolean dynamic;\n\n    private boolean runtime;\n\n    private List<Route> children;\n\n    public Route() {\n    }\n\n    public Route(Long id) {\n        super(id);\n    }\n\n    public int getPriority() {\n        return priority;\n    }\n\n    public void setPriority(int priority) {\n        this.priority = priority;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public long getParentId() {\n        return parentId;\n    }\n\n    public void setParentId(long parentId) {\n        this.parentId = parentId;\n    }\n\n    public List<Route> getChildren() {\n        return children;\n    }\n\n    public void setChildren(List<Route> subRules) {\n        this.children = subRules;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public boolean isDynamic() {\n        return dynamic;\n    }\n\n    public void setDynamic(boolean dynamic) {\n        this.dynamic = dynamic;\n    }\n\n    public boolean isRuntime() {\n        return runtime;\n    }\n\n    public void setRuntime(boolean runtime) {\n        this.runtime = runtime;\n    }\n\n    public boolean isForce() {\n        return force;\n    }\n\n    public void setForce(boolean force) {\n        this.force = force;\n    }\n\n    public String getService() {\n        return service;\n    }\n\n    public void setService(String service) {\n        this.service = service;\n    }\n\n    public String getRule() {\n        return rule;\n    }\n\n    public void setRule(String rule) {\n        this.rule = rule.trim();\n        String[] rules = rule.split(\"=>\");\n        if (rules.length != 2) {\n            if (rule.endsWith(\"=>\")) {\n                this.matchRule = rules[0].trim();\n                this.filterRule = \"\";\n            } else {\n                throw new IllegalArgumentException(\"Illegal Route Condition Rule\");\n            }\n        } else {\n            this.matchRule = rules[0].trim();\n            this.filterRule = rules[1].trim();\n        }\n    }\n\n    public String getMatchRule() {\n        return matchRule;\n    }\n\n    public void setMatchRule(String matchRule) {\n        if (matchRule != null) {\n            this.matchRule = matchRule.trim();\n        } else {\n            this.matchRule = matchRule;\n        }\n    }\n\n    public String getFilterRule() {\n        return filterRule;\n    }\n\n    public void setFilterRule(String filterRule) {\n        if (filterRule != null) {\n            this.filterRule = filterRule.trim();\n        } else {\n            this.filterRule = filterRule;\n        }\n    }\n\n    @java.lang.Override\n    public String toString() {\n        return \"Route [parentId=\" + parentId + \", name=\" + name\n                + \", serviceName=\" + service + \", matchRule=\" + matchRule\n                + \", filterRule=\" + filterRule + \", priority=\" + priority\n                + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n    }\n\n    public URL toUrl() {\n        String group = null;\n        String version = null;\n        String path = service;\n        int i = path.indexOf(\"/\");\n        if (i > 0) {\n            group = path.substring(0, i);\n            path = path.substring(i + 1);\n        }\n        i = path.lastIndexOf(\":\");\n        if (i > 0) {\n            version = path.substring(i + 1);\n            path = path.substring(0, i);\n        }\n        return URL.valueOf(Constants.ROUTE_PROTOCOL + \"://\" + Constants.ANYHOST_VALUE + \"/\" + path\n                + \"?\" + Constants.CATEGORY_KEY + \"=\" + Constants.ROUTERS_CATEGORY\n                + \"&router=condition&runtime=\" + isRuntime() + \"&enabled=\" + isEnabled() + \"&priority=\" + getPriority() + \"&force=\" + isForce() + \"&dynamic=\" + isDynamic()\n                + \"&name=\" + getName() + \"&\" + Constants.RULE_KEY + \"=\" + URL.encode(getMatchRule() + \" => \" + getFilterRule())\n                + (group == null ? \"\" : \"&\" + Constants.GROUP_KEY + \"=\" + group)\n                + (version == null ? \"\" : \"&\" + Constants.VERSION_KEY + \"=\" + version));\n    }\n\n}",
        "start_point": {
            "row": 27,
            "column": 0
        },
        "end_point": {
            "row": 234,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public Route() {\n}",
                "name": "Route",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            },
            {
                "definition": "public Route(Long id) {\n    super(id);\n}",
                "name": "Route",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "Long",
                        "name": "id"
                    }
                ],
                "body": "{\n    super(id);\n}",
                "constructor": true,
                "start_point": {
                    "row": 76,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "public int getPriority() {\n    return priority;\n}",
                "name": "getPriority",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return priority;\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 82,
                    "column": 5
                }
            },
            {
                "definition": "public void setPriority(int priority) {\n    this.priority = priority;\n}",
                "name": "setPriority",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "int",
                        "name": "priority"
                    }
                ],
                "body": "{\n    this.priority = priority;\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 86,
                    "column": 5
                }
            },
            {
                "definition": "public String getUsername() {\n    return username;\n}",
                "name": "getUsername",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return username;\n}",
                "start_point": {
                    "row": 88,
                    "column": 4
                },
                "end_point": {
                    "row": 90,
                    "column": 5
                }
            },
            {
                "definition": "public void setUsername(String username) {\n    this.username = username;\n}",
                "name": "setUsername",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    this.username = username;\n}",
                "start_point": {
                    "row": 92,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "public long getParentId() {\n    return parentId;\n}",
                "name": "getParentId",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return parentId;\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            },
            {
                "definition": "public void setParentId(long parentId) {\n    this.parentId = parentId;\n}",
                "name": "setParentId",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "long",
                        "name": "parentId"
                    }
                ],
                "body": "{\n    this.parentId = parentId;\n}",
                "start_point": {
                    "row": 100,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> getChildren() {\n    return children;\n}",
                "name": "getChildren",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return children;\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "public void setChildren(List<Route> subRules) {\n    this.children = subRules;\n}",
                "name": "setChildren",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Route>",
                        "name": "subRules"
                    }
                ],
                "body": "{\n    this.children = subRules;\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 110,
                    "column": 5
                }
            },
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 112,
                    "column": 4
                },
                "end_point": {
                    "row": 114,
                    "column": 5
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 116,
                    "column": 4
                },
                "end_point": {
                    "row": 118,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 120,
                    "column": 4
                },
                "end_point": {
                    "row": 122,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 124,
                    "column": 4
                },
                "end_point": {
                    "row": 126,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isDynamic() {\n    return dynamic;\n}",
                "name": "isDynamic",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return dynamic;\n}",
                "start_point": {
                    "row": 128,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "public void setDynamic(boolean dynamic) {\n    this.dynamic = dynamic;\n}",
                "name": "setDynamic",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "dynamic"
                    }
                ],
                "body": "{\n    this.dynamic = dynamic;\n}",
                "start_point": {
                    "row": 132,
                    "column": 4
                },
                "end_point": {
                    "row": 134,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isRuntime() {\n    return runtime;\n}",
                "name": "isRuntime",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return runtime;\n}",
                "start_point": {
                    "row": 136,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "public void setRuntime(boolean runtime) {\n    this.runtime = runtime;\n}",
                "name": "setRuntime",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "runtime"
                    }
                ],
                "body": "{\n    this.runtime = runtime;\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 142,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isForce() {\n    return force;\n}",
                "name": "isForce",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return force;\n}",
                "start_point": {
                    "row": 144,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "public void setForce(boolean force) {\n    this.force = force;\n}",
                "name": "setForce",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "force"
                    }
                ],
                "body": "{\n    this.force = force;\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 150,
                    "column": 5
                }
            },
            {
                "definition": "public String getService() {\n    return service;\n}",
                "name": "getService",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return service;\n}",
                "start_point": {
                    "row": 152,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "public void setService(String service) {\n    this.service = service;\n}",
                "name": "setService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    this.service = service;\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 158,
                    "column": 5
                }
            },
            {
                "definition": "public String getRule() {\n    return rule;\n}",
                "name": "getRule",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return rule;\n}",
                "start_point": {
                    "row": 160,
                    "column": 4
                },
                "end_point": {
                    "row": 162,
                    "column": 5
                }
            },
            {
                "definition": "public void setRule(String rule) {\n    this.rule = rule.trim();\n    String[] rules = rule.split(\"=>\");\n    if (rules.length != 2) {\n        if (rule.endsWith(\"=>\")) {\n            this.matchRule = rules[0].trim();\n            this.filterRule = \"\";\n        } else {\n            throw new IllegalArgumentException(\"Illegal Route Condition Rule\");\n        }\n    } else {\n        this.matchRule = rules[0].trim();\n        this.filterRule = rules[1].trim();\n    }\n}",
                "name": "setRule",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "rule"
                    }
                ],
                "body": "{\n    this.rule = rule.trim();\n    String[] rules = rule.split(\"=>\");\n    if (rules.length != 2) {\n        if (rule.endsWith(\"=>\")) {\n            this.matchRule = rules[0].trim();\n            this.filterRule = \"\";\n        } else {\n            throw new IllegalArgumentException(\"Illegal Route Condition Rule\");\n        }\n    } else {\n        this.matchRule = rules[0].trim();\n        this.filterRule = rules[1].trim();\n    }\n}",
                "start_point": {
                    "row": 164,
                    "column": 4
                },
                "end_point": {
                    "row": 178,
                    "column": 5
                }
            },
            {
                "definition": "public String getMatchRule() {\n    return matchRule;\n}",
                "name": "getMatchRule",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return matchRule;\n}",
                "start_point": {
                    "row": 180,
                    "column": 4
                },
                "end_point": {
                    "row": 182,
                    "column": 5
                }
            },
            {
                "definition": "public void setMatchRule(String matchRule) {\n    if (matchRule != null) {\n        this.matchRule = matchRule.trim();\n    } else {\n        this.matchRule = matchRule;\n    }\n}",
                "name": "setMatchRule",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "matchRule"
                    }
                ],
                "body": "{\n    if (matchRule != null) {\n        this.matchRule = matchRule.trim();\n    } else {\n        this.matchRule = matchRule;\n    }\n}",
                "start_point": {
                    "row": 184,
                    "column": 4
                },
                "end_point": {
                    "row": 190,
                    "column": 5
                }
            },
            {
                "definition": "public String getFilterRule() {\n    return filterRule;\n}",
                "name": "getFilterRule",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return filterRule;\n}",
                "start_point": {
                    "row": 192,
                    "column": 4
                },
                "end_point": {
                    "row": 194,
                    "column": 5
                }
            },
            {
                "definition": "public void setFilterRule(String filterRule) {\n    if (filterRule != null) {\n        this.filterRule = filterRule.trim();\n    } else {\n        this.filterRule = filterRule;\n    }\n}",
                "name": "setFilterRule",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "filterRule"
                    }
                ],
                "body": "{\n    if (filterRule != null) {\n        this.filterRule = filterRule.trim();\n    } else {\n        this.filterRule = filterRule;\n    }\n}",
                "start_point": {
                    "row": 196,
                    "column": 4
                },
                "end_point": {
                    "row": 202,
                    "column": 5
                }
            },
            {
                "definition": "@java.lang.Override\npublic String toString() {\n    return \"Route [parentId=\" + parentId + \", name=\" + name\n            + \", serviceName=\" + service + \", matchRule=\" + matchRule\n            + \", filterRule=\" + filterRule + \", priority=\" + priority\n            + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n}",
                "name": "toString",
                "modifiers": "@java.lang.Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"Route [parentId=\" + parentId + \", name=\" + name\n            + \", serviceName=\" + service + \", matchRule=\" + matchRule\n            + \", filterRule=\" + filterRule + \", priority=\" + priority\n            + \", username=\" + username + \", enabled=\" + enabled + \"]\";\n}",
                "start_point": {
                    "row": 204,
                    "column": 4
                },
                "end_point": {
                    "row": 210,
                    "column": 5
                }
            },
            {
                "definition": "public URL toUrl() {\n    String group = null;\n    String version = null;\n    String path = service;\n    int i = path.indexOf(\"/\");\n    if (i > 0) {\n        group = path.substring(0, i);\n        path = path.substring(i + 1);\n    }\n    i = path.lastIndexOf(\":\");\n    if (i > 0) {\n        version = path.substring(i + 1);\n        path = path.substring(0, i);\n    }\n    return URL.valueOf(Constants.ROUTE_PROTOCOL + \"://\" + Constants.ANYHOST_VALUE + \"/\" + path\n            + \"?\" + Constants.CATEGORY_KEY + \"=\" + Constants.ROUTERS_CATEGORY\n            + \"&router=condition&runtime=\" + isRuntime() + \"&enabled=\" + isEnabled() + \"&priority=\" + getPriority() + \"&force=\" + isForce() + \"&dynamic=\" + isDynamic()\n            + \"&name=\" + getName() + \"&\" + Constants.RULE_KEY + \"=\" + URL.encode(getMatchRule() + \" => \" + getFilterRule())\n            + (group == null ? \"\" : \"&\" + Constants.GROUP_KEY + \"=\" + group)\n            + (version == null ? \"\" : \"&\" + Constants.VERSION_KEY + \"=\" + version));\n}",
                "name": "toUrl",
                "modifiers": "public",
                "return_type": "URL",
                "parameters": [],
                "body": "{\n    String group = null;\n    String version = null;\n    String path = service;\n    int i = path.indexOf(\"/\");\n    if (i > 0) {\n        group = path.substring(0, i);\n        path = path.substring(i + 1);\n    }\n    i = path.lastIndexOf(\":\");\n    if (i > 0) {\n        version = path.substring(i + 1);\n        path = path.substring(0, i);\n    }\n    return URL.valueOf(Constants.ROUTE_PROTOCOL + \"://\" + Constants.ANYHOST_VALUE + \"/\" + path\n            + \"?\" + Constants.CATEGORY_KEY + \"=\" + Constants.ROUTERS_CATEGORY\n            + \"&router=condition&runtime=\" + isRuntime() + \"&enabled=\" + isEnabled() + \"&priority=\" + getPriority() + \"&force=\" + isForce() + \"&dynamic=\" + isDynamic()\n            + \"&name=\" + getName() + \"&\" + Constants.RULE_KEY + \"=\" + URL.encode(getMatchRule() + \" => \" + getFilterRule())\n            + (group == null ? \"\" : \"&\" + Constants.GROUP_KEY + \"=\" + group)\n            + (version == null ? \"\" : \"&\" + Constants.VERSION_KEY + \"=\" + version));\n}",
                "start_point": {
                    "row": 212,
                    "column": 4
                },
                "end_point": {
                    "row": 232,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/RegistryServerSync.java",
        "definition": "@Component\npublic class RegistryServerSync implements InitializingBean, DisposableBean, NotifyListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(RegistryServerSync.class);\n\n    private static final URL SUBSCRIBE = new URL(Constants.ADMIN_PROTOCOL, NetUtils.getLocalHost(), 0, \"\",\n            Constants.INTERFACE_KEY, Constants.ANY_VALUE,\n            Constants.GROUP_KEY, Constants.ANY_VALUE,\n            Constants.VERSION_KEY, Constants.ANY_VALUE,\n            Constants.CLASSIFIER_KEY, Constants.ANY_VALUE,\n            Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY + \",\"\n            + Constants.CONSUMERS_CATEGORY + \",\"\n            + Constants.ROUTERS_CATEGORY + \",\"\n            + Constants.CONFIGURATORS_CATEGORY,\n            Constants.ENABLED_KEY, Constants.ANY_VALUE,\n            Constants.CHECK_KEY, String.valueOf(false));\n\n    private static final AtomicLong ID = new AtomicLong();\n\n    /**\n     * Make sure ID never changed when the same url notified many times\n     */\n    private final ConcurrentHashMap<String, String> URL_IDS_MAPPER = new ConcurrentHashMap<>();\n\n    // ConcurrentMap<category, ConcurrentMap<servicename, Map<MD5, URL>>>\n    private final ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>>\n        registryCache = new ConcurrentHashMap<>();\n    @Autowired\n    private RegistryService registryService;\n\n    public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n        return registryCache;\n    }\n\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Init Dubbo Admin Sync Cache...\");\n        registryService.subscribe(SUBSCRIBE, this);\n    }\n\n    public void destroy() throws Exception {\n        registryService.unsubscribe(SUBSCRIBE, this);\n    }\n\n    // Notification of of any service with any type (override\u3001subcribe\u3001route\u3001provider) is full.\n    public void notify(List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            return;\n        }\n        // Map<category, Map<servicename, Map<Long, URL>>>\n        final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n        String interfaceName = null;\n        for (URL url : urls) {\n            String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n            if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n                ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n                if (services != null) {\n                    String group = url.getParameter(Constants.GROUP_KEY);\n                    String version = url.getParameter(Constants.VERSION_KEY);\n                    // NOTE: group and version in empty protocol is *\n                    if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                        services.remove(url.getServiceKey());\n                    } else {\n                        for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                            String service = serviceEntry.getKey();\n                            if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                    && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                    && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                                services.remove(service);\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (StringUtils.isEmpty(interfaceName)) {\n                    interfaceName = url.getServiceInterface();\n                }\n                Map<String, Map<String, URL>> services = categories.get(category);\n                if (services == null) {\n                    services = new HashMap<>();\n                    categories.put(category, services);\n                }\n                String service = url.getServiceKey();\n                Map<String, URL> ids = services.get(service);\n                if (ids == null) {\n                    ids = new HashMap<>();\n                    services.put(service, ids);\n                }\n\n                // Make sure we use the same ID for the same URL\n                if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                    ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n                } else {\n                    String md5 = MD5Util.MD5_16bit(url.toFullString());\n                    ids.put(md5, url);\n                    URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n                }\n            }\n        }\n        if (categories.size() == 0) {\n            return;\n        }\n        for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n            String category = categoryEntry.getKey();\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services == null) {\n                services = new ConcurrentHashMap<String, Map<String, URL>>();\n                registryCache.put(category, services);\n            } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n                Set<String> keys = new HashSet<String>(services.keySet());\n                for (String key : keys) {\n                    if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                        services.remove(key);\n                    }\n                }\n            }\n            services.putAll(categoryEntry.getValue());\n        }\n    }\n}",
        "package": "package org.apache.dubbo.admin.service;",
        "tree_path": "RegistryServerSync",
        "name": "RegistryServerSync",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements InitializingBean, DisposableBean, NotifyListener",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(RegistryServerSync.class);\n\n    private static final URL SUBSCRIBE = new URL(Constants.ADMIN_PROTOCOL, NetUtils.getLocalHost(), 0, \"\",\n            Constants.INTERFACE_KEY, Constants.ANY_VALUE,\n            Constants.GROUP_KEY, Constants.ANY_VALUE,\n            Constants.VERSION_KEY, Constants.ANY_VALUE,\n            Constants.CLASSIFIER_KEY, Constants.ANY_VALUE,\n            Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY + \",\"\n            + Constants.CONSUMERS_CATEGORY + \",\"\n            + Constants.ROUTERS_CATEGORY + \",\"\n            + Constants.CONFIGURATORS_CATEGORY,\n            Constants.ENABLED_KEY, Constants.ANY_VALUE,\n            Constants.CHECK_KEY, String.valueOf(false));\n\n    private static final AtomicLong ID = new AtomicLong();\n\n    /**\n     * Make sure ID never changed when the same url notified many times\n     */\n    private final ConcurrentHashMap<String, String> URL_IDS_MAPPER = new ConcurrentHashMap<>();\n\n    // ConcurrentMap<category, ConcurrentMap<servicename, Map<MD5, URL>>>\n    private final ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>>\n        registryCache = new ConcurrentHashMap<>();\n    @Autowired\n    private RegistryService registryService;\n\n    public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n        return registryCache;\n    }\n\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Init Dubbo Admin Sync Cache...\");\n        registryService.subscribe(SUBSCRIBE, this);\n    }\n\n    public void destroy() throws Exception {\n        registryService.unsubscribe(SUBSCRIBE, this);\n    }\n\n    // Notification of of any service with any type (override\u3001subcribe\u3001route\u3001provider) is full.\n    public void notify(List<URL> urls) {\n        if (urls == null || urls.isEmpty()) {\n            return;\n        }\n        // Map<category, Map<servicename, Map<Long, URL>>>\n        final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n        String interfaceName = null;\n        for (URL url : urls) {\n            String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n            if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n                ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n                if (services != null) {\n                    String group = url.getParameter(Constants.GROUP_KEY);\n                    String version = url.getParameter(Constants.VERSION_KEY);\n                    // NOTE: group and version in empty protocol is *\n                    if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                        services.remove(url.getServiceKey());\n                    } else {\n                        for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                            String service = serviceEntry.getKey();\n                            if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                    && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                    && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                                services.remove(service);\n                            }\n                        }\n                    }\n                }\n            } else {\n                if (StringUtils.isEmpty(interfaceName)) {\n                    interfaceName = url.getServiceInterface();\n                }\n                Map<String, Map<String, URL>> services = categories.get(category);\n                if (services == null) {\n                    services = new HashMap<>();\n                    categories.put(category, services);\n                }\n                String service = url.getServiceKey();\n                Map<String, URL> ids = services.get(service);\n                if (ids == null) {\n                    ids = new HashMap<>();\n                    services.put(service, ids);\n                }\n\n                // Make sure we use the same ID for the same URL\n                if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                    ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n                } else {\n                    String md5 = MD5Util.MD5_16bit(url.toFullString());\n                    ids.put(md5, url);\n                    URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n                }\n            }\n        }\n        if (categories.size() == 0) {\n            return;\n        }\n        for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n            String category = categoryEntry.getKey();\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services == null) {\n                services = new ConcurrentHashMap<String, Map<String, URL>>();\n                registryCache.put(category, services);\n            } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n                Set<String> keys = new HashSet<String>(services.keySet());\n                for (String key : keys) {\n                    if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                        services.remove(key);\n                    }\n                }\n            }\n            services.putAll(categoryEntry.getValue());\n        }\n    }\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 156,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n    return registryCache;\n}",
                "name": "getRegistryCache",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return registryCache;\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                }
            },
            {
                "definition": "public void afterPropertiesSet() throws Exception {\n    logger.info(\"Init Dubbo Admin Sync Cache...\");\n    registryService.subscribe(SUBSCRIBE, this);\n}",
                "name": "afterPropertiesSet",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Init Dubbo Admin Sync Cache...\");\n    registryService.subscribe(SUBSCRIBE, this);\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "public void destroy() throws Exception {\n    registryService.unsubscribe(SUBSCRIBE, this);\n}",
                "name": "destroy",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    registryService.unsubscribe(SUBSCRIBE, this);\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "public void notify(List<URL> urls) {\n    if (urls == null || urls.isEmpty()) {\n        return;\n    }\n    // Map<category, Map<servicename, Map<Long, URL>>>\n    final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n    String interfaceName = null;\n    for (URL url : urls) {\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services != null) {\n                String group = url.getParameter(Constants.GROUP_KEY);\n                String version = url.getParameter(Constants.VERSION_KEY);\n                // NOTE: group and version in empty protocol is *\n                if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                    services.remove(url.getServiceKey());\n                } else {\n                    for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                        String service = serviceEntry.getKey();\n                        if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                            services.remove(service);\n                        }\n                    }\n                }\n            }\n        } else {\n            if (StringUtils.isEmpty(interfaceName)) {\n                interfaceName = url.getServiceInterface();\n            }\n            Map<String, Map<String, URL>> services = categories.get(category);\n            if (services == null) {\n                services = new HashMap<>();\n                categories.put(category, services);\n            }\n            String service = url.getServiceKey();\n            Map<String, URL> ids = services.get(service);\n            if (ids == null) {\n                ids = new HashMap<>();\n                services.put(service, ids);\n            }\n\n            // Make sure we use the same ID for the same URL\n            if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n            } else {\n                String md5 = MD5Util.MD5_16bit(url.toFullString());\n                ids.put(md5, url);\n                URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n            }\n        }\n    }\n    if (categories.size() == 0) {\n        return;\n    }\n    for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n        String category = categoryEntry.getKey();\n        ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n        if (services == null) {\n            services = new ConcurrentHashMap<String, Map<String, URL>>();\n            registryCache.put(category, services);\n        } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n            Set<String> keys = new HashSet<String>(services.keySet());\n            for (String key : keys) {\n                if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                    services.remove(key);\n                }\n            }\n        }\n        services.putAll(categoryEntry.getValue());\n    }\n}",
                "name": "notify",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<URL>",
                        "name": "urls"
                    }
                ],
                "body": "{\n    if (urls == null || urls.isEmpty()) {\n        return;\n    }\n    // Map<category, Map<servicename, Map<Long, URL>>>\n    final Map<String, Map<String, Map<String, URL>>> categories = new HashMap<>();\n    String interfaceName = null;\n    for (URL url : urls) {\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        if (Constants.EMPTY_PROTOCOL.equalsIgnoreCase(url.getProtocol())) { // NOTE: group and version in empty protocol is *\n            ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n            if (services != null) {\n                String group = url.getParameter(Constants.GROUP_KEY);\n                String version = url.getParameter(Constants.VERSION_KEY);\n                // NOTE: group and version in empty protocol is *\n                if (!Constants.ANY_VALUE.equals(group) && !Constants.ANY_VALUE.equals(version)) {\n                    services.remove(url.getServiceKey());\n                } else {\n                    for (Map.Entry<String, Map<String, URL>> serviceEntry : services.entrySet()) {\n                        String service = serviceEntry.getKey();\n                        if (Tool.getInterface(service).equals(url.getServiceInterface())\n                                && (Constants.ANY_VALUE.equals(group) || StringUtils.isEquals(group, Tool.getGroup(service)))\n                                && (Constants.ANY_VALUE.equals(version) || StringUtils.isEquals(version, Tool.getVersion(service)))) {\n                            services.remove(service);\n                        }\n                    }\n                }\n            }\n        } else {\n            if (StringUtils.isEmpty(interfaceName)) {\n                interfaceName = url.getServiceInterface();\n            }\n            Map<String, Map<String, URL>> services = categories.get(category);\n            if (services == null) {\n                services = new HashMap<>();\n                categories.put(category, services);\n            }\n            String service = url.getServiceKey();\n            Map<String, URL> ids = services.get(service);\n            if (ids == null) {\n                ids = new HashMap<>();\n                services.put(service, ids);\n            }\n\n            // Make sure we use the same ID for the same URL\n            if (URL_IDS_MAPPER.containsKey(url.toFullString())) {\n                ids.put(URL_IDS_MAPPER.get(url.toFullString()), url);\n            } else {\n                String md5 = MD5Util.MD5_16bit(url.toFullString());\n                ids.put(md5, url);\n                URL_IDS_MAPPER.putIfAbsent(url.toFullString(), md5);\n            }\n        }\n    }\n    if (categories.size() == 0) {\n        return;\n    }\n    for (Map.Entry<String, Map<String, Map<String, URL>>> categoryEntry : categories.entrySet()) {\n        String category = categoryEntry.getKey();\n        ConcurrentMap<String, Map<String, URL>> services = registryCache.get(category);\n        if (services == null) {\n            services = new ConcurrentHashMap<String, Map<String, URL>>();\n            registryCache.put(category, services);\n        } else {// Fix map can not be cleared when service is unregistered: when a unique \u201cgroup/service:version\u201d service is unregistered, but we still have the same services with different version or group, so empty protocols can not be invoked.\n            Set<String> keys = new HashSet<String>(services.keySet());\n            for (String key : keys) {\n                if (Tool.getInterface(key).equals(interfaceName) && !categoryEntry.getValue().entrySet().contains(key)) {\n                    services.remove(key);\n                }\n            }\n        }\n        services.putAll(categoryEntry.getValue());\n    }\n}",
                "start_point": {
                    "row": 82,
                    "column": 4
                },
                "end_point": {
                    "row": 155,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/impl/AbstractService.java",
        "definition": "public class AbstractService {\n\n    protected static final Logger logger = LoggerFactory.getLogger(AbstractService.class);\n    @Autowired\n    protected RegistryService registryService;\n    @Autowired\n    private RegistryServerSync sync;\n\n    public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n        return sync.getRegistryCache();\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.service.impl;",
        "tree_path": "AbstractService",
        "name": "AbstractService",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    protected static final Logger logger = LoggerFactory.getLogger(AbstractService.class);\n    @Autowired\n    protected RegistryService registryService;\n    @Autowired\n    private RegistryServerSync sync;\n\n    public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n        return sync.getRegistryCache();\n    }\n\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 44,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public ConcurrentMap<String, ConcurrentMap<String, Map<String, URL>>> getRegistryCache() {\n    return sync.getRegistryCache();\n}",
                "name": "getRegistryCache",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return sync.getRegistryCache();\n}",
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 42,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/impl/ConsumerServiceImpl.java",
        "definition": "@Component\npublic class ConsumerServiceImpl extends AbstractService implements ConsumerService {\n\n    public List<Consumer> findByService(String service) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByService(service));\n    }\n\n    public Consumer findConsumer(String id) {\n        return SyncUtils.url2Consumer(findConsumerUrl(id));\n    }\n\n    private Pair<String, URL> findConsumerUrl(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONSUMERS_CATEGORY, id);\n    }\n\n    public List<Consumer> findAll() {\n        return SyncUtils.url2ConsumerList(findAllConsumerUrl());\n    }\n\n    private Map<String, URL> findAllConsumerUrl() {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findAddresses() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (null == consumerUrls) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getAddress();\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n\n        if(consumerUrls == null)\n            return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    String addr = u.getAddress();\n                    if (addr != null) ret.add(addr);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByService(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (null == consumerUrls) return ret;\n\n        for (Map.Entry<String, URL> e2 : consumerUrls.get(service).entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<Consumer> findByAddress(String consumerAddress) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByAddress(consumerAddress));\n    }\n\n    public List<String> findServicesByAddress(String address) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null || address == null || address.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (address.equals(u.getAddress())) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    private Map<String, URL> findConsumerUrlByAddress(String address) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findApplications() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getParameter(Constants.APPLICATION_KEY);\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findApplicationsByServiceName(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null) return ret;\n\n        Map<String, URL> value = consumerUrls.get(service);\n        if (value == null) {\n            return ret;\n        }\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<Consumer> findByApplication(String application) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByApplication(application));\n    }\n\n    public List<Consumer> findByAppandService(String app, String serviceName) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByAppandService(app, serviceName));\n    }\n\n    private Map<String, URL> findConsumerUrlByAppandService(String application, String service) {\n        Map<String, String> filter = new HashMap<>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, application);\n        filter.put(Constants.SERVICE_FILTER_KEY, service);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    private Map<String, URL> findConsumerUrlByApplication(String application) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, application);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findServicesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null || application == null || application.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findServices() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls != null) ret.addAll(consumerUrls.keySet());\n        return ret;\n    }\n\n    public Map<String, URL> findConsumerUrlByService(String service) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.service.impl;",
        "tree_path": "ConsumerServiceImpl",
        "name": "ConsumerServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": "extends AbstractService",
        "super_interfaces": "implements ConsumerService",
        "body": "{\n\n    public List<Consumer> findByService(String service) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByService(service));\n    }\n\n    public Consumer findConsumer(String id) {\n        return SyncUtils.url2Consumer(findConsumerUrl(id));\n    }\n\n    private Pair<String, URL> findConsumerUrl(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONSUMERS_CATEGORY, id);\n    }\n\n    public List<Consumer> findAll() {\n        return SyncUtils.url2ConsumerList(findAllConsumerUrl());\n    }\n\n    private Map<String, URL> findAllConsumerUrl() {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findAddresses() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (null == consumerUrls) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getAddress();\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n\n        if(consumerUrls == null)\n            return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    String addr = u.getAddress();\n                    if (addr != null) ret.add(addr);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByService(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (null == consumerUrls) return ret;\n\n        for (Map.Entry<String, URL> e2 : consumerUrls.get(service).entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<Consumer> findByAddress(String consumerAddress) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByAddress(consumerAddress));\n    }\n\n    public List<String> findServicesByAddress(String address) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null || address == null || address.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (address.equals(u.getAddress())) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    private Map<String, URL> findConsumerUrlByAddress(String address) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findApplications() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getParameter(Constants.APPLICATION_KEY);\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findApplicationsByServiceName(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null) return ret;\n\n        Map<String, URL> value = consumerUrls.get(service);\n        if (value == null) {\n            return ret;\n        }\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<Consumer> findByApplication(String application) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByApplication(application));\n    }\n\n    public List<Consumer> findByAppandService(String app, String serviceName) {\n        return SyncUtils.url2ConsumerList(findConsumerUrlByAppandService(app, serviceName));\n    }\n\n    private Map<String, URL> findConsumerUrlByAppandService(String application, String service) {\n        Map<String, String> filter = new HashMap<>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, application);\n        filter.put(Constants.SERVICE_FILTER_KEY, service);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    private Map<String, URL> findConsumerUrlByApplication(String application) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, application);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findServicesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls == null || application == null || application.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findServices() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n        if (consumerUrls != null) ret.addAll(consumerUrls.keySet());\n        return ret;\n    }\n\n    public Map<String, URL> findConsumerUrlByService(String service) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 234,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public List<Consumer> findByService(String service) {\n    return SyncUtils.url2ConsumerList(findConsumerUrlByService(service));\n}",
                "name": "findByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ConsumerList(findConsumerUrlByService(service));\n}",
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 37,
                    "column": 5
                }
            },
            {
                "definition": "public Consumer findConsumer(String id) {\n    return SyncUtils.url2Consumer(findConsumerUrl(id));\n}",
                "name": "findConsumer",
                "modifiers": "public",
                "return_type": "Consumer",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.url2Consumer(findConsumerUrl(id));\n}",
                "start_point": {
                    "row": 39,
                    "column": 4
                },
                "end_point": {
                    "row": 41,
                    "column": 5
                }
            },
            {
                "definition": "private Pair<String, URL> findConsumerUrl(String id) {\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONSUMERS_CATEGORY, id);\n}",
                "name": "findConsumerUrl",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONSUMERS_CATEGORY, id);\n}",
                "start_point": {
                    "row": 43,
                    "column": 4
                },
                "end_point": {
                    "row": 45,
                    "column": 5
                }
            },
            {
                "definition": "public List<Consumer> findAll() {\n    return SyncUtils.url2ConsumerList(findAllConsumerUrl());\n}",
                "name": "findAll",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return SyncUtils.url2ConsumerList(findAllConsumerUrl());\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findAllConsumerUrl() {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findAllConsumerUrl",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 55,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findAddresses() {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (null == consumerUrls) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "name": "findAddresses",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (null == consumerUrls) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 57,
                    "column": 4
                },
                "end_point": {
                    "row": 72,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findAddressesByApplication(String application) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n\n    if(consumerUrls == null)\n        return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                String addr = u.getAddress();\n                if (addr != null) ret.add(addr);\n            }\n        }\n    }\n\n    return ret;\n}",
                "name": "findAddressesByApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n\n    if(consumerUrls == null)\n        return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                String addr = u.getAddress();\n                if (addr != null) ret.add(addr);\n            }\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 74,
                    "column": 4
                },
                "end_point": {
                    "row": 93,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findAddressesByService(String service) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (null == consumerUrls) return ret;\n\n    for (Map.Entry<String, URL> e2 : consumerUrls.get(service).entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getAddress();\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "name": "findAddressesByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (null == consumerUrls) return ret;\n\n    for (Map.Entry<String, URL> e2 : consumerUrls.get(service).entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getAddress();\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "public List<Consumer> findByAddress(String consumerAddress) {\n    return SyncUtils.url2ConsumerList(findConsumerUrlByAddress(consumerAddress));\n}",
                "name": "findByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "consumerAddress"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ConsumerList(findConsumerUrlByAddress(consumerAddress));\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findServicesByAddress(String address) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null || address == null || address.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (address.equals(u.getAddress())) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "name": "findServicesByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null || address == null || address.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (address.equals(u.getAddress())) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 113,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findConsumerUrlByAddress(String address) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findConsumerUrlByAddress",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 132,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findApplications() {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "name": "findApplications",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 155,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findApplicationsByServiceName(String service) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null) return ret;\n\n    Map<String, URL> value = consumerUrls.get(service);\n    if (value == null) {\n        return ret;\n    }\n    for (Map.Entry<String, URL> e2 : value.entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getParameter(Constants.APPLICATION_KEY);\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "name": "findApplicationsByServiceName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null) return ret;\n\n    Map<String, URL> value = consumerUrls.get(service);\n    if (value == null) {\n        return ret;\n    }\n    for (Map.Entry<String, URL> e2 : value.entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getParameter(Constants.APPLICATION_KEY);\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 157,
                    "column": 4
                },
                "end_point": {
                    "row": 173,
                    "column": 5
                }
            },
            {
                "definition": "public List<Consumer> findByApplication(String application) {\n    return SyncUtils.url2ConsumerList(findConsumerUrlByApplication(application));\n}",
                "name": "findByApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ConsumerList(findConsumerUrlByApplication(application));\n}",
                "start_point": {
                    "row": 175,
                    "column": 4
                },
                "end_point": {
                    "row": 177,
                    "column": 5
                }
            },
            {
                "definition": "public List<Consumer> findByAppandService(String app, String serviceName) {\n    return SyncUtils.url2ConsumerList(findConsumerUrlByAppandService(app, serviceName));\n}",
                "name": "findByAppandService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "app"
                    },
                    {
                        "type": "String",
                        "name": "serviceName"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ConsumerList(findConsumerUrlByAppandService(app, serviceName));\n}",
                "start_point": {
                    "row": 179,
                    "column": 4
                },
                "end_point": {
                    "row": 181,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findConsumerUrlByAppandService(String application, String service) {\n    Map<String, String> filter = new HashMap<>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, application);\n    filter.put(Constants.SERVICE_FILTER_KEY, service);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findConsumerUrlByAppandService",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    },
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, application);\n    filter.put(Constants.SERVICE_FILTER_KEY, service);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 183,
                    "column": 4
                },
                "end_point": {
                    "row": 190,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findConsumerUrlByApplication(String application) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, application);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findConsumerUrlByApplication",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, application);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 192,
                    "column": 4
                },
                "end_point": {
                    "row": 198,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findServicesByApplication(String application) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null || application == null || application.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "name": "findServicesByApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls == null || application == null || application.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : consumerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 200,
                    "column": 4
                },
                "end_point": {
                    "row": 217,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findServices() {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls != null) ret.addAll(consumerUrls.keySet());\n    return ret;\n}",
                "name": "findServices",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> consumerUrls = getRegistryCache().get(Constants.CONSUMERS_CATEGORY);\n    if (consumerUrls != null) ret.addAll(consumerUrls.keySet());\n    return ret;\n}",
                "start_point": {
                    "row": 219,
                    "column": 4
                },
                "end_point": {
                    "row": 224,
                    "column": 5
                }
            },
            {
                "definition": "public Map<String, URL> findConsumerUrlByService(String service) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findConsumerUrlByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY);\n    filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 226,
                    "column": 4
                },
                "end_point": {
                    "row": 232,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/impl/OverrideServiceImpl.java",
        "definition": "@Component\npublic class OverrideServiceImpl extends AbstractService implements OverrideService {\n\n    public void saveOverride(Override override) {\n        URL url = getUrlFromOverride(override);\n        registryService.register(url);\n    }\n\n    public void updateOverride(Override override) {\n        String hash = override.getHash();\n        if (hash == null) {\n            throw new IllegalStateException(\"no override id\");\n        }\n        URL oldOverride = findOverrideUrl(hash);\n        if (oldOverride == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        URL newOverride = getUrlFromOverride(override);\n\n        registryService.unregister(oldOverride);\n        registryService.register(newOverride);\n\n    }\n\n    public void deleteOverride(String id) {\n        URL oldOverride = findOverrideUrl(id);\n        if (oldOverride == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        registryService.unregister(oldOverride);\n    }\n\n    public void enableOverride(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no override id\");\n        }\n\n        URL oldOverride = findOverrideUrl(id);\n        if (oldOverride == null) {\n            throw new IllegalStateException(\"Override was changed!\");\n        }\n        if (oldOverride.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        URL newOverride = oldOverride.addParameter(\"enabled\", true);\n        registryService.unregister(oldOverride);\n        registryService.register(newOverride);\n\n    }\n\n    public void disableOverride(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no override id\");\n        }\n\n        URL oldProvider = findOverrideUrl(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Override was changed!\");\n        }\n        if (!oldProvider.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        URL newProvider = oldProvider.addParameter(\"enabled\", false);\n        registryService.unregister(oldProvider);\n        registryService.register(newProvider);\n\n    }\n\n    private Map<String, URL> findOverrideUrl(String service, String address, String application) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n        if (service != null && service.length() > 0) {\n            filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n        }\n        if (address != null && address.length() > 0) {\n            filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n        }\n        if (application != null && application.length() > 0) {\n            filter.put(Constants.APPLICATION_KEY, application);\n        }\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Override> findByAddress(String address) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(null, address, null));\n    }\n\n    public List<Override> findByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(service, address, null));\n    }\n\n    public List<Override> findByApplication(String application) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(null, null, application));\n    }\n\n    public List<Override> findByService(String service) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(service, null, null));\n    }\n\n    public List<Override> findByServiceAndApplication(String service, String application) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(service, null, application));\n    }\n\n    public List<Override> findAll() {\n        return SyncUtils.url2OverrideList(findOverrideUrl(null, null, null));\n    }\n\n    private Pair<String, URL> findOverrideUrlPair(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONFIGURATORS_CATEGORY, id);\n    }\n\n    public Override findById(String id) {\n        return SyncUtils.url2Override(findOverrideUrlPair(id));\n    }\n\n    private URL getUrlFromOverride(Override override) {\n        return override.toUrl();\n        /*Map<String, String> params = ConvertUtil.serviceName2Map(override.getService());\n        if(!params.containsKey(Constants.INTERFACE_KEY)) {\n            throw new IllegalArgumentException(\"No interface info\");\n        }\n        if(!params.containsKey(Constants.VERSION_KEY)) {\n            throw new IllegalArgumentException(\"No version info\");\n        }\n        \n        boolean enabled = override.isEnabled();\n        if(!enabled) {\n            params.put(\"enabled\", \"false\");\n        }\n        String application = override.getApplication();\n        if(!StringUtils.isEmpty(application)) {\n            params.put(\"application\", application);\n        }\n        String address = override.getAddress();\n        if(!StringUtils.isEmpty(address)) {\n            params.put(\"address\", address);\n        }\n        \n        String overrideAddress = override.getOverrideAddress();\n        if(StringUtils.isEmpty(overrideAddress)) {\n            overrideAddress = \"0.0.0.0\";\n        }\n        params.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n        \n        URL url = new URL(\"override\", overrideAddress, -1, params);\n        url = url.addParameterString(override.getParams());\n        return url;*/\n    }\n\n    URL findOverrideUrl(String id) {\n        return getUrlFromOverride(findById(id));\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.service.impl;",
        "tree_path": "OverrideServiceImpl",
        "name": "OverrideServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": "extends AbstractService",
        "super_interfaces": "implements OverrideService",
        "body": "{\n\n    public void saveOverride(Override override) {\n        URL url = getUrlFromOverride(override);\n        registryService.register(url);\n    }\n\n    public void updateOverride(Override override) {\n        String hash = override.getHash();\n        if (hash == null) {\n            throw new IllegalStateException(\"no override id\");\n        }\n        URL oldOverride = findOverrideUrl(hash);\n        if (oldOverride == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        URL newOverride = getUrlFromOverride(override);\n\n        registryService.unregister(oldOverride);\n        registryService.register(newOverride);\n\n    }\n\n    public void deleteOverride(String id) {\n        URL oldOverride = findOverrideUrl(id);\n        if (oldOverride == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        registryService.unregister(oldOverride);\n    }\n\n    public void enableOverride(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no override id\");\n        }\n\n        URL oldOverride = findOverrideUrl(id);\n        if (oldOverride == null) {\n            throw new IllegalStateException(\"Override was changed!\");\n        }\n        if (oldOverride.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        URL newOverride = oldOverride.addParameter(\"enabled\", true);\n        registryService.unregister(oldOverride);\n        registryService.register(newOverride);\n\n    }\n\n    public void disableOverride(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no override id\");\n        }\n\n        URL oldProvider = findOverrideUrl(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Override was changed!\");\n        }\n        if (!oldProvider.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        URL newProvider = oldProvider.addParameter(\"enabled\", false);\n        registryService.unregister(oldProvider);\n        registryService.register(newProvider);\n\n    }\n\n    private Map<String, URL> findOverrideUrl(String service, String address, String application) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n        if (service != null && service.length() > 0) {\n            filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n        }\n        if (address != null && address.length() > 0) {\n            filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n        }\n        if (application != null && application.length() > 0) {\n            filter.put(Constants.APPLICATION_KEY, application);\n        }\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Override> findByAddress(String address) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(null, address, null));\n    }\n\n    public List<Override> findByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(service, address, null));\n    }\n\n    public List<Override> findByApplication(String application) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(null, null, application));\n    }\n\n    public List<Override> findByService(String service) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(service, null, null));\n    }\n\n    public List<Override> findByServiceAndApplication(String service, String application) {\n        return SyncUtils.url2OverrideList(findOverrideUrl(service, null, application));\n    }\n\n    public List<Override> findAll() {\n        return SyncUtils.url2OverrideList(findOverrideUrl(null, null, null));\n    }\n\n    private Pair<String, URL> findOverrideUrlPair(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONFIGURATORS_CATEGORY, id);\n    }\n\n    public Override findById(String id) {\n        return SyncUtils.url2Override(findOverrideUrlPair(id));\n    }\n\n    private URL getUrlFromOverride(Override override) {\n        return override.toUrl();\n        /*Map<String, String> params = ConvertUtil.serviceName2Map(override.getService());\n        if(!params.containsKey(Constants.INTERFACE_KEY)) {\n            throw new IllegalArgumentException(\"No interface info\");\n        }\n        if(!params.containsKey(Constants.VERSION_KEY)) {\n            throw new IllegalArgumentException(\"No version info\");\n        }\n        \n        boolean enabled = override.isEnabled();\n        if(!enabled) {\n            params.put(\"enabled\", \"false\");\n        }\n        String application = override.getApplication();\n        if(!StringUtils.isEmpty(application)) {\n            params.put(\"application\", application);\n        }\n        String address = override.getAddress();\n        if(!StringUtils.isEmpty(address)) {\n            params.put(\"address\", address);\n        }\n        \n        String overrideAddress = override.getOverrideAddress();\n        if(StringUtils.isEmpty(overrideAddress)) {\n            overrideAddress = \"0.0.0.0\";\n        }\n        params.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n        \n        URL url = new URL(\"override\", overrideAddress, -1, params);\n        url = url.addParameterString(override.getParams());\n        return url;*/\n    }\n\n    URL findOverrideUrl(String id) {\n        return getUrlFromOverride(findById(id));\n    }\n\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 189,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public void saveOverride(Override override) {\n    URL url = getUrlFromOverride(override);\n    registryService.register(url);\n}",
                "name": "saveOverride",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    }
                ],
                "body": "{\n    URL url = getUrlFromOverride(override);\n    registryService.register(url);\n}",
                "start_point": {
                    "row": 37,
                    "column": 4
                },
                "end_point": {
                    "row": 40,
                    "column": 5
                }
            },
            {
                "definition": "public void updateOverride(Override override) {\n    String hash = override.getHash();\n    if (hash == null) {\n        throw new IllegalStateException(\"no override id\");\n    }\n    URL oldOverride = findOverrideUrl(hash);\n    if (oldOverride == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    URL newOverride = getUrlFromOverride(override);\n\n    registryService.unregister(oldOverride);\n    registryService.register(newOverride);\n\n}",
                "name": "updateOverride",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    }
                ],
                "body": "{\n    String hash = override.getHash();\n    if (hash == null) {\n        throw new IllegalStateException(\"no override id\");\n    }\n    URL oldOverride = findOverrideUrl(hash);\n    if (oldOverride == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    URL newOverride = getUrlFromOverride(override);\n\n    registryService.unregister(oldOverride);\n    registryService.register(newOverride);\n\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "public void deleteOverride(String id) {\n    URL oldOverride = findOverrideUrl(id);\n    if (oldOverride == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    registryService.unregister(oldOverride);\n}",
                "name": "deleteOverride",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    URL oldOverride = findOverrideUrl(id);\n    if (oldOverride == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    registryService.unregister(oldOverride);\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            },
            {
                "definition": "public void enableOverride(String id) {\n    if (id == null) {\n        throw new IllegalStateException(\"no override id\");\n    }\n\n    URL oldOverride = findOverrideUrl(id);\n    if (oldOverride == null) {\n        throw new IllegalStateException(\"Override was changed!\");\n    }\n    if (oldOverride.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    URL newOverride = oldOverride.addParameter(\"enabled\", true);\n    registryService.unregister(oldOverride);\n    registryService.register(newOverride);\n\n}",
                "name": "enableOverride",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    if (id == null) {\n        throw new IllegalStateException(\"no override id\");\n    }\n\n    URL oldOverride = findOverrideUrl(id);\n    if (oldOverride == null) {\n        throw new IllegalStateException(\"Override was changed!\");\n    }\n    if (oldOverride.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    URL newOverride = oldOverride.addParameter(\"enabled\", true);\n    registryService.unregister(oldOverride);\n    registryService.register(newOverride);\n\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 83,
                    "column": 5
                }
            },
            {
                "definition": "public void disableOverride(String id) {\n    if (id == null) {\n        throw new IllegalStateException(\"no override id\");\n    }\n\n    URL oldProvider = findOverrideUrl(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Override was changed!\");\n    }\n    if (!oldProvider.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    URL newProvider = oldProvider.addParameter(\"enabled\", false);\n    registryService.unregister(oldProvider);\n    registryService.register(newProvider);\n\n}",
                "name": "disableOverride",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    if (id == null) {\n        throw new IllegalStateException(\"no override id\");\n    }\n\n    URL oldProvider = findOverrideUrl(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Override was changed!\");\n    }\n    if (!oldProvider.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    URL newProvider = oldProvider.addParameter(\"enabled\", false);\n    registryService.unregister(oldProvider);\n    registryService.register(newProvider);\n\n}",
                "start_point": {
                    "row": 85,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findOverrideUrl(String service, String address, String application) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n    if (service != null && service.length() > 0) {\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n    }\n    if (address != null && address.length() > 0) {\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n    }\n    if (application != null && application.length() > 0) {\n        filter.put(Constants.APPLICATION_KEY, application);\n    }\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findOverrideUrl",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    },
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n    if (service != null && service.length() > 0) {\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n    }\n    if (address != null && address.length() > 0) {\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n    }\n    if (application != null && application.length() > 0) {\n        filter.put(Constants.APPLICATION_KEY, application);\n    }\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 117,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> findByAddress(String address) {\n    return SyncUtils.url2OverrideList(findOverrideUrl(null, address, null));\n}",
                "name": "findByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    return SyncUtils.url2OverrideList(findOverrideUrl(null, address, null));\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 121,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> findByServiceAndAddress(String service, String address) {\n    return SyncUtils.url2OverrideList(findOverrideUrl(service, address, null));\n}",
                "name": "findByServiceAndAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    return SyncUtils.url2OverrideList(findOverrideUrl(service, address, null));\n}",
                "start_point": {
                    "row": 123,
                    "column": 4
                },
                "end_point": {
                    "row": 125,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> findByApplication(String application) {\n    return SyncUtils.url2OverrideList(findOverrideUrl(null, null, application));\n}",
                "name": "findByApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    return SyncUtils.url2OverrideList(findOverrideUrl(null, null, application));\n}",
                "start_point": {
                    "row": 127,
                    "column": 4
                },
                "end_point": {
                    "row": 129,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> findByService(String service) {\n    return SyncUtils.url2OverrideList(findOverrideUrl(service, null, null));\n}",
                "name": "findByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    return SyncUtils.url2OverrideList(findOverrideUrl(service, null, null));\n}",
                "start_point": {
                    "row": 131,
                    "column": 4
                },
                "end_point": {
                    "row": 133,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> findByServiceAndApplication(String service, String application) {\n    return SyncUtils.url2OverrideList(findOverrideUrl(service, null, application));\n}",
                "name": "findByServiceAndApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    return SyncUtils.url2OverrideList(findOverrideUrl(service, null, application));\n}",
                "start_point": {
                    "row": 135,
                    "column": 4
                },
                "end_point": {
                    "row": 137,
                    "column": 5
                }
            },
            {
                "definition": "public List<Override> findAll() {\n    return SyncUtils.url2OverrideList(findOverrideUrl(null, null, null));\n}",
                "name": "findAll",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return SyncUtils.url2OverrideList(findOverrideUrl(null, null, null));\n}",
                "start_point": {
                    "row": 139,
                    "column": 4
                },
                "end_point": {
                    "row": 141,
                    "column": 5
                }
            },
            {
                "definition": "private Pair<String, URL> findOverrideUrlPair(String id) {\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONFIGURATORS_CATEGORY, id);\n}",
                "name": "findOverrideUrlPair",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.CONFIGURATORS_CATEGORY, id);\n}",
                "start_point": {
                    "row": 143,
                    "column": 4
                },
                "end_point": {
                    "row": 145,
                    "column": 5
                }
            },
            {
                "definition": "public Override findById(String id) {\n    return SyncUtils.url2Override(findOverrideUrlPair(id));\n}",
                "name": "findById",
                "modifiers": "public",
                "return_type": "Override",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.url2Override(findOverrideUrlPair(id));\n}",
                "start_point": {
                    "row": 147,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            },
            {
                "definition": "private URL getUrlFromOverride(Override override) {\n    return override.toUrl();\n    /*Map<String, String> params = ConvertUtil.serviceName2Map(override.getService());\n    if(!params.containsKey(Constants.INTERFACE_KEY)) {\n        throw new IllegalArgumentException(\"No interface info\");\n    }\n    if(!params.containsKey(Constants.VERSION_KEY)) {\n        throw new IllegalArgumentException(\"No version info\");\n    }\n    \n    boolean enabled = override.isEnabled();\n    if(!enabled) {\n        params.put(\"enabled\", \"false\");\n    }\n    String application = override.getApplication();\n    if(!StringUtils.isEmpty(application)) {\n        params.put(\"application\", application);\n    }\n    String address = override.getAddress();\n    if(!StringUtils.isEmpty(address)) {\n        params.put(\"address\", address);\n    }\n    \n    String overrideAddress = override.getOverrideAddress();\n    if(StringUtils.isEmpty(overrideAddress)) {\n        overrideAddress = \"0.0.0.0\";\n    }\n    params.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n    \n    URL url = new URL(\"override\", overrideAddress, -1, params);\n    url = url.addParameterString(override.getParams());\n    return url;*/\n}",
                "name": "getUrlFromOverride",
                "modifiers": "private",
                "return_type": "URL",
                "parameters": [
                    {
                        "type": "Override",
                        "name": "override"
                    }
                ],
                "body": "{\n    return override.toUrl();\n    /*Map<String, String> params = ConvertUtil.serviceName2Map(override.getService());\n    if(!params.containsKey(Constants.INTERFACE_KEY)) {\n        throw new IllegalArgumentException(\"No interface info\");\n    }\n    if(!params.containsKey(Constants.VERSION_KEY)) {\n        throw new IllegalArgumentException(\"No version info\");\n    }\n    \n    boolean enabled = override.isEnabled();\n    if(!enabled) {\n        params.put(\"enabled\", \"false\");\n    }\n    String application = override.getApplication();\n    if(!StringUtils.isEmpty(application)) {\n        params.put(\"application\", application);\n    }\n    String address = override.getAddress();\n    if(!StringUtils.isEmpty(address)) {\n        params.put(\"address\", address);\n    }\n    \n    String overrideAddress = override.getOverrideAddress();\n    if(StringUtils.isEmpty(overrideAddress)) {\n        overrideAddress = \"0.0.0.0\";\n    }\n    params.put(Constants.CATEGORY_KEY, Constants.CONFIGURATORS_CATEGORY);\n    \n    URL url = new URL(\"override\", overrideAddress, -1, params);\n    url = url.addParameterString(override.getParams());\n    return url;*/\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 183,
                    "column": 5
                }
            },
            {
                "definition": "URL findOverrideUrl(String id) {\n    return getUrlFromOverride(findById(id));\n}",
                "name": "findOverrideUrl",
                "modifiers": null,
                "return_type": "URL",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return getUrlFromOverride(findById(id));\n}",
                "start_point": {
                    "row": 185,
                    "column": 4
                },
                "end_point": {
                    "row": 187,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/impl/OwnerServiceImpl.java",
        "definition": "@Component\npublic class OwnerServiceImpl extends AbstractService implements OwnerService {\n\n    @Autowired\n    ProviderService providerService;\n\n    @Autowired\n    OverrideService overrideService;\n\n    public List<String> findAllServiceNames() {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public List<String> findServiceNamesByUsername(String username) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public List<String> findUsernamesByServiceName(String serviceName) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public List<Owner> findByService(String serviceName) {\n        List<Provider> pList = providerService.findByService(serviceName);\n        List<Override> cList = overrideService.findByServiceAndAddress(serviceName, Constants.ANYHOST_VALUE);\n        return toOverrideLiset(pList, cList);\n    }\n\n    public List<Owner> findAll() {\n        List<Provider> pList = providerService.findAll();\n        List<Override> cList = overrideService.findAll();\n        return toOverrideLiset(pList, cList);\n    }\n\n    public Owner findById(String id) {\n\n        return null;\n    }\n\n    private List<Owner> toOverrideLiset(List<Provider> pList, List<Override> cList) {\n        Map<String, Owner> oList = new HashMap<String, Owner>();\n        for (Provider p : pList) {\n            if (p.getUsername() != null) {\n                for (String username : Constants.COMMA_SPLIT_PATTERN.split(p.getUsername())) {\n                    Owner o = new Owner();\n                    o.setService(p.getService());\n                    o.setUsername(username);\n                    oList.put(o.getService() + \"/\" + o.getUsername(), o);\n                }\n            }\n        }\n        for (Override c : cList) {\n            Map<String, String> params = StringUtils.parseQueryString(c.getParams());\n            String usernames = params.get(\"owner\");\n            if (usernames != null && usernames.length() > 0) {\n                for (String username : Constants.COMMA_SPLIT_PATTERN.split(usernames)) {\n                    Owner o = new Owner();\n                    o.setService(c.getService());\n                    o.setUsername(username);\n                    oList.put(o.getService() + \"/\" + o.getUsername(), o);\n                }\n            }\n        }\n        return new ArrayList<Owner>(oList.values());\n    }\n\n    public void saveOwner(Owner owner) {\n        List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n        if (overrides == null || overrides.size() == 0) {\n            Override override = new Override();\n            override.setAddress(Constants.ANYHOST_VALUE);\n            override.setService(owner.getService());\n            override.setEnabled(true);\n            override.setParams(\"owner=\" + owner.getUsername());\n            overrideService.saveOverride(override);\n        } else {\n            for (Override override : overrides) {\n                Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                String usernames = params.get(\"owner\");\n                if (usernames == null || usernames.length() == 0) {\n                    usernames = owner.getUsername();\n                } else {\n                    usernames = usernames + \",\" + owner.getUsername();\n                }\n                params.put(\"owner\", usernames);\n                override.setParams(StringUtils.toQueryString(params));\n                overrideService.updateOverride(override);\n            }\n        }\n    }\n\n    public void deleteOwner(Owner owner) {\n        List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n        if (overrides == null || overrides.size() == 0) {\n            Override override = new Override();\n            override.setAddress(Constants.ANYHOST_VALUE);\n            override.setService(owner.getService());\n            override.setEnabled(true);\n            override.setParams(\"owner=\" + owner.getUsername());\n            overrideService.saveOverride(override);\n        } else {\n            for (Override override : overrides) {\n                Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                String usernames = params.get(\"owner\");\n                if (usernames != null && usernames.length() > 0) {\n                    if (usernames.equals(owner.getUsername())) {\n                        params.remove(\"owner\");\n                    } else {\n                        usernames = usernames.replace(owner.getUsername() + \",\", \"\").replace(\",\" + owner.getUsername(), \"\");\n                        params.put(\"owner\", usernames);\n                    }\n                    if (params.size() > 0) {\n                        override.setParams(StringUtils.toQueryString(params));\n                        overrideService.updateOverride(override);\n                    } else {\n                        overrideService.deleteOverride(override.getHash());\n                    }\n                }\n            }\n        }\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.service.impl;",
        "tree_path": "OwnerServiceImpl",
        "name": "OwnerServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": "extends AbstractService",
        "super_interfaces": "implements OwnerService",
        "body": "{\n\n    @Autowired\n    ProviderService providerService;\n\n    @Autowired\n    OverrideService overrideService;\n\n    public List<String> findAllServiceNames() {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public List<String> findServiceNamesByUsername(String username) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public List<String> findUsernamesByServiceName(String serviceName) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public List<Owner> findByService(String serviceName) {\n        List<Provider> pList = providerService.findByService(serviceName);\n        List<Override> cList = overrideService.findByServiceAndAddress(serviceName, Constants.ANYHOST_VALUE);\n        return toOverrideLiset(pList, cList);\n    }\n\n    public List<Owner> findAll() {\n        List<Provider> pList = providerService.findAll();\n        List<Override> cList = overrideService.findAll();\n        return toOverrideLiset(pList, cList);\n    }\n\n    public Owner findById(String id) {\n\n        return null;\n    }\n\n    private List<Owner> toOverrideLiset(List<Provider> pList, List<Override> cList) {\n        Map<String, Owner> oList = new HashMap<String, Owner>();\n        for (Provider p : pList) {\n            if (p.getUsername() != null) {\n                for (String username : Constants.COMMA_SPLIT_PATTERN.split(p.getUsername())) {\n                    Owner o = new Owner();\n                    o.setService(p.getService());\n                    o.setUsername(username);\n                    oList.put(o.getService() + \"/\" + o.getUsername(), o);\n                }\n            }\n        }\n        for (Override c : cList) {\n            Map<String, String> params = StringUtils.parseQueryString(c.getParams());\n            String usernames = params.get(\"owner\");\n            if (usernames != null && usernames.length() > 0) {\n                for (String username : Constants.COMMA_SPLIT_PATTERN.split(usernames)) {\n                    Owner o = new Owner();\n                    o.setService(c.getService());\n                    o.setUsername(username);\n                    oList.put(o.getService() + \"/\" + o.getUsername(), o);\n                }\n            }\n        }\n        return new ArrayList<Owner>(oList.values());\n    }\n\n    public void saveOwner(Owner owner) {\n        List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n        if (overrides == null || overrides.size() == 0) {\n            Override override = new Override();\n            override.setAddress(Constants.ANYHOST_VALUE);\n            override.setService(owner.getService());\n            override.setEnabled(true);\n            override.setParams(\"owner=\" + owner.getUsername());\n            overrideService.saveOverride(override);\n        } else {\n            for (Override override : overrides) {\n                Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                String usernames = params.get(\"owner\");\n                if (usernames == null || usernames.length() == 0) {\n                    usernames = owner.getUsername();\n                } else {\n                    usernames = usernames + \",\" + owner.getUsername();\n                }\n                params.put(\"owner\", usernames);\n                override.setParams(StringUtils.toQueryString(params));\n                overrideService.updateOverride(override);\n            }\n        }\n    }\n\n    public void deleteOwner(Owner owner) {\n        List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n        if (overrides == null || overrides.size() == 0) {\n            Override override = new Override();\n            override.setAddress(Constants.ANYHOST_VALUE);\n            override.setService(owner.getService());\n            override.setEnabled(true);\n            override.setParams(\"owner=\" + owner.getUsername());\n            overrideService.saveOverride(override);\n        } else {\n            for (Override override : overrides) {\n                Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                String usernames = params.get(\"owner\");\n                if (usernames != null && usernames.length() > 0) {\n                    if (usernames.equals(owner.getUsername())) {\n                        params.remove(\"owner\");\n                    } else {\n                        usernames = usernames.replace(owner.getUsername() + \",\", \"\").replace(\",\" + owner.getUsername(), \"\");\n                        params.put(\"owner\", usernames);\n                    }\n                    if (params.size() > 0) {\n                        override.setParams(StringUtils.toQueryString(params));\n                        overrideService.updateOverride(override);\n                    } else {\n                        overrideService.deleteOverride(override.getHash());\n                    }\n                }\n            }\n        }\n    }\n\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 158,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public List<String> findAllServiceNames() {\n    // TODO Auto-generated method stub\n    return null;\n}",
                "name": "findAllServiceNames",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // TODO Auto-generated method stub\n    return null;\n}",
                "start_point": {
                    "row": 43,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findServiceNamesByUsername(String username) {\n    // TODO Auto-generated method stub\n    return null;\n}",
                "name": "findServiceNamesByUsername",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    // TODO Auto-generated method stub\n    return null;\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findUsernamesByServiceName(String serviceName) {\n    // TODO Auto-generated method stub\n    return null;\n}",
                "name": "findUsernamesByServiceName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "serviceName"
                    }
                ],
                "body": "{\n    // TODO Auto-generated method stub\n    return null;\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "public List<Owner> findByService(String serviceName) {\n    List<Provider> pList = providerService.findByService(serviceName);\n    List<Override> cList = overrideService.findByServiceAndAddress(serviceName, Constants.ANYHOST_VALUE);\n    return toOverrideLiset(pList, cList);\n}",
                "name": "findByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "serviceName"
                    }
                ],
                "body": "{\n    List<Provider> pList = providerService.findByService(serviceName);\n    List<Override> cList = overrideService.findByServiceAndAddress(serviceName, Constants.ANYHOST_VALUE);\n    return toOverrideLiset(pList, cList);\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 62,
                    "column": 5
                }
            },
            {
                "definition": "public List<Owner> findAll() {\n    List<Provider> pList = providerService.findAll();\n    List<Override> cList = overrideService.findAll();\n    return toOverrideLiset(pList, cList);\n}",
                "name": "findAll",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    List<Provider> pList = providerService.findAll();\n    List<Override> cList = overrideService.findAll();\n    return toOverrideLiset(pList, cList);\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "public Owner findById(String id) {\n\n    return null;\n}",
                "name": "findById",
                "modifiers": "public",
                "return_type": "Owner",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n\n    return null;\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "private List<Owner> toOverrideLiset(List<Provider> pList, List<Override> cList) {\n    Map<String, Owner> oList = new HashMap<String, Owner>();\n    for (Provider p : pList) {\n        if (p.getUsername() != null) {\n            for (String username : Constants.COMMA_SPLIT_PATTERN.split(p.getUsername())) {\n                Owner o = new Owner();\n                o.setService(p.getService());\n                o.setUsername(username);\n                oList.put(o.getService() + \"/\" + o.getUsername(), o);\n            }\n        }\n    }\n    for (Override c : cList) {\n        Map<String, String> params = StringUtils.parseQueryString(c.getParams());\n        String usernames = params.get(\"owner\");\n        if (usernames != null && usernames.length() > 0) {\n            for (String username : Constants.COMMA_SPLIT_PATTERN.split(usernames)) {\n                Owner o = new Owner();\n                o.setService(c.getService());\n                o.setUsername(username);\n                oList.put(o.getService() + \"/\" + o.getUsername(), o);\n            }\n        }\n    }\n    return new ArrayList<Owner>(oList.values());\n}",
                "name": "toOverrideLiset",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Provider>",
                        "name": "pList"
                    },
                    {
                        "type": "List<Override>",
                        "name": "cList"
                    }
                ],
                "body": "{\n    Map<String, Owner> oList = new HashMap<String, Owner>();\n    for (Provider p : pList) {\n        if (p.getUsername() != null) {\n            for (String username : Constants.COMMA_SPLIT_PATTERN.split(p.getUsername())) {\n                Owner o = new Owner();\n                o.setService(p.getService());\n                o.setUsername(username);\n                oList.put(o.getService() + \"/\" + o.getUsername(), o);\n            }\n        }\n    }\n    for (Override c : cList) {\n        Map<String, String> params = StringUtils.parseQueryString(c.getParams());\n        String usernames = params.get(\"owner\");\n        if (usernames != null && usernames.length() > 0) {\n            for (String username : Constants.COMMA_SPLIT_PATTERN.split(usernames)) {\n                Owner o = new Owner();\n                o.setService(c.getService());\n                o.setUsername(username);\n                oList.put(o.getService() + \"/\" + o.getUsername(), o);\n            }\n        }\n    }\n    return new ArrayList<Owner>(oList.values());\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 100,
                    "column": 5
                }
            },
            {
                "definition": "public void saveOwner(Owner owner) {\n    List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n    if (overrides == null || overrides.size() == 0) {\n        Override override = new Override();\n        override.setAddress(Constants.ANYHOST_VALUE);\n        override.setService(owner.getService());\n        override.setEnabled(true);\n        override.setParams(\"owner=\" + owner.getUsername());\n        overrideService.saveOverride(override);\n    } else {\n        for (Override override : overrides) {\n            Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n            String usernames = params.get(\"owner\");\n            if (usernames == null || usernames.length() == 0) {\n                usernames = owner.getUsername();\n            } else {\n                usernames = usernames + \",\" + owner.getUsername();\n            }\n            params.put(\"owner\", usernames);\n            override.setParams(StringUtils.toQueryString(params));\n            overrideService.updateOverride(override);\n        }\n    }\n}",
                "name": "saveOwner",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Owner",
                        "name": "owner"
                    }
                ],
                "body": "{\n    List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n    if (overrides == null || overrides.size() == 0) {\n        Override override = new Override();\n        override.setAddress(Constants.ANYHOST_VALUE);\n        override.setService(owner.getService());\n        override.setEnabled(true);\n        override.setParams(\"owner=\" + owner.getUsername());\n        overrideService.saveOverride(override);\n    } else {\n        for (Override override : overrides) {\n            Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n            String usernames = params.get(\"owner\");\n            if (usernames == null || usernames.length() == 0) {\n                usernames = owner.getUsername();\n            } else {\n                usernames = usernames + \",\" + owner.getUsername();\n            }\n            params.put(\"owner\", usernames);\n            override.setParams(StringUtils.toQueryString(params));\n            overrideService.updateOverride(override);\n        }\n    }\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 125,
                    "column": 5
                }
            },
            {
                "definition": "public void deleteOwner(Owner owner) {\n    List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n    if (overrides == null || overrides.size() == 0) {\n        Override override = new Override();\n        override.setAddress(Constants.ANYHOST_VALUE);\n        override.setService(owner.getService());\n        override.setEnabled(true);\n        override.setParams(\"owner=\" + owner.getUsername());\n        overrideService.saveOverride(override);\n    } else {\n        for (Override override : overrides) {\n            Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n            String usernames = params.get(\"owner\");\n            if (usernames != null && usernames.length() > 0) {\n                if (usernames.equals(owner.getUsername())) {\n                    params.remove(\"owner\");\n                } else {\n                    usernames = usernames.replace(owner.getUsername() + \",\", \"\").replace(\",\" + owner.getUsername(), \"\");\n                    params.put(\"owner\", usernames);\n                }\n                if (params.size() > 0) {\n                    override.setParams(StringUtils.toQueryString(params));\n                    overrideService.updateOverride(override);\n                } else {\n                    overrideService.deleteOverride(override.getHash());\n                }\n            }\n        }\n    }\n}",
                "name": "deleteOwner",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Owner",
                        "name": "owner"
                    }
                ],
                "body": "{\n    List<Override> overrides = overrideService.findByServiceAndAddress(owner.getService(), Constants.ANYHOST_VALUE);\n    if (overrides == null || overrides.size() == 0) {\n        Override override = new Override();\n        override.setAddress(Constants.ANYHOST_VALUE);\n        override.setService(owner.getService());\n        override.setEnabled(true);\n        override.setParams(\"owner=\" + owner.getUsername());\n        overrideService.saveOverride(override);\n    } else {\n        for (Override override : overrides) {\n            Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n            String usernames = params.get(\"owner\");\n            if (usernames != null && usernames.length() > 0) {\n                if (usernames.equals(owner.getUsername())) {\n                    params.remove(\"owner\");\n                } else {\n                    usernames = usernames.replace(owner.getUsername() + \",\", \"\").replace(\",\" + owner.getUsername(), \"\");\n                    params.put(\"owner\", usernames);\n                }\n                if (params.size() > 0) {\n                    override.setParams(StringUtils.toQueryString(params));\n                    overrideService.updateOverride(override);\n                } else {\n                    overrideService.deleteOverride(override.getHash());\n                }\n            }\n        }\n    }\n}",
                "start_point": {
                    "row": 127,
                    "column": 4
                },
                "end_point": {
                    "row": 156,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/impl/ProviderServiceImpl.java",
        "definition": "@Component\npublic class ProviderServiceImpl extends AbstractService implements ProviderService {\n\n    @Autowired\n    OverrideService overrideService;\n\n    public void create(Provider provider) {\n        URL url = provider.toUrl();\n        registryService.register(url);\n    }\n\n    public void enableProvider(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n\n        Provider oldProvider = findProvider(id);\n\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        if (oldProvider.isDynamic()) {\n            // Make sure we only have one override configured disable property.\n            if (!oldProvider.isEnabled()) {\n                Override override = new Override();\n                override.setAddress(oldProvider.getAddress());\n                override.setService(oldProvider.getService());\n                override.setEnabled(true);\n                override.setParams(Constants.DISABLED_KEY + \"=false\");\n                overrideService.saveOverride(override);\n                return;\n            }\n            List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n            for (Override o : oList) {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                if (params.containsKey(Constants.DISABLED_KEY)) {\n                    if (params.get(Constants.DISABLED_KEY).equals(\"true\")) {\n                        overrideService.deleteOverride(o.getHash());\n                    }\n                }\n            }\n        } else {\n            oldProvider.setEnabled(true);\n            updateProvider(oldProvider);\n        }\n    }\n\n    public void disableProvider(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n\n        Provider oldProvider = findProvider(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n\n        if (oldProvider.isDynamic()) {\n            // Make sure we only have one override configured disable property.\n            if (oldProvider.isEnabled()) {\n                Override override = new Override();\n                override.setAddress(oldProvider.getAddress());\n                override.setService(oldProvider.getService());\n                override.setEnabled(true);\n                override.setParams(Constants.DISABLED_KEY + \"=true\");\n                overrideService.saveOverride(override);\n                return;\n            }\n            List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n            for (Override o : oList) {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                if (params.containsKey(Constants.DISABLED_KEY)) {\n                    if (params.get(Constants.DISABLED_KEY).equals(\"false\")) {\n                        overrideService.deleteOverride(o.getHash());\n                    }\n                }\n            }\n        } else {\n            oldProvider.setEnabled(false);\n            updateProvider(oldProvider);\n        }\n\n    }\n\n    public void doublingProvider(String id) {\n        setWeight(id, 2F);\n    }\n\n    public void halvingProvider(String id) {\n        setWeight(id, 0.5F);\n    }\n\n    public void setWeight(String id, float factor) {\n        if (id == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n        Provider oldProvider = findProvider(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        Map<String, String> map = StringUtils.parseQueryString(oldProvider.getParameters());\n        String weight = map.get(Constants.WEIGHT_KEY);\n        if (oldProvider.isDynamic()) {\n            // Make sure we only have one override configured disable property.\n            List<Override> overrides = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n            if (overrides == null || overrides.size() == 0) {\n                int value = getWeight(weight, factor);\n                if (value != Constants.DEFAULT_WEIGHT) {\n                    Override override = new Override();\n                    override.setAddress(oldProvider.getAddress());\n                    override.setService(oldProvider.getService());\n                    override.setEnabled(true);\n                    override.setParams(Constants.WEIGHT_KEY + \"=\" + String.valueOf(value));\n                    overrideService.saveOverride(override);\n                }\n            } else {\n                for (Override override : overrides) {\n                    Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                    String overrideWeight = params.get(Constants.WEIGHT_KEY);\n                    if (overrideWeight == null || overrideWeight.length() == 0) {\n                        overrideWeight = weight;\n                    }\n                    int value = getWeight(overrideWeight, factor);\n                    if (value == getWeight(weight, 1)) {\n                        params.remove(Constants.WEIGHT_KEY);\n                    } else {\n                        params.put(Constants.WEIGHT_KEY, String.valueOf(value));\n                    }\n                    if (params.size() > 0) {\n                        override.setParams(StringUtils.toQueryString(params));\n                        overrideService.updateOverride(override);\n                    } else {\n                        overrideService.deleteOverride(override.getHash());\n                    }\n                }\n            }\n        } else {\n            int value = getWeight(weight, factor);\n            if (value == Constants.DEFAULT_WEIGHT) {\n                map.remove(Constants.WEIGHT_KEY);\n            } else {\n                map.put(Constants.WEIGHT_KEY, String.valueOf(value));\n            }\n            oldProvider.setParameters(StringUtils.toQueryString(map));\n            updateProvider(oldProvider);\n        }\n    }\n\n    private int getWeight(String value, float factor) {\n        int weight = 100;\n        if (value != null && value.length() > 0) {\n            weight = Integer.parseInt(value);\n        }\n        weight = (int) (weight * factor);\n        if (weight < 1) weight = 1;\n        if (weight == 2) weight = 3;\n        if (weight == 24) weight = 25;\n        return weight;\n    }\n\n    public void deleteStaticProvider(String id) {\n        URL oldProvider = findProviderUrl(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        registryService.unregister(oldProvider);\n    }\n\n    public void updateProvider(Provider provider) {\n        String hash = provider.getHash();\n        if (hash == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n\n        URL oldProvider = findProviderUrl(hash);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        URL newProvider = provider.toUrl();\n\n        registryService.unregister(oldProvider);\n        registryService.register(newProvider);\n    }\n\n    public Provider findProvider(String id) {\n        return SyncUtils.url2Provider(findProviderUrlPair(id));\n    }\n\n    public Pair<String, URL> findProviderUrlPair(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.PROVIDERS_CATEGORY, id);\n    }\n\n    public List<String> findServices() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls != null) ret.addAll(providerUrls.keySet());\n        return ret;\n    }\n\n    public List<String> findAddresses() {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (null == providerUrls) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getAddress();\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    String addr = u.getAddress();\n                    if (addr != null) ret.add(addr);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByService(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (null == providerUrls) return ret;\n\n        for (Map.Entry<String, URL> e2 : providerUrls.get(service).entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<String> findApplicationsByServiceName(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (null == providerUrls) return ret;\n\n        Map<String, URL> value = providerUrls.get(service);\n        if (value == null) {\n            return ret;\n        }\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<Provider> findByService(String serviceName) {\n        return SyncUtils.url2ProviderList(findProviderUrlByService(serviceName));\n    }\n\n    public List<Provider> findByAppandService(String app, String serviceName) {\n        return SyncUtils.url2ProviderList(findProviderUrlByAppandService(app, serviceName));\n    }\n\n    private Map<String, URL> findProviderUrlByService(String service) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Provider> findAll() {\n        return SyncUtils.url2ProviderList(findAllProviderUrl());\n    }\n\n    private Map<String, URL> findAllProviderUrl() {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Provider> findByAddress(String providerAddress) {\n        return SyncUtils.url2ProviderList(findProviderUrlByAddress(providerAddress));\n    }\n\n    public Map<String, URL> findProviderUrlByAddress(String address) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findServicesByAddress(String address) {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null || address == null || address.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (address.equals(u.getAddress())) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findApplications() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getParameter(Constants.APPLICATION_KEY);\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<Provider> findByApplication(String application) {\n        return SyncUtils.url2ProviderList(findProviderUrlByApplication(application));\n    }\n\n    private Map<String, URL> findProviderUrlByAppandService(String app, String service) {\n        Map<String, String> filter = new HashMap<>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, app);\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n\n    private Map<String, URL> findProviderUrlByApplication(String application) {\n        Map<String, String> filter = new HashMap<>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, application);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findServicesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null || application == null || application.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findMethodsByService(String service) {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null || service == null || service.length() == 0) return ret;\n\n        Map<String, URL> providers = providerUrls.get(service);\n        if (null == providers || providers.isEmpty()) return ret;\n\n        Entry<String, URL> p = providers.entrySet().iterator().next();\n        String value = p.getValue().getParameter(\"methods\");\n        if (value == null || value.length() == 0) {\n            return ret;\n        }\n        String[] methods = value.split(ParseUtils.METHOD_SPLIT);\n        if (methods == null || methods.length == 0) {\n            return ret;\n        }\n\n        for (String m : methods) {\n            ret.add(m);\n        }\n        return ret;\n    }\n\n    private URL findProviderUrl(String id) {\n        return findProvider(id).toUrl();\n    }\n\n    public Provider findByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2Provider(findProviderUrl(service, address));\n    }\n\n    private Pair<String, URL> findProviderUrl(String service, String address) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n        Map<String, URL> ret = SyncUtils.filterFromCategory(getRegistryCache(), filter);\n        if (ret.isEmpty()) {\n            return null;\n        } else {\n            String key = ret.entrySet().iterator().next().getKey();\n            return new Pair<String, URL>(key, ret.get(key));\n        }\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.service.impl;",
        "tree_path": "ProviderServiceImpl",
        "name": "ProviderServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": "extends AbstractService",
        "super_interfaces": "implements ProviderService",
        "body": "{\n\n    @Autowired\n    OverrideService overrideService;\n\n    public void create(Provider provider) {\n        URL url = provider.toUrl();\n        registryService.register(url);\n    }\n\n    public void enableProvider(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n\n        Provider oldProvider = findProvider(id);\n\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        if (oldProvider.isDynamic()) {\n            // Make sure we only have one override configured disable property.\n            if (!oldProvider.isEnabled()) {\n                Override override = new Override();\n                override.setAddress(oldProvider.getAddress());\n                override.setService(oldProvider.getService());\n                override.setEnabled(true);\n                override.setParams(Constants.DISABLED_KEY + \"=false\");\n                overrideService.saveOverride(override);\n                return;\n            }\n            List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n            for (Override o : oList) {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                if (params.containsKey(Constants.DISABLED_KEY)) {\n                    if (params.get(Constants.DISABLED_KEY).equals(\"true\")) {\n                        overrideService.deleteOverride(o.getHash());\n                    }\n                }\n            }\n        } else {\n            oldProvider.setEnabled(true);\n            updateProvider(oldProvider);\n        }\n    }\n\n    public void disableProvider(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n\n        Provider oldProvider = findProvider(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n\n        if (oldProvider.isDynamic()) {\n            // Make sure we only have one override configured disable property.\n            if (oldProvider.isEnabled()) {\n                Override override = new Override();\n                override.setAddress(oldProvider.getAddress());\n                override.setService(oldProvider.getService());\n                override.setEnabled(true);\n                override.setParams(Constants.DISABLED_KEY + \"=true\");\n                overrideService.saveOverride(override);\n                return;\n            }\n            List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n            for (Override o : oList) {\n                Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n                if (params.containsKey(Constants.DISABLED_KEY)) {\n                    if (params.get(Constants.DISABLED_KEY).equals(\"false\")) {\n                        overrideService.deleteOverride(o.getHash());\n                    }\n                }\n            }\n        } else {\n            oldProvider.setEnabled(false);\n            updateProvider(oldProvider);\n        }\n\n    }\n\n    public void doublingProvider(String id) {\n        setWeight(id, 2F);\n    }\n\n    public void halvingProvider(String id) {\n        setWeight(id, 0.5F);\n    }\n\n    public void setWeight(String id, float factor) {\n        if (id == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n        Provider oldProvider = findProvider(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        Map<String, String> map = StringUtils.parseQueryString(oldProvider.getParameters());\n        String weight = map.get(Constants.WEIGHT_KEY);\n        if (oldProvider.isDynamic()) {\n            // Make sure we only have one override configured disable property.\n            List<Override> overrides = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n            if (overrides == null || overrides.size() == 0) {\n                int value = getWeight(weight, factor);\n                if (value != Constants.DEFAULT_WEIGHT) {\n                    Override override = new Override();\n                    override.setAddress(oldProvider.getAddress());\n                    override.setService(oldProvider.getService());\n                    override.setEnabled(true);\n                    override.setParams(Constants.WEIGHT_KEY + \"=\" + String.valueOf(value));\n                    overrideService.saveOverride(override);\n                }\n            } else {\n                for (Override override : overrides) {\n                    Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                    String overrideWeight = params.get(Constants.WEIGHT_KEY);\n                    if (overrideWeight == null || overrideWeight.length() == 0) {\n                        overrideWeight = weight;\n                    }\n                    int value = getWeight(overrideWeight, factor);\n                    if (value == getWeight(weight, 1)) {\n                        params.remove(Constants.WEIGHT_KEY);\n                    } else {\n                        params.put(Constants.WEIGHT_KEY, String.valueOf(value));\n                    }\n                    if (params.size() > 0) {\n                        override.setParams(StringUtils.toQueryString(params));\n                        overrideService.updateOverride(override);\n                    } else {\n                        overrideService.deleteOverride(override.getHash());\n                    }\n                }\n            }\n        } else {\n            int value = getWeight(weight, factor);\n            if (value == Constants.DEFAULT_WEIGHT) {\n                map.remove(Constants.WEIGHT_KEY);\n            } else {\n                map.put(Constants.WEIGHT_KEY, String.valueOf(value));\n            }\n            oldProvider.setParameters(StringUtils.toQueryString(map));\n            updateProvider(oldProvider);\n        }\n    }\n\n    private int getWeight(String value, float factor) {\n        int weight = 100;\n        if (value != null && value.length() > 0) {\n            weight = Integer.parseInt(value);\n        }\n        weight = (int) (weight * factor);\n        if (weight < 1) weight = 1;\n        if (weight == 2) weight = 3;\n        if (weight == 24) weight = 25;\n        return weight;\n    }\n\n    public void deleteStaticProvider(String id) {\n        URL oldProvider = findProviderUrl(id);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        registryService.unregister(oldProvider);\n    }\n\n    public void updateProvider(Provider provider) {\n        String hash = provider.getHash();\n        if (hash == null) {\n            throw new IllegalStateException(\"no provider id\");\n        }\n\n        URL oldProvider = findProviderUrl(hash);\n        if (oldProvider == null) {\n            throw new IllegalStateException(\"Provider was changed!\");\n        }\n        URL newProvider = provider.toUrl();\n\n        registryService.unregister(oldProvider);\n        registryService.register(newProvider);\n    }\n\n    public Provider findProvider(String id) {\n        return SyncUtils.url2Provider(findProviderUrlPair(id));\n    }\n\n    public Pair<String, URL> findProviderUrlPair(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.PROVIDERS_CATEGORY, id);\n    }\n\n    public List<String> findServices() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls != null) ret.addAll(providerUrls.keySet());\n        return ret;\n    }\n\n    public List<String> findAddresses() {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (null == providerUrls) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getAddress();\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    String addr = u.getAddress();\n                    if (addr != null) ret.add(addr);\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findAddressesByService(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (null == providerUrls) return ret;\n\n        for (Map.Entry<String, URL> e2 : providerUrls.get(service).entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<String> findApplicationsByServiceName(String service) {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (null == providerUrls) return ret;\n\n        Map<String, URL> value = providerUrls.get(service);\n        if (value == null) {\n            return ret;\n        }\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n\n        return ret;\n    }\n\n    public List<Provider> findByService(String serviceName) {\n        return SyncUtils.url2ProviderList(findProviderUrlByService(serviceName));\n    }\n\n    public List<Provider> findByAppandService(String app, String serviceName) {\n        return SyncUtils.url2ProviderList(findProviderUrlByAppandService(app, serviceName));\n    }\n\n    private Map<String, URL> findProviderUrlByService(String service) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Provider> findAll() {\n        return SyncUtils.url2ProviderList(findAllProviderUrl());\n    }\n\n    private Map<String, URL> findAllProviderUrl() {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Provider> findByAddress(String providerAddress) {\n        return SyncUtils.url2ProviderList(findProviderUrlByAddress(providerAddress));\n    }\n\n    public Map<String, URL> findProviderUrlByAddress(String address) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findServicesByAddress(String address) {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null || address == null || address.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (address.equals(u.getAddress())) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findApplications() {\n        List<String> ret = new ArrayList<String>();\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                String app = u.getParameter(Constants.APPLICATION_KEY);\n                if (app != null) ret.add(app);\n            }\n        }\n\n        return ret;\n    }\n\n    public List<Provider> findByApplication(String application) {\n        return SyncUtils.url2ProviderList(findProviderUrlByApplication(application));\n    }\n\n    private Map<String, URL> findProviderUrlByAppandService(String app, String service) {\n        Map<String, String> filter = new HashMap<>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, app);\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n\n    private Map<String, URL> findProviderUrlByApplication(String application) {\n        Map<String, String> filter = new HashMap<>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(Constants.APPLICATION_KEY, application);\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<String> findServicesByApplication(String application) {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null || application == null || application.length() == 0) return ret;\n\n        for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n            Map<String, URL> value = e1.getValue();\n            for (Map.Entry<String, URL> e2 : value.entrySet()) {\n                URL u = e2.getValue();\n                if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                    ret.add(e1.getKey());\n                    break;\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    public List<String> findMethodsByService(String service) {\n        List<String> ret = new ArrayList<String>();\n\n        ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n        if (providerUrls == null || service == null || service.length() == 0) return ret;\n\n        Map<String, URL> providers = providerUrls.get(service);\n        if (null == providers || providers.isEmpty()) return ret;\n\n        Entry<String, URL> p = providers.entrySet().iterator().next();\n        String value = p.getValue().getParameter(\"methods\");\n        if (value == null || value.length() == 0) {\n            return ret;\n        }\n        String[] methods = value.split(ParseUtils.METHOD_SPLIT);\n        if (methods == null || methods.length == 0) {\n            return ret;\n        }\n\n        for (String m : methods) {\n            ret.add(m);\n        }\n        return ret;\n    }\n\n    private URL findProviderUrl(String id) {\n        return findProvider(id).toUrl();\n    }\n\n    public Provider findByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2Provider(findProviderUrl(service, address));\n    }\n\n    private Pair<String, URL> findProviderUrl(String service, String address) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n        Map<String, URL> ret = SyncUtils.filterFromCategory(getRegistryCache(), filter);\n        if (ret.isEmpty()) {\n            return null;\n        } else {\n            String key = ret.entrySet().iterator().next().getKey();\n            return new Pair<String, URL>(key, ret.get(key));\n        }\n    }\n\n}",
        "start_point": {
            "row": 42,
            "column": 0
        },
        "end_point": {
            "row": 472,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public void create(Provider provider) {\n    URL url = provider.toUrl();\n    registryService.register(url);\n}",
                "name": "create",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Provider",
                        "name": "provider"
                    }
                ],
                "body": "{\n    URL url = provider.toUrl();\n    registryService.register(url);\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "public void enableProvider(String id) {\n    if (id == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n\n    Provider oldProvider = findProvider(id);\n\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    if (oldProvider.isDynamic()) {\n        // Make sure we only have one override configured disable property.\n        if (!oldProvider.isEnabled()) {\n            Override override = new Override();\n            override.setAddress(oldProvider.getAddress());\n            override.setService(oldProvider.getService());\n            override.setEnabled(true);\n            override.setParams(Constants.DISABLED_KEY + \"=false\");\n            overrideService.saveOverride(override);\n            return;\n        }\n        List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n        for (Override o : oList) {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            if (params.containsKey(Constants.DISABLED_KEY)) {\n                if (params.get(Constants.DISABLED_KEY).equals(\"true\")) {\n                    overrideService.deleteOverride(o.getHash());\n                }\n            }\n        }\n    } else {\n        oldProvider.setEnabled(true);\n        updateProvider(oldProvider);\n    }\n}",
                "name": "enableProvider",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    if (id == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n\n    Provider oldProvider = findProvider(id);\n\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    if (oldProvider.isDynamic()) {\n        // Make sure we only have one override configured disable property.\n        if (!oldProvider.isEnabled()) {\n            Override override = new Override();\n            override.setAddress(oldProvider.getAddress());\n            override.setService(oldProvider.getService());\n            override.setEnabled(true);\n            override.setParams(Constants.DISABLED_KEY + \"=false\");\n            overrideService.saveOverride(override);\n            return;\n        }\n        List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n        for (Override o : oList) {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            if (params.containsKey(Constants.DISABLED_KEY)) {\n                if (params.get(Constants.DISABLED_KEY).equals(\"true\")) {\n                    overrideService.deleteOverride(o.getHash());\n                }\n            }\n        }\n    } else {\n        oldProvider.setEnabled(true);\n        updateProvider(oldProvider);\n    }\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            },
            {
                "definition": "public void disableProvider(String id) {\n    if (id == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n\n    Provider oldProvider = findProvider(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n\n    if (oldProvider.isDynamic()) {\n        // Make sure we only have one override configured disable property.\n        if (oldProvider.isEnabled()) {\n            Override override = new Override();\n            override.setAddress(oldProvider.getAddress());\n            override.setService(oldProvider.getService());\n            override.setEnabled(true);\n            override.setParams(Constants.DISABLED_KEY + \"=true\");\n            overrideService.saveOverride(override);\n            return;\n        }\n        List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n        for (Override o : oList) {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            if (params.containsKey(Constants.DISABLED_KEY)) {\n                if (params.get(Constants.DISABLED_KEY).equals(\"false\")) {\n                    overrideService.deleteOverride(o.getHash());\n                }\n            }\n        }\n    } else {\n        oldProvider.setEnabled(false);\n        updateProvider(oldProvider);\n    }\n\n}",
                "name": "disableProvider",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    if (id == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n\n    Provider oldProvider = findProvider(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n\n    if (oldProvider.isDynamic()) {\n        // Make sure we only have one override configured disable property.\n        if (oldProvider.isEnabled()) {\n            Override override = new Override();\n            override.setAddress(oldProvider.getAddress());\n            override.setService(oldProvider.getService());\n            override.setEnabled(true);\n            override.setParams(Constants.DISABLED_KEY + \"=true\");\n            overrideService.saveOverride(override);\n            return;\n        }\n        List<Override> oList = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n\n        for (Override o : oList) {\n            Map<String, String> params = StringUtils.parseQueryString(o.getParams());\n            if (params.containsKey(Constants.DISABLED_KEY)) {\n                if (params.get(Constants.DISABLED_KEY).equals(\"false\")) {\n                    overrideService.deleteOverride(o.getHash());\n                }\n            }\n        }\n    } else {\n        oldProvider.setEnabled(false);\n        updateProvider(oldProvider);\n    }\n\n}",
                "start_point": {
                    "row": 90,
                    "column": 4
                },
                "end_point": {
                    "row": 126,
                    "column": 5
                }
            },
            {
                "definition": "public void doublingProvider(String id) {\n    setWeight(id, 2F);\n}",
                "name": "doublingProvider",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    setWeight(id, 2F);\n}",
                "start_point": {
                    "row": 128,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "public void halvingProvider(String id) {\n    setWeight(id, 0.5F);\n}",
                "name": "halvingProvider",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    setWeight(id, 0.5F);\n}",
                "start_point": {
                    "row": 132,
                    "column": 4
                },
                "end_point": {
                    "row": 134,
                    "column": 5
                }
            },
            {
                "definition": "public void setWeight(String id, float factor) {\n    if (id == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n    Provider oldProvider = findProvider(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    Map<String, String> map = StringUtils.parseQueryString(oldProvider.getParameters());\n    String weight = map.get(Constants.WEIGHT_KEY);\n    if (oldProvider.isDynamic()) {\n        // Make sure we only have one override configured disable property.\n        List<Override> overrides = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n        if (overrides == null || overrides.size() == 0) {\n            int value = getWeight(weight, factor);\n            if (value != Constants.DEFAULT_WEIGHT) {\n                Override override = new Override();\n                override.setAddress(oldProvider.getAddress());\n                override.setService(oldProvider.getService());\n                override.setEnabled(true);\n                override.setParams(Constants.WEIGHT_KEY + \"=\" + String.valueOf(value));\n                overrideService.saveOverride(override);\n            }\n        } else {\n            for (Override override : overrides) {\n                Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                String overrideWeight = params.get(Constants.WEIGHT_KEY);\n                if (overrideWeight == null || overrideWeight.length() == 0) {\n                    overrideWeight = weight;\n                }\n                int value = getWeight(overrideWeight, factor);\n                if (value == getWeight(weight, 1)) {\n                    params.remove(Constants.WEIGHT_KEY);\n                } else {\n                    params.put(Constants.WEIGHT_KEY, String.valueOf(value));\n                }\n                if (params.size() > 0) {\n                    override.setParams(StringUtils.toQueryString(params));\n                    overrideService.updateOverride(override);\n                } else {\n                    overrideService.deleteOverride(override.getHash());\n                }\n            }\n        }\n    } else {\n        int value = getWeight(weight, factor);\n        if (value == Constants.DEFAULT_WEIGHT) {\n            map.remove(Constants.WEIGHT_KEY);\n        } else {\n            map.put(Constants.WEIGHT_KEY, String.valueOf(value));\n        }\n        oldProvider.setParameters(StringUtils.toQueryString(map));\n        updateProvider(oldProvider);\n    }\n}",
                "name": "setWeight",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    },
                    {
                        "type": "float",
                        "name": "factor"
                    }
                ],
                "body": "{\n    if (id == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n    Provider oldProvider = findProvider(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    Map<String, String> map = StringUtils.parseQueryString(oldProvider.getParameters());\n    String weight = map.get(Constants.WEIGHT_KEY);\n    if (oldProvider.isDynamic()) {\n        // Make sure we only have one override configured disable property.\n        List<Override> overrides = overrideService.findByServiceAndAddress(oldProvider.getService(), oldProvider.getAddress());\n        if (overrides == null || overrides.size() == 0) {\n            int value = getWeight(weight, factor);\n            if (value != Constants.DEFAULT_WEIGHT) {\n                Override override = new Override();\n                override.setAddress(oldProvider.getAddress());\n                override.setService(oldProvider.getService());\n                override.setEnabled(true);\n                override.setParams(Constants.WEIGHT_KEY + \"=\" + String.valueOf(value));\n                overrideService.saveOverride(override);\n            }\n        } else {\n            for (Override override : overrides) {\n                Map<String, String> params = StringUtils.parseQueryString(override.getParams());\n                String overrideWeight = params.get(Constants.WEIGHT_KEY);\n                if (overrideWeight == null || overrideWeight.length() == 0) {\n                    overrideWeight = weight;\n                }\n                int value = getWeight(overrideWeight, factor);\n                if (value == getWeight(weight, 1)) {\n                    params.remove(Constants.WEIGHT_KEY);\n                } else {\n                    params.put(Constants.WEIGHT_KEY, String.valueOf(value));\n                }\n                if (params.size() > 0) {\n                    override.setParams(StringUtils.toQueryString(params));\n                    overrideService.updateOverride(override);\n                } else {\n                    overrideService.deleteOverride(override.getHash());\n                }\n            }\n        }\n    } else {\n        int value = getWeight(weight, factor);\n        if (value == Constants.DEFAULT_WEIGHT) {\n            map.remove(Constants.WEIGHT_KEY);\n        } else {\n            map.put(Constants.WEIGHT_KEY, String.valueOf(value));\n        }\n        oldProvider.setParameters(StringUtils.toQueryString(map));\n        updateProvider(oldProvider);\n    }\n}",
                "start_point": {
                    "row": 136,
                    "column": 4
                },
                "end_point": {
                    "row": 190,
                    "column": 5
                }
            },
            {
                "definition": "private int getWeight(String value, float factor) {\n    int weight = 100;\n    if (value != null && value.length() > 0) {\n        weight = Integer.parseInt(value);\n    }\n    weight = (int) (weight * factor);\n    if (weight < 1) weight = 1;\n    if (weight == 2) weight = 3;\n    if (weight == 24) weight = 25;\n    return weight;\n}",
                "name": "getWeight",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "value"
                    },
                    {
                        "type": "float",
                        "name": "factor"
                    }
                ],
                "body": "{\n    int weight = 100;\n    if (value != null && value.length() > 0) {\n        weight = Integer.parseInt(value);\n    }\n    weight = (int) (weight * factor);\n    if (weight < 1) weight = 1;\n    if (weight == 2) weight = 3;\n    if (weight == 24) weight = 25;\n    return weight;\n}",
                "start_point": {
                    "row": 192,
                    "column": 4
                },
                "end_point": {
                    "row": 202,
                    "column": 5
                }
            },
            {
                "definition": "public void deleteStaticProvider(String id) {\n    URL oldProvider = findProviderUrl(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    registryService.unregister(oldProvider);\n}",
                "name": "deleteStaticProvider",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    URL oldProvider = findProviderUrl(id);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    registryService.unregister(oldProvider);\n}",
                "start_point": {
                    "row": 204,
                    "column": 4
                },
                "end_point": {
                    "row": 210,
                    "column": 5
                }
            },
            {
                "definition": "public void updateProvider(Provider provider) {\n    String hash = provider.getHash();\n    if (hash == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n\n    URL oldProvider = findProviderUrl(hash);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    URL newProvider = provider.toUrl();\n\n    registryService.unregister(oldProvider);\n    registryService.register(newProvider);\n}",
                "name": "updateProvider",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Provider",
                        "name": "provider"
                    }
                ],
                "body": "{\n    String hash = provider.getHash();\n    if (hash == null) {\n        throw new IllegalStateException(\"no provider id\");\n    }\n\n    URL oldProvider = findProviderUrl(hash);\n    if (oldProvider == null) {\n        throw new IllegalStateException(\"Provider was changed!\");\n    }\n    URL newProvider = provider.toUrl();\n\n    registryService.unregister(oldProvider);\n    registryService.register(newProvider);\n}",
                "start_point": {
                    "row": 212,
                    "column": 4
                },
                "end_point": {
                    "row": 226,
                    "column": 5
                }
            },
            {
                "definition": "public Provider findProvider(String id) {\n    return SyncUtils.url2Provider(findProviderUrlPair(id));\n}",
                "name": "findProvider",
                "modifiers": "public",
                "return_type": "Provider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.url2Provider(findProviderUrlPair(id));\n}",
                "start_point": {
                    "row": 228,
                    "column": 4
                },
                "end_point": {
                    "row": 230,
                    "column": 5
                }
            },
            {
                "definition": "public Pair<String, URL> findProviderUrlPair(String id) {\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.PROVIDERS_CATEGORY, id);\n}",
                "name": "findProviderUrlPair",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.PROVIDERS_CATEGORY, id);\n}",
                "start_point": {
                    "row": 232,
                    "column": 4
                },
                "end_point": {
                    "row": 234,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findServices() {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls != null) ret.addAll(providerUrls.keySet());\n    return ret;\n}",
                "name": "findServices",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls != null) ret.addAll(providerUrls.keySet());\n    return ret;\n}",
                "start_point": {
                    "row": 236,
                    "column": 4
                },
                "end_point": {
                    "row": 241,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findAddresses() {\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (null == providerUrls) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "name": "findAddresses",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (null == providerUrls) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getAddress();\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 243,
                    "column": 4
                },
                "end_point": {
                    "row": 259,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findAddressesByApplication(String application) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                String addr = u.getAddress();\n                if (addr != null) ret.add(addr);\n            }\n        }\n    }\n\n    return ret;\n}",
                "name": "findAddressesByApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                String addr = u.getAddress();\n                if (addr != null) ret.add(addr);\n            }\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 261,
                    "column": 4
                },
                "end_point": {
                    "row": 276,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findAddressesByService(String service) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (null == providerUrls) return ret;\n\n    for (Map.Entry<String, URL> e2 : providerUrls.get(service).entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getAddress();\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "name": "findAddressesByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (null == providerUrls) return ret;\n\n    for (Map.Entry<String, URL> e2 : providerUrls.get(service).entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getAddress();\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 278,
                    "column": 4
                },
                "end_point": {
                    "row": 290,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findApplicationsByServiceName(String service) {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (null == providerUrls) return ret;\n\n    Map<String, URL> value = providerUrls.get(service);\n    if (value == null) {\n        return ret;\n    }\n    for (Map.Entry<String, URL> e2 : value.entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getParameter(Constants.APPLICATION_KEY);\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "name": "findApplicationsByServiceName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (null == providerUrls) return ret;\n\n    Map<String, URL> value = providerUrls.get(service);\n    if (value == null) {\n        return ret;\n    }\n    for (Map.Entry<String, URL> e2 : value.entrySet()) {\n        URL u = e2.getValue();\n        String app = u.getParameter(Constants.APPLICATION_KEY);\n        if (app != null) ret.add(app);\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 292,
                    "column": 4
                },
                "end_point": {
                    "row": 308,
                    "column": 5
                }
            },
            {
                "definition": "public List<Provider> findByService(String serviceName) {\n    return SyncUtils.url2ProviderList(findProviderUrlByService(serviceName));\n}",
                "name": "findByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "serviceName"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ProviderList(findProviderUrlByService(serviceName));\n}",
                "start_point": {
                    "row": 310,
                    "column": 4
                },
                "end_point": {
                    "row": 312,
                    "column": 5
                }
            },
            {
                "definition": "public List<Provider> findByAppandService(String app, String serviceName) {\n    return SyncUtils.url2ProviderList(findProviderUrlByAppandService(app, serviceName));\n}",
                "name": "findByAppandService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "app"
                    },
                    {
                        "type": "String",
                        "name": "serviceName"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ProviderList(findProviderUrlByAppandService(app, serviceName));\n}",
                "start_point": {
                    "row": 314,
                    "column": 4
                },
                "end_point": {
                    "row": 316,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findProviderUrlByService(String service) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findProviderUrlByService",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 318,
                    "column": 4
                },
                "end_point": {
                    "row": 324,
                    "column": 5
                }
            },
            {
                "definition": "public List<Provider> findAll() {\n    return SyncUtils.url2ProviderList(findAllProviderUrl());\n}",
                "name": "findAll",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return SyncUtils.url2ProviderList(findAllProviderUrl());\n}",
                "start_point": {
                    "row": 326,
                    "column": 4
                },
                "end_point": {
                    "row": 328,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findAllProviderUrl() {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findAllProviderUrl",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 330,
                    "column": 4
                },
                "end_point": {
                    "row": 334,
                    "column": 5
                }
            },
            {
                "definition": "public List<Provider> findByAddress(String providerAddress) {\n    return SyncUtils.url2ProviderList(findProviderUrlByAddress(providerAddress));\n}",
                "name": "findByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "providerAddress"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ProviderList(findProviderUrlByAddress(providerAddress));\n}",
                "start_point": {
                    "row": 336,
                    "column": 4
                },
                "end_point": {
                    "row": 338,
                    "column": 5
                }
            },
            {
                "definition": "public Map<String, URL> findProviderUrlByAddress(String address) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findProviderUrlByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 340,
                    "column": 4
                },
                "end_point": {
                    "row": 346,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findServicesByAddress(String address) {\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null || address == null || address.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (address.equals(u.getAddress())) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "name": "findServicesByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null || address == null || address.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (address.equals(u.getAddress())) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 348,
                    "column": 4
                },
                "end_point": {
                    "row": 366,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findApplications() {\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "name": "findApplications",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            String app = u.getParameter(Constants.APPLICATION_KEY);\n            if (app != null) ret.add(app);\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 368,
                    "column": 4
                },
                "end_point": {
                    "row": 383,
                    "column": 5
                }
            },
            {
                "definition": "public List<Provider> findByApplication(String application) {\n    return SyncUtils.url2ProviderList(findProviderUrlByApplication(application));\n}",
                "name": "findByApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    return SyncUtils.url2ProviderList(findProviderUrlByApplication(application));\n}",
                "start_point": {
                    "row": 385,
                    "column": 4
                },
                "end_point": {
                    "row": 387,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findProviderUrlByAppandService(String app, String service) {\n    Map<String, String> filter = new HashMap<>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, app);\n    filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findProviderUrlByAppandService",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "app"
                    },
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, app);\n    filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 389,
                    "column": 4
                },
                "end_point": {
                    "row": 395,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findProviderUrlByApplication(String application) {\n    Map<String, String> filter = new HashMap<>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, application);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findProviderUrlByApplication",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(Constants.APPLICATION_KEY, application);\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 398,
                    "column": 4
                },
                "end_point": {
                    "row": 403,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findServicesByApplication(String application) {\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null || application == null || application.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "name": "findServicesByApplication",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "application"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null || application == null || application.length() == 0) return ret;\n\n    for (Map.Entry<String, Map<String, URL>> e1 : providerUrls.entrySet()) {\n        Map<String, URL> value = e1.getValue();\n        for (Map.Entry<String, URL> e2 : value.entrySet()) {\n            URL u = e2.getValue();\n            if (application.equals(u.getParameter(Constants.APPLICATION_KEY))) {\n                ret.add(e1.getKey());\n                break;\n            }\n        }\n    }\n\n    return ret;\n}",
                "start_point": {
                    "row": 405,
                    "column": 4
                },
                "end_point": {
                    "row": 423,
                    "column": 5
                }
            },
            {
                "definition": "public List<String> findMethodsByService(String service) {\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null || service == null || service.length() == 0) return ret;\n\n    Map<String, URL> providers = providerUrls.get(service);\n    if (null == providers || providers.isEmpty()) return ret;\n\n    Entry<String, URL> p = providers.entrySet().iterator().next();\n    String value = p.getValue().getParameter(\"methods\");\n    if (value == null || value.length() == 0) {\n        return ret;\n    }\n    String[] methods = value.split(ParseUtils.METHOD_SPLIT);\n    if (methods == null || methods.length == 0) {\n        return ret;\n    }\n\n    for (String m : methods) {\n        ret.add(m);\n    }\n    return ret;\n}",
                "name": "findMethodsByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    List<String> ret = new ArrayList<String>();\n\n    ConcurrentMap<String, Map<String, URL>> providerUrls = getRegistryCache().get(Constants.PROVIDERS_CATEGORY);\n    if (providerUrls == null || service == null || service.length() == 0) return ret;\n\n    Map<String, URL> providers = providerUrls.get(service);\n    if (null == providers || providers.isEmpty()) return ret;\n\n    Entry<String, URL> p = providers.entrySet().iterator().next();\n    String value = p.getValue().getParameter(\"methods\");\n    if (value == null || value.length() == 0) {\n        return ret;\n    }\n    String[] methods = value.split(ParseUtils.METHOD_SPLIT);\n    if (methods == null || methods.length == 0) {\n        return ret;\n    }\n\n    for (String m : methods) {\n        ret.add(m);\n    }\n    return ret;\n}",
                "start_point": {
                    "row": 425,
                    "column": 4
                },
                "end_point": {
                    "row": 448,
                    "column": 5
                }
            },
            {
                "definition": "private URL findProviderUrl(String id) {\n    return findProvider(id).toUrl();\n}",
                "name": "findProviderUrl",
                "modifiers": "private",
                "return_type": "URL",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return findProvider(id).toUrl();\n}",
                "start_point": {
                    "row": 450,
                    "column": 4
                },
                "end_point": {
                    "row": 452,
                    "column": 5
                }
            },
            {
                "definition": "public Provider findByServiceAndAddress(String service, String address) {\n    return SyncUtils.url2Provider(findProviderUrl(service, address));\n}",
                "name": "findByServiceAndAddress",
                "modifiers": "public",
                "return_type": "Provider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    return SyncUtils.url2Provider(findProviderUrl(service, address));\n}",
                "start_point": {
                    "row": 454,
                    "column": 4
                },
                "end_point": {
                    "row": 456,
                    "column": 5
                }
            },
            {
                "definition": "private Pair<String, URL> findProviderUrl(String service, String address) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n    Map<String, URL> ret = SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    if (ret.isEmpty()) {\n        return null;\n    } else {\n        String key = ret.entrySet().iterator().next().getKey();\n        return new Pair<String, URL>(key, ret.get(key));\n    }\n}",
                "name": "findProviderUrl",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.PROVIDERS_CATEGORY);\n    filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n\n    Map<String, URL> ret = SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    if (ret.isEmpty()) {\n        return null;\n    } else {\n        String key = ret.entrySet().iterator().next().getKey();\n        return new Pair<String, URL>(key, ret.get(key));\n    }\n}",
                "start_point": {
                    "row": 458,
                    "column": 4
                },
                "end_point": {
                    "row": 470,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/impl/RouteServiceImpl.java",
        "definition": "@Component\npublic class RouteServiceImpl extends AbstractService implements RouteService {\n\n    public void createRoute(Route route) {\n        registryService.register(route.toUrl());\n    }\n\n    public void updateRoute(Route route) {\n        String hash = route.getHash();\n        if (hash == null) {\n            throw new IllegalStateException(\"no route hash\");\n        }\n        URL oldRoute = findRouteUrl(hash);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n\n        registryService.unregister(oldRoute);\n        registryService.register(route.toUrl());\n    }\n\n    public void deleteRoute(String id) {\n        URL oldRoute = findRouteUrl(id);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        registryService.unregister(oldRoute);\n    }\n\n    public void enableRoute(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no route id\");\n        }\n\n        URL oldRoute = findRouteUrl(id);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        if (oldRoute.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        registryService.unregister(oldRoute);\n        URL newRoute = oldRoute.addParameter(\"enabled\", true);\n        registryService.register(newRoute);\n\n    }\n\n    public void disableRoute(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no route id\");\n        }\n\n        URL oldRoute = findRouteUrl(id);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        if (!oldRoute.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        URL newRoute = oldRoute.addParameter(\"enabled\", false);\n        registryService.unregister(oldRoute);\n        registryService.register(newRoute);\n\n    }\n\n    public List<Route> findAll() {\n        return SyncUtils.url2RouteList(findAllUrl());\n    }\n\n    private Map<String, URL> findAllUrl() {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public Route findRoute(String id) {\n        return SyncUtils.url2Route(findRouteUrlPair(id));\n    }\n\n    public Pair<String, URL> findRouteUrlPair(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.ROUTERS_CATEGORY, id);\n    }\n\n    private URL findRouteUrl(String id) {\n        return findRoute(id).toUrl();\n    }\n\n    private Map<String, URL> findRouteUrl(String service, String address, boolean force) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n        if (service != null && service.length() > 0) {\n            filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n        }\n        if (address != null && address.length() > 0) {\n            filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n        }\n        if (force) {\n            filter.put(\"force\", \"true\");\n        }\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Route> findByService(String serviceName) {\n        return SyncUtils.url2RouteList(findRouteUrl(serviceName, null, false));\n    }\n\n    public List<Route> findByAddress(String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(null, address, false));\n    }\n\n    public List<Route> findByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(service, address, false));\n    }\n\n    public List<Route> findForceRouteByService(String service) {\n        return SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n    }\n\n    public List<Route> findForceRouteByAddress(String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(null, address, true));\n    }\n\n    public List<Route> findForceRouteByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(service, address, true));\n    }\n\n    public List<Route> findAllForceRoute() {\n        return SyncUtils.url2RouteList(findRouteUrl(null, null, true));\n    }\n\n    public Route getBlackwhitelistRouteByService(String service) {\n        List<Route> routes = SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n        for (Route route : routes) {\n            if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n                return route;\n            }\n        }\n        return null;\n    }\n\n}",
        "package": "package org.apache.dubbo.admin.service.impl;",
        "tree_path": "RouteServiceImpl",
        "name": "RouteServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": "extends AbstractService",
        "super_interfaces": "implements RouteService",
        "body": "{\n\n    public void createRoute(Route route) {\n        registryService.register(route.toUrl());\n    }\n\n    public void updateRoute(Route route) {\n        String hash = route.getHash();\n        if (hash == null) {\n            throw new IllegalStateException(\"no route hash\");\n        }\n        URL oldRoute = findRouteUrl(hash);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n\n        registryService.unregister(oldRoute);\n        registryService.register(route.toUrl());\n    }\n\n    public void deleteRoute(String id) {\n        URL oldRoute = findRouteUrl(id);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        registryService.unregister(oldRoute);\n    }\n\n    public void enableRoute(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no route id\");\n        }\n\n        URL oldRoute = findRouteUrl(id);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        if (oldRoute.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        registryService.unregister(oldRoute);\n        URL newRoute = oldRoute.addParameter(\"enabled\", true);\n        registryService.register(newRoute);\n\n    }\n\n    public void disableRoute(String id) {\n        if (id == null) {\n            throw new IllegalStateException(\"no route id\");\n        }\n\n        URL oldRoute = findRouteUrl(id);\n        if (oldRoute == null) {\n            throw new IllegalStateException(\"Route was changed!\");\n        }\n        if (!oldRoute.getParameter(\"enabled\", true)) {\n            return;\n        }\n\n        URL newRoute = oldRoute.addParameter(\"enabled\", false);\n        registryService.unregister(oldRoute);\n        registryService.register(newRoute);\n\n    }\n\n    public List<Route> findAll() {\n        return SyncUtils.url2RouteList(findAllUrl());\n    }\n\n    private Map<String, URL> findAllUrl() {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public Route findRoute(String id) {\n        return SyncUtils.url2Route(findRouteUrlPair(id));\n    }\n\n    public Pair<String, URL> findRouteUrlPair(String id) {\n        return SyncUtils.filterFromCategory(getRegistryCache(), Constants.ROUTERS_CATEGORY, id);\n    }\n\n    private URL findRouteUrl(String id) {\n        return findRoute(id).toUrl();\n    }\n\n    private Map<String, URL> findRouteUrl(String service, String address, boolean force) {\n        Map<String, String> filter = new HashMap<String, String>();\n        filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n        if (service != null && service.length() > 0) {\n            filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n        }\n        if (address != null && address.length() > 0) {\n            filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n        }\n        if (force) {\n            filter.put(\"force\", \"true\");\n        }\n        return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n    }\n\n    public List<Route> findByService(String serviceName) {\n        return SyncUtils.url2RouteList(findRouteUrl(serviceName, null, false));\n    }\n\n    public List<Route> findByAddress(String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(null, address, false));\n    }\n\n    public List<Route> findByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(service, address, false));\n    }\n\n    public List<Route> findForceRouteByService(String service) {\n        return SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n    }\n\n    public List<Route> findForceRouteByAddress(String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(null, address, true));\n    }\n\n    public List<Route> findForceRouteByServiceAndAddress(String service, String address) {\n        return SyncUtils.url2RouteList(findRouteUrl(service, address, true));\n    }\n\n    public List<Route> findAllForceRoute() {\n        return SyncUtils.url2RouteList(findRouteUrl(null, null, true));\n    }\n\n    public Route getBlackwhitelistRouteByService(String service) {\n        List<Route> routes = SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n        for (Route route : routes) {\n            if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n                return route;\n            }\n        }\n        return null;\n    }\n\n}",
        "start_point": {
            "row": 35,
            "column": 0
        },
        "end_point": {
            "row": 178,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public void createRoute(Route route) {\n    registryService.register(route.toUrl());\n}",
                "name": "createRoute",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Route",
                        "name": "route"
                    }
                ],
                "body": "{\n    registryService.register(route.toUrl());\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 40,
                    "column": 5
                }
            },
            {
                "definition": "public void updateRoute(Route route) {\n    String hash = route.getHash();\n    if (hash == null) {\n        throw new IllegalStateException(\"no route hash\");\n    }\n    URL oldRoute = findRouteUrl(hash);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n\n    registryService.unregister(oldRoute);\n    registryService.register(route.toUrl());\n}",
                "name": "updateRoute",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Route",
                        "name": "route"
                    }
                ],
                "body": "{\n    String hash = route.getHash();\n    if (hash == null) {\n        throw new IllegalStateException(\"no route hash\");\n    }\n    URL oldRoute = findRouteUrl(hash);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n\n    registryService.unregister(oldRoute);\n    registryService.register(route.toUrl());\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "public void deleteRoute(String id) {\n    URL oldRoute = findRouteUrl(id);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    registryService.unregister(oldRoute);\n}",
                "name": "deleteRoute",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    URL oldRoute = findRouteUrl(id);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    registryService.unregister(oldRoute);\n}",
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 62,
                    "column": 5
                }
            },
            {
                "definition": "public void enableRoute(String id) {\n    if (id == null) {\n        throw new IllegalStateException(\"no route id\");\n    }\n\n    URL oldRoute = findRouteUrl(id);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    if (oldRoute.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    registryService.unregister(oldRoute);\n    URL newRoute = oldRoute.addParameter(\"enabled\", true);\n    registryService.register(newRoute);\n\n}",
                "name": "enableRoute",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    if (id == null) {\n        throw new IllegalStateException(\"no route id\");\n    }\n\n    URL oldRoute = findRouteUrl(id);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    if (oldRoute.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    registryService.unregister(oldRoute);\n    URL newRoute = oldRoute.addParameter(\"enabled\", true);\n    registryService.register(newRoute);\n\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "public void disableRoute(String id) {\n    if (id == null) {\n        throw new IllegalStateException(\"no route id\");\n    }\n\n    URL oldRoute = findRouteUrl(id);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    if (!oldRoute.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    URL newRoute = oldRoute.addParameter(\"enabled\", false);\n    registryService.unregister(oldRoute);\n    registryService.register(newRoute);\n\n}",
                "name": "disableRoute",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    if (id == null) {\n        throw new IllegalStateException(\"no route id\");\n    }\n\n    URL oldRoute = findRouteUrl(id);\n    if (oldRoute == null) {\n        throw new IllegalStateException(\"Route was changed!\");\n    }\n    if (!oldRoute.getParameter(\"enabled\", true)) {\n        return;\n    }\n\n    URL newRoute = oldRoute.addParameter(\"enabled\", false);\n    registryService.unregister(oldRoute);\n    registryService.register(newRoute);\n\n}",
                "start_point": {
                    "row": 83,
                    "column": 4
                },
                "end_point": {
                    "row": 100,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findAll() {\n    return SyncUtils.url2RouteList(findAllUrl());\n}",
                "name": "findAll",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return SyncUtils.url2RouteList(findAllUrl());\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 104,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findAllUrl() {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findAllUrl",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 106,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "public Route findRoute(String id) {\n    return SyncUtils.url2Route(findRouteUrlPair(id));\n}",
                "name": "findRoute",
                "modifiers": "public",
                "return_type": "Route",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.url2Route(findRouteUrlPair(id));\n}",
                "start_point": {
                    "row": 113,
                    "column": 4
                },
                "end_point": {
                    "row": 115,
                    "column": 5
                }
            },
            {
                "definition": "public Pair<String, URL> findRouteUrlPair(String id) {\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.ROUTERS_CATEGORY, id);\n}",
                "name": "findRouteUrlPair",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return SyncUtils.filterFromCategory(getRegistryCache(), Constants.ROUTERS_CATEGORY, id);\n}",
                "start_point": {
                    "row": 117,
                    "column": 4
                },
                "end_point": {
                    "row": 119,
                    "column": 5
                }
            },
            {
                "definition": "private URL findRouteUrl(String id) {\n    return findRoute(id).toUrl();\n}",
                "name": "findRouteUrl",
                "modifiers": "private",
                "return_type": "URL",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return findRoute(id).toUrl();\n}",
                "start_point": {
                    "row": 121,
                    "column": 4
                },
                "end_point": {
                    "row": 123,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, URL> findRouteUrl(String service, String address, boolean force) {\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n    if (service != null && service.length() > 0) {\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n    }\n    if (address != null && address.length() > 0) {\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n    }\n    if (force) {\n        filter.put(\"force\", \"true\");\n    }\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "name": "findRouteUrl",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    },
                    {
                        "type": "boolean",
                        "name": "force"
                    }
                ],
                "body": "{\n    Map<String, String> filter = new HashMap<String, String>();\n    filter.put(Constants.CATEGORY_KEY, Constants.ROUTERS_CATEGORY);\n    if (service != null && service.length() > 0) {\n        filter.put(SyncUtils.SERVICE_FILTER_KEY, service);\n    }\n    if (address != null && address.length() > 0) {\n        filter.put(SyncUtils.ADDRESS_FILTER_KEY, address);\n    }\n    if (force) {\n        filter.put(\"force\", \"true\");\n    }\n    return SyncUtils.filterFromCategory(getRegistryCache(), filter);\n}",
                "start_point": {
                    "row": 125,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findByService(String serviceName) {\n    return SyncUtils.url2RouteList(findRouteUrl(serviceName, null, false));\n}",
                "name": "findByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "serviceName"
                    }
                ],
                "body": "{\n    return SyncUtils.url2RouteList(findRouteUrl(serviceName, null, false));\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 142,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findByAddress(String address) {\n    return SyncUtils.url2RouteList(findRouteUrl(null, address, false));\n}",
                "name": "findByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    return SyncUtils.url2RouteList(findRouteUrl(null, address, false));\n}",
                "start_point": {
                    "row": 144,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findByServiceAndAddress(String service, String address) {\n    return SyncUtils.url2RouteList(findRouteUrl(service, address, false));\n}",
                "name": "findByServiceAndAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    return SyncUtils.url2RouteList(findRouteUrl(service, address, false));\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 150,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findForceRouteByService(String service) {\n    return SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n}",
                "name": "findForceRouteByService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    return SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n}",
                "start_point": {
                    "row": 152,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findForceRouteByAddress(String address) {\n    return SyncUtils.url2RouteList(findRouteUrl(null, address, true));\n}",
                "name": "findForceRouteByAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    return SyncUtils.url2RouteList(findRouteUrl(null, address, true));\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 158,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findForceRouteByServiceAndAddress(String service, String address) {\n    return SyncUtils.url2RouteList(findRouteUrl(service, address, true));\n}",
                "name": "findForceRouteByServiceAndAddress",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    },
                    {
                        "type": "String",
                        "name": "address"
                    }
                ],
                "body": "{\n    return SyncUtils.url2RouteList(findRouteUrl(service, address, true));\n}",
                "start_point": {
                    "row": 160,
                    "column": 4
                },
                "end_point": {
                    "row": 162,
                    "column": 5
                }
            },
            {
                "definition": "public List<Route> findAllForceRoute() {\n    return SyncUtils.url2RouteList(findRouteUrl(null, null, true));\n}",
                "name": "findAllForceRoute",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return SyncUtils.url2RouteList(findRouteUrl(null, null, true));\n}",
                "start_point": {
                    "row": 164,
                    "column": 4
                },
                "end_point": {
                    "row": 166,
                    "column": 5
                }
            },
            {
                "definition": "public Route getBlackwhitelistRouteByService(String service) {\n    List<Route> routes = SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n    for (Route route : routes) {\n        if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n            return route;\n        }\n    }\n    return null;\n}",
                "name": "getBlackwhitelistRouteByService",
                "modifiers": "public",
                "return_type": "Route",
                "parameters": [
                    {
                        "type": "String",
                        "name": "service"
                    }
                ],
                "body": "{\n    List<Route> routes = SyncUtils.url2RouteList(findRouteUrl(service, null, true));\n    for (Route route : routes) {\n        if (route.getName().endsWith(AccessDTO.KEY_BLACK_WHITE_LIST)) {\n            return route;\n        }\n    }\n    return null;\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 176,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "dubbo-admin-backend/src/main/java/org/apache/dubbo/admin/service/impl/ConfigServiceImpl.java",
        "definition": "public class ConfigServiceImpl extends AbstractService implements ConfigService {\n\n    /* (non-Javadoc)\n     * @see com.alibaba.dubbo.governance.service.ConfigService#update(java.util.List)\n     */\n    public void update(List<Config> configs) {\n        // TODO Auto-generated method stub\n\n    }\n\n    /* (non-Javadoc)\n     * @see com.alibaba.dubbo.governance.service.ConfigService#findAllConfigsMap()\n     */\n    public Map<String, String> findAllConfigsMap() {\n        // TODO Auto-generated method stub\n        return null;\n    }\n}",
        "package": "package org.apache.dubbo.admin.service.impl;",
        "tree_path": "ConfigServiceImpl",
        "name": "ConfigServiceImpl",
        "modifiers": "public",
        "superclass": "extends AbstractService",
        "super_interfaces": "implements ConfigService",
        "body": "{\n\n    /* (non-Javadoc)\n     * @see com.alibaba.dubbo.governance.service.ConfigService#update(java.util.List)\n     */\n    public void update(List<Config> configs) {\n        // TODO Auto-generated method stub\n\n    }\n\n    /* (non-Javadoc)\n     * @see com.alibaba.dubbo.governance.service.ConfigService#findAllConfigsMap()\n     */\n    public Map<String, String> findAllConfigsMap() {\n        // TODO Auto-generated method stub\n        return null;\n    }\n}",
        "start_point": {
            "row": 28,
            "column": 0
        },
        "end_point": {
            "row": 45,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public void update(List<Config> configs) {\n    // TODO Auto-generated method stub\n\n}",
                "name": "update",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<Config>",
                        "name": "configs"
                    }
                ],
                "body": "{\n    // TODO Auto-generated method stub\n\n}",
                "start_point": {
                    "row": 33,
                    "column": 4
                },
                "end_point": {
                    "row": 36,
                    "column": 5
                }
            },
            {
                "definition": "public Map<String, String> findAllConfigsMap() {\n    // TODO Auto-generated method stub\n    return null;\n}",
                "name": "findAllConfigsMap",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // TODO Auto-generated method stub\n    return null;\n}",
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            }
        ]
    }
]