[
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "public class QualifiedScanningTest\n    extends TestCase\n{\n    @Named\n    interface A\n    {\n    }\n\n    @Named\n    static abstract class B\n    {\n    }\n\n    @Named\n    static class C\n    {\n    }\n\n    @Qualifier\n    @Retention( RetentionPolicy.RUNTIME )\n    public @interface Legacy\n    {\n    }\n\n    @Named\n    @Legacy\n    static class D\n    {\n    }\n\n    @Legacy\n    @Named\n    static class E\n    {\n    }\n\n    static class F\n        extends B\n    {\n    }\n\n    @Singleton\n    static class G\n    {\n    }\n\n    static class TestListener\n        implements QualifiedTypeListener\n    {\n        final List<Class<?>> clazzes = new ArrayList<Class<?>>();\n\n        final Set<Object> sources = new HashSet<Object>();\n\n        public void hear( final Annotation qualifier, final Class<?> clazz, final Object source )\n        {\n            clazzes.add( clazz );\n            sources.add( source );\n        }\n    }\n\n    public void testQualifiedScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n        assertEquals( 35, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( C.class ) );\n        assertTrue( listener.clazzes.contains( D.class ) );\n        assertTrue( listener.clazzes.contains( E.class ) );\n    }\n\n    public void testAdaptedScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n        new ClassSpaceScanner( space ).accept( new ClassSpaceVisitor()\n        {\n            public void visit( final ClassSpace _space )\n            {\n                visitor.visit( _space );\n            }\n\n            public ClassVisitor visitClass( final URL url )\n            {\n                if ( url.toString().contains( \"$D.class\" ) )\n                {\n                    return null;\n                }\n                return visitor.visitClass( url );\n            }\n\n            public void visitEnd()\n            {\n                visitor.visitEnd();\n            }\n        } );\n\n        assertEquals( 34, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( C.class ) );\n        assertTrue( listener.clazzes.contains( E.class ) );\n    }\n\n    public void testFilteredScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n        new ClassSpaceScanner( new ClassFinder()\n        {\n            public Enumeration<URL> findClasses( final ClassSpace space2 )\n            {\n                return space2.findEntries( null, \"*D.class\", true );\n            }\n        }, space ).accept( visitor );\n\n        assertEquals( 1, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( D.class ) );\n    }\n\n    @Ignore( \"Need to replace some test archives\" )\n    public void /* test */ignoreIndexedScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n        new ClassSpaceScanner( new SisuIndexFinder( false ), space ).accept( visitor );\n\n        // we deliberately use a partial index\n\n        assertEquals( 2, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( C.class ) );\n        assertTrue( listener.clazzes.contains( D.class ) );\n    }\n\n    public void testBrokenScanning()\n        throws IOException\n    {\n        // System.setProperty( \"java.protocol.handler.pkgs\", getClass().getPackage().getName() );\n        URL.setURLStreamHandlerFactory( new URLStreamHandlerFactory()\n        {\n            public URLStreamHandler createURLStreamHandler( final String protocol )\n            {\n                if ( \"oops\".equals( protocol ) )\n                {\n                    return new Handler();\n                }\n                return null;\n            }\n        } );\n\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n\n        final URL badURL = new URL( \"oops:bad/\" );\n        final ClassSpace brokenResourceSpace = new ClassSpace()\n        {\n            public Class<?> loadClass( final String name )\n            {\n                return space.loadClass( name );\n            }\n\n            public DeferredClass<?> deferLoadClass( final String name )\n            {\n                return space.deferLoadClass( name );\n            }\n\n            public Enumeration<URL> getResources( final String name )\n            {\n                return space.getResources( name );\n            }\n\n            public URL getResource( final String name )\n            {\n                return badURL;\n            }\n\n            public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n            {\n                return Collections.enumeration( Collections.singleton( badURL ) );\n            }\n        };\n\n        new ClassSpaceScanner( brokenResourceSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n        final ClassSpace brokenLoadSpace = new ClassSpace()\n        {\n            public Class<?> loadClass( final String name )\n            {\n                throw new TypeNotPresentException( name, new ClassNotFoundException( name ) );\n            }\n\n            public DeferredClass<?> deferLoadClass( final String name )\n            {\n                return space.deferLoadClass( name );\n            }\n\n            public Enumeration<URL> getResources( final String name )\n            {\n                return space.getResources( name );\n            }\n\n            public URL getResource( final String name )\n            {\n                return space.getResource( name );\n            }\n\n            public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n            {\n                return space.findEntries( path, glob, recurse );\n            }\n        };\n\n        new ClassSpaceScanner( brokenLoadSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n        ClassSpaceScanner.accept( null, null );\n\n        assertFalse( new SisuIndexFinder( false ).findClasses( brokenResourceSpace ).hasMoreElements() );\n    }\n\n    public void testSourceDetection()\n        throws MalformedURLException\n    {\n        final TestListener listener = new TestListener();\n\n        final QualifiedTypeVisitor visitor = new QualifiedTypeVisitor( listener );\n\n        visitor.visit( new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } ) );\n\n        assertEquals( 0, listener.sources.size() );\n\n        visitor.visitClass( new URL( \"file:target/classes/java/lang/Object.class\" ) );\n        visitor.visit( 0, 0, Type.getInternalName( Object.class ), null, null, null );\n        visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n        visitor.visitEnd();\n\n        assertEquals( 1, listener.sources.size() );\n        assertTrue( listener.sources.contains( \"target/classes/\" ) );\n\n        visitor.visitClass( new URL( \"jar:file:bar.jar!/java/lang/String.class\" ) );\n        visitor.visit( 0, 0, Type.getInternalName( String.class ), null, null, null );\n        visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n        visitor.visitEnd();\n\n        assertEquals( 2, listener.sources.size() );\n        assertTrue( listener.sources.contains( \"target/classes/\" ) );\n        assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n\n        visitor.visitClass( new URL( \"file:some/obfuscated/location\" ) );\n        visitor.visit( 0, 0, Type.getInternalName( Integer.class ), null, null, null );\n        visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n        visitor.visitEnd();\n\n        assertEquals( 3, listener.sources.size() );\n        assertTrue( listener.sources.contains( \"target/classes/\" ) );\n        assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n        assertTrue( listener.sources.contains( \"some/obfuscated/location\" ) );\n    }\n\n    public void testOptionalLogging()\n        throws Exception\n    {\n        final Level level = Logger.getLogger( \"\" ).getLevel();\n        try\n        {\n            Logger.getLogger( \"\" ).setLevel( Level.SEVERE );\n\n            // check everything still works without any SLF4J jars\n            final ClassLoader noLoggingLoader =\n                new URLClassLoader( ( (URLClassLoader) getClass().getClassLoader() ).getURLs(), null )\n                {\n                    @Override\n                    protected synchronized Class<?> loadClass( final String name, final boolean resolve )\n                        throws ClassNotFoundException\n                    {\n                        if ( name.contains( \"slf4j\" ) )\n                        {\n                            throw new ClassNotFoundException( name );\n                        }\n                        if ( name.contains( \"cobertura\" ) )\n                        {\n                            return QualifiedScanningTest.class.getClassLoader().loadClass( name );\n                        }\n                        return super.loadClass( name, resolve );\n                    }\n                };\n\n            noLoggingLoader.loadClass( BrokenScanningExample.class.getName() ).newInstance();\n        }\n        finally\n        {\n            Logger.getLogger( \"\" ).setLevel( level );\n        }\n    }\n\n    public void testICU4J()\n    {\n        final ClassLoader loader = getClass().getClassLoader();\n        final URL[] urls = { loader.getResource( \"icu4j-2.6.1.jar\" ) };\n        final ClassSpace space = new URLClassSpace( loader, urls );\n\n        final TestListener listener = new TestListener();\n        new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n        assertEquals( 0, listener.clazzes.size() );\n    }\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest",
        "name": "QualifiedScanningTest",
        "modifiers": "public",
        "superclass": "extends TestCase",
        "super_interfaces": null,
        "body": "{\n    @Named\n    interface A\n    {\n    }\n\n    @Named\n    static abstract class B\n    {\n    }\n\n    @Named\n    static class C\n    {\n    }\n\n    @Qualifier\n    @Retention( RetentionPolicy.RUNTIME )\n    public @interface Legacy\n    {\n    }\n\n    @Named\n    @Legacy\n    static class D\n    {\n    }\n\n    @Legacy\n    @Named\n    static class E\n    {\n    }\n\n    static class F\n        extends B\n    {\n    }\n\n    @Singleton\n    static class G\n    {\n    }\n\n    static class TestListener\n        implements QualifiedTypeListener\n    {\n        final List<Class<?>> clazzes = new ArrayList<Class<?>>();\n\n        final Set<Object> sources = new HashSet<Object>();\n\n        public void hear( final Annotation qualifier, final Class<?> clazz, final Object source )\n        {\n            clazzes.add( clazz );\n            sources.add( source );\n        }\n    }\n\n    public void testQualifiedScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n        assertEquals( 35, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( C.class ) );\n        assertTrue( listener.clazzes.contains( D.class ) );\n        assertTrue( listener.clazzes.contains( E.class ) );\n    }\n\n    public void testAdaptedScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n        new ClassSpaceScanner( space ).accept( new ClassSpaceVisitor()\n        {\n            public void visit( final ClassSpace _space )\n            {\n                visitor.visit( _space );\n            }\n\n            public ClassVisitor visitClass( final URL url )\n            {\n                if ( url.toString().contains( \"$D.class\" ) )\n                {\n                    return null;\n                }\n                return visitor.visitClass( url );\n            }\n\n            public void visitEnd()\n            {\n                visitor.visitEnd();\n            }\n        } );\n\n        assertEquals( 34, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( C.class ) );\n        assertTrue( listener.clazzes.contains( E.class ) );\n    }\n\n    public void testFilteredScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n        new ClassSpaceScanner( new ClassFinder()\n        {\n            public Enumeration<URL> findClasses( final ClassSpace space2 )\n            {\n                return space2.findEntries( null, \"*D.class\", true );\n            }\n        }, space ).accept( visitor );\n\n        assertEquals( 1, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( D.class ) );\n    }\n\n    @Ignore( \"Need to replace some test archives\" )\n    public void /* test */ignoreIndexedScanning()\n    {\n        final TestListener listener = new TestListener();\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n        final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n        new ClassSpaceScanner( new SisuIndexFinder( false ), space ).accept( visitor );\n\n        // we deliberately use a partial index\n\n        assertEquals( 2, listener.clazzes.size() );\n\n        assertTrue( listener.clazzes.contains( C.class ) );\n        assertTrue( listener.clazzes.contains( D.class ) );\n    }\n\n    public void testBrokenScanning()\n        throws IOException\n    {\n        // System.setProperty( \"java.protocol.handler.pkgs\", getClass().getPackage().getName() );\n        URL.setURLStreamHandlerFactory( new URLStreamHandlerFactory()\n        {\n            public URLStreamHandler createURLStreamHandler( final String protocol )\n            {\n                if ( \"oops\".equals( protocol ) )\n                {\n                    return new Handler();\n                }\n                return null;\n            }\n        } );\n\n        final ClassSpace space =\n            new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n\n        final URL badURL = new URL( \"oops:bad/\" );\n        final ClassSpace brokenResourceSpace = new ClassSpace()\n        {\n            public Class<?> loadClass( final String name )\n            {\n                return space.loadClass( name );\n            }\n\n            public DeferredClass<?> deferLoadClass( final String name )\n            {\n                return space.deferLoadClass( name );\n            }\n\n            public Enumeration<URL> getResources( final String name )\n            {\n                return space.getResources( name );\n            }\n\n            public URL getResource( final String name )\n            {\n                return badURL;\n            }\n\n            public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n            {\n                return Collections.enumeration( Collections.singleton( badURL ) );\n            }\n        };\n\n        new ClassSpaceScanner( brokenResourceSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n        final ClassSpace brokenLoadSpace = new ClassSpace()\n        {\n            public Class<?> loadClass( final String name )\n            {\n                throw new TypeNotPresentException( name, new ClassNotFoundException( name ) );\n            }\n\n            public DeferredClass<?> deferLoadClass( final String name )\n            {\n                return space.deferLoadClass( name );\n            }\n\n            public Enumeration<URL> getResources( final String name )\n            {\n                return space.getResources( name );\n            }\n\n            public URL getResource( final String name )\n            {\n                return space.getResource( name );\n            }\n\n            public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n            {\n                return space.findEntries( path, glob, recurse );\n            }\n        };\n\n        new ClassSpaceScanner( brokenLoadSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n        ClassSpaceScanner.accept( null, null );\n\n        assertFalse( new SisuIndexFinder( false ).findClasses( brokenResourceSpace ).hasMoreElements() );\n    }\n\n    public void testSourceDetection()\n        throws MalformedURLException\n    {\n        final TestListener listener = new TestListener();\n\n        final QualifiedTypeVisitor visitor = new QualifiedTypeVisitor( listener );\n\n        visitor.visit( new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } ) );\n\n        assertEquals( 0, listener.sources.size() );\n\n        visitor.visitClass( new URL( \"file:target/classes/java/lang/Object.class\" ) );\n        visitor.visit( 0, 0, Type.getInternalName( Object.class ), null, null, null );\n        visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n        visitor.visitEnd();\n\n        assertEquals( 1, listener.sources.size() );\n        assertTrue( listener.sources.contains( \"target/classes/\" ) );\n\n        visitor.visitClass( new URL( \"jar:file:bar.jar!/java/lang/String.class\" ) );\n        visitor.visit( 0, 0, Type.getInternalName( String.class ), null, null, null );\n        visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n        visitor.visitEnd();\n\n        assertEquals( 2, listener.sources.size() );\n        assertTrue( listener.sources.contains( \"target/classes/\" ) );\n        assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n\n        visitor.visitClass( new URL( \"file:some/obfuscated/location\" ) );\n        visitor.visit( 0, 0, Type.getInternalName( Integer.class ), null, null, null );\n        visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n        visitor.visitEnd();\n\n        assertEquals( 3, listener.sources.size() );\n        assertTrue( listener.sources.contains( \"target/classes/\" ) );\n        assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n        assertTrue( listener.sources.contains( \"some/obfuscated/location\" ) );\n    }\n\n    public void testOptionalLogging()\n        throws Exception\n    {\n        final Level level = Logger.getLogger( \"\" ).getLevel();\n        try\n        {\n            Logger.getLogger( \"\" ).setLevel( Level.SEVERE );\n\n            // check everything still works without any SLF4J jars\n            final ClassLoader noLoggingLoader =\n                new URLClassLoader( ( (URLClassLoader) getClass().getClassLoader() ).getURLs(), null )\n                {\n                    @Override\n                    protected synchronized Class<?> loadClass( final String name, final boolean resolve )\n                        throws ClassNotFoundException\n                    {\n                        if ( name.contains( \"slf4j\" ) )\n                        {\n                            throw new ClassNotFoundException( name );\n                        }\n                        if ( name.contains( \"cobertura\" ) )\n                        {\n                            return QualifiedScanningTest.class.getClassLoader().loadClass( name );\n                        }\n                        return super.loadClass( name, resolve );\n                    }\n                };\n\n            noLoggingLoader.loadClass( BrokenScanningExample.class.getName() ).newInstance();\n        }\n        finally\n        {\n            Logger.getLogger( \"\" ).setLevel( level );\n        }\n    }\n\n    public void testICU4J()\n    {\n        final ClassLoader loader = getClass().getClassLoader();\n        final URL[] urls = { loader.getResource( \"icu4j-2.6.1.jar\" ) };\n        final ClassSpace space = new URLClassSpace( loader, urls );\n\n        final TestListener listener = new TestListener();\n        new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n        assertEquals( 0, listener.clazzes.size() );\n    }\n}",
        "start_point": {
            "row": 42,
            "column": 0
        },
        "end_point": {
            "row": 355,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public void testQualifiedScanning()\n{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n    assertEquals( 35, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( C.class ) );\n    assertTrue( listener.clazzes.contains( D.class ) );\n    assertTrue( listener.clazzes.contains( E.class ) );\n}",
                "name": "testQualifiedScanning",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n    assertEquals( 35, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( C.class ) );\n    assertTrue( listener.clazzes.contains( D.class ) );\n    assertTrue( listener.clazzes.contains( E.class ) );\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            },
            {
                "definition": "public void testAdaptedScanning()\n{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n    new ClassSpaceScanner( space ).accept( new ClassSpaceVisitor()\n    {\n        public void visit( final ClassSpace _space )\n        {\n            visitor.visit( _space );\n        }\n\n        public ClassVisitor visitClass( final URL url )\n        {\n            if ( url.toString().contains( \"$D.class\" ) )\n            {\n                return null;\n            }\n            return visitor.visitClass( url );\n        }\n\n        public void visitEnd()\n        {\n            visitor.visitEnd();\n        }\n    } );\n\n    assertEquals( 34, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( C.class ) );\n    assertTrue( listener.clazzes.contains( E.class ) );\n}",
                "name": "testAdaptedScanning",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n    new ClassSpaceScanner( space ).accept( new ClassSpaceVisitor()\n    {\n        public void visit( final ClassSpace _space )\n        {\n            visitor.visit( _space );\n        }\n\n        public ClassVisitor visitClass( final URL url )\n        {\n            if ( url.toString().contains( \"$D.class\" ) )\n            {\n                return null;\n            }\n            return visitor.visitClass( url );\n        }\n\n        public void visitEnd()\n        {\n            visitor.visitEnd();\n        }\n    } );\n\n    assertEquals( 34, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( C.class ) );\n    assertTrue( listener.clazzes.contains( E.class ) );\n}",
                "start_point": {
                    "row": 115,
                    "column": 4
                },
                "end_point": {
                    "row": 147,
                    "column": 5
                }
            },
            {
                "definition": "public void testFilteredScanning()\n{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n    new ClassSpaceScanner( new ClassFinder()\n    {\n        public Enumeration<URL> findClasses( final ClassSpace space2 )\n        {\n            return space2.findEntries( null, \"*D.class\", true );\n        }\n    }, space ).accept( visitor );\n\n    assertEquals( 1, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( D.class ) );\n}",
                "name": "testFilteredScanning",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n    new ClassSpaceScanner( new ClassFinder()\n    {\n        public Enumeration<URL> findClasses( final ClassSpace space2 )\n        {\n            return space2.findEntries( null, \"*D.class\", true );\n        }\n    }, space ).accept( visitor );\n\n    assertEquals( 1, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( D.class ) );\n}",
                "start_point": {
                    "row": 149,
                    "column": 4
                },
                "end_point": {
                    "row": 166,
                    "column": 5
                }
            },
            {
                "definition": "@Ignore( \"Need to replace some test archives\" )\npublic void /* test */ignoreIndexedScanning()\n{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n    new ClassSpaceScanner( new SisuIndexFinder( false ), space ).accept( visitor );\n\n    // we deliberately use a partial index\n\n    assertEquals( 2, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( C.class ) );\n    assertTrue( listener.clazzes.contains( D.class ) );\n}",
                "name": "ignoreIndexedScanning",
                "modifiers": "@Ignore( \"Need to replace some test archives\" )\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final TestListener listener = new TestListener();\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n    final ClassSpaceVisitor visitor = new QualifiedTypeVisitor( listener );\n    new ClassSpaceScanner( new SisuIndexFinder( false ), space ).accept( visitor );\n\n    // we deliberately use a partial index\n\n    assertEquals( 2, listener.clazzes.size() );\n\n    assertTrue( listener.clazzes.contains( C.class ) );\n    assertTrue( listener.clazzes.contains( D.class ) );\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 183,
                    "column": 5
                }
            },
            {
                "definition": "public void testBrokenScanning()\n    throws IOException\n{\n    // System.setProperty( \"java.protocol.handler.pkgs\", getClass().getPackage().getName() );\n    URL.setURLStreamHandlerFactory( new URLStreamHandlerFactory()\n    {\n        public URLStreamHandler createURLStreamHandler( final String protocol )\n        {\n            if ( \"oops\".equals( protocol ) )\n            {\n                return new Handler();\n            }\n            return null;\n        }\n    } );\n\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n\n    final URL badURL = new URL( \"oops:bad/\" );\n    final ClassSpace brokenResourceSpace = new ClassSpace()\n    {\n        public Class<?> loadClass( final String name )\n        {\n            return space.loadClass( name );\n        }\n\n        public DeferredClass<?> deferLoadClass( final String name )\n        {\n            return space.deferLoadClass( name );\n        }\n\n        public Enumeration<URL> getResources( final String name )\n        {\n            return space.getResources( name );\n        }\n\n        public URL getResource( final String name )\n        {\n            return badURL;\n        }\n\n        public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n        {\n            return Collections.enumeration( Collections.singleton( badURL ) );\n        }\n    };\n\n    new ClassSpaceScanner( brokenResourceSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n    final ClassSpace brokenLoadSpace = new ClassSpace()\n    {\n        public Class<?> loadClass( final String name )\n        {\n            throw new TypeNotPresentException( name, new ClassNotFoundException( name ) );\n        }\n\n        public DeferredClass<?> deferLoadClass( final String name )\n        {\n            return space.deferLoadClass( name );\n        }\n\n        public Enumeration<URL> getResources( final String name )\n        {\n            return space.getResources( name );\n        }\n\n        public URL getResource( final String name )\n        {\n            return space.getResource( name );\n        }\n\n        public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n        {\n            return space.findEntries( path, glob, recurse );\n        }\n    };\n\n    new ClassSpaceScanner( brokenLoadSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n    ClassSpaceScanner.accept( null, null );\n\n    assertFalse( new SisuIndexFinder( false ).findClasses( brokenResourceSpace ).hasMoreElements() );\n}",
                "name": "testBrokenScanning",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // System.setProperty( \"java.protocol.handler.pkgs\", getClass().getPackage().getName() );\n    URL.setURLStreamHandlerFactory( new URLStreamHandlerFactory()\n    {\n        public URLStreamHandler createURLStreamHandler( final String protocol )\n        {\n            if ( \"oops\".equals( protocol ) )\n            {\n                return new Handler();\n            }\n            return null;\n        }\n    } );\n\n    final ClassSpace space =\n        new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } );\n\n    final URL badURL = new URL( \"oops:bad/\" );\n    final ClassSpace brokenResourceSpace = new ClassSpace()\n    {\n        public Class<?> loadClass( final String name )\n        {\n            return space.loadClass( name );\n        }\n\n        public DeferredClass<?> deferLoadClass( final String name )\n        {\n            return space.deferLoadClass( name );\n        }\n\n        public Enumeration<URL> getResources( final String name )\n        {\n            return space.getResources( name );\n        }\n\n        public URL getResource( final String name )\n        {\n            return badURL;\n        }\n\n        public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n        {\n            return Collections.enumeration( Collections.singleton( badURL ) );\n        }\n    };\n\n    new ClassSpaceScanner( brokenResourceSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n    final ClassSpace brokenLoadSpace = new ClassSpace()\n    {\n        public Class<?> loadClass( final String name )\n        {\n            throw new TypeNotPresentException( name, new ClassNotFoundException( name ) );\n        }\n\n        public DeferredClass<?> deferLoadClass( final String name )\n        {\n            return space.deferLoadClass( name );\n        }\n\n        public Enumeration<URL> getResources( final String name )\n        {\n            return space.getResources( name );\n        }\n\n        public URL getResource( final String name )\n        {\n            return space.getResource( name );\n        }\n\n        public Enumeration<URL> findEntries( final String path, final String glob, final boolean recurse )\n        {\n            return space.findEntries( path, glob, recurse );\n        }\n    };\n\n    new ClassSpaceScanner( brokenLoadSpace ).accept( new QualifiedTypeVisitor( null ) );\n\n    ClassSpaceScanner.accept( null, null );\n\n    assertFalse( new SisuIndexFinder( false ).findClasses( brokenResourceSpace ).hasMoreElements() );\n}",
                "start_point": {
                    "row": 185,
                    "column": 4
                },
                "end_point": {
                    "row": 268,
                    "column": 5
                }
            },
            {
                "definition": "public void testSourceDetection()\n    throws MalformedURLException\n{\n    final TestListener listener = new TestListener();\n\n    final QualifiedTypeVisitor visitor = new QualifiedTypeVisitor( listener );\n\n    visitor.visit( new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } ) );\n\n    assertEquals( 0, listener.sources.size() );\n\n    visitor.visitClass( new URL( \"file:target/classes/java/lang/Object.class\" ) );\n    visitor.visit( 0, 0, Type.getInternalName( Object.class ), null, null, null );\n    visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n    visitor.visitEnd();\n\n    assertEquals( 1, listener.sources.size() );\n    assertTrue( listener.sources.contains( \"target/classes/\" ) );\n\n    visitor.visitClass( new URL( \"jar:file:bar.jar!/java/lang/String.class\" ) );\n    visitor.visit( 0, 0, Type.getInternalName( String.class ), null, null, null );\n    visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n    visitor.visitEnd();\n\n    assertEquals( 2, listener.sources.size() );\n    assertTrue( listener.sources.contains( \"target/classes/\" ) );\n    assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n\n    visitor.visitClass( new URL( \"file:some/obfuscated/location\" ) );\n    visitor.visit( 0, 0, Type.getInternalName( Integer.class ), null, null, null );\n    visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n    visitor.visitEnd();\n\n    assertEquals( 3, listener.sources.size() );\n    assertTrue( listener.sources.contains( \"target/classes/\" ) );\n    assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n    assertTrue( listener.sources.contains( \"some/obfuscated/location\" ) );\n}",
                "name": "testSourceDetection",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final TestListener listener = new TestListener();\n\n    final QualifiedTypeVisitor visitor = new QualifiedTypeVisitor( listener );\n\n    visitor.visit( new URLClassSpace( getClass().getClassLoader(), new URL[] { getClass().getResource( \"\" ) } ) );\n\n    assertEquals( 0, listener.sources.size() );\n\n    visitor.visitClass( new URL( \"file:target/classes/java/lang/Object.class\" ) );\n    visitor.visit( 0, 0, Type.getInternalName( Object.class ), null, null, null );\n    visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n    visitor.visitEnd();\n\n    assertEquals( 1, listener.sources.size() );\n    assertTrue( listener.sources.contains( \"target/classes/\" ) );\n\n    visitor.visitClass( new URL( \"jar:file:bar.jar!/java/lang/String.class\" ) );\n    visitor.visit( 0, 0, Type.getInternalName( String.class ), null, null, null );\n    visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n    visitor.visitEnd();\n\n    assertEquals( 2, listener.sources.size() );\n    assertTrue( listener.sources.contains( \"target/classes/\" ) );\n    assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n\n    visitor.visitClass( new URL( \"file:some/obfuscated/location\" ) );\n    visitor.visit( 0, 0, Type.getInternalName( Integer.class ), null, null, null );\n    visitor.visitAnnotation( Type.getDescriptor( Named.class ), true );\n    visitor.visitEnd();\n\n    assertEquals( 3, listener.sources.size() );\n    assertTrue( listener.sources.contains( \"target/classes/\" ) );\n    assertTrue( listener.sources.contains( \"file:bar.jar!/\" ) );\n    assertTrue( listener.sources.contains( \"some/obfuscated/location\" ) );\n}",
                "start_point": {
                    "row": 270,
                    "column": 4
                },
                "end_point": {
                    "row": 307,
                    "column": 5
                }
            },
            {
                "definition": "public void testOptionalLogging()\n    throws Exception\n{\n    final Level level = Logger.getLogger( \"\" ).getLevel();\n    try\n    {\n        Logger.getLogger( \"\" ).setLevel( Level.SEVERE );\n\n        // check everything still works without any SLF4J jars\n        final ClassLoader noLoggingLoader =\n            new URLClassLoader( ( (URLClassLoader) getClass().getClassLoader() ).getURLs(), null )\n            {\n                @Override\n                protected synchronized Class<?> loadClass( final String name, final boolean resolve )\n                    throws ClassNotFoundException\n                {\n                    if ( name.contains( \"slf4j\" ) )\n                    {\n                        throw new ClassNotFoundException( name );\n                    }\n                    if ( name.contains( \"cobertura\" ) )\n                    {\n                        return QualifiedScanningTest.class.getClassLoader().loadClass( name );\n                    }\n                    return super.loadClass( name, resolve );\n                }\n            };\n\n        noLoggingLoader.loadClass( BrokenScanningExample.class.getName() ).newInstance();\n    }\n    finally\n    {\n        Logger.getLogger( \"\" ).setLevel( level );\n    }\n}",
                "name": "testOptionalLogging",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final Level level = Logger.getLogger( \"\" ).getLevel();\n    try\n    {\n        Logger.getLogger( \"\" ).setLevel( Level.SEVERE );\n\n        // check everything still works without any SLF4J jars\n        final ClassLoader noLoggingLoader =\n            new URLClassLoader( ( (URLClassLoader) getClass().getClassLoader() ).getURLs(), null )\n            {\n                @Override\n                protected synchronized Class<?> loadClass( final String name, final boolean resolve )\n                    throws ClassNotFoundException\n                {\n                    if ( name.contains( \"slf4j\" ) )\n                    {\n                        throw new ClassNotFoundException( name );\n                    }\n                    if ( name.contains( \"cobertura\" ) )\n                    {\n                        return QualifiedScanningTest.class.getClassLoader().loadClass( name );\n                    }\n                    return super.loadClass( name, resolve );\n                }\n            };\n\n        noLoggingLoader.loadClass( BrokenScanningExample.class.getName() ).newInstance();\n    }\n    finally\n    {\n        Logger.getLogger( \"\" ).setLevel( level );\n    }\n}",
                "start_point": {
                    "row": 309,
                    "column": 4
                },
                "end_point": {
                    "row": 343,
                    "column": 5
                }
            },
            {
                "definition": "public void testICU4J()\n{\n    final ClassLoader loader = getClass().getClassLoader();\n    final URL[] urls = { loader.getResource( \"icu4j-2.6.1.jar\" ) };\n    final ClassSpace space = new URLClassSpace( loader, urls );\n\n    final TestListener listener = new TestListener();\n    new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n    assertEquals( 0, listener.clazzes.size() );\n}",
                "name": "testICU4J",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    final ClassLoader loader = getClass().getClassLoader();\n    final URL[] urls = { loader.getResource( \"icu4j-2.6.1.jar\" ) };\n    final ClassSpace space = new URLClassSpace( loader, urls );\n\n    final TestListener listener = new TestListener();\n    new ClassSpaceScanner( space ).accept( new QualifiedTypeVisitor( listener ) );\n    assertEquals( 0, listener.clazzes.size() );\n}",
                "start_point": {
                    "row": 345,
                    "column": 4
                },
                "end_point": {
                    "row": 354,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "@Named\nstatic abstract class B\n{\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest.B",
        "name": "B",
        "modifiers": "@Named\n    static abstract",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n}",
        "start_point": {
            "row": 50,
            "column": 4
        },
        "end_point": {
            "row": 53,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": []
    },
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "@Named\nstatic class C\n{\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest.C",
        "name": "C",
        "modifiers": "@Named\n    static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n}",
        "start_point": {
            "row": 55,
            "column": 4
        },
        "end_point": {
            "row": 58,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": []
    },
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "@Named\n@Legacy\nstatic class D\n{\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest.D",
        "name": "D",
        "modifiers": "@Named\n    @Legacy\n    static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n}",
        "start_point": {
            "row": 66,
            "column": 4
        },
        "end_point": {
            "row": 70,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": []
    },
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "@Legacy\n@Named\nstatic class E\n{\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest.E",
        "name": "E",
        "modifiers": "@Legacy\n    @Named\n    static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n}",
        "start_point": {
            "row": 72,
            "column": 4
        },
        "end_point": {
            "row": 76,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": []
    },
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "static class F\n    extends B\n{\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest.F",
        "name": "F",
        "modifiers": "static",
        "superclass": "extends B",
        "super_interfaces": null,
        "body": "{\n}",
        "start_point": {
            "row": 78,
            "column": 4
        },
        "end_point": {
            "row": 81,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": []
    },
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "@Singleton\nstatic class G\n{\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest.G",
        "name": "G",
        "modifiers": "@Singleton\n    static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n}",
        "start_point": {
            "row": 83,
            "column": 4
        },
        "end_point": {
            "row": 86,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": []
    },
    {
        "rev_path": "org.eclipse.sisu.inject.tests/src/org/eclipse/sisu/space/QualifiedScanningTest.java",
        "definition": "static class TestListener\n    implements QualifiedTypeListener\n{\n    final List<Class<?>> clazzes = new ArrayList<Class<?>>();\n\n    final Set<Object> sources = new HashSet<Object>();\n\n    public void hear( final Annotation qualifier, final Class<?> clazz, final Object source )\n    {\n        clazzes.add( clazz );\n        sources.add( source );\n    }\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedScanningTest.TestListener",
        "name": "TestListener",
        "modifiers": "static",
        "superclass": null,
        "super_interfaces": "implements QualifiedTypeListener",
        "body": "{\n    final List<Class<?>> clazzes = new ArrayList<Class<?>>();\n\n    final Set<Object> sources = new HashSet<Object>();\n\n    public void hear( final Annotation qualifier, final Class<?> clazz, final Object source )\n    {\n        clazzes.add( clazz );\n        sources.add( source );\n    }\n}",
        "start_point": {
            "row": 88,
            "column": 4
        },
        "end_point": {
            "row": 100,
            "column": 5
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public void hear( final Annotation qualifier, final Class<?> clazz, final Object source )\n{\n    clazzes.add( clazz );\n    sources.add( source );\n}",
                "name": "hear",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Annotation"
                    },
                    {
                        "type": "final",
                        "name": "Class<?>"
                    },
                    {
                        "type": "final",
                        "name": "Object"
                    }
                ],
                "body": "{\n    clazzes.add( clazz );\n    sources.add( source );\n}",
                "start_point": {
                    "row": 95,
                    "column": 8
                },
                "end_point": {
                    "row": 99,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "org.eclipse.sisu.inject/src/org/eclipse/sisu/space/QualifiedTypeVisitor.java",
        "definition": "public final class QualifiedTypeVisitor\n    extends ClassVisitor\n    implements ClassSpaceVisitor\n{\n    // ----------------------------------------------------------------------\n    // Implementation fields\n    // ----------------------------------------------------------------------\n\n    private final QualifierCache qualifierCache = new QualifierCache();\n\n    private final QualifiedTypeListener listener;\n\n    private ClassSpace space;\n\n    private URL location;\n\n    private String source;\n\n    private String clazzName;\n\n    private boolean qualified;\n\n    // ----------------------------------------------------------------------\n    // Constructors\n    // ----------------------------------------------------------------------\n\n    public QualifiedTypeVisitor( final QualifiedTypeListener listener )\n    {\n        super( Opcodes.ASM4 );\n        this.listener = listener;\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    public static boolean verify( final ClassSpace space, final Class<?>... specification )\n    {\n        for ( final Class<?> expectedClazz : specification )\n        {\n            try\n            {\n                final Class<?> spaceClazz = space.loadClass( expectedClazz.getName() );\n                if ( spaceClazz != expectedClazz )\n                {\n                    Logs.warn( \"Inconsistent ClassLoader for: {} in: {}\", expectedClazz, space );\n                    Logs.warn( \"Expected: {} saw: {}\", expectedClazz.getClassLoader(), spaceClazz.getClassLoader() );\n                }\n            }\n            catch ( final TypeNotPresentException e )\n            {\n                if ( expectedClazz.isAnnotation() )\n                {\n                    Logs.trace( \"Potential problem: {} is not visible from: {}\", expectedClazz, space );\n                }\n            }\n        }\n        return true;\n    }\n\n    public void visit( final ClassSpace _space )\n    {\n        space = _space;\n        source = null;\n\n        if ( Logs.TRACE_ENABLED )\n        {\n            verify( _space, Qualifier.class, Module.class );\n        }\n    }\n\n    public ClassVisitor visitClass( final URL url )\n    {\n        location = url;\n        clazzName = null;\n        qualified = false;\n\n        return this;\n    }\n\n    @Override\n    public void visit( final int version, final int access, final String name, final String signature,\n                       final String superName, final String[] interfaces )\n    {\n        if ( ( access & ( Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_SYNTHETIC ) ) == 0 )\n        {\n            clazzName = name; // concrete type\n        }\n    }\n\n    @Override\n    public AnnotationVisitor visitAnnotation( final String desc, final boolean visible )\n    {\n        if ( null != clazzName )\n        {\n            qualified = qualified || qualifierCache.qualify( space, desc );\n        }\n        return null;\n    }\n\n    @Override\n    public void visitEnd()\n    {\n        if ( qualified )\n        {\n            qualified = false; // we might be called twice (once per-class, once per-space)\n\n            // compressed record of class location\n            final String path = location.getPath();\n            if ( null == source || !path.startsWith( source ) )\n            {\n                final int i = path.indexOf( clazzName );\n                source = i <= 0 ? path : path.substring( 0, i );\n            }\n\n            listener.hear( null, space.loadClass( clazzName.replace( '/', '.' ) ), source );\n        }\n    }\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifiedTypeVisitor",
        "name": "QualifiedTypeVisitor",
        "modifiers": "public final",
        "superclass": "extends ClassVisitor",
        "super_interfaces": "implements ClassSpaceVisitor",
        "body": "{\n    // ----------------------------------------------------------------------\n    // Implementation fields\n    // ----------------------------------------------------------------------\n\n    private final QualifierCache qualifierCache = new QualifierCache();\n\n    private final QualifiedTypeListener listener;\n\n    private ClassSpace space;\n\n    private URL location;\n\n    private String source;\n\n    private String clazzName;\n\n    private boolean qualified;\n\n    // ----------------------------------------------------------------------\n    // Constructors\n    // ----------------------------------------------------------------------\n\n    public QualifiedTypeVisitor( final QualifiedTypeListener listener )\n    {\n        super( Opcodes.ASM4 );\n        this.listener = listener;\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    public static boolean verify( final ClassSpace space, final Class<?>... specification )\n    {\n        for ( final Class<?> expectedClazz : specification )\n        {\n            try\n            {\n                final Class<?> spaceClazz = space.loadClass( expectedClazz.getName() );\n                if ( spaceClazz != expectedClazz )\n                {\n                    Logs.warn( \"Inconsistent ClassLoader for: {} in: {}\", expectedClazz, space );\n                    Logs.warn( \"Expected: {} saw: {}\", expectedClazz.getClassLoader(), spaceClazz.getClassLoader() );\n                }\n            }\n            catch ( final TypeNotPresentException e )\n            {\n                if ( expectedClazz.isAnnotation() )\n                {\n                    Logs.trace( \"Potential problem: {} is not visible from: {}\", expectedClazz, space );\n                }\n            }\n        }\n        return true;\n    }\n\n    public void visit( final ClassSpace _space )\n    {\n        space = _space;\n        source = null;\n\n        if ( Logs.TRACE_ENABLED )\n        {\n            verify( _space, Qualifier.class, Module.class );\n        }\n    }\n\n    public ClassVisitor visitClass( final URL url )\n    {\n        location = url;\n        clazzName = null;\n        qualified = false;\n\n        return this;\n    }\n\n    @Override\n    public void visit( final int version, final int access, final String name, final String signature,\n                       final String superName, final String[] interfaces )\n    {\n        if ( ( access & ( Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_SYNTHETIC ) ) == 0 )\n        {\n            clazzName = name; // concrete type\n        }\n    }\n\n    @Override\n    public AnnotationVisitor visitAnnotation( final String desc, final boolean visible )\n    {\n        if ( null != clazzName )\n        {\n            qualified = qualified || qualifierCache.qualify( space, desc );\n        }\n        return null;\n    }\n\n    @Override\n    public void visitEnd()\n    {\n        if ( qualified )\n        {\n            qualified = false; // we might be called twice (once per-class, once per-space)\n\n            // compressed record of class location\n            final String path = location.getPath();\n            if ( null == source || !path.startsWith( source ) )\n            {\n                final int i = path.indexOf( clazzName );\n                source = i <= 0 ? path : path.substring( 0, i );\n            }\n\n            listener.hear( null, space.loadClass( clazzName.replace( '/', '.' ) ), source );\n        }\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 144,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public QualifiedTypeVisitor( final QualifiedTypeListener listener )\n{\n    super( Opcodes.ASM4 );\n    this.listener = listener;\n}",
                "name": "QualifiedTypeVisitor",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "final",
                        "name": "QualifiedTypeListener"
                    }
                ],
                "body": "{\n    super( Opcodes.ASM4 );\n    this.listener = listener;\n}",
                "constructor": true,
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "public static boolean verify( final ClassSpace space, final Class<?>... specification )\n{\n    for ( final Class<?> expectedClazz : specification )\n    {\n        try\n        {\n            final Class<?> spaceClazz = space.loadClass( expectedClazz.getName() );\n            if ( spaceClazz != expectedClazz )\n            {\n                Logs.warn( \"Inconsistent ClassLoader for: {} in: {}\", expectedClazz, space );\n                Logs.warn( \"Expected: {} saw: {}\", expectedClazz.getClassLoader(), spaceClazz.getClassLoader() );\n            }\n        }\n        catch ( final TypeNotPresentException e )\n        {\n            if ( expectedClazz.isAnnotation() )\n            {\n                Logs.trace( \"Potential problem: {} is not visible from: {}\", expectedClazz, space );\n            }\n        }\n    }\n    return true;\n}",
                "name": "verify",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "ClassSpace"
                    }
                ],
                "body": "{\n    for ( final Class<?> expectedClazz : specification )\n    {\n        try\n        {\n            final Class<?> spaceClazz = space.loadClass( expectedClazz.getName() );\n            if ( spaceClazz != expectedClazz )\n            {\n                Logs.warn( \"Inconsistent ClassLoader for: {} in: {}\", expectedClazz, space );\n                Logs.warn( \"Expected: {} saw: {}\", expectedClazz.getClassLoader(), spaceClazz.getClassLoader() );\n            }\n        }\n        catch ( final TypeNotPresentException e )\n        {\n            if ( expectedClazz.isAnnotation() )\n            {\n                Logs.trace( \"Potential problem: {} is not visible from: {}\", expectedClazz, space );\n            }\n        }\n    }\n    return true;\n}",
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "public void visit( final ClassSpace _space )\n{\n    space = _space;\n    source = null;\n\n    if ( Logs.TRACE_ENABLED )\n    {\n        verify( _space, Qualifier.class, Module.class );\n    }\n}",
                "name": "visit",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "ClassSpace"
                    }
                ],
                "body": "{\n    space = _space;\n    source = null;\n\n    if ( Logs.TRACE_ENABLED )\n    {\n        verify( _space, Qualifier.class, Module.class );\n    }\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "public ClassVisitor visitClass( final URL url )\n{\n    location = url;\n    clazzName = null;\n    qualified = false;\n\n    return this;\n}",
                "name": "visitClass",
                "modifiers": "public",
                "return_type": "ClassVisitor",
                "parameters": [
                    {
                        "type": "final",
                        "name": "URL"
                    }
                ],
                "body": "{\n    location = url;\n    clazzName = null;\n    qualified = false;\n\n    return this;\n}",
                "start_point": {
                    "row": 97,
                    "column": 4
                },
                "end_point": {
                    "row": 104,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void visit( final int version, final int access, final String name, final String signature,\n                   final String superName, final String[] interfaces )\n{\n    if ( ( access & ( Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_SYNTHETIC ) ) == 0 )\n    {\n        clazzName = name; // concrete type\n    }\n}",
                "name": "visit",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "int"
                    },
                    {
                        "type": "final",
                        "name": "int"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "String[]"
                    }
                ],
                "body": "{\n    if ( ( access & ( Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT | Opcodes.ACC_SYNTHETIC ) ) == 0 )\n    {\n        clazzName = name; // concrete type\n    }\n}",
                "start_point": {
                    "row": 106,
                    "column": 4
                },
                "end_point": {
                    "row": 114,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic AnnotationVisitor visitAnnotation( final String desc, final boolean visible )\n{\n    if ( null != clazzName )\n    {\n        qualified = qualified || qualifierCache.qualify( space, desc );\n    }\n    return null;\n}",
                "name": "visitAnnotation",
                "modifiers": "@Override\n    public",
                "return_type": "AnnotationVisitor",
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "boolean"
                    }
                ],
                "body": "{\n    if ( null != clazzName )\n    {\n        qualified = qualified || qualifierCache.qualify( space, desc );\n    }\n    return null;\n}",
                "start_point": {
                    "row": 116,
                    "column": 4
                },
                "end_point": {
                    "row": 124,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void visitEnd()\n{\n    if ( qualified )\n    {\n        qualified = false; // we might be called twice (once per-class, once per-space)\n\n        // compressed record of class location\n        final String path = location.getPath();\n        if ( null == source || !path.startsWith( source ) )\n        {\n            final int i = path.indexOf( clazzName );\n            source = i <= 0 ? path : path.substring( 0, i );\n        }\n\n        listener.hear( null, space.loadClass( clazzName.replace( '/', '.' ) ), source );\n    }\n}",
                "name": "visitEnd",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    if ( qualified )\n    {\n        qualified = false; // we might be called twice (once per-class, once per-space)\n\n        // compressed record of class location\n        final String path = location.getPath();\n        if ( null == source || !path.startsWith( source ) )\n        {\n            final int i = path.indexOf( clazzName );\n            source = i <= 0 ? path : path.substring( 0, i );\n        }\n\n        listener.hear( null, space.loadClass( clazzName.replace( '/', '.' ) ), source );\n    }\n}",
                "start_point": {
                    "row": 126,
                    "column": 4
                },
                "end_point": {
                    "row": 143,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "org.eclipse.sisu.inject/src/org/eclipse/sisu/space/QualifierCache.java",
        "definition": "final class QualifierCache\n    extends ClassVisitor\n{\n    // ----------------------------------------------------------------------\n    // Constants\n    // ----------------------------------------------------------------------\n\n    private static final String QUALIFIER_DESC = Type.getDescriptor( Qualifier.class );\n\n    // ----------------------------------------------------------------------\n    // Implementation fields\n    // ----------------------------------------------------------------------\n\n    private static final Map<String, Boolean> cachedResults = new ConcurrentHashMap<String, Boolean>( 32, 0.75f, 1 );\n\n    private boolean isQualified;\n\n    // ----------------------------------------------------------------------\n    // Constructors\n    // ----------------------------------------------------------------------\n\n    QualifierCache()\n    {\n        super( Opcodes.ASM4 );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    @Override\n    public AnnotationVisitor visitAnnotation( final String desc, final boolean visible )\n    {\n        isQualified |= QUALIFIER_DESC.equals( desc );\n        return null;\n    }\n\n    // ----------------------------------------------------------------------\n    // Local methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Attempts to load the potential {@link Qualifier} annotation and return its class.\n     * \n     * @param space The class space\n     * @param desc The annotation descriptor\n     * @return {@code true} if the annotation is a qualifier; otherwise {@code false}\n     */\n    boolean qualify( final ClassSpace space, final String desc )\n    {\n        final Boolean result = cachedResults.get( desc );\n        if ( null == result )\n        {\n            isQualified = false;\n\n            final String name = desc.substring( 1, desc.length() - 1 );\n            ClassSpaceScanner.accept( this, space.getResource( name + \".class\" ) );\n            cachedResults.put( desc, Boolean.valueOf( isQualified ) );\n\n            return isQualified;\n        }\n        return result.booleanValue();\n    }\n}",
        "package": "package org.eclipse.sisu.space;",
        "tree_path": "QualifierCache",
        "name": "QualifierCache",
        "modifiers": "final",
        "superclass": "extends ClassVisitor",
        "super_interfaces": null,
        "body": "{\n    // ----------------------------------------------------------------------\n    // Constants\n    // ----------------------------------------------------------------------\n\n    private static final String QUALIFIER_DESC = Type.getDescriptor( Qualifier.class );\n\n    // ----------------------------------------------------------------------\n    // Implementation fields\n    // ----------------------------------------------------------------------\n\n    private static final Map<String, Boolean> cachedResults = new ConcurrentHashMap<String, Boolean>( 32, 0.75f, 1 );\n\n    private boolean isQualified;\n\n    // ----------------------------------------------------------------------\n    // Constructors\n    // ----------------------------------------------------------------------\n\n    QualifierCache()\n    {\n        super( Opcodes.ASM4 );\n    }\n\n    // ----------------------------------------------------------------------\n    // Public methods\n    // ----------------------------------------------------------------------\n\n    @Override\n    public AnnotationVisitor visitAnnotation( final String desc, final boolean visible )\n    {\n        isQualified |= QUALIFIER_DESC.equals( desc );\n        return null;\n    }\n\n    // ----------------------------------------------------------------------\n    // Local methods\n    // ----------------------------------------------------------------------\n\n    /**\n     * Attempts to load the potential {@link Qualifier} annotation and return its class.\n     * \n     * @param space The class space\n     * @param desc The annotation descriptor\n     * @return {@code true} if the annotation is a qualifier; otherwise {@code false}\n     */\n    boolean qualify( final ClassSpace space, final String desc )\n    {\n        final Boolean result = cachedResults.get( desc );\n        if ( null == result )\n        {\n            isQualified = false;\n\n            final String name = desc.substring( 1, desc.length() - 1 );\n            ClassSpaceScanner.accept( this, space.getResource( name + \".class\" ) );\n            cachedResults.put( desc, Boolean.valueOf( isQualified ) );\n\n            return isQualified;\n        }\n        return result.booleanValue();\n    }\n}",
        "start_point": {
            "row": 25,
            "column": 0
        },
        "end_point": {
            "row": 88,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "QualifierCache()\n{\n    super( Opcodes.ASM4 );\n}",
                "name": "QualifierCache",
                "modifiers": null,
                "parameters": [],
                "body": "{\n    super( Opcodes.ASM4 );\n}",
                "constructor": true,
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic AnnotationVisitor visitAnnotation( final String desc, final boolean visible )\n{\n    isQualified |= QUALIFIER_DESC.equals( desc );\n    return null;\n}",
                "name": "visitAnnotation",
                "modifiers": "@Override\n    public",
                "return_type": "AnnotationVisitor",
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "boolean"
                    }
                ],
                "body": "{\n    isQualified |= QUALIFIER_DESC.equals( desc );\n    return null;\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 60,
                    "column": 5
                }
            },
            {
                "definition": "boolean qualify( final ClassSpace space, final String desc )\n{\n    final Boolean result = cachedResults.get( desc );\n    if ( null == result )\n    {\n        isQualified = false;\n\n        final String name = desc.substring( 1, desc.length() - 1 );\n        ClassSpaceScanner.accept( this, space.getResource( name + \".class\" ) );\n        cachedResults.put( desc, Boolean.valueOf( isQualified ) );\n\n        return isQualified;\n    }\n    return result.booleanValue();\n}",
                "name": "qualify",
                "modifiers": null,
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "ClassSpace"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    }
                ],
                "body": "{\n    final Boolean result = cachedResults.get( desc );\n    if ( null == result )\n    {\n        isQualified = false;\n\n        final String name = desc.substring( 1, desc.length() - 1 );\n        ClassSpaceScanner.accept( this, space.getResource( name + \".class\" ) );\n        cachedResults.put( desc, Boolean.valueOf( isQualified ) );\n\n        return isQualified;\n    }\n    return result.booleanValue();\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 87,
                    "column": 5
                }
            }
        ]
    }
]