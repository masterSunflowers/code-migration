[
    {
        "rev_path": "gravitee-am-certificate/gravitee-am-certificate-javakeystore/src/main/java/io/gravitee/am/certificate/javakeystore/provider/JavaKeyStoreProvider.java",
        "definition": "public class JavaKeyStoreProvider implements CertificateProvider, InitializingBean {\n\n    private KeyPair keyPair;\n    private Signer signer;\n\n    @Autowired\n    private JavaKeyStoreConfiguration configuration;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        keyPair = new KeyStoreKeyFactory(new InputStreamResource(new FileInputStream(new File(configuration.getJks()))),\n                configuration.getStorepass().toCharArray()).getKeyPair(configuration.getAlias(), configuration.getKeypass().toCharArray());\n        signer = new RsaSigner((RSAPrivateKey) keyPair.getPrivate());\n    }\n\n    @Override\n    public String sign(String payload) {\n        return JwtHelper.encode(payload, signer).getEncoded();\n    }\n\n    @Override\n    public String publicKey() {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n       /* encode the \"ssh-rsa\" string */\n        try {\n            byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n            out.write(sshrsa);\n            /* Encode the public exponent */\n            BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n            byte[] data = e.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            /* Encode the modulus */\n            BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n            data = m.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            return Base64.getEncoder().encodeToString(out.toByteArray());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private void encodeUInt32(int value, OutputStream out) throws IOException {\n        byte[] tmp = new byte[4];\n        tmp[0] = (byte)((value >>> 24) & 0xff);\n        tmp[1] = (byte)((value >>> 16) & 0xff);\n        tmp[2] = (byte)((value >>> 8) & 0xff);\n        tmp[3] = (byte)(value & 0xff);\n        out.write(tmp);\n    }\n\n\n}",
        "package": "package io.gravitee.am.certificate.javakeystore.provider;",
        "tree_path": "JavaKeyStoreProvider",
        "name": "JavaKeyStoreProvider",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements CertificateProvider, InitializingBean",
        "body": "{\n\n    private KeyPair keyPair;\n    private Signer signer;\n\n    @Autowired\n    private JavaKeyStoreConfiguration configuration;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        keyPair = new KeyStoreKeyFactory(new InputStreamResource(new FileInputStream(new File(configuration.getJks()))),\n                configuration.getStorepass().toCharArray()).getKeyPair(configuration.getAlias(), configuration.getKeypass().toCharArray());\n        signer = new RsaSigner((RSAPrivateKey) keyPair.getPrivate());\n    }\n\n    @Override\n    public String sign(String payload) {\n        return JwtHelper.encode(payload, signer).getEncoded();\n    }\n\n    @Override\n    public String publicKey() {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n       /* encode the \"ssh-rsa\" string */\n        try {\n            byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n            out.write(sshrsa);\n            /* Encode the public exponent */\n            BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n            byte[] data = e.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            /* Encode the modulus */\n            BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n            data = m.toByteArray();\n            encodeUInt32(data.length, out);\n            out.write(data);\n            return Base64.getEncoder().encodeToString(out.toByteArray());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    private void encodeUInt32(int value, OutputStream out) throws IOException {\n        byte[] tmp = new byte[4];\n        tmp[0] = (byte)((value >>> 24) & 0xff);\n        tmp[1] = (byte)((value >>> 16) & 0xff);\n        tmp[2] = (byte)((value >>> 8) & 0xff);\n        tmp[3] = (byte)(value & 0xff);\n        out.write(tmp);\n    }\n\n\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 91,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void afterPropertiesSet() throws Exception {\n    keyPair = new KeyStoreKeyFactory(new InputStreamResource(new FileInputStream(new File(configuration.getJks()))),\n            configuration.getStorepass().toCharArray()).getKeyPair(configuration.getAlias(), configuration.getKeypass().toCharArray());\n    signer = new RsaSigner((RSAPrivateKey) keyPair.getPrivate());\n}",
                "name": "afterPropertiesSet",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    keyPair = new KeyStoreKeyFactory(new InputStreamResource(new FileInputStream(new File(configuration.getJks()))),\n            configuration.getStorepass().toCharArray()).getKeyPair(configuration.getAlias(), configuration.getKeypass().toCharArray());\n    signer = new RsaSigner((RSAPrivateKey) keyPair.getPrivate());\n}",
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String sign(String payload) {\n    return JwtHelper.encode(payload, signer).getEncoded();\n}",
                "name": "sign",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "payload"
                    }
                ],
                "body": "{\n    return JwtHelper.encode(payload, signer).getEncoded();\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String publicKey() {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n   /* encode the \"ssh-rsa\" string */\n    try {\n        byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n        out.write(sshrsa);\n        /* Encode the public exponent */\n        BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n        byte[] data = e.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        /* Encode the modulus */\n        BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n        data = m.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        return Base64.getEncoder().encodeToString(out.toByteArray());\n    } catch (Exception e) {\n        return null;\n    }\n}",
                "name": "publicKey",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n   /* encode the \"ssh-rsa\" string */\n    try {\n        byte[] sshrsa = new byte[] {0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a'};\n        out.write(sshrsa);\n        /* Encode the public exponent */\n        BigInteger e = ((RSAPublicKey) keyPair.getPublic()).getPublicExponent();\n        byte[] data = e.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        /* Encode the modulus */\n        BigInteger m = ((RSAPublicKey) keyPair.getPublic()).getModulus();\n        data = m.toByteArray();\n        encodeUInt32(data.length, out);\n        out.write(data);\n        return Base64.getEncoder().encodeToString(out.toByteArray());\n    } catch (Exception e) {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "private void encodeUInt32(int value, OutputStream out) throws IOException {\n    byte[] tmp = new byte[4];\n    tmp[0] = (byte)((value >>> 24) & 0xff);\n    tmp[1] = (byte)((value >>> 16) & 0xff);\n    tmp[2] = (byte)((value >>> 8) & 0xff);\n    tmp[3] = (byte)(value & 0xff);\n    out.write(tmp);\n}",
                "name": "encodeUInt32",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "int",
                        "name": "value"
                    },
                    {
                        "type": "OutputStream",
                        "name": "out"
                    }
                ],
                "body": "{\n    byte[] tmp = new byte[4];\n    tmp[0] = (byte)((value >>> 24) & 0xff);\n    tmp[1] = (byte)((value >>> 16) & 0xff);\n    tmp[2] = (byte)((value >>> 8) & 0xff);\n    tmp[3] = (byte)(value & 0xff);\n    out.write(tmp);\n}",
                "start_point": {
                    "row": 81,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-identityprovider/gravitee-am-identityprovider-github/src/main/java/io/gravitee/am/identityprovider/github/authentication/GithubAuthenticationProvider.java",
        "definition": "@Import(GithubAuthenticationProviderConfiguration.class)\npublic class GithubAuthenticationProvider implements OAuth2AuthenticationProvider {\n\n    private static final Logger logger = LoggerFactory.getLogger(GithubAuthenticationProvider.class);\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            Map<String, String> params = extractMap(content);\n            String accessToken = params.get(\"access_token\");\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"token \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate github user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n        additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n        additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n        additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n        additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n        additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n        additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n        additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n        additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n        additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n        additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n        additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n        additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n        additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n        additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n    }\n}",
        "package": "package io.gravitee.am.identityprovider.github.authentication;",
        "tree_path": "GithubAuthenticationProvider",
        "name": "GithubAuthenticationProvider",
        "modifiers": "@Import(GithubAuthenticationProviderConfiguration.class)\npublic",
        "superclass": null,
        "super_interfaces": "implements OAuth2AuthenticationProvider",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(GithubAuthenticationProvider.class);\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            Map<String, String> params = extractMap(content);\n            String accessToken = params.get(\"access_token\");\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"token \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate github user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n        additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n        additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n        additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n        additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n        additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n        additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n        additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n        additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n        additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n        additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n        additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n        additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n        additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n        additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n        additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n        additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n        additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n        additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n        additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n    }\n}",
        "start_point": {
            "row": 51,
            "column": 0
        },
        "end_point": {
            "row": 159,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic User loadUserByUsername(Authentication authentication) {\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        Map<String, String> params = extractMap(content);\n        String accessToken = params.get(\"access_token\");\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"token \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate github user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        Map<String, String> params = extractMap(content);\n        String accessToken = params.get(\"access_token\");\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"token \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate github user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 96,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic User loadUserByUsername(String username) {\n    return null;\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 98,
                    "column": 4
                },
                "end_point": {
                    "row": 101,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2IdentityProviderConfiguration configuration() {\n    return configuration;\n}",
                "name": "configuration",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2IdentityProviderConfiguration",
                "parameters": [],
                "body": "{\n    return configuration;\n}",
                "start_point": {
                    "row": 103,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "private User createUser(JsonNode jsonNode) {\n    User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n    additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n    additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n    additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n    additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n    additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n    additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n    additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n    additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n    additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n    additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n    additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n    additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n    additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n    additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "name": "createUser",
                "modifiers": "private",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "jsonNode"
                    }
                ],
                "body": "{\n    User user = new DefaultUser(jsonNode.get(GithubUser.LOGIN).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(GithubUser.LOGIN).asText());\n    additionalInformation.put(GithubUser.AVATAR_URL, jsonNode.get(GithubUser.AVATAR_URL).asText());\n    additionalInformation.put(GithubUser.GRAVATAR_ID, jsonNode.get(GithubUser.GRAVATAR_ID).asText());\n    additionalInformation.put(GithubUser.URL, jsonNode.get(GithubUser.URL).asText());\n    additionalInformation.put(GithubUser.HTML_URL, jsonNode.get(GithubUser.HTML_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS_URL, jsonNode.get(GithubUser.FOLLOWERS_URL).asText());\n    additionalInformation.put(GithubUser.FOLLOWING_URL, jsonNode.get(GithubUser.FOLLOWING_URL).asText());\n    additionalInformation.put(GithubUser.GISTS_URL, jsonNode.get(GithubUser.GISTS_URL).asText());\n    additionalInformation.put(GithubUser.STARRED_URL, jsonNode.get(GithubUser.STARRED_URL).asText());\n    additionalInformation.put(GithubUser.SUBSCRIPTIONS_URL, jsonNode.get(GithubUser.SUBSCRIPTIONS_URL).asText());\n    additionalInformation.put(GithubUser.ORGANIZATIONS_URL, jsonNode.get(GithubUser.ORGANIZATIONS_URL).asText());\n    additionalInformation.put(GithubUser.REPOS_URL, jsonNode.get(GithubUser.REPOS_URL).asText());\n    additionalInformation.put(GithubUser.EVENTS_URL, jsonNode.get(GithubUser.EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.RECEIVED_EVENTS_URL, jsonNode.get(GithubUser.RECEIVED_EVENTS_URL).asText());\n    additionalInformation.put(GithubUser.SITE_ADMIN, jsonNode.get(GithubUser.SITE_ADMIN).asText());\n    additionalInformation.put(GithubUser.NAME, jsonNode.get(GithubUser.NAME).asText());\n    additionalInformation.put(GithubUser.COMPANY, jsonNode.get(GithubUser.COMPANY).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    additionalInformation.put(GithubUser.PUBLIC_REPOS, jsonNode.get(GithubUser.PUBLIC_REPOS).asText());\n    additionalInformation.put(GithubUser.PUBLIC_GISTS, jsonNode.get(GithubUser.PUBLIC_GISTS).asText());\n    additionalInformation.put(GithubUser.FOLLOWERS, jsonNode.get(GithubUser.FOLLOWERS).asText());\n    additionalInformation.put(GithubUser.FOLLOWING, jsonNode.get(GithubUser.FOLLOWING).asText());\n    additionalInformation.put(GithubUser.LOCATION, jsonNode.get(GithubUser.LOCATION).asText());\n    additionalInformation.put(GithubUser.EMAIL, jsonNode.get(GithubUser.EMAIL).asText());\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 139,
                    "column": 5
                }
            },
            {
                "definition": "private String read(Reader rd) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "name": "read",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "Reader",
                        "name": "rd"
                    }
                ],
                "body": "{\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "start_point": {
                    "row": 141,
                    "column": 4
                },
                "end_point": {
                    "row": 148,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, String> extractMap(String param) {\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n}",
                "name": "extractMap",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "param"
                    }
                ],
                "body": "{\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n}",
                "start_point": {
                    "row": 150,
                    "column": 4
                },
                "end_point": {
                    "row": 158,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-identityprovider/gravitee-am-identityprovider-oauth2-generic/src/main/java/io/gravitee/am/identityprovider/oauth2/authentication/OAuth2GenericAuthenticationProvider.java",
        "definition": "@Import(OAuth2GenericAuthenticationProviderConfiguration.class)\npublic class OAuth2GenericAuthenticationProvider implements OAuth2AuthenticationProvider {\n\n    private static final Logger logger = LoggerFactory.getLogger(OAuth2GenericAuthenticationProvider.class);\n    private static final String CLAIMS_SUB = \"sub\";\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Autowired\n    private OAuth2GenericIdentityProviderMapper mapper;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.GRANT_TYPE, \"authorization_code\"));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            JsonNode params = objectMapper.readTree(content);\n            String accessToken = params.get(\"access_token\").asText();\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n        if (this.mapper.getMappers() != null) {\n            this.mapper.getMappers().forEach((k, v) -> {\n                if (jsonNode.get(v) != null) {\n                    additionalInformation.put(k, jsonNode.get(v).asText());\n                }\n            });\n        }\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n\n    }\n}",
        "package": "package io.gravitee.am.identityprovider.oauth2.authentication;",
        "tree_path": "OAuth2GenericAuthenticationProvider",
        "name": "OAuth2GenericAuthenticationProvider",
        "modifiers": "@Import(OAuth2GenericAuthenticationProviderConfiguration.class)\npublic",
        "superclass": null,
        "super_interfaces": "implements OAuth2AuthenticationProvider",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(OAuth2GenericAuthenticationProvider.class);\n    private static final String CLAIMS_SUB = \"sub\";\n    private ObjectMapper objectMapper = new ObjectMapper();\n\n    @Autowired\n    private HttpClient client;\n\n    @Autowired\n    private OAuth2IdentityProviderConfiguration configuration;\n\n    @Autowired\n    private OAuth2GenericIdentityProviderMapper mapper;\n\n    @Override\n    public User loadUserByUsername(Authentication authentication) {\n        try {\n            HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n            List<NameValuePair> urlParameters = new ArrayList<>();\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n            urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n            urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n            urlParameters.add(new BasicNameValuePair(OAuth2Utils.GRANT_TYPE, \"authorization_code\"));\n            post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n            // authenticate user\n            HttpResponse response = client.execute(post);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            String content = read(rd);\n            if (response.getStatusLine().getStatusCode() != 200) {\n                throw new BadCredentialsException(content);\n            }\n            JsonNode params = objectMapper.readTree(content);\n            String accessToken = params.get(\"access_token\").asText();\n\n            // get user profile\n            HttpGet request = new HttpGet(configuration.getUserProfileUri());\n            request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n            response = client.execute(request);\n            rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n            content = read(rd);\n            JsonNode jsonNode = objectMapper.readTree(content);\n            return createUser(jsonNode);\n        } catch (Exception e) {\n            logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n            throw new InternalAuthenticationServiceException(e.getMessage());\n        }\n    }\n\n    @Override\n    public User loadUserByUsername(String username) {\n        return null;\n    }\n\n    @Override\n    public OAuth2IdentityProviderConfiguration configuration() {\n        return configuration;\n    }\n\n    private User createUser(JsonNode jsonNode) {\n        User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n        // set additional information\n        Map<String, Object> additionalInformation = new HashMap<>();\n        additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n        if (this.mapper.getMappers() != null) {\n            this.mapper.getMappers().forEach((k, v) -> {\n                if (jsonNode.get(v) != null) {\n                    additionalInformation.put(k, jsonNode.get(v).asText());\n                }\n            });\n        }\n        ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n        return user;\n    }\n\n    private String read(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n\n    private Map<String, String> extractMap(String param) {\n        Map<String, String> query_pairs = new LinkedHashMap<>();\n        String[] pairs = param.split(\"&\");\n        for (String pair : pairs) {\n            int idx = pair.indexOf(\"=\");\n            query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n        }\n        return query_pairs;\n\n    }\n}",
        "start_point": {
            "row": 51,
            "column": 0
        },
        "end_point": {
            "row": 148,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic User loadUserByUsername(Authentication authentication) {\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.GRANT_TYPE, \"authorization_code\"));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        JsonNode params = objectMapper.readTree(content);\n        String accessToken = params.get(\"access_token\").asText();\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    try {\n        HttpPost post = new HttpPost(configuration.getAccessTokenUri());\n        List<NameValuePair> urlParameters = new ArrayList<>();\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.CLIENT_ID, configuration.getClientId()));\n        urlParameters.add(new BasicNameValuePair(\"client_secret\", configuration.getClientSecret()));\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.REDIRECT_URI, (String) authentication.getAdditionalInformation().get(OAuth2Utils.REDIRECT_URI)));\n        urlParameters.add(new BasicNameValuePair(\"code\", (String) authentication.getCredentials()));\n        urlParameters.add(new BasicNameValuePair(OAuth2Utils.GRANT_TYPE, \"authorization_code\"));\n        post.setEntity(new UrlEncodedFormEntity(urlParameters));\n\n        // authenticate user\n        HttpResponse response = client.execute(post);\n        BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        String content = read(rd);\n        if (response.getStatusLine().getStatusCode() != 200) {\n            throw new BadCredentialsException(content);\n        }\n        JsonNode params = objectMapper.readTree(content);\n        String accessToken = params.get(\"access_token\").asText();\n\n        // get user profile\n        HttpGet request = new HttpGet(configuration.getUserProfileUri());\n        request.addHeader(\"Authorization\", \"Bearer \" + accessToken);\n        response = client.execute(request);\n        rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));\n        content = read(rd);\n        JsonNode jsonNode = objectMapper.readTree(content);\n        return createUser(jsonNode);\n    } catch (Exception e) {\n        logger.error(\"Fail to authenticate OAuth 2.0 generic user account\", e);\n        throw new InternalAuthenticationServiceException(e.getMessage());\n    }\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 101,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic User loadUserByUsername(String username) {\n    return null;\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    return null;\n}",
                "start_point": {
                    "row": 103,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2IdentityProviderConfiguration configuration() {\n    return configuration;\n}",
                "name": "configuration",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2IdentityProviderConfiguration",
                "parameters": [],
                "body": "{\n    return configuration;\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "private User createUser(JsonNode jsonNode) {\n    User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n    if (this.mapper.getMappers() != null) {\n        this.mapper.getMappers().forEach((k, v) -> {\n            if (jsonNode.get(v) != null) {\n                additionalInformation.put(k, jsonNode.get(v).asText());\n            }\n        });\n    }\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "name": "createUser",
                "modifiers": "private",
                "return_type": "User",
                "parameters": [
                    {
                        "type": "JsonNode",
                        "name": "jsonNode"
                    }
                ],
                "body": "{\n    User user = new DefaultUser(jsonNode.get(CLAIMS_SUB).asText());\n    // set additional information\n    Map<String, Object> additionalInformation = new HashMap<>();\n    additionalInformation.put(\"sub\", jsonNode.get(CLAIMS_SUB).asText());\n    if (this.mapper.getMappers() != null) {\n        this.mapper.getMappers().forEach((k, v) -> {\n            if (jsonNode.get(v) != null) {\n                additionalInformation.put(k, jsonNode.get(v).asText());\n            }\n        });\n    }\n    ((DefaultUser) user).setAdditonalInformation(additionalInformation);\n    return user;\n}",
                "start_point": {
                    "row": 113,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "private String read(Reader rd) throws IOException {\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "name": "read",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "Reader",
                        "name": "rd"
                    }
                ],
                "body": "{\n    StringBuilder sb = new StringBuilder();\n    int cp;\n    while ((cp = rd.read()) != -1) {\n        sb.append((char) cp);\n    }\n    return sb.toString();\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 136,
                    "column": 5
                }
            },
            {
                "definition": "private Map<String, String> extractMap(String param) {\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n\n}",
                "name": "extractMap",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "param"
                    }
                ],
                "body": "{\n    Map<String, String> query_pairs = new LinkedHashMap<>();\n    String[] pairs = param.split(\"&\");\n    for (String pair : pairs) {\n        int idx = pair.indexOf(\"=\");\n        query_pairs.put(pair.substring(0, idx), pair.substring(idx + 1));\n    }\n    return query_pairs;\n\n}",
                "start_point": {
                    "row": 138,
                    "column": 4
                },
                "end_point": {
                    "row": 147,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/ManagementApplication.java",
        "definition": "public class ManagementApplication extends ResourceConfig {\n\n    public ManagementApplication() {\n\n        BeanConfig beanConfig = new BeanConfig();\n        beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n        beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n        beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n        beanConfig.setScan(true);\n\n        register(DomainsResource.class);\n        register(PlatformResource.class);\n        register(DashboardResource.class);\n\n        register(ObjectMapperResolver.class);\n        register(ManagementExceptionMapper.class);\n        register(UnrecognizedPropertyExceptionMapper.class);\n        register(ThrowableMapper.class);\n        register(NotFoundExceptionMapper.class);\n        register(BadRequestExceptionMapper.class);\n\n        register(CorsResponseFilter.class);\n        register(UriBuilderRequestFilter.class);\n        register(ByteArrayOutputStreamWriter.class);\n        register(JacksonFeature.class);\n\n        register(ApiListingResource.class);\n        register(SwaggerSerializers.class);\n\n        property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api;",
        "tree_path": "ManagementApplication",
        "name": "ManagementApplication",
        "modifiers": "public",
        "superclass": "extends ResourceConfig",
        "super_interfaces": null,
        "body": "{\n\n    public ManagementApplication() {\n\n        BeanConfig beanConfig = new BeanConfig();\n        beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n        beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n        beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n        beanConfig.setScan(true);\n\n        register(DomainsResource.class);\n        register(PlatformResource.class);\n        register(DashboardResource.class);\n\n        register(ObjectMapperResolver.class);\n        register(ManagementExceptionMapper.class);\n        register(UnrecognizedPropertyExceptionMapper.class);\n        register(ThrowableMapper.class);\n        register(NotFoundExceptionMapper.class);\n        register(BadRequestExceptionMapper.class);\n\n        register(CorsResponseFilter.class);\n        register(UriBuilderRequestFilter.class);\n        register(ByteArrayOutputStreamWriter.class);\n        register(JacksonFeature.class);\n\n        register(ApiListingResource.class);\n        register(SwaggerSerializers.class);\n\n        property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 65,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public ManagementApplication() {\n\n    BeanConfig beanConfig = new BeanConfig();\n    beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n    beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n    beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n    beanConfig.setScan(true);\n\n    register(DomainsResource.class);\n    register(PlatformResource.class);\n    register(DashboardResource.class);\n\n    register(ObjectMapperResolver.class);\n    register(ManagementExceptionMapper.class);\n    register(UnrecognizedPropertyExceptionMapper.class);\n    register(ThrowableMapper.class);\n    register(NotFoundExceptionMapper.class);\n    register(BadRequestExceptionMapper.class);\n\n    register(CorsResponseFilter.class);\n    register(UriBuilderRequestFilter.class);\n    register(ByteArrayOutputStreamWriter.class);\n    register(JacksonFeature.class);\n\n    register(ApiListingResource.class);\n    register(SwaggerSerializers.class);\n\n    property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n}",
                "name": "ManagementApplication",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n\n    BeanConfig beanConfig = new BeanConfig();\n    beanConfig.setVersion(Version.RUNTIME_VERSION.MAJOR_VERSION);\n    beanConfig.setResourcePackage(\"io.gravitee.am.management.handlers.management.api.resources\");\n    beanConfig.setTitle(\"Gravitee.io - Access Management API\");\n    beanConfig.setScan(true);\n\n    register(DomainsResource.class);\n    register(PlatformResource.class);\n    register(DashboardResource.class);\n\n    register(ObjectMapperResolver.class);\n    register(ManagementExceptionMapper.class);\n    register(UnrecognizedPropertyExceptionMapper.class);\n    register(ThrowableMapper.class);\n    register(NotFoundExceptionMapper.class);\n    register(BadRequestExceptionMapper.class);\n\n    register(CorsResponseFilter.class);\n    register(UriBuilderRequestFilter.class);\n    register(ByteArrayOutputStreamWriter.class);\n    register(JacksonFeature.class);\n\n    register(ApiListingResource.class);\n    register(SwaggerSerializers.class);\n\n    property(ServerProperties.BV_SEND_ERROR_IN_RESPONSE, true);\n}",
                "constructor": true,
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/resources/DomainsResource.java",
        "definition": "@Path(\"/domains\")\n@Api(tags = {\"domain\"})\npublic class DomainsResource extends AbstractResource {\n\n    @Autowired\n    private DomainService domainService;\n\n    @Context\n    private ResourceContext resourceContext;\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(\n            value = \"List security domains\",\n            notes = \"List all the security domains accessible to the current user.\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void list(@Suspended final AsyncResponse response) {\n         domainService.findAll()\n                 .map(domains ->\n                        domains.stream().map(domain -> {\n                            domain.setLoginForm(null);\n                            return domain;\n                        })\n                        .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                        .collect(Collectors.toList()))\n                .subscribe(\n                        result -> response.resume(Response.ok(result).build()),\n                        error -> response.resume(error));\n    }\n\n    @POST\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Create a security domain\")\n    @ApiResponses({\n            @ApiResponse(code = 201, message = \"Domain successfully created\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void create(\n            @ApiParam(name = \"domain\", required = true)\n            @Valid @NotNull final NewDomain newDomain,\n            @Suspended final AsyncResponse response) {\n        domainService.create(newDomain)\n                .subscribe(\n                        domain -> response.resume(Response\n                                                    .created(URI.create(\"/domains/\" + domain.getId()))\n                                                    .entity(domain)\n                                                    .build()),\n                        error -> response.resume(error));\n    }\n\n    @Path(\"{domain}\")\n    public DomainResource getDomainResource() {\n        return resourceContext.getResource(DomainResource.class);\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.resources;",
        "tree_path": "DomainsResource",
        "name": "DomainsResource",
        "modifiers": "@Path(\"/domains\")\n@Api(tags = {\"domain\"})\npublic",
        "superclass": "extends AbstractResource",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private DomainService domainService;\n\n    @Context\n    private ResourceContext resourceContext;\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(\n            value = \"List security domains\",\n            notes = \"List all the security domains accessible to the current user.\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void list(@Suspended final AsyncResponse response) {\n         domainService.findAll()\n                 .map(domains ->\n                        domains.stream().map(domain -> {\n                            domain.setLoginForm(null);\n                            return domain;\n                        })\n                        .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                        .collect(Collectors.toList()))\n                .subscribe(\n                        result -> response.resume(Response.ok(result).build()),\n                        error -> response.resume(error));\n    }\n\n    @POST\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Create a security domain\")\n    @ApiResponses({\n            @ApiResponse(code = 201, message = \"Domain successfully created\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public void create(\n            @ApiParam(name = \"domain\", required = true)\n            @Valid @NotNull final NewDomain newDomain,\n            @Suspended final AsyncResponse response) {\n        domainService.create(newDomain)\n                .subscribe(\n                        domain -> response.resume(Response\n                                                    .created(URI.create(\"/domains/\" + domain.getId()))\n                                                    .entity(domain)\n                                                    .build()),\n                        error -> response.resume(error));\n    }\n\n    @Path(\"{domain}\")\n    public DomainResource getDomainResource() {\n        return resourceContext.getResource(DomainResource.class);\n    }\n\n}",
        "start_point": {
            "row": 41,
            "column": 0
        },
        "end_point": {
            "row": 98,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@GET\n@Produces(MediaType.APPLICATION_JSON)\n@ApiOperation(\n        value = \"List security domains\",\n        notes = \"List all the security domains accessible to the current user.\")\n@ApiResponses({\n        @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n        @ApiResponse(code = 500, message = \"Internal server error\")})\npublic void list(@Suspended final AsyncResponse response) {\n     domainService.findAll()\n             .map(domains ->\n                    domains.stream().map(domain -> {\n                        domain.setLoginForm(null);\n                        return domain;\n                    })\n                    .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                    .collect(Collectors.toList()))\n            .subscribe(\n                    result -> response.resume(Response.ok(result).build()),\n                    error -> response.resume(error));\n}",
                "name": "list",
                "modifiers": "@GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @ApiOperation(\n            value = \"List security domains\",\n            notes = \"List all the security domains accessible to the current user.\")\n    @ApiResponses({\n            @ApiResponse(code = 200, message = \"List accessible security domains for current user\", response = Domain.class, responseContainer = \"List\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@Suspended final",
                        "name": "AsyncResponse"
                    }
                ],
                "body": "{\n     domainService.findAll()\n             .map(domains ->\n                    domains.stream().map(domain -> {\n                        domain.setLoginForm(null);\n                        return domain;\n                    })\n                    .sorted((o1, o2) -> String.CASE_INSENSITIVE_ORDER.compare(o1.getName(), o2.getName()))\n                    .collect(Collectors.toList()))\n            .subscribe(\n                    result -> response.resume(Response.ok(result).build()),\n                    error -> response.resume(error));\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@POST\n@Produces(MediaType.APPLICATION_JSON)\n@Consumes(MediaType.APPLICATION_JSON)\n@ApiOperation(value = \"Create a security domain\")\n@ApiResponses({\n        @ApiResponse(code = 201, message = \"Domain successfully created\"),\n        @ApiResponse(code = 500, message = \"Internal server error\")})\npublic void create(\n        @ApiParam(name = \"domain\", required = true)\n        @Valid @NotNull final NewDomain newDomain,\n        @Suspended final AsyncResponse response) {\n    domainService.create(newDomain)\n            .subscribe(\n                    domain -> response.resume(Response\n                                                .created(URI.create(\"/domains/\" + domain.getId()))\n                                                .entity(domain)\n                                                .build()),\n                    error -> response.resume(error));\n}",
                "name": "create",
                "modifiers": "@POST\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @ApiOperation(value = \"Create a security domain\")\n    @ApiResponses({\n            @ApiResponse(code = 201, message = \"Domain successfully created\"),\n            @ApiResponse(code = 500, message = \"Internal server error\")})\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@ApiParam(name = \"domain\", required = true)\n            @Valid @NotNull final",
                        "name": "NewDomain"
                    },
                    {
                        "type": "@Suspended final",
                        "name": "AsyncResponse"
                    }
                ],
                "body": "{\n    domainService.create(newDomain)\n            .subscribe(\n                    domain -> response.resume(Response\n                                                .created(URI.create(\"/domains/\" + domain.getId()))\n                                                .entity(domain)\n                                                .build()),\n                    error -> response.resume(error));\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 91,
                    "column": 5
                }
            },
            {
                "definition": "@Path(\"{domain}\")\npublic DomainResource getDomainResource() {\n    return resourceContext.getResource(DomainResource.class);\n}",
                "name": "getDomainResource",
                "modifiers": "@Path(\"{domain}\")\n    public",
                "return_type": "DomainResource",
                "parameters": [],
                "body": "{\n    return resourceContext.getResource(DomainResource.class);\n}",
                "start_point": {
                    "row": 93,
                    "column": 4
                },
                "end_point": {
                    "row": 96,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/spring/security/SecurityConfiguration.java",
        "definition": "@Configuration\n@EnableWebSecurity\n@EnableResourceServer\npublic class SecurityConfiguration extends ResourceServerConfigurerAdapter {\n\n    @Autowired\n    private Environment environment;\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Override\n    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n        resources\n                .tokenServices(remoteTokenServices())\n                .resourceId(null)\n                .eventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n    }\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n                .authorizeRequests()\n                    .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                    .anyRequest().authenticated()\n            .and()\n                .httpBasic()\n                    .disable()\n                .csrf()\n                .disable()\n            .addFilterBefore(corsFilter(), ChannelProcessingFilter.class);\n    }\n\n    @Bean\n    public Filter corsFilter() {\n        return new CORSFilter();\n    }\n\n    @Bean\n    public RemoteTokenServices remoteTokenServices() {\n        RemoteTokenServices s = new RemoteTokenServices();\n        s.setCheckTokenEndpointUrl(environment.getProperty(\"authentication.oauth2.url\"));\n        s.setClientId(environment.getProperty(\"authentication.oauth2.clientId\"));\n        s.setClientSecret(environment.getProperty(\"authentication.oauth2.clientSecret\"));\n        return s;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.spring.security;",
        "tree_path": "SecurityConfiguration",
        "name": "SecurityConfiguration",
        "modifiers": "@Configuration\n@EnableWebSecurity\n@EnableResourceServer\npublic",
        "superclass": "extends ResourceServerConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private Environment environment;\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Override\n    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n        resources\n                .tokenServices(remoteTokenServices())\n                .resourceId(null)\n                .eventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n    }\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n            .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n                .authorizeRequests()\n                    .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                    .anyRequest().authenticated()\n            .and()\n                .httpBasic()\n                    .disable()\n                .csrf()\n                .disable()\n            .addFilterBefore(corsFilter(), ChannelProcessingFilter.class);\n    }\n\n    @Bean\n    public Filter corsFilter() {\n        return new CORSFilter();\n    }\n\n    @Bean\n    public RemoteTokenServices remoteTokenServices() {\n        RemoteTokenServices s = new RemoteTokenServices();\n        s.setCheckTokenEndpointUrl(environment.getProperty(\"authentication.oauth2.url\"));\n        s.setClientId(environment.getProperty(\"authentication.oauth2.clientId\"));\n        s.setClientSecret(environment.getProperty(\"authentication.oauth2.clientSecret\"));\n        return s;\n    }\n}",
        "start_point": {
            "row": 40,
            "column": 0
        },
        "end_point": {
            "row": 89,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n    resources\n            .tokenServices(remoteTokenServices())\n            .resourceId(null)\n            .eventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ResourceServerSecurityConfigurer",
                        "name": "resources"
                    }
                ],
                "body": "{\n    resources\n            .tokenServices(remoteTokenServices())\n            .resourceId(null)\n            .eventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void configure(HttpSecurity http) throws Exception {\n    http\n        .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n        .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .anyRequest().authenticated()\n        .and()\n            .httpBasic()\n                .disable()\n            .csrf()\n            .disable()\n        .addFilterBefore(corsFilter(), ChannelProcessingFilter.class);\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpSecurity",
                        "name": "http"
                    }
                ],
                "body": "{\n    http\n        .sessionManagement()\n            .sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n        .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .anyRequest().authenticated()\n        .and()\n            .httpBasic()\n                .disable()\n            .csrf()\n            .disable()\n        .addFilterBefore(corsFilter(), ChannelProcessingFilter.class);\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic Filter corsFilter() {\n    return new CORSFilter();\n}",
                "name": "corsFilter",
                "modifiers": "@Bean\n    public",
                "return_type": "Filter",
                "parameters": [],
                "body": "{\n    return new CORSFilter();\n}",
                "start_point": {
                    "row": 76,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic RemoteTokenServices remoteTokenServices() {\n    RemoteTokenServices s = new RemoteTokenServices();\n    s.setCheckTokenEndpointUrl(environment.getProperty(\"authentication.oauth2.url\"));\n    s.setClientId(environment.getProperty(\"authentication.oauth2.clientId\"));\n    s.setClientSecret(environment.getProperty(\"authentication.oauth2.clientSecret\"));\n    return s;\n}",
                "name": "remoteTokenServices",
                "modifiers": "@Bean\n    public",
                "return_type": "RemoteTokenServices",
                "parameters": [],
                "body": "{\n    RemoteTokenServices s = new RemoteTokenServices();\n    s.setCheckTokenEndpointUrl(environment.getProperty(\"authentication.oauth2.url\"));\n    s.setClientId(environment.getProperty(\"authentication.oauth2.clientId\"));\n    s.setClientSecret(environment.getProperty(\"authentication.oauth2.clientSecret\"));\n    return s;\n}",
                "start_point": {
                    "row": 81,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/DeployAdminDomainUpgrader.java",
        "definition": "@Component\npublic class DeployAdminDomainUpgrader implements Upgrader, Ordered {\n\n    private static final Logger logger = LoggerFactory.getLogger(DeployAdminDomainUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private EventManager eventManager;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n        try {\n            // TODO Async call\n            Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n            eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain);\n            return true;\n        } catch (DomainNotFoundException dnfe) {\n            logger.error(\"Failed to find admin domain\", dnfe);\n            throw new IllegalStateException(\"Failed to deploy admin domain\", dnfe);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return 170;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "DeployAdminDomainUpgrader",
        "name": "DeployAdminDomainUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    private static final Logger logger = LoggerFactory.getLogger(DeployAdminDomainUpgrader.class);\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private EventManager eventManager;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n        try {\n            // TODO Async call\n            Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n            eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain);\n            return true;\n        } catch (DomainNotFoundException dnfe) {\n            logger.error(\"Failed to find admin domain\", dnfe);\n            throw new IllegalStateException(\"Failed to deploy admin domain\", dnfe);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return 170;\n    }\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 62,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n    try {\n        // TODO Async call\n        Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n        eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain);\n        return true;\n    } catch (DomainNotFoundException dnfe) {\n        logger.error(\"Failed to find admin domain\", dnfe);\n        throw new IllegalStateException(\"Failed to deploy admin domain\", dnfe);\n    }\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Deploying registered {} domain\", ADMIN_DOMAIN);\n    try {\n        // TODO Async call\n        Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n        eventManager.publishEvent(DomainEvent.DEPLOY, adminDomain);\n        return true;\n    } catch (DomainNotFoundException dnfe) {\n        logger.error(\"Failed to find admin domain\", dnfe);\n        throw new IllegalStateException(\"Failed to deploy admin domain\", dnfe);\n    }\n}",
                "start_point": {
                    "row": 44,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return 170;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return 170;\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/InitializeUpgrader.java",
        "definition": "@Component\npublic class InitializeUpgrader implements Upgrader, Ordered {\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n    private final static String ADMIN_CLIENT_SECRET = \"admin-secret\";\n    private final static String DEFAULT_SCOPE = \"openid\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        try {\n            // TODO async call\n            Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n            // update master flag\n            // TODO: keep history in database to avoid this call\n            if (!adminDomain.isMaster()) {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                // TODO async call\n                domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n            }\n            logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n        } catch (DomainNotFoundException dnfe) {\n            //TODO: Use configuration to get admin values\n            // Create a new admin domain\n            logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n            NewDomain adminDomain = new NewDomain();\n            adminDomain.setName(\"admin\");\n            adminDomain.setDescription(\"AM Admin domain\");\n            // TODO async call\n            Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n            // Create default scope\n            NewScope scope = new NewScope();\n            scope.setKey(DEFAULT_SCOPE);\n            scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n            scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n            // TODO async call\n            Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n            // Create a new admin client\n            logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n            NewClient adminClient = new NewClient();\n            adminClient.setClientId(ADMIN_CLIENT_ID);\n            adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n            // TODO async call\n            Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n            // Create an inline identity provider\n            logger.info(\"Create an user-inline provider\");\n            NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n            adminIdentityProvider.setType(\"inline-am-idp\");\n            adminIdentityProvider.setName(\"Inline users\");\n            adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n            // TODO async call\n            IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n            // Associate the identity provider to the client and enabled it\n            logger.info(\"Associate user-inline provider to previously created client\");\n            UpdateClient updateClient = new UpdateClient();\n            updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n            updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n            updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n            updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n            updateClient.setAutoApproveScopes(updateClient.getScopes());\n            updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n            updateClient.setEnabled(true);\n            // TODO async call\n            clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n            // Enabled the domain\n            logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n            UpdateDomain updateDomain = new UpdateDomain();\n            updateDomain.setName(createdDomain.getName());\n            updateDomain.setDescription(createdDomain.getDescription());\n            updateDomain.setEnabled(true);\n            updateDomain.setPath(createdDomain.getPath());\n            // TODO async call\n            domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n            // Set master flag\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n        }\n\n        return true;\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "InitializeUpgrader",
        "name": "InitializeUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(InitializeUpgrader.class);\n\n    private final static String ADMIN_DOMAIN = \"admin\";\n\n    private final static String ADMIN_CLIENT_ID = \"admin\";\n    private final static String ADMIN_CLIENT_SECRET = \"admin-secret\";\n    private final static String DEFAULT_SCOPE = \"openid\";\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n        try {\n            // TODO async call\n            Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n            // update master flag\n            // TODO: keep history in database to avoid this call\n            if (!adminDomain.isMaster()) {\n                logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n                // TODO async call\n                domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n            }\n            logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n        } catch (DomainNotFoundException dnfe) {\n            //TODO: Use configuration to get admin values\n            // Create a new admin domain\n            logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n            NewDomain adminDomain = new NewDomain();\n            adminDomain.setName(\"admin\");\n            adminDomain.setDescription(\"AM Admin domain\");\n            // TODO async call\n            Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n            // Create default scope\n            NewScope scope = new NewScope();\n            scope.setKey(DEFAULT_SCOPE);\n            scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n            scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n            // TODO async call\n            Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n            // Create a new admin client\n            logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n            NewClient adminClient = new NewClient();\n            adminClient.setClientId(ADMIN_CLIENT_ID);\n            adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n            // TODO async call\n            Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n            // Create an inline identity provider\n            logger.info(\"Create an user-inline provider\");\n            NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n            adminIdentityProvider.setType(\"inline-am-idp\");\n            adminIdentityProvider.setName(\"Inline users\");\n            adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n            // TODO async call\n            IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n            // Associate the identity provider to the client and enabled it\n            logger.info(\"Associate user-inline provider to previously created client\");\n            UpdateClient updateClient = new UpdateClient();\n            updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n            updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n            updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n            updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n            updateClient.setAutoApproveScopes(updateClient.getScopes());\n            updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n            updateClient.setEnabled(true);\n            // TODO async call\n            clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n            // Enabled the domain\n            logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n            UpdateDomain updateDomain = new UpdateDomain();\n            updateDomain.setName(createdDomain.getName());\n            updateDomain.setDescription(createdDomain.getDescription());\n            updateDomain.setEnabled(true);\n            updateDomain.setPath(createdDomain.getPath());\n            // TODO async call\n            domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n            // Set master flag\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n        }\n\n        return true;\n    }\n\n    @Override\n    public int getOrder() {\n        return Ordered.HIGHEST_PRECEDENCE;\n    }\n}",
        "start_point": {
            "row": 40,
            "column": 0
        },
        "end_point": {
            "row": 152,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    try {\n        // TODO async call\n        Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n        // update master flag\n        // TODO: keep history in database to avoid this call\n        if (!adminDomain.isMaster()) {\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n        }\n        logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n    } catch (DomainNotFoundException dnfe) {\n        //TODO: Use configuration to get admin values\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        // TODO async call\n        Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n        // Create default scope\n        NewScope scope = new NewScope();\n        scope.setKey(DEFAULT_SCOPE);\n        scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n        scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n        // TODO async call\n        Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n        // Create a new admin client\n        logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n        NewClient adminClient = new NewClient();\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n        adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n        // TODO async call\n        Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n        // Create an inline identity provider\n        logger.info(\"Create an user-inline provider\");\n        NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n        adminIdentityProvider.setType(\"inline-am-idp\");\n        adminIdentityProvider.setName(\"Inline users\");\n        adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n        // TODO async call\n        IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n        // Associate the identity provider to the client and enabled it\n        logger.info(\"Associate user-inline provider to previously created client\");\n        UpdateClient updateClient = new UpdateClient();\n        updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n        updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n        updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n        updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n        updateClient.setAutoApproveScopes(updateClient.getScopes());\n        updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n        updateClient.setEnabled(true);\n        // TODO async call\n        clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n        // Enabled the domain\n        logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n        UpdateDomain updateDomain = new UpdateDomain();\n        updateDomain.setName(createdDomain.getName());\n        updateDomain.setDescription(createdDomain.getDescription());\n        updateDomain.setEnabled(true);\n        updateDomain.setPath(createdDomain.getPath());\n        // TODO async call\n        domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n        // Set master flag\n        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n        // TODO async call\n        domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n    }\n\n    return true;\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Looking for a registered {} domain\", ADMIN_DOMAIN);\n\n    try {\n        // TODO async call\n        Domain adminDomain = domainService.findById(ADMIN_DOMAIN).blockingGet();\n        // update master flag\n        // TODO: keep history in database to avoid this call\n        if (!adminDomain.isMaster()) {\n            logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n            // TODO async call\n            domainService.setMasterDomain(adminDomain.getId(), true).subscribe();\n        }\n        logger.info(\"{} domain already exists. Skipping.\", ADMIN_DOMAIN);\n    } catch (DomainNotFoundException dnfe) {\n        //TODO: Use configuration to get admin values\n        // Create a new admin domain\n        logger.info(\"{} domain does not exists. Creating it.\", ADMIN_DOMAIN);\n        NewDomain adminDomain = new NewDomain();\n        adminDomain.setName(\"admin\");\n        adminDomain.setDescription(\"AM Admin domain\");\n        // TODO async call\n        Domain createdDomain = domainService.create(adminDomain).blockingGet();\n\n        // Create default scope\n        NewScope scope = new NewScope();\n        scope.setKey(DEFAULT_SCOPE);\n        scope.setName(Character.toUpperCase(DEFAULT_SCOPE.charAt(0)) + DEFAULT_SCOPE.substring(1));\n        scope.setDescription(\"Default description for scope \" + DEFAULT_SCOPE);\n        // TODO async call\n        Scope createdScope = scopeService.create(createdDomain.getId(), scope).blockingGet();\n\n        // Create a new admin client\n        logger.info(\"Create an initial {} client\", ADMIN_CLIENT_ID);\n        NewClient adminClient = new NewClient();\n        adminClient.setClientId(ADMIN_CLIENT_ID);\n        adminClient.setClientSecret(ADMIN_CLIENT_SECRET);\n        // TODO async call\n        Client createdClient = clientService.create(createdDomain.getId(), adminClient).blockingGet();\n\n        // Create an inline identity provider\n        logger.info(\"Create an user-inline provider\");\n        NewIdentityProvider adminIdentityProvider = new NewIdentityProvider();\n        adminIdentityProvider.setType(\"inline-am-idp\");\n        adminIdentityProvider.setName(\"Inline users\");\n        adminIdentityProvider.setConfiguration(\"{\\\"users\\\":[{\\\"firstname\\\":\\\"Administrator\\\",\\\"lastname\\\":\\\"\\\",\\\"username\\\":\\\"admin\\\",\\\"password\\\":\\\"adminadmin\\\"}]}\");\n        // TODO async call\n        IdentityProvider createdIdentityProvider = identityProviderService.create(createdDomain.getId(), adminIdentityProvider).blockingGet();\n\n        // Associate the identity provider to the client and enabled it\n        logger.info(\"Associate user-inline provider to previously created client\");\n        UpdateClient updateClient = new UpdateClient();\n        updateClient.setAccessTokenValiditySeconds(createdClient.getAccessTokenValiditySeconds());\n        updateClient.setRefreshTokenValiditySeconds(createdClient.getRefreshTokenValiditySeconds());\n        updateClient.setAuthorizedGrantTypes(Collections.singletonList(GrantType.IMPLICIT.type()));\n        updateClient.setScopes(Collections.singletonList(createdScope.getKey()));\n        updateClient.setAutoApproveScopes(updateClient.getScopes());\n        updateClient.setIdentities(Collections.singleton(createdIdentityProvider.getId()));\n        updateClient.setEnabled(true);\n        // TODO async call\n        clientService.update(createdDomain.getId(), createdClient.getId(), updateClient).blockingGet();\n\n        // Enabled the domain\n        logger.info(\"Start {} security domain\", ADMIN_DOMAIN);\n        UpdateDomain updateDomain = new UpdateDomain();\n        updateDomain.setName(createdDomain.getName());\n        updateDomain.setDescription(createdDomain.getDescription());\n        updateDomain.setEnabled(true);\n        updateDomain.setPath(createdDomain.getPath());\n        // TODO async call\n        domainService.update(createdDomain.getId(), updateDomain).blockingGet();\n\n        // Set master flag\n        logger.info(\"Set master flag for security domain {}\", ADMIN_DOMAIN);\n        // TODO async call\n        domainService.setMasterDomain(createdDomain.getId(), true).subscribe();\n    }\n\n    return true;\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 146,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Ordered.HIGHEST_PRECEDENCE;\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 151,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-service/src/main/java/io/gravitee/am/management/service/impl/upgrades/ScopeUpgrader.java",
        "definition": "@Component\npublic class ScopeUpgrader implements Upgrader, Ordered {\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(ScopeUpgrader.class);\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Applying scope upgrade\");\n        // TODO async call\n        Set<Domain> domains = domainService.findAll().blockingGet();\n\n        domains.forEach(this::upgradeDomain);\n\n        return true;\n    }\n\n    private void upgradeDomain(Domain domain) {\n        logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n        // TODO async call\n        Set<Scope> scopes = scopeService.findByDomain(domain.getId()).blockingGet();\n        if (scopes.isEmpty()) {\n            logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n\n            createClientScopes(domain);\n            createRoleScopes(domain);\n        }\n    }\n\n    private void createClientScopes(Domain domain) {\n        // TODO async call\n        Set<Client> clients = clientService.findByDomain(domain.getId()).blockingGet();\n\n        if (clients != null) {\n            clients.forEach(client -> {\n                if (client.getScopes() != null) {\n                    client.getScopes().forEach(scope -> createScope(domain.getId(), scope));\n                }\n            });\n        }\n    }\n\n    private void createRoleScopes(Domain domain) {\n        // TODO async call\n        Set<Role> roles = roleService.findByDomain(domain.getId()).blockingGet();\n\n        if (roles != null) {\n            roles.forEach(role -> {\n                if (role.getPermissions() != null) {\n                    role.getPermissions().forEach(scope -> createScope(domain.getId(), scope));\n                }\n            });\n        }\n    }\n\n    private void createScope(String domain, String scopeKey) {\n        // TODO async call\n        Set<Scope> scopes = scopeService.findByDomain(domain).blockingGet();\n        Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n        if (!optScope.isPresent()) {\n            logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n            NewScope scope = new NewScope();\n            scope.setKey(scopeKey);\n            scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n            scope.setDescription(\"Default description for scope \" + scopeKey);\n            scopeService.create(domain, scope);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return 160;\n    }\n}",
        "package": "package io.gravitee.am.management.service.impl.upgrades;",
        "tree_path": "ScopeUpgrader",
        "name": "ScopeUpgrader",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements Upgrader, Ordered",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(ScopeUpgrader.class);\n\n    @Autowired\n    private DomainService domainService;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Override\n    public boolean upgrade() {\n        logger.info(\"Applying scope upgrade\");\n        // TODO async call\n        Set<Domain> domains = domainService.findAll().blockingGet();\n\n        domains.forEach(this::upgradeDomain);\n\n        return true;\n    }\n\n    private void upgradeDomain(Domain domain) {\n        logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n        // TODO async call\n        Set<Scope> scopes = scopeService.findByDomain(domain.getId()).blockingGet();\n        if (scopes.isEmpty()) {\n            logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n\n            createClientScopes(domain);\n            createRoleScopes(domain);\n        }\n    }\n\n    private void createClientScopes(Domain domain) {\n        // TODO async call\n        Set<Client> clients = clientService.findByDomain(domain.getId()).blockingGet();\n\n        if (clients != null) {\n            clients.forEach(client -> {\n                if (client.getScopes() != null) {\n                    client.getScopes().forEach(scope -> createScope(domain.getId(), scope));\n                }\n            });\n        }\n    }\n\n    private void createRoleScopes(Domain domain) {\n        // TODO async call\n        Set<Role> roles = roleService.findByDomain(domain.getId()).blockingGet();\n\n        if (roles != null) {\n            roles.forEach(role -> {\n                if (role.getPermissions() != null) {\n                    role.getPermissions().forEach(scope -> createScope(domain.getId(), scope));\n                }\n            });\n        }\n    }\n\n    private void createScope(String domain, String scopeKey) {\n        // TODO async call\n        Set<Scope> scopes = scopeService.findByDomain(domain).blockingGet();\n        Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n        if (!optScope.isPresent()) {\n            logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n            NewScope scope = new NewScope();\n            scope.setKey(scopeKey);\n            scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n            scope.setDescription(\"Default description for scope \" + scopeKey);\n            scopeService.create(domain, scope);\n        }\n    }\n\n    @Override\n    public int getOrder() {\n        return 160;\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 126,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean upgrade() {\n    logger.info(\"Applying scope upgrade\");\n    // TODO async call\n    Set<Domain> domains = domainService.findAll().blockingGet();\n\n    domains.forEach(this::upgradeDomain);\n\n    return true;\n}",
                "name": "upgrade",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Applying scope upgrade\");\n    // TODO async call\n    Set<Domain> domains = domainService.findAll().blockingGet();\n\n    domains.forEach(this::upgradeDomain);\n\n    return true;\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "private void upgradeDomain(Domain domain) {\n    logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n    // TODO async call\n    Set<Scope> scopes = scopeService.findByDomain(domain.getId()).blockingGet();\n    if (scopes.isEmpty()) {\n        logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n\n        createClientScopes(domain);\n        createRoleScopes(domain);\n    }\n}",
                "name": "upgradeDomain",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    logger.info(\"Looking for scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n    // TODO async call\n    Set<Scope> scopes = scopeService.findByDomain(domain.getId()).blockingGet();\n    if (scopes.isEmpty()) {\n        logger.info(\"No scope found for domain id[{}] name[{}]. Upgrading...\", domain.getId(), domain.getName());\n\n        createClientScopes(domain);\n        createRoleScopes(domain);\n    }\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 80,
                    "column": 5
                }
            },
            {
                "definition": "private void createClientScopes(Domain domain) {\n    // TODO async call\n    Set<Client> clients = clientService.findByDomain(domain.getId()).blockingGet();\n\n    if (clients != null) {\n        clients.forEach(client -> {\n            if (client.getScopes() != null) {\n                client.getScopes().forEach(scope -> createScope(domain.getId(), scope));\n            }\n        });\n    }\n}",
                "name": "createClientScopes",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    // TODO async call\n    Set<Client> clients = clientService.findByDomain(domain.getId()).blockingGet();\n\n    if (clients != null) {\n        clients.forEach(client -> {\n            if (client.getScopes() != null) {\n                client.getScopes().forEach(scope -> createScope(domain.getId(), scope));\n            }\n        });\n    }\n}",
                "start_point": {
                    "row": 82,
                    "column": 4
                },
                "end_point": {
                    "row": 93,
                    "column": 5
                }
            },
            {
                "definition": "private void createRoleScopes(Domain domain) {\n    // TODO async call\n    Set<Role> roles = roleService.findByDomain(domain.getId()).blockingGet();\n\n    if (roles != null) {\n        roles.forEach(role -> {\n            if (role.getPermissions() != null) {\n                role.getPermissions().forEach(scope -> createScope(domain.getId(), scope));\n            }\n        });\n    }\n}",
                "name": "createRoleScopes",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    // TODO async call\n    Set<Role> roles = roleService.findByDomain(domain.getId()).blockingGet();\n\n    if (roles != null) {\n        roles.forEach(role -> {\n            if (role.getPermissions() != null) {\n                role.getPermissions().forEach(scope -> createScope(domain.getId(), scope));\n            }\n        });\n    }\n}",
                "start_point": {
                    "row": 95,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "private void createScope(String domain, String scopeKey) {\n    // TODO async call\n    Set<Scope> scopes = scopeService.findByDomain(domain).blockingGet();\n    Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n    if (!optScope.isPresent()) {\n        logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n        NewScope scope = new NewScope();\n        scope.setKey(scopeKey);\n        scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n        scope.setDescription(\"Default description for scope \" + scopeKey);\n        scopeService.create(domain, scope);\n    }\n}",
                "name": "createScope",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    },
                    {
                        "type": "String",
                        "name": "scopeKey"
                    }
                ],
                "body": "{\n    // TODO async call\n    Set<Scope> scopes = scopeService.findByDomain(domain).blockingGet();\n    Optional<Scope> optScope = scopes.stream().filter(scope -> scope.getKey().equalsIgnoreCase(scopeKey)).findFirst();\n    if (!optScope.isPresent()) {\n        logger.info(\"Create a new scope key[{}] for domain[{}]\", scopeKey, domain);\n        NewScope scope = new NewScope();\n        scope.setKey(scopeKey);\n        scope.setName(Character.toUpperCase(scopeKey.charAt(0)) + scopeKey.substring(1));\n        scope.setDescription(\"Default description for scope \" + scopeKey);\n        scopeService.create(domain, scope);\n    }\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 120,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int getOrder() {\n    return 160;\n}",
                "name": "getOrder",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return 160;\n}",
                "start_point": {
                    "row": 122,
                    "column": 4
                },
                "end_point": {
                    "row": 125,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-model/src/main/java/io/gravitee/am/model/Domain.java",
        "definition": "public class Domain {\n\n    /**\n     * Domain identifier.\n     */\n    private String id;\n\n    /**\n     * Domain name.\n     */\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    private boolean enabled;\n\n    /**\n     * Domain master flag.\n     */\n    private boolean master;\n\n    /**\n     * Domain creation date\n     */\n    private Date createdAt;\n\n    /**\n     * Domain last updated date\n     */\n    private Date updatedAt;\n\n    /**\n     * Domain HTTP path\n     */\n    private String path;\n\n    private LoginForm loginForm;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginForm getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginForm loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Domain domain = (Domain) o;\n\n        return id.equals(domain.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "package": "package io.gravitee.am.model;",
        "tree_path": "Domain",
        "name": "Domain",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * Domain identifier.\n     */\n    private String id;\n\n    /**\n     * Domain name.\n     */\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    private boolean enabled;\n\n    /**\n     * Domain master flag.\n     */\n    private boolean master;\n\n    /**\n     * Domain creation date\n     */\n    private Date createdAt;\n\n    /**\n     * Domain last updated date\n     */\n    private Date updatedAt;\n\n    /**\n     * Domain HTTP path\n     */\n    private String path;\n\n    private LoginForm loginForm;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public Date getCreatedAt() {\n        return createdAt;\n    }\n\n    public void setCreatedAt(Date createdAt) {\n        this.createdAt = createdAt;\n    }\n\n    public Date getUpdatedAt() {\n        return updatedAt;\n    }\n\n    public void setUpdatedAt(Date updatedAt) {\n        this.updatedAt = updatedAt;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginForm getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginForm loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        Domain domain = (Domain) o;\n\n        return id.equals(domain.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "start_point": {
            "row": 25,
            "column": 0
        },
        "end_point": {
            "row": 155,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public String getId() {\n    return id;\n}",
                "name": "getId",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return id;\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "public void setId(String id) {\n    this.id = id;\n}",
                "name": "setId",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    this.id = id;\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 81,
                    "column": 4
                },
                "end_point": {
                    "row": 83,
                    "column": 5
                }
            },
            {
                "definition": "public String getDescription() {\n    return description;\n}",
                "name": "getDescription",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return description;\n}",
                "start_point": {
                    "row": 85,
                    "column": 4
                },
                "end_point": {
                    "row": 87,
                    "column": 5
                }
            },
            {
                "definition": "public void setDescription(String description) {\n    this.description = description;\n}",
                "name": "setDescription",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "description"
                    }
                ],
                "body": "{\n    this.description = description;\n}",
                "start_point": {
                    "row": 89,
                    "column": 4
                },
                "end_point": {
                    "row": 91,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 93,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 97,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isMaster() {\n    return master;\n}",
                "name": "isMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return master;\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 103,
                    "column": 5
                }
            },
            {
                "definition": "public void setMaster(boolean master) {\n    this.master = master;\n}",
                "name": "setMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "master"
                    }
                ],
                "body": "{\n    this.master = master;\n}",
                "start_point": {
                    "row": 105,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "public Date getCreatedAt() {\n    return createdAt;\n}",
                "name": "getCreatedAt",
                "modifiers": "public",
                "return_type": "Date",
                "parameters": [],
                "body": "{\n    return createdAt;\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 111,
                    "column": 5
                }
            },
            {
                "definition": "public void setCreatedAt(Date createdAt) {\n    this.createdAt = createdAt;\n}",
                "name": "setCreatedAt",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Date",
                        "name": "createdAt"
                    }
                ],
                "body": "{\n    this.createdAt = createdAt;\n}",
                "start_point": {
                    "row": 113,
                    "column": 4
                },
                "end_point": {
                    "row": 115,
                    "column": 5
                }
            },
            {
                "definition": "public Date getUpdatedAt() {\n    return updatedAt;\n}",
                "name": "getUpdatedAt",
                "modifiers": "public",
                "return_type": "Date",
                "parameters": [],
                "body": "{\n    return updatedAt;\n}",
                "start_point": {
                    "row": 117,
                    "column": 4
                },
                "end_point": {
                    "row": 119,
                    "column": 5
                }
            },
            {
                "definition": "public void setUpdatedAt(Date updatedAt) {\n    this.updatedAt = updatedAt;\n}",
                "name": "setUpdatedAt",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Date",
                        "name": "updatedAt"
                    }
                ],
                "body": "{\n    this.updatedAt = updatedAt;\n}",
                "start_point": {
                    "row": 121,
                    "column": 4
                },
                "end_point": {
                    "row": 123,
                    "column": 5
                }
            },
            {
                "definition": "public String getPath() {\n    return path;\n}",
                "name": "getPath",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return path;\n}",
                "start_point": {
                    "row": 125,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "public void setPath(String path) {\n    this.path = path;\n}",
                "name": "setPath",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "path"
                    }
                ],
                "body": "{\n    this.path = path;\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 131,
                    "column": 5
                }
            },
            {
                "definition": "public LoginForm getLoginForm() {\n    return loginForm;\n}",
                "name": "getLoginForm",
                "modifiers": "public",
                "return_type": "LoginForm",
                "parameters": [],
                "body": "{\n    return loginForm;\n}",
                "start_point": {
                    "row": 133,
                    "column": 4
                },
                "end_point": {
                    "row": 135,
                    "column": 5
                }
            },
            {
                "definition": "public void setLoginForm(LoginForm loginForm) {\n    this.loginForm = loginForm;\n}",
                "name": "setLoginForm",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "LoginForm",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    this.loginForm = loginForm;\n}",
                "start_point": {
                    "row": 137,
                    "column": 4
                },
                "end_point": {
                    "row": 139,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    Domain domain = (Domain) o;\n\n    return id.equals(domain.id);\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    Domain domain = (Domain) o;\n\n    return id.equals(domain.id);\n}",
                "start_point": {
                    "row": 141,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    return id.hashCode();\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return id.hashCode();\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-repository/gravitee-am-repository-mongodb/src/main/java/io/gravitee/am/repository/mongodb/management/MongoDomainRepository.java",
        "definition": "@Component\npublic class MongoDomainRepository extends AbstractManagementMongoRepository implements DomainRepository {\n\n    private static final String FIELD_ID = \"_id\";\n    private MongoCollection<DomainMongo> domainsCollection;\n\n    @Autowired\n    private IdGenerator idGenerator;\n\n    @PostConstruct\n    public void init() {\n        domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Single<Domain> create(Domain item) {\n        DomainMongo domain = convert(item);\n        domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n        return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Domain> update(Domain item) {\n        DomainMongo domain = convert(item);\n        return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String id) {\n        return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n    }\n\n    private Domain convert(DomainMongo domainMongo) {\n        if (domainMongo == null) {\n            return null;\n        }\n\n        Domain domain = new Domain();\n        domain.setId(domainMongo.getId());\n        domain.setPath(domainMongo.getPath());\n        domain.setCreatedAt(domainMongo.getCreatedAt());\n        domain.setUpdatedAt(domainMongo.getUpdatedAt());\n        domain.setName(domainMongo.getName());\n        domain.setDescription(domainMongo.getDescription());\n        domain.setEnabled(domainMongo.isEnabled());\n        domain.setMaster(domainMongo.isMaster());\n        domain.setLoginForm(convert(domainMongo.getLoginForm()));\n        return domain;\n    }\n\n    private DomainMongo convert(Domain domain) {\n        if (domain == null) {\n            return null;\n        }\n\n        DomainMongo domainMongo = new DomainMongo();\n        domainMongo.setId(domain.getId());\n        domainMongo.setPath(domain.getPath());\n        domainMongo.setCreatedAt(domain.getCreatedAt());\n        domainMongo.setUpdatedAt(domain.getUpdatedAt());\n        domainMongo.setName(domain.getName());\n        domainMongo.setDescription(domain.getDescription());\n        domainMongo.setEnabled(domain.isEnabled());\n        domainMongo.setMaster(domain.isMaster());\n        domainMongo.setLoginForm(convert(domain.getLoginForm()));\n        return domainMongo;\n    }\n\n    private LoginForm convert(LoginFormMongo loginFormMongo) {\n        if (loginFormMongo == null) {\n            return null;\n        }\n\n        LoginForm loginForm = new LoginForm();\n        loginForm.setEnabled(loginFormMongo.isEnabled());\n        loginForm.setContent(loginFormMongo.getContent());\n        loginForm.setAssets(loginFormMongo.getAssets());\n        return loginForm;\n    }\n\n    private LoginFormMongo convert(LoginForm loginForm) {\n        if (loginForm == null) {\n            return null;\n        }\n\n        LoginFormMongo formMongo = new LoginFormMongo();\n        formMongo.setEnabled(loginForm.isEnabled());\n        formMongo.setContent(loginForm.getContent());\n        formMongo.setAssets(loginForm.getAssets());\n        return formMongo;\n    }\n}",
        "package": "package io.gravitee.am.repository.mongodb.management;",
        "tree_path": "MongoDomainRepository",
        "name": "MongoDomainRepository",
        "modifiers": "@Component\npublic",
        "superclass": "extends AbstractManagementMongoRepository",
        "super_interfaces": "implements DomainRepository",
        "body": "{\n\n    private static final String FIELD_ID = \"_id\";\n    private MongoCollection<DomainMongo> domainsCollection;\n\n    @Autowired\n    private IdGenerator idGenerator;\n\n    @PostConstruct\n    public void init() {\n        domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n    }\n\n    @Override\n    public Single<Domain> create(Domain item) {\n        DomainMongo domain = convert(item);\n        domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n        return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Domain> update(Domain item) {\n        DomainMongo domain = convert(item);\n        return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String id) {\n        return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n    }\n\n    private Domain convert(DomainMongo domainMongo) {\n        if (domainMongo == null) {\n            return null;\n        }\n\n        Domain domain = new Domain();\n        domain.setId(domainMongo.getId());\n        domain.setPath(domainMongo.getPath());\n        domain.setCreatedAt(domainMongo.getCreatedAt());\n        domain.setUpdatedAt(domainMongo.getUpdatedAt());\n        domain.setName(domainMongo.getName());\n        domain.setDescription(domainMongo.getDescription());\n        domain.setEnabled(domainMongo.isEnabled());\n        domain.setMaster(domainMongo.isMaster());\n        domain.setLoginForm(convert(domainMongo.getLoginForm()));\n        return domain;\n    }\n\n    private DomainMongo convert(Domain domain) {\n        if (domain == null) {\n            return null;\n        }\n\n        DomainMongo domainMongo = new DomainMongo();\n        domainMongo.setId(domain.getId());\n        domainMongo.setPath(domain.getPath());\n        domainMongo.setCreatedAt(domain.getCreatedAt());\n        domainMongo.setUpdatedAt(domain.getUpdatedAt());\n        domainMongo.setName(domain.getName());\n        domainMongo.setDescription(domain.getDescription());\n        domainMongo.setEnabled(domain.isEnabled());\n        domainMongo.setMaster(domain.isMaster());\n        domainMongo.setLoginForm(convert(domain.getLoginForm()));\n        return domainMongo;\n    }\n\n    private LoginForm convert(LoginFormMongo loginFormMongo) {\n        if (loginFormMongo == null) {\n            return null;\n        }\n\n        LoginForm loginForm = new LoginForm();\n        loginForm.setEnabled(loginFormMongo.isEnabled());\n        loginForm.setContent(loginFormMongo.getContent());\n        loginForm.setAssets(loginFormMongo.getAssets());\n        return loginForm;\n    }\n\n    private LoginFormMongo convert(LoginForm loginForm) {\n        if (loginForm == null) {\n            return null;\n        }\n\n        LoginFormMongo formMongo = new LoginFormMongo();\n        formMongo.setEnabled(loginForm.isEnabled());\n        formMongo.setContent(loginForm.getContent());\n        formMongo.setAssets(loginForm.getAssets());\n        return formMongo;\n    }\n}",
        "start_point": {
            "row": 44,
            "column": 0
        },
        "end_point": {
            "row": 150,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@PostConstruct\npublic void init() {\n    domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n}",
                "name": "init",
                "modifiers": "@PostConstruct\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    domainsCollection = mongoOperations.getCollection(\"domains\", DomainMongo.class);\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findAll() {\n    return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "name": "findAll",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Observable.fromPublisher(domainsCollection.find()).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Maybe<Domain> findById(String id) {\n    return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n}",
                "name": "findById",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return Observable.fromPublisher(domainsCollection.find(eq(FIELD_ID, id)).first()).firstElement().map(this::convert);\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 66,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n    return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "name": "findByIdIn",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "ids"
                    }
                ],
                "body": "{\n    return Observable.fromPublisher(domainsCollection.find(in(FIELD_ID, ids))).map(this::convert).collect(HashSet::new, Set::add);\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> create(Domain item) {\n    DomainMongo domain = convert(item);\n    domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n    return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "item"
                    }
                ],
                "body": "{\n    DomainMongo domain = convert(item);\n    domain.setId(domain.getId() == null ? (String) idGenerator.generate() : domain.getId());\n    return Single.fromPublisher(domainsCollection.insertOne(domain)).flatMap(success -> findById(domain.getId()).toSingle());\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> update(Domain item) {\n    DomainMongo domain = convert(item);\n    return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n}",
                "name": "update",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "item"
                    }
                ],
                "body": "{\n    DomainMongo domain = convert(item);\n    return Single.fromPublisher(domainsCollection.replaceOne(eq(FIELD_ID, domain.getId()), domain)).flatMap(updateResult -> findById(domain.getId()).toSingle());\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Irrelevant> delete(String id) {\n    return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n}",
                "name": "delete",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return Single.fromPublisher(domainsCollection.deleteOne(eq(FIELD_ID, id))).map(deleteResult -> Irrelevant.DOMAIN);\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            },
            {
                "definition": "private Domain convert(DomainMongo domainMongo) {\n    if (domainMongo == null) {\n        return null;\n    }\n\n    Domain domain = new Domain();\n    domain.setId(domainMongo.getId());\n    domain.setPath(domainMongo.getPath());\n    domain.setCreatedAt(domainMongo.getCreatedAt());\n    domain.setUpdatedAt(domainMongo.getUpdatedAt());\n    domain.setName(domainMongo.getName());\n    domain.setDescription(domainMongo.getDescription());\n    domain.setEnabled(domainMongo.isEnabled());\n    domain.setMaster(domainMongo.isMaster());\n    domain.setLoginForm(convert(domainMongo.getLoginForm()));\n    return domain;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "Domain",
                "parameters": [
                    {
                        "type": "DomainMongo",
                        "name": "domainMongo"
                    }
                ],
                "body": "{\n    if (domainMongo == null) {\n        return null;\n    }\n\n    Domain domain = new Domain();\n    domain.setId(domainMongo.getId());\n    domain.setPath(domainMongo.getPath());\n    domain.setCreatedAt(domainMongo.getCreatedAt());\n    domain.setUpdatedAt(domainMongo.getUpdatedAt());\n    domain.setName(domainMongo.getName());\n    domain.setDescription(domainMongo.getDescription());\n    domain.setEnabled(domainMongo.isEnabled());\n    domain.setMaster(domainMongo.isMaster());\n    domain.setLoginForm(convert(domainMongo.getLoginForm()));\n    return domain;\n}",
                "start_point": {
                    "row": 91,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "private DomainMongo convert(Domain domain) {\n    if (domain == null) {\n        return null;\n    }\n\n    DomainMongo domainMongo = new DomainMongo();\n    domainMongo.setId(domain.getId());\n    domainMongo.setPath(domain.getPath());\n    domainMongo.setCreatedAt(domain.getCreatedAt());\n    domainMongo.setUpdatedAt(domain.getUpdatedAt());\n    domainMongo.setName(domain.getName());\n    domainMongo.setDescription(domain.getDescription());\n    domainMongo.setEnabled(domain.isEnabled());\n    domainMongo.setMaster(domain.isMaster());\n    domainMongo.setLoginForm(convert(domain.getLoginForm()));\n    return domainMongo;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "DomainMongo",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    if (domain == null) {\n        return null;\n    }\n\n    DomainMongo domainMongo = new DomainMongo();\n    domainMongo.setId(domain.getId());\n    domainMongo.setPath(domain.getPath());\n    domainMongo.setCreatedAt(domain.getCreatedAt());\n    domainMongo.setUpdatedAt(domain.getUpdatedAt());\n    domainMongo.setName(domain.getName());\n    domainMongo.setDescription(domain.getDescription());\n    domainMongo.setEnabled(domain.isEnabled());\n    domainMongo.setMaster(domain.isMaster());\n    domainMongo.setLoginForm(convert(domain.getLoginForm()));\n    return domainMongo;\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 125,
                    "column": 5
                }
            },
            {
                "definition": "private LoginForm convert(LoginFormMongo loginFormMongo) {\n    if (loginFormMongo == null) {\n        return null;\n    }\n\n    LoginForm loginForm = new LoginForm();\n    loginForm.setEnabled(loginFormMongo.isEnabled());\n    loginForm.setContent(loginFormMongo.getContent());\n    loginForm.setAssets(loginFormMongo.getAssets());\n    return loginForm;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "LoginForm",
                "parameters": [
                    {
                        "type": "LoginFormMongo",
                        "name": "loginFormMongo"
                    }
                ],
                "body": "{\n    if (loginFormMongo == null) {\n        return null;\n    }\n\n    LoginForm loginForm = new LoginForm();\n    loginForm.setEnabled(loginFormMongo.isEnabled());\n    loginForm.setContent(loginFormMongo.getContent());\n    loginForm.setAssets(loginFormMongo.getAssets());\n    return loginForm;\n}",
                "start_point": {
                    "row": 127,
                    "column": 4
                },
                "end_point": {
                    "row": 137,
                    "column": 5
                }
            },
            {
                "definition": "private LoginFormMongo convert(LoginForm loginForm) {\n    if (loginForm == null) {\n        return null;\n    }\n\n    LoginFormMongo formMongo = new LoginFormMongo();\n    formMongo.setEnabled(loginForm.isEnabled());\n    formMongo.setContent(loginForm.getContent());\n    formMongo.setAssets(loginForm.getAssets());\n    return formMongo;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "LoginFormMongo",
                "parameters": [
                    {
                        "type": "LoginForm",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    if (loginForm == null) {\n        return null;\n    }\n\n    LoginFormMongo formMongo = new LoginFormMongo();\n    formMongo.setEnabled(loginForm.isEnabled());\n    formMongo.setContent(loginForm.getContent());\n    formMongo.setAssets(loginForm.getAssets());\n    return formMongo;\n}",
                "start_point": {
                    "row": 139,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-repository/gravitee-am-repository-mongodb/src/main/java/io/gravitee/am/repository/mongodb/management/internal/model/DomainMongo.java",
        "definition": "public class DomainMongo extends Auditable {\n\n    @BsonId\n    private String id;\n\n    private String name;\n\n    private String description;\n\n    private boolean enabled;\n\n    private boolean master;\n\n    private String path;\n\n    private LoginFormMongo loginForm;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginFormMongo getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginFormMongo loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        DomainMongo that = (DomainMongo) o;\n\n        return id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "package": "package io.gravitee.am.repository.mongodb.management.internal.model;",
        "tree_path": "DomainMongo",
        "name": "DomainMongo",
        "modifiers": "public",
        "superclass": "extends Auditable",
        "super_interfaces": null,
        "body": "{\n\n    @BsonId\n    private String id;\n\n    private String name;\n\n    private String description;\n\n    private boolean enabled;\n\n    private boolean master;\n\n    private String path;\n\n    private LoginFormMongo loginForm;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isMaster() {\n        return master;\n    }\n\n    public void setMaster(boolean master) {\n        this.master = master;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n\n    public LoginFormMongo getLoginForm() {\n        return loginForm;\n    }\n\n    public void setLoginForm(LoginFormMongo loginForm) {\n        this.loginForm = loginForm;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        DomainMongo that = (DomainMongo) o;\n\n        return id.equals(that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return id.hashCode();\n    }\n}",
        "start_point": {
            "row": 24,
            "column": 0
        },
        "end_point": {
            "row": 111,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public String getId() {\n    return id;\n}",
                "name": "getId",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return id;\n}",
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            },
            {
                "definition": "public void setId(String id) {\n    this.id = id;\n}",
                "name": "setId",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    this.id = id;\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 47,
                    "column": 5
                }
            },
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 49,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 55,
                    "column": 5
                }
            },
            {
                "definition": "public String getDescription() {\n    return description;\n}",
                "name": "getDescription",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return description;\n}",
                "start_point": {
                    "row": 57,
                    "column": 4
                },
                "end_point": {
                    "row": 59,
                    "column": 5
                }
            },
            {
                "definition": "public void setDescription(String description) {\n    this.description = description;\n}",
                "name": "setDescription",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "description"
                    }
                ],
                "body": "{\n    this.description = description;\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 63,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isMaster() {\n    return master;\n}",
                "name": "isMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return master;\n}",
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 67,
                    "column": 5
                }
            },
            {
                "definition": "public void setMaster(boolean master) {\n    this.master = master;\n}",
                "name": "setMaster",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "master"
                    }
                ],
                "body": "{\n    this.master = master;\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "public String getPath() {\n    return path;\n}",
                "name": "getPath",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return path;\n}",
                "start_point": {
                    "row": 81,
                    "column": 4
                },
                "end_point": {
                    "row": 83,
                    "column": 5
                }
            },
            {
                "definition": "public void setPath(String path) {\n    this.path = path;\n}",
                "name": "setPath",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "path"
                    }
                ],
                "body": "{\n    this.path = path;\n}",
                "start_point": {
                    "row": 85,
                    "column": 4
                },
                "end_point": {
                    "row": 87,
                    "column": 5
                }
            },
            {
                "definition": "public LoginFormMongo getLoginForm() {\n    return loginForm;\n}",
                "name": "getLoginForm",
                "modifiers": "public",
                "return_type": "LoginFormMongo",
                "parameters": [],
                "body": "{\n    return loginForm;\n}",
                "start_point": {
                    "row": 89,
                    "column": 4
                },
                "end_point": {
                    "row": 91,
                    "column": 5
                }
            },
            {
                "definition": "public void setLoginForm(LoginFormMongo loginForm) {\n    this.loginForm = loginForm;\n}",
                "name": "setLoginForm",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "LoginFormMongo",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    this.loginForm = loginForm;\n}",
                "start_point": {
                    "row": 93,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DomainMongo that = (DomainMongo) o;\n\n    return id.equals(that.id);\n}",
                "name": "equals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    DomainMongo that = (DomainMongo) o;\n\n    return id.equals(that.id);\n}",
                "start_point": {
                    "row": 97,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    return id.hashCode();\n}",
                "name": "hashCode",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return id.hashCode();\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 110,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/main/java/io/gravitee/am/service/impl/DomainServiceImpl.java",
        "definition": "@Component\npublic class DomainServiceImpl implements DomainService {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(DomainServiceImpl.class);\n\n    @Autowired\n    private DomainRepository domainRepository;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private CertificateService certificateService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        LOGGER.debug(\"Find domain by ID: {}\", id);\n        return domainRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        LOGGER.debug(\"Find all domains\");\n        return domainRepository.findAll()\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        LOGGER.debug(\"Find domains by id in {}\", ids);\n        return domainRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> create(NewDomain newDomain) {\n        LOGGER.debug(\"Create a new domain: {}\", newDomain);\n        String id = generateContextPath(newDomain.getName());\n\n        return domainRepository.findById(id)\n                .isEmpty()\n                .flatMap(empty -> {\n                    if (!empty) {\n                        throw new DomainAlreadyExistsException(newDomain.getName());\n                    } else {\n                        Domain domain = new Domain();\n                        domain.setId(id);\n                        domain.setPath(id);\n                        domain.setName(newDomain.getName());\n                        domain.setDescription(newDomain.getDescription());\n                        domain.setEnabled(false);\n                        domain.setCreatedAt(new Date());\n                        domain.setUpdatedAt(domain.getCreatedAt());\n                        return domainRepository.create(domain);\n                    }\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n            });\n    }\n\n    @Override\n    public Single<Domain> update(String domainId, UpdateDomain updateDomain) {\n        LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(updateDomain.getPath());\n                        domain.setName(updateDomain.getName());\n                        domain.setDescription(updateDomain.getDescription());\n                        domain.setEnabled(updateDomain.isEnabled());\n                        // master flag is set programmatically (keep old value)\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> reload(String domainId) {\n        LOGGER.debug(\"Reload a domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> setMasterDomain(String domainId, boolean isMaster) {\n        LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(isMaster);\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String domainId) {\n        LOGGER.debug(\"Delete security domain {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(optDomain -> {\n                    if (!optDomain.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    }\n                    if (optDomain.get().isMaster()) {\n                        throw new DomainDeleteMasterException(domainId);\n                    }\n                    return Single.just(optDomain.get());\n                })\n                .flatMap(domain -> {\n                    // delete clients\n                    return clientService.findByDomain(domainId)\n                            .flatMap(clients -> Observable.fromIterable(clients)\n                                    .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete certificates\n                    return certificateService.findByDomain(domainId)\n                            .flatMap(certificates -> Observable.fromIterable(certificates)\n                                    .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete identity providers\n                    return identityProviderService.findByDomain(domainId)\n                            .flatMap(idps -> Observable.fromIterable(idps)\n                                    .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete roles\n                    return roleService.findByDomain(domainId)\n                            .flatMap(roles -> Observable.fromIterable(roles)\n                                    .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete users\n                    return userService.findByDomain(domainId)\n                            .flatMap(users -> Observable.fromIterable(users)\n                                    .flatMapSingle(u -> userService.delete(u.getId())).toList());\n                })\n                .flatMap(irrelevant -> domainRepository.delete(domainId))\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n                });\n    }\n\n    @Override\n    public Single<LoginForm> updateLoginForm(String domainId, UpdateLoginForm loginForm) {\n        LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        LoginForm form = new LoginForm();\n                        form.setEnabled(loginForm.isEnabled());\n                        form.setContent(loginForm.getContent());\n                        form.setAssets(loginForm.getAssets());\n\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(form);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain).map(domain1 -> form);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> deleteLoginForm(String domainId) {\n        LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(null);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n                });\n    }\n\n    private String generateContextPath(String domainName) {\n        String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n        Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n        domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n        return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n    }\n}",
        "package": "package io.gravitee.am.service.impl;",
        "tree_path": "DomainServiceImpl",
        "name": "DomainServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements DomainService",
        "body": "{\n\n    private final Logger LOGGER = LoggerFactory.getLogger(DomainServiceImpl.class);\n\n    @Autowired\n    private DomainRepository domainRepository;\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private CertificateService certificateService;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public Maybe<Domain> findById(String id) {\n        LOGGER.debug(\"Find domain by ID: {}\", id);\n        return domainRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findAll() {\n        LOGGER.debug(\"Find all domains\");\n        return domainRepository.findAll()\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n        LOGGER.debug(\"Find domains by id in {}\", ids);\n        return domainRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> create(NewDomain newDomain) {\n        LOGGER.debug(\"Create a new domain: {}\", newDomain);\n        String id = generateContextPath(newDomain.getName());\n\n        return domainRepository.findById(id)\n                .isEmpty()\n                .flatMap(empty -> {\n                    if (!empty) {\n                        throw new DomainAlreadyExistsException(newDomain.getName());\n                    } else {\n                        Domain domain = new Domain();\n                        domain.setId(id);\n                        domain.setPath(id);\n                        domain.setName(newDomain.getName());\n                        domain.setDescription(newDomain.getDescription());\n                        domain.setEnabled(false);\n                        domain.setCreatedAt(new Date());\n                        domain.setUpdatedAt(domain.getCreatedAt());\n                        return domainRepository.create(domain);\n                    }\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n            });\n    }\n\n    @Override\n    public Single<Domain> update(String domainId, UpdateDomain updateDomain) {\n        LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(updateDomain.getPath());\n                        domain.setName(updateDomain.getName());\n                        domain.setDescription(updateDomain.getDescription());\n                        domain.setEnabled(updateDomain.isEnabled());\n                        // master flag is set programmatically (keep old value)\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> reload(String domainId) {\n        LOGGER.debug(\"Reload a domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(oldDomain.isMaster());\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> setMasterDomain(String domainId, boolean isMaster) {\n        LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain oldDomain = domainOpt.get();\n\n                        Domain domain = new Domain();\n                        domain.setId(domainId);\n                        domain.setPath(oldDomain.getPath());\n                        domain.setName(oldDomain.getName());\n                        domain.setDescription(oldDomain.getDescription());\n                        domain.setEnabled(oldDomain.isEnabled());\n                        domain.setMaster(isMaster);\n                        domain.setCreatedAt(oldDomain.getCreatedAt());\n                        domain.setUpdatedAt(new Date());\n                        domain.setLoginForm(oldDomain.getLoginForm());\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String domainId) {\n        LOGGER.debug(\"Delete security domain {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(optDomain -> {\n                    if (!optDomain.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    }\n                    if (optDomain.get().isMaster()) {\n                        throw new DomainDeleteMasterException(domainId);\n                    }\n                    return Single.just(optDomain.get());\n                })\n                .flatMap(domain -> {\n                    // delete clients\n                    return clientService.findByDomain(domainId)\n                            .flatMap(clients -> Observable.fromIterable(clients)\n                                    .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete certificates\n                    return certificateService.findByDomain(domainId)\n                            .flatMap(certificates -> Observable.fromIterable(certificates)\n                                    .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete identity providers\n                    return identityProviderService.findByDomain(domainId)\n                            .flatMap(idps -> Observable.fromIterable(idps)\n                                    .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete roles\n                    return roleService.findByDomain(domainId)\n                            .flatMap(roles -> Observable.fromIterable(roles)\n                                    .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n                })\n                .flatMap(irrelevant -> {\n                    // delete users\n                    return userService.findByDomain(domainId)\n                            .flatMap(users -> Observable.fromIterable(users)\n                                    .flatMapSingle(u -> userService.delete(u.getId())).toList());\n                })\n                .flatMap(irrelevant -> domainRepository.delete(domainId))\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n                });\n    }\n\n    @Override\n    public Single<LoginForm> updateLoginForm(String domainId, UpdateLoginForm loginForm) {\n        LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        LoginForm form = new LoginForm();\n                        form.setEnabled(loginForm.isEnabled());\n                        form.setContent(loginForm.getContent());\n                        form.setAssets(loginForm.getAssets());\n\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(form);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain).map(domain1 -> form);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n                });\n    }\n\n    @Override\n    public Single<Domain> deleteLoginForm(String domainId) {\n        LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n        return domainRepository.findById(domainId)\n                .map(domain -> Optional.of(domain))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(domainOpt -> {\n                    if(!domainOpt.isPresent()) {\n                        throw new DomainNotFoundException(domainId);\n                    } else {\n                        Domain domain = domainOpt.get();\n                        domain.setLoginForm(null);\n                        domain.setUpdatedAt(new Date());\n\n                        return domainRepository.update(domain);\n                    }\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n                });\n    }\n\n    private String generateContextPath(String domainName) {\n        String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n        Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n        domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n        return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n    }\n}",
        "start_point": {
            "row": 46,
            "column": 0
        },
        "end_point": {
            "row": 367,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Maybe<Domain> findById(String id) {\n    LOGGER.debug(\"Find domain by ID: {}\", id);\n    return domainRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n            });\n}",
                "name": "findById",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find domain by ID: {}\", id);\n    return domainRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a domain using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a domain using its ID: %s\", id), ex));\n            });\n}",
                "start_point": {
                    "row": 69,
                    "column": 4
                },
                "end_point": {
                    "row": 78,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findAll() {\n    LOGGER.debug(\"Find all domains\");\n    return domainRepository.findAll()\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n            });\n}",
                "name": "findAll",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    LOGGER.debug(\"Find all domains\");\n    return domainRepository.findAll()\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find all domains\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find all domains\", ex));\n            });\n}",
                "start_point": {
                    "row": 80,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Domain>> findByIdIn(Collection<String> ids) {\n    LOGGER.debug(\"Find domains by id in {}\", ids);\n    return domainRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n            });\n}",
                "name": "findByIdIn",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<String>",
                        "name": "ids"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find domains by id in {}\", ids);\n    return domainRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find domains by id in {}\", ids, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find domains by id in\", ex));\n            });\n}",
                "start_point": {
                    "row": 90,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> create(NewDomain newDomain) {\n    LOGGER.debug(\"Create a new domain: {}\", newDomain);\n    String id = generateContextPath(newDomain.getName());\n\n    return domainRepository.findById(id)\n            .isEmpty()\n            .flatMap(empty -> {\n                if (!empty) {\n                    throw new DomainAlreadyExistsException(newDomain.getName());\n                } else {\n                    Domain domain = new Domain();\n                    domain.setId(id);\n                    domain.setPath(id);\n                    domain.setName(newDomain.getName());\n                    domain.setDescription(newDomain.getDescription());\n                    domain.setEnabled(false);\n                    domain.setCreatedAt(new Date());\n                    domain.setUpdatedAt(domain.getCreatedAt());\n                    return domainRepository.create(domain);\n                }\n            })\n        .onErrorResumeNext(ex -> {\n            if (ex instanceof AbstractManagementException) {\n                return Single.error(ex);\n            }\n\n            LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n            return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n        });\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "NewDomain",
                        "name": "newDomain"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Create a new domain: {}\", newDomain);\n    String id = generateContextPath(newDomain.getName());\n\n    return domainRepository.findById(id)\n            .isEmpty()\n            .flatMap(empty -> {\n                if (!empty) {\n                    throw new DomainAlreadyExistsException(newDomain.getName());\n                } else {\n                    Domain domain = new Domain();\n                    domain.setId(id);\n                    domain.setPath(id);\n                    domain.setName(newDomain.getName());\n                    domain.setDescription(newDomain.getDescription());\n                    domain.setEnabled(false);\n                    domain.setCreatedAt(new Date());\n                    domain.setUpdatedAt(domain.getCreatedAt());\n                    return domainRepository.create(domain);\n                }\n            })\n        .onErrorResumeNext(ex -> {\n            if (ex instanceof AbstractManagementException) {\n                return Single.error(ex);\n            }\n\n            LOGGER.error(\"An error occurs while trying to create a domain\", ex);\n            return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a domain\", ex));\n        });\n}",
                "start_point": {
                    "row": 100,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> update(String domainId, UpdateDomain updateDomain) {\n    LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(updateDomain.getPath());\n                    domain.setName(updateDomain.getName());\n                    domain.setDescription(updateDomain.getDescription());\n                    domain.setEnabled(updateDomain.isEnabled());\n                    // master flag is set programmatically (keep old value)\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "name": "update",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    },
                    {
                        "type": "UpdateDomain",
                        "name": "updateDomain"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Update an existing domain: {}\", updateDomain);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(updateDomain.getPath());\n                    domain.setName(updateDomain.getName());\n                    domain.setDescription(updateDomain.getDescription());\n                    domain.setEnabled(updateDomain.isEnabled());\n                    // master flag is set programmatically (keep old value)\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 132,
                    "column": 4
                },
                "end_point": {
                    "row": 168,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> reload(String domainId) {\n    LOGGER.debug(\"Reload a domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n            });\n}",
                "name": "reload",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Reload a domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(oldDomain.isMaster());\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to reload a domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to reload a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 170,
                    "column": 4
                },
                "end_point": {
                    "row": 205,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> setMasterDomain(String domainId, boolean isMaster) {\n    LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(isMaster);\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n            });\n}",
                "name": "setMasterDomain",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    },
                    {
                        "type": "boolean",
                        "name": "isMaster"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Set master flag for domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain oldDomain = domainOpt.get();\n\n                    Domain domain = new Domain();\n                    domain.setId(domainId);\n                    domain.setPath(oldDomain.getPath());\n                    domain.setName(oldDomain.getName());\n                    domain.setDescription(oldDomain.getDescription());\n                    domain.setEnabled(oldDomain.isEnabled());\n                    domain.setMaster(isMaster);\n                    domain.setCreatedAt(oldDomain.getCreatedAt());\n                    domain.setUpdatedAt(new Date());\n                    domain.setLoginForm(oldDomain.getLoginForm());\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to set master flag for domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to set master flag for a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 207,
                    "column": 4
                },
                "end_point": {
                    "row": 241,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Irrelevant> delete(String domainId) {\n    LOGGER.debug(\"Delete security domain {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(optDomain -> {\n                if (!optDomain.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                }\n                if (optDomain.get().isMaster()) {\n                    throw new DomainDeleteMasterException(domainId);\n                }\n                return Single.just(optDomain.get());\n            })\n            .flatMap(domain -> {\n                // delete clients\n                return clientService.findByDomain(domainId)\n                        .flatMap(clients -> Observable.fromIterable(clients)\n                                .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete certificates\n                return certificateService.findByDomain(domainId)\n                        .flatMap(certificates -> Observable.fromIterable(certificates)\n                                .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete identity providers\n                return identityProviderService.findByDomain(domainId)\n                        .flatMap(idps -> Observable.fromIterable(idps)\n                                .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete roles\n                return roleService.findByDomain(domainId)\n                        .flatMap(roles -> Observable.fromIterable(roles)\n                                .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete users\n                return userService.findByDomain(domainId)\n                        .flatMap(users -> Observable.fromIterable(users)\n                                .flatMapSingle(u -> userService.delete(u.getId())).toList());\n            })\n            .flatMap(irrelevant -> domainRepository.delete(domainId))\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n            });\n}",
                "name": "delete",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Delete security domain {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(optDomain -> {\n                if (!optDomain.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                }\n                if (optDomain.get().isMaster()) {\n                    throw new DomainDeleteMasterException(domainId);\n                }\n                return Single.just(optDomain.get());\n            })\n            .flatMap(domain -> {\n                // delete clients\n                return clientService.findByDomain(domainId)\n                        .flatMap(clients -> Observable.fromIterable(clients)\n                                .flatMapSingle(c -> clientService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete certificates\n                return certificateService.findByDomain(domainId)\n                        .flatMap(certificates -> Observable.fromIterable(certificates)\n                                .flatMapSingle(c -> certificateService.delete(c.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete identity providers\n                return identityProviderService.findByDomain(domainId)\n                        .flatMap(idps -> Observable.fromIterable(idps)\n                                .flatMapSingle(i -> identityProviderService.delete(i.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete roles\n                return roleService.findByDomain(domainId)\n                        .flatMap(roles -> Observable.fromIterable(roles)\n                                .flatMapSingle(r -> roleService.delete(r.getId())).toList());\n            })\n            .flatMap(irrelevant -> {\n                // delete users\n                return userService.findByDomain(domainId)\n                        .flatMap(users -> Observable.fromIterable(users)\n                                .flatMapSingle(u -> userService.delete(u.getId())).toList());\n            })\n            .flatMap(irrelevant -> domainRepository.delete(domainId))\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete security domain {}\", domainId, ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to delete security domain \" + domainId, ex));\n            });\n}",
                "start_point": {
                    "row": 243,
                    "column": 4
                },
                "end_point": {
                    "row": 298,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<LoginForm> updateLoginForm(String domainId, UpdateLoginForm loginForm) {\n    LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    LoginForm form = new LoginForm();\n                    form.setEnabled(loginForm.isEnabled());\n                    form.setContent(loginForm.getContent());\n                    form.setAssets(loginForm.getAssets());\n\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(form);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain).map(domain1 -> form);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "name": "updateLoginForm",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    },
                    {
                        "type": "UpdateLoginForm",
                        "name": "loginForm"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Update login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    LoginForm form = new LoginForm();\n                    form.setEnabled(loginForm.isEnabled());\n                    form.setContent(loginForm.getContent());\n                    form.setAssets(loginForm.getAssets());\n\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(form);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain).map(domain1 -> form);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 300,
                    "column": 4
                },
                "end_point": {
                    "row": 331,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Domain> deleteLoginForm(String domainId) {\n    LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(null);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n            });\n}",
                "name": "deleteLoginForm",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Delete login form of an existing domain: {}\", domainId);\n    return domainRepository.findById(domainId)\n            .map(domain -> Optional.of(domain))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(domainOpt -> {\n                if(!domainOpt.isPresent()) {\n                    throw new DomainNotFoundException(domainId);\n                } else {\n                    Domain domain = domainOpt.get();\n                    domain.setLoginForm(null);\n                    domain.setUpdatedAt(new Date());\n\n                    return domainRepository.update(domain);\n                }\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update login form domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update login form domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 333,
                    "column": 4
                },
                "end_point": {
                    "row": 359,
                    "column": 5
                }
            },
            {
                "definition": "private String generateContextPath(String domainName) {\n    String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n    Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n    domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n    return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n}",
                "name": "generateContextPath",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "domainName"
                    }
                ],
                "body": "{\n    String nfdNormalizedString = Normalizer.normalize(domainName, Normalizer.Form.NFD);\n    Pattern pattern = Pattern.compile(\"\\\\p{InCombiningDiacriticalMarks}+\");\n    domainName = pattern.matcher(nfdNormalizedString).replaceAll(\"\");\n    return domainName.toLowerCase().trim().replaceAll(\"\\\\s{1,}\", \"-\");\n}",
                "start_point": {
                    "row": 361,
                    "column": 4
                },
                "end_point": {
                    "row": 366,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/main/java/io/gravitee/am/service/impl/RoleServiceImpl.java",
        "definition": "@Component\npublic class RoleServiceImpl implements RoleService {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(RoleServiceImpl.class);\n\n    @Autowired\n    private RoleRepository roleRepository;\n\n    @Override\n    public Single<Set<Role>> findByDomain(String domain) {\n        LOGGER.debug(\"Find roles by domain: {}\", domain);\n        return roleRepository.findByDomain(domain)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n                });\n    }\n\n    @Override\n    public Maybe<Role> findById(String id) {\n        LOGGER.debug(\"Find role by ID: {}\", id);\n        return roleRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Role>> findByIdIn(List<String> ids) {\n        LOGGER.debug(\"Find roles by ids: {}\", ids);\n        return roleRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n                });\n    }\n\n\n    @Override\n    public Single<Role> create(String domain, NewRole newRole) {\n        LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n        String roleId = UUID.toString(UUID.random());\n\n        // check if role name is unique\n        return checkRoleUniqueness(newRole.getName(), roleId, domain)\n                .flatMap(irrelevant -> {\n                    Role role = new Role();\n                    role.setId(roleId);\n                    role.setDomain(domain);\n                    role.setName(newRole.getName());\n                    role.setDescription(newRole.getDescription());\n                    role.setCreatedAt(new Date());\n                    role.setUpdatedAt(role.getCreatedAt());\n                    return roleRepository.create(role);\n                })\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n                });\n    }\n\n    @Override\n    public Single<Role> update(String domain, String id, UpdateRole updateRole) {\n        LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n        return roleRepository.findById(id)\n                .map(role -> Optional.of(role))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(roleOpt -> {\n                    if (!roleOpt.isPresent()) {\n                        throw new RoleNotFoundException(id);\n                    }\n                    return Single.just(roleOpt.get());\n                })\n                .flatMap(oldRole -> {\n                    // check if role name is unique\n                    return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                            .flatMap(irrelevant -> {\n                                oldRole.setName(updateRole.getName());\n                                oldRole.setDescription(updateRole.getDescription());\n                                oldRole.setPermissions(updateRole.getPermissions());\n                                oldRole.setUpdatedAt(new Date());\n                                return roleRepository.update(oldRole);\n                            });\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n                });\n\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String roleId) {\n        LOGGER.debug(\"Delete role {}\", roleId);\n        return roleRepository.findById(roleId)\n                .isEmpty()\n                    .flatMap(empty -> {\n                        if (empty) {\n                            throw new RoleNotFoundException(roleId);\n                        }\n                        return roleRepository.delete(roleId);\n                    })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                    return Single.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n                });\n    }\n\n    private Single<Irrelevant> checkRoleUniqueness(String roleName, String roleId, String domain) {\n\n        return roleRepository.findByDomain(domain)\n                .flatMap(roles -> {\n                    if (roles.stream()\n                            .filter(role -> !role.getId().equals(roleId))\n                            .anyMatch(role -> role.getName().equals(roleName))) {\n                        throw new RoleAlreadyExistsException(roleName);\n                    }\n                    return Single.just(Irrelevant.ROLE);\n                });\n    }\n\n}",
        "package": "package io.gravitee.am.service.impl;",
        "tree_path": "RoleServiceImpl",
        "name": "RoleServiceImpl",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements RoleService",
        "body": "{\n\n    private final Logger LOGGER = LoggerFactory.getLogger(RoleServiceImpl.class);\n\n    @Autowired\n    private RoleRepository roleRepository;\n\n    @Override\n    public Single<Set<Role>> findByDomain(String domain) {\n        LOGGER.debug(\"Find roles by domain: {}\", domain);\n        return roleRepository.findByDomain(domain)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n                });\n    }\n\n    @Override\n    public Maybe<Role> findById(String id) {\n        LOGGER.debug(\"Find role by ID: {}\", id);\n        return roleRepository.findById(id)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                    return Maybe.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n                });\n    }\n\n    @Override\n    public Single<Set<Role>> findByIdIn(List<String> ids) {\n        LOGGER.debug(\"Find roles by ids: {}\", ids);\n        return roleRepository.findByIdIn(ids)\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n                });\n    }\n\n\n    @Override\n    public Single<Role> create(String domain, NewRole newRole) {\n        LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n        String roleId = UUID.toString(UUID.random());\n\n        // check if role name is unique\n        return checkRoleUniqueness(newRole.getName(), roleId, domain)\n                .flatMap(irrelevant -> {\n                    Role role = new Role();\n                    role.setId(roleId);\n                    role.setDomain(domain);\n                    role.setName(newRole.getName());\n                    role.setDescription(newRole.getDescription());\n                    role.setCreatedAt(new Date());\n                    role.setUpdatedAt(role.getCreatedAt());\n                    return roleRepository.create(role);\n                })\n                .onErrorResumeNext(ex -> {\n                    LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n                });\n    }\n\n    @Override\n    public Single<Role> update(String domain, String id, UpdateRole updateRole) {\n        LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n        return roleRepository.findById(id)\n                .map(role -> Optional.of(role))\n                .defaultIfEmpty(Optional.empty())\n                .toSingle()\n                .flatMap(roleOpt -> {\n                    if (!roleOpt.isPresent()) {\n                        throw new RoleNotFoundException(id);\n                    }\n                    return Single.just(roleOpt.get());\n                })\n                .flatMap(oldRole -> {\n                    // check if role name is unique\n                    return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                            .flatMap(irrelevant -> {\n                                oldRole.setName(updateRole.getName());\n                                oldRole.setDescription(updateRole.getDescription());\n                                oldRole.setPermissions(updateRole.getPermissions());\n                                oldRole.setUpdatedAt(new Date());\n                                return roleRepository.update(oldRole);\n                            });\n                })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                    return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n                });\n\n    }\n\n    @Override\n    public Single<Irrelevant> delete(String roleId) {\n        LOGGER.debug(\"Delete role {}\", roleId);\n        return roleRepository.findById(roleId)\n                .isEmpty()\n                    .flatMap(empty -> {\n                        if (empty) {\n                            throw new RoleNotFoundException(roleId);\n                        }\n                        return roleRepository.delete(roleId);\n                    })\n                .onErrorResumeNext(ex -> {\n                    if (ex instanceof AbstractManagementException) {\n                        return Single.error(ex);\n                    }\n\n                    LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                    return Single.error(new TechnicalManagementException(\n                            String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n                });\n    }\n\n    private Single<Irrelevant> checkRoleUniqueness(String roleName, String roleId, String domain) {\n\n        return roleRepository.findByDomain(domain)\n                .flatMap(roles -> {\n                    if (roles.stream()\n                            .filter(role -> !role.getId().equals(roleId))\n                            .anyMatch(role -> role.getName().equals(roleName))) {\n                        throw new RoleAlreadyExistsException(roleName);\n                    }\n                    return Single.just(Irrelevant.ROLE);\n                });\n    }\n\n}",
        "start_point": {
            "row": 44,
            "column": 0
        },
        "end_point": {
            "row": 179,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Single<Set<Role>> findByDomain(String domain) {\n    LOGGER.debug(\"Find roles by domain: {}\", domain);\n    return roleRepository.findByDomain(domain)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n            });\n}",
                "name": "findByDomain",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find roles by domain: {}\", domain);\n    return roleRepository.findByDomain(domain)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by domain\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by domain\", ex));\n            });\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 60,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Maybe<Role> findById(String id) {\n    LOGGER.debug(\"Find role by ID: {}\", id);\n    return roleRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n            });\n}",
                "name": "findById",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find role by ID: {}\", id);\n    return roleRepository.findById(id)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find a role using its ID: {}\", id, ex);\n                return Maybe.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to find a role using its ID: %s\", id), ex));\n            });\n}",
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Set<Role>> findByIdIn(List<String> ids) {\n    LOGGER.debug(\"Find roles by ids: {}\", ids);\n    return roleRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n            });\n}",
                "name": "findByIdIn",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "List<String>",
                        "name": "ids"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Find roles by ids: {}\", ids);\n    return roleRepository.findByIdIn(ids)\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to find roles by ids\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to find roles by ids\", ex));\n            });\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 81,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Role> create(String domain, NewRole newRole) {\n    LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n    String roleId = UUID.toString(UUID.random());\n\n    // check if role name is unique\n    return checkRoleUniqueness(newRole.getName(), roleId, domain)\n            .flatMap(irrelevant -> {\n                Role role = new Role();\n                role.setId(roleId);\n                role.setDomain(domain);\n                role.setName(newRole.getName());\n                role.setDescription(newRole.getDescription());\n                role.setCreatedAt(new Date());\n                role.setUpdatedAt(role.getCreatedAt());\n                return roleRepository.create(role);\n            })\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n            });\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    },
                    {
                        "type": "NewRole",
                        "name": "newRole"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Create a new role {} for domain {}\", newRole, domain);\n\n    String roleId = UUID.toString(UUID.random());\n\n    // check if role name is unique\n    return checkRoleUniqueness(newRole.getName(), roleId, domain)\n            .flatMap(irrelevant -> {\n                Role role = new Role();\n                role.setId(roleId);\n                role.setDomain(domain);\n                role.setName(newRole.getName());\n                role.setDescription(newRole.getDescription());\n                role.setCreatedAt(new Date());\n                role.setUpdatedAt(role.getCreatedAt());\n                return roleRepository.create(role);\n            })\n            .onErrorResumeNext(ex -> {\n                LOGGER.error(\"An error occurs while trying to create a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to create a role\", ex));\n            });\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Role> update(String domain, String id, UpdateRole updateRole) {\n    LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n    return roleRepository.findById(id)\n            .map(role -> Optional.of(role))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(roleOpt -> {\n                if (!roleOpt.isPresent()) {\n                    throw new RoleNotFoundException(id);\n                }\n                return Single.just(roleOpt.get());\n            })\n            .flatMap(oldRole -> {\n                // check if role name is unique\n                return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                        .flatMap(irrelevant -> {\n                            oldRole.setName(updateRole.getName());\n                            oldRole.setDescription(updateRole.getDescription());\n                            oldRole.setPermissions(updateRole.getPermissions());\n                            oldRole.setUpdatedAt(new Date());\n                            return roleRepository.update(oldRole);\n                        });\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n            });\n\n}",
                "name": "update",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "domain"
                    },
                    {
                        "type": "String",
                        "name": "id"
                    },
                    {
                        "type": "UpdateRole",
                        "name": "updateRole"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Update a role {} for domain {}\", id, domain);\n\n    return roleRepository.findById(id)\n            .map(role -> Optional.of(role))\n            .defaultIfEmpty(Optional.empty())\n            .toSingle()\n            .flatMap(roleOpt -> {\n                if (!roleOpt.isPresent()) {\n                    throw new RoleNotFoundException(id);\n                }\n                return Single.just(roleOpt.get());\n            })\n            .flatMap(oldRole -> {\n                // check if role name is unique\n                return checkRoleUniqueness(updateRole.getName(), oldRole.getId(), domain)\n                        .flatMap(irrelevant -> {\n                            oldRole.setName(updateRole.getName());\n                            oldRole.setDescription(updateRole.getDescription());\n                            oldRole.setPermissions(updateRole.getPermissions());\n                            oldRole.setUpdatedAt(new Date());\n                            return roleRepository.update(oldRole);\n                        });\n            })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to update a role\", ex);\n                return Single.error(new TechnicalManagementException(\"An error occurs while trying to update a role\", ex));\n            });\n\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 142,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Single<Irrelevant> delete(String roleId) {\n    LOGGER.debug(\"Delete role {}\", roleId);\n    return roleRepository.findById(roleId)\n            .isEmpty()\n                .flatMap(empty -> {\n                    if (empty) {\n                        throw new RoleNotFoundException(roleId);\n                    }\n                    return roleRepository.delete(roleId);\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                return Single.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n            });\n}",
                "name": "delete",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "roleId"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Delete role {}\", roleId);\n    return roleRepository.findById(roleId)\n            .isEmpty()\n                .flatMap(empty -> {\n                    if (empty) {\n                        throw new RoleNotFoundException(roleId);\n                    }\n                    return roleRepository.delete(roleId);\n                })\n            .onErrorResumeNext(ex -> {\n                if (ex instanceof AbstractManagementException) {\n                    return Single.error(ex);\n                }\n\n                LOGGER.error(\"An error occurs while trying to delete role: {}\", roleId, ex);\n                return Single.error(new TechnicalManagementException(\n                        String.format(\"An error occurs while trying to delete role: %s\", roleId), ex));\n            });\n}",
                "start_point": {
                    "row": 144,
                    "column": 4
                },
                "end_point": {
                    "row": 164,
                    "column": 5
                }
            },
            {
                "definition": "private Single<Irrelevant> checkRoleUniqueness(String roleName, String roleId, String domain) {\n\n    return roleRepository.findByDomain(domain)\n            .flatMap(roles -> {\n                if (roles.stream()\n                        .filter(role -> !role.getId().equals(roleId))\n                        .anyMatch(role -> role.getName().equals(roleName))) {\n                    throw new RoleAlreadyExistsException(roleName);\n                }\n                return Single.just(Irrelevant.ROLE);\n            });\n}",
                "name": "checkRoleUniqueness",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "roleName"
                    },
                    {
                        "type": "String",
                        "name": "roleId"
                    },
                    {
                        "type": "String",
                        "name": "domain"
                    }
                ],
                "body": "{\n\n    return roleRepository.findByDomain(domain)\n            .flatMap(roles -> {\n                if (roles.stream()\n                        .filter(role -> !role.getId().equals(roleId))\n                        .anyMatch(role -> role.getName().equals(roleName))) {\n                    throw new RoleAlreadyExistsException(roleName);\n                }\n                return Single.just(Irrelevant.ROLE);\n            });\n}",
                "start_point": {
                    "row": 166,
                    "column": 4
                },
                "end_point": {
                    "row": 177,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/main/java/io/gravitee/am/service/model/UpdateDomain.java",
        "definition": "public class UpdateDomain {\n\n    /**\n     * Domain name.\n     */\n    @NotNull\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    @NotNull\n    private boolean enabled;\n\n    /**\n     * Domain HTTP path.\n     */\n    private String path;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n}",
        "package": "package io.gravitee.am.service.model;",
        "tree_path": "UpdateDomain",
        "name": "UpdateDomain",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * Domain name.\n     */\n    @NotNull\n    private String name;\n\n    /**\n     * Domain description.\n     */\n    private String description;\n\n    /**\n     * Domain enabled.\n     */\n    @NotNull\n    private boolean enabled;\n\n    /**\n     * Domain HTTP path.\n     */\n    private String path;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    public void setEnabled(boolean enabled) {\n        this.enabled = enabled;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n}",
        "start_point": {
            "row": 23,
            "column": 0
        },
        "end_point": {
            "row": 78,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            },
            {
                "definition": "public String getDescription() {\n    return description;\n}",
                "name": "getDescription",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return description;\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "public void setDescription(String description) {\n    this.description = description;\n}",
                "name": "setDescription",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "description"
                    }
                ],
                "body": "{\n    this.description = description;\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "public boolean isEnabled() {\n    return enabled;\n}",
                "name": "isEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return enabled;\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            },
            {
                "definition": "public void setEnabled(boolean enabled) {\n    this.enabled = enabled;\n}",
                "name": "setEnabled",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "enabled"
                    }
                ],
                "body": "{\n    this.enabled = enabled;\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 69,
                    "column": 5
                }
            },
            {
                "definition": "public String getPath() {\n    return path;\n}",
                "name": "getPath",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return path;\n}",
                "start_point": {
                    "row": 71,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            },
            {
                "definition": "public void setPath(String path) {\n    this.path = path;\n}",
                "name": "setPath",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "path"
                    }
                ],
                "body": "{\n    this.path = path;\n}",
                "start_point": {
                    "row": 75,
                    "column": 4
                },
                "end_point": {
                    "row": 77,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-service/src/test/java/io/gravitee/am/service/RoleServiceTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\npublic class RoleServiceTest {\n\n    @InjectMocks\n    private RoleService roleService = new RoleServiceImpl();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private RoleRepository roleRepository;\n\n    private final static String DOMAIN = \"domain1\";\n\n    @Test\n    public void shouldFindById() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n        testObserver.awaitTerminalEvent();\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValueCount(1);\n    }\n\n    @Test\n    public void shouldFindById_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertNoValues();\n    }\n\n    @Test\n    public void shouldFindById_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n        TestObserver testObserver = new TestObserver();\n        roleService.findById(\"my-role\").subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByDomain() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByDomain_technicalException() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByIdsIn() {\n        when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByIdsIn_technicalException() {\n        when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldCreate() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_technicalException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_uniquenessException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findById(\"my-role\");\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_technicalException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_uniquenessException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleAlreadyExistsException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_roleNotFound() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldDelete_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).delete(anyString());\n    }\n\n    @Test\n    public void shouldDelete_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldDelete() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n        TestObserver testObserver = roleService.delete( \"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).delete(\"my-role\");\n    }\n}",
        "package": "package io.gravitee.am.service;",
        "tree_path": "RoleServiceTest",
        "name": "RoleServiceTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private RoleService roleService = new RoleServiceImpl();\n\n    @Mock\n    private DomainService domainService;\n\n    @Mock\n    private ClientService clientService;\n\n    @Mock\n    private RoleRepository roleRepository;\n\n    private final static String DOMAIN = \"domain1\";\n\n    @Test\n    public void shouldFindById() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n        testObserver.awaitTerminalEvent();\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValueCount(1);\n    }\n\n    @Test\n    public void shouldFindById_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n        TestObserver testObserver = roleService.findById(\"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertNoValues();\n    }\n\n    @Test\n    public void shouldFindById_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n        TestObserver testObserver = new TestObserver();\n        roleService.findById(\"my-role\").subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByDomain() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByDomain_technicalException() {\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldFindByIdsIn() {\n        when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n        TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n        testObserver.assertValue(roles -> roles.size() == 1);\n    }\n\n    @Test\n    public void shouldFindByIdsIn_technicalException() {\n        when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver<>();\n        roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldCreate() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_technicalException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldCreate_uniquenessException() {\n        NewRole newRole = Mockito.mock(NewRole.class);\n        when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n        when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n        TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).findById(\"my-role\");\n        verify(roleRepository, times(1)).findByDomain(DOMAIN);\n        verify(roleRepository, times(1)).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_technicalException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).update(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_uniquenessException() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n        Role role = new Role();\n        role.setId(\"existing-role-id\");\n        role.setName(\"existing-role-name\");\n\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleAlreadyExistsException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldUpdate_roleNotFound() {\n        UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n        when(updateRole.getName()).thenReturn(\"existing-role-name\");\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = new TestObserver();\n        roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).findByDomain(DOMAIN);\n        verify(roleRepository, never()).create(any(Role.class));\n    }\n\n    @Test\n    public void shouldDelete_notExistingRole() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(RoleNotFoundException.class);\n        testObserver.assertNotComplete();\n\n        verify(roleRepository, never()).delete(anyString());\n    }\n\n    @Test\n    public void shouldDelete_technicalException() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n        TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n        testObserver.assertError(TechnicalManagementException.class);\n        testObserver.assertNotComplete();\n    }\n\n    @Test\n    public void shouldDelete() {\n        when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n        when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n        TestObserver testObserver = roleService.delete( \"my-role\").test();\n        testObserver.awaitTerminalEvent();\n\n        testObserver.assertComplete();\n        testObserver.assertNoErrors();\n\n        verify(roleRepository, times(1)).delete(\"my-role\");\n    }\n}",
        "start_point": {
            "row": 49,
            "column": 0
        },
        "end_point": {
            "row": 296,
            "column": 1
        },
        "file_mode": "Modified",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldFindById() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n    testObserver.awaitTerminalEvent();\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValueCount(1);\n}",
                "name": "shouldFindById",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n\n    testObserver.awaitTerminalEvent();\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValueCount(1);\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindById_notExistingRole() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertNoValues();\n}",
                "name": "shouldFindById_notExistingRole",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n    TestObserver testObserver = roleService.findById(\"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertNoValues();\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 84,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindById_technicalException() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n    TestObserver testObserver = new TestObserver();\n    roleService.findById(\"my-role\").subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldFindById_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n    TestObserver testObserver = new TestObserver();\n    roleService.findById(\"my-role\").subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 86,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByDomain() {\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "name": "shouldFindByDomain",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByDomain(DOMAIN).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByDomain_technicalException() {\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldFindByDomain_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByDomain(DOMAIN).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 116,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByIdsIn() {\n    when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "name": "shouldFindByIdsIn",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByIdIn(Arrays.asList(\"my-role\"))).thenReturn(Single.just(Collections.singleton(new Role())));\n    TestObserver<Set<Role>> testObserver = roleService.findByIdIn(Arrays.asList(\"my-role\")).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n    testObserver.assertValue(roles -> roles.size() == 1);\n}",
                "start_point": {
                    "row": 118,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindByIdsIn_technicalException() {\n    when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldFindByIdsIn_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findByIdIn(anyList())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver<>();\n    roleService.findByIdIn(Arrays.asList(\"my-role\")).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 138,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldCreate() {\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).create(any(Role.class));\n}",
                "name": "shouldCreate",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.create(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.create(DOMAIN, newRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).create(any(Role.class));\n}",
                "start_point": {
                    "row": 140,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldCreate_technicalException() {\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldCreate_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 168,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldCreate_uniquenessException() {\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldCreate_uniquenessException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    NewRole newRole = Mockito.mock(NewRole.class);\n    when(newRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.create(DOMAIN, newRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 170,
                    "column": 4
                },
                "end_point": {
                    "row": 188,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findById(\"my-role\");\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).update(any(Role.class));\n}",
                "name": "shouldUpdate",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.emptySet()));\n    when(roleRepository.update(any(Role.class))).thenReturn(Single.just(new Role()));\n\n    TestObserver testObserver = roleService.update(DOMAIN,\"my-role\", updateRole).test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).findById(\"my-role\");\n    verify(roleRepository, times(1)).findByDomain(DOMAIN);\n    verify(roleRepository, times(1)).update(any(Role.class));\n}",
                "start_point": {
                    "row": 190,
                    "column": 4
                },
                "end_point": {
                    "row": 206,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate_technicalException() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).update(any(Role.class));\n}",
                "name": "shouldUpdate_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.error(TechnicalException::new));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN,\"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).update(any(Role.class));\n}",
                "start_point": {
                    "row": 208,
                    "column": 4
                },
                "end_point": {
                    "row": 221,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate_uniquenessException() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleAlreadyExistsException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldUpdate_uniquenessException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n\n    Role role = new Role();\n    role.setId(\"existing-role-id\");\n    role.setName(\"existing-role-name\");\n\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.findByDomain(DOMAIN)).thenReturn(Single.just(Collections.singleton(role)));\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleAlreadyExistsException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 223,
                    "column": 4
                },
                "end_point": {
                    "row": 242,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdate_roleNotFound() {\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "name": "shouldUpdate_roleNotFound",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    UpdateRole updateRole = Mockito.mock(UpdateRole.class);\n    when(updateRole.getName()).thenReturn(\"existing-role-name\");\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = new TestObserver();\n    roleService.update(DOMAIN, \"my-role\", updateRole).subscribe(testObserver);\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).findByDomain(DOMAIN);\n    verify(roleRepository, never()).create(any(Role.class));\n}",
                "start_point": {
                    "row": 244,
                    "column": 4
                },
                "end_point": {
                    "row": 258,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldDelete_notExistingRole() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).delete(anyString());\n}",
                "name": "shouldDelete_notExistingRole",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.empty());\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(RoleNotFoundException.class);\n    testObserver.assertNotComplete();\n\n    verify(roleRepository, never()).delete(anyString());\n}",
                "start_point": {
                    "row": 260,
                    "column": 4
                },
                "end_point": {
                    "row": 270,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldDelete_technicalException() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "name": "shouldDelete_technicalException",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(anyString())).thenReturn(Single.error(TechnicalException::new));\n\n    TestObserver testObserver = roleService.delete(\"my-role\").test();\n\n    testObserver.assertError(TechnicalManagementException.class);\n    testObserver.assertNotComplete();\n}",
                "start_point": {
                    "row": 272,
                    "column": 4
                },
                "end_point": {
                    "row": 281,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldDelete() {\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n    TestObserver testObserver = roleService.delete( \"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).delete(\"my-role\");\n}",
                "name": "shouldDelete",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(roleRepository.findById(\"my-role\")).thenReturn(Maybe.just(new Role()));\n    when(roleRepository.delete(\"my-role\")).thenReturn(Single.just(Irrelevant.ROLE));\n\n    TestObserver testObserver = roleService.delete( \"my-role\").test();\n    testObserver.awaitTerminalEvent();\n\n    testObserver.assertComplete();\n    testObserver.assertNoErrors();\n\n    verify(roleRepository, times(1)).delete(\"my-role\");\n}",
                "start_point": {
                    "row": 283,
                    "column": 4
                },
                "end_point": {
                    "row": 295,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/filter/CORSFilter.java",
        "definition": "public class CORSFilter implements Filter {\n\n     public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletResponse response = (HttpServletResponse) res;\n        HttpServletRequest request = (HttpServletRequest) req;\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n        if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n            chain.doFilter(req, res);\n        }\n    }\n\n    public void init(FilterConfig filterConfig) {\n    }\n\n    public void destroy() {\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.filter;",
        "tree_path": "CORSFilter",
        "name": "CORSFilter",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements Filter",
        "body": "{\n\n     public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletResponse response = (HttpServletResponse) res;\n        HttpServletRequest request = (HttpServletRequest) req;\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n        if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n            chain.doFilter(req, res);\n        }\n    }\n\n    public void init(FilterConfig filterConfig) {\n    }\n\n    public void destroy() {\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 50,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletResponse response = (HttpServletResponse) res;\n    HttpServletRequest request = (HttpServletRequest) req;\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n    if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n        chain.doFilter(req, res);\n    }\n}",
                "name": "doFilter",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ServletRequest",
                        "name": "req"
                    },
                    {
                        "type": "ServletResponse",
                        "name": "res"
                    },
                    {
                        "type": "FilterChain",
                        "name": "chain"
                    }
                ],
                "body": "{\n    HttpServletResponse response = (HttpServletResponse) res;\n    HttpServletRequest request = (HttpServletRequest) req;\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n    if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n        chain.doFilter(req, res);\n    }\n}",
                "start_point": {
                    "row": 31,
                    "column": 5
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            },
            {
                "definition": "public void init(FilterConfig filterConfig) {\n}",
                "name": "init",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "FilterConfig",
                        "name": "filterConfig"
                    }
                ],
                "body": "{\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "public void destroy() {\n}",
                "name": "destroy",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-management/src/main/java/io/gravitee/am/management/handlers/management/api/provider/CorsResponseFilter.java",
        "definition": "@Provider\n@PreMatching\npublic class CorsResponseFilter implements ContainerResponseFilter {\n\n    /**\n     * Logger.\n     */\n    private final Logger LOGGER = LoggerFactory.getLogger(CorsResponseFilter.class);\n\n    /**\n     * Add the cross domain data to the output if needed.\n     *\n     * @param reqCtx The container request (input)\n     * @param respCtx The container request (output)\n     * @throws IOException\n     */\n    @Override\n    public void filter(ContainerRequestContext reqCtx, ContainerResponseContext respCtx) throws IOException {\n        LOGGER.debug(\"Executing CORS response filter\");\n\n        respCtx.getHeaders().add(\"Access-Control-Allow-Origin\", reqCtx.getHeaderString(\"origin\"));\n        respCtx.getHeaders().addAll(\"Access-Control-Allow-Headers\", \"Cache-Control\", \"Pragma\", \"Origin\", \"Authorization\", \"Content-Type\", \"X-Requested-With\");\n        respCtx.getHeaders().add(\"Access-Control-Allow-Credentials\", \"true\");\n        respCtx.getHeaders().addAll(\"Access-Control-Allow-Methods\", \"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\", \"X-XSRF-TOKEN\");\n        respCtx.getHeaders().add(\"Access-Control-Max-Age\", \"1209600\");\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.management.api.provider;",
        "tree_path": "CorsResponseFilter",
        "name": "CorsResponseFilter",
        "modifiers": "@Provider\n@PreMatching\npublic",
        "superclass": null,
        "super_interfaces": "implements ContainerResponseFilter",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger LOGGER = LoggerFactory.getLogger(CorsResponseFilter.class);\n\n    /**\n     * Add the cross domain data to the output if needed.\n     *\n     * @param reqCtx The container request (input)\n     * @param respCtx The container request (output)\n     * @throws IOException\n     */\n    @Override\n    public void filter(ContainerRequestContext reqCtx, ContainerResponseContext respCtx) throws IOException {\n        LOGGER.debug(\"Executing CORS response filter\");\n\n        respCtx.getHeaders().add(\"Access-Control-Allow-Origin\", reqCtx.getHeaderString(\"origin\"));\n        respCtx.getHeaders().addAll(\"Access-Control-Allow-Headers\", \"Cache-Control\", \"Pragma\", \"Origin\", \"Authorization\", \"Content-Type\", \"X-Requested-With\");\n        respCtx.getHeaders().add(\"Access-Control-Allow-Credentials\", \"true\");\n        respCtx.getHeaders().addAll(\"Access-Control-Allow-Methods\", \"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\", \"X-XSRF-TOKEN\");\n        respCtx.getHeaders().add(\"Access-Control-Max-Age\", \"1209600\");\n    }\n}",
        "start_point": {
            "row": 31,
            "column": 0
        },
        "end_point": {
            "row": 57,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void filter(ContainerRequestContext reqCtx, ContainerResponseContext respCtx) throws IOException {\n    LOGGER.debug(\"Executing CORS response filter\");\n\n    respCtx.getHeaders().add(\"Access-Control-Allow-Origin\", reqCtx.getHeaderString(\"origin\"));\n    respCtx.getHeaders().addAll(\"Access-Control-Allow-Headers\", \"Cache-Control\", \"Pragma\", \"Origin\", \"Authorization\", \"Content-Type\", \"X-Requested-With\");\n    respCtx.getHeaders().add(\"Access-Control-Allow-Credentials\", \"true\");\n    respCtx.getHeaders().addAll(\"Access-Control-Allow-Methods\", \"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\", \"X-XSRF-TOKEN\");\n    respCtx.getHeaders().add(\"Access-Control-Max-Age\", \"1209600\");\n}",
                "name": "filter",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ContainerRequestContext",
                        "name": "reqCtx"
                    },
                    {
                        "type": "ContainerResponseContext",
                        "name": "respCtx"
                    }
                ],
                "body": "{\n    LOGGER.debug(\"Executing CORS response filter\");\n\n    respCtx.getHeaders().add(\"Access-Control-Allow-Origin\", reqCtx.getHeaderString(\"origin\"));\n    respCtx.getHeaders().addAll(\"Access-Control-Allow-Headers\", \"Cache-Control\", \"Pragma\", \"Origin\", \"Authorization\", \"Content-Type\", \"X-Requested-With\");\n    respCtx.getHeaders().add(\"Access-Control-Allow-Credentials\", \"true\");\n    respCtx.getHeaders().addAll(\"Access-Control-Allow-Methods\", \"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\", \"X-XSRF-TOKEN\");\n    respCtx.getHeaders().add(\"Access-Control-Max-Age\", \"1209600\");\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/AuthorizationServerConfiguration.java",
        "definition": "@Configuration\n@Import({CustomAuthorizationServerEndpointsConfiguration.class, CustomAuthorizationServerSecurityConfiguration.class})\npublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private TokenStore tokenStore;\n\n    @Autowired\n    private AuthorizationCodeServices authorizationCodeServices;\n\n    @Autowired\n    @Qualifier(\"authenticationManagerBean\")\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Autowired\n    @Qualifier(\"userDetailsServiceBean\")\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private ExtensionGrantManager extensionGrantManager;\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.withClientDetails(clientDetailsService);\n    }\n\n    @Bean\n    public ClientDetailsUserDetailsService clientDetailsUserDetailsService() {\n        return new ClientDetailsUserDetailsService(clientDetailsService);\n    }\n\n    @Bean\n    public AuthenticationManager clientAuthenticationManager() {\n        DaoAuthenticationProvider clientAuthenticationProvider = new DaoAuthenticationProvider();\n        clientAuthenticationProvider.setUserDetailsService(clientDetailsUserDetailsService());\n        clientAuthenticationProvider.setHideUserNotFoundExceptions(false);\n        return new ProviderManager(Collections.singletonList(clientAuthenticationProvider));\n    }\n\n    @Bean\n    public AccessTokenConverter accessTokenConverter() {\n        return new DefaultIntrospectionAccessTokenConverter();\n    }\n\n    @Bean\n    public TokenEnhancer tokenEnhancer() { return new CustomTokenEnhancer(); }\n\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n        endpoints\n            .tokenStore(tokenStore)\n            .accessTokenConverter(accessTokenConverter())\n            .tokenEnhancer(tokenEnhancer())\n            .reuseRefreshTokens(false)\n            .userDetailsService(userDetailsService)\n            .authorizationCodeServices(authorizationCodeServices)\n            .requestFactory(new CustomOAuth2RequestFactory(clientDetailsService))\n            .authenticationManager(authenticationManager)\n            .userApprovalHandler(userApprovalHandler())\n            .approvalStore(approvalStore())\n            .tokenGranter(tokenGranter(endpoints))\n                .addInterceptor(new HandlerInterceptorAdapter() {\n                    @Override\n                    public boolean preHandle(HttpServletRequest hsr, HttpServletResponse rs, Object o) throws Exception {\n                        rs.setHeader(\"Access-Control-Allow-Origin\", hsr.getHeader(\"origin\"));\n                        rs.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n                        rs.setHeader(\"Access-Control-Max-Age\", \"3600\");\n                        rs.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization\");\n                        return true;\n                    }\n                });\n    }\n\n    @Override\n    public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {\n        oauthServer\n                .realm(\"realm/\" + domain.getName())\n                .checkTokenAccess(\"isAuthenticated()\")\n                .accessDeniedHandler(oAuth2AccessDeniedHandler())\n                .allowFormAuthenticationForClients()\n                .authenticationEntryPoint(oAuth2AuthenticationEntryPoint());\n\n        BasicAuthenticationFilter basicAuthenticationFilter = new BasicAuthenticationFilter(clientAuthenticationManager(), oAuth2AuthenticationEntryPoint());\n        basicAuthenticationFilter.setAuthenticationDetailsSource(new ClientAwareAuthenticationDetailsSource());\n        oauthServer.addTokenEndpointAuthenticationFilter(basicAuthenticationFilter);\n    }\n\n    @Bean\n    public OAuth2AuthenticationEntryPoint oAuth2AuthenticationEntryPoint() {\n        OAuth2AuthenticationEntryPoint oAuth2AuthenticationEntryPoint = new OAuth2AuthenticationEntryPoint();\n        oAuth2AuthenticationEntryPoint.setRealmName(\"realm/\" + domain.getName());\n        oAuth2AuthenticationEntryPoint.setTypeName(\"Basic\");\n\n        return oAuth2AuthenticationEntryPoint;\n    }\n\n    @Bean\n    public OAuth2AccessDeniedHandler oAuth2AccessDeniedHandler() {\n        return new OAuth2AccessDeniedHandler();\n    }\n\n    private TokenGranter tokenGranter(final AuthorizationServerEndpointsConfigurer endpoints) {\n        List<TokenGranter> granters = new ArrayList<>(Arrays.asList(endpoints.getTokenGranter()));\n        extensionGrantManager.providers().forEach((id, tokenGranterProvider) -> {\n            CustomTokenGranter customTokenGranter = new CustomTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory(), extensionGrantManager.getTokenGranter(id));\n            customTokenGranter.setExtensionGrantProvider(tokenGranterProvider);\n            customTokenGranter.setAuthenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n            granters.add(customTokenGranter);\n        });\n        return new CompositeTokenGranter(granters);\n    }\n\n    @Bean\n    public UserApprovalHandler userApprovalHandler() {\n        DefaultApprovalStoreUserApprovalHandler approvalHandler = new DefaultApprovalStoreUserApprovalHandler();\n        approvalHandler.setClientDetailsService(clientDetailsService);\n        approvalHandler.setApprovalStore(approvalStore());\n        approvalHandler.setRequestFactory(new CustomOAuth2RequestFactory(clientDetailsService));\n        return approvalHandler;\n    }\n\n    @Bean\n    public ApprovalStore approvalStore() {\n        return new DefaultApprovalStore();\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2;",
        "tree_path": "AuthorizationServerConfiguration",
        "name": "AuthorizationServerConfiguration",
        "modifiers": "@Configuration\n@Import({CustomAuthorizationServerEndpointsConfiguration.class, CustomAuthorizationServerSecurityConfiguration.class})\npublic",
        "superclass": "extends AuthorizationServerConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private TokenStore tokenStore;\n\n    @Autowired\n    private AuthorizationCodeServices authorizationCodeServices;\n\n    @Autowired\n    @Qualifier(\"authenticationManagerBean\")\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Autowired\n    @Qualifier(\"userDetailsServiceBean\")\n    private UserDetailsService userDetailsService;\n\n    @Autowired\n    private ExtensionGrantManager extensionGrantManager;\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.withClientDetails(clientDetailsService);\n    }\n\n    @Bean\n    public ClientDetailsUserDetailsService clientDetailsUserDetailsService() {\n        return new ClientDetailsUserDetailsService(clientDetailsService);\n    }\n\n    @Bean\n    public AuthenticationManager clientAuthenticationManager() {\n        DaoAuthenticationProvider clientAuthenticationProvider = new DaoAuthenticationProvider();\n        clientAuthenticationProvider.setUserDetailsService(clientDetailsUserDetailsService());\n        clientAuthenticationProvider.setHideUserNotFoundExceptions(false);\n        return new ProviderManager(Collections.singletonList(clientAuthenticationProvider));\n    }\n\n    @Bean\n    public AccessTokenConverter accessTokenConverter() {\n        return new DefaultIntrospectionAccessTokenConverter();\n    }\n\n    @Bean\n    public TokenEnhancer tokenEnhancer() { return new CustomTokenEnhancer(); }\n\n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n        endpoints\n            .tokenStore(tokenStore)\n            .accessTokenConverter(accessTokenConverter())\n            .tokenEnhancer(tokenEnhancer())\n            .reuseRefreshTokens(false)\n            .userDetailsService(userDetailsService)\n            .authorizationCodeServices(authorizationCodeServices)\n            .requestFactory(new CustomOAuth2RequestFactory(clientDetailsService))\n            .authenticationManager(authenticationManager)\n            .userApprovalHandler(userApprovalHandler())\n            .approvalStore(approvalStore())\n            .tokenGranter(tokenGranter(endpoints))\n                .addInterceptor(new HandlerInterceptorAdapter() {\n                    @Override\n                    public boolean preHandle(HttpServletRequest hsr, HttpServletResponse rs, Object o) throws Exception {\n                        rs.setHeader(\"Access-Control-Allow-Origin\", hsr.getHeader(\"origin\"));\n                        rs.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n                        rs.setHeader(\"Access-Control-Max-Age\", \"3600\");\n                        rs.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization\");\n                        return true;\n                    }\n                });\n    }\n\n    @Override\n    public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {\n        oauthServer\n                .realm(\"realm/\" + domain.getName())\n                .checkTokenAccess(\"isAuthenticated()\")\n                .accessDeniedHandler(oAuth2AccessDeniedHandler())\n                .allowFormAuthenticationForClients()\n                .authenticationEntryPoint(oAuth2AuthenticationEntryPoint());\n\n        BasicAuthenticationFilter basicAuthenticationFilter = new BasicAuthenticationFilter(clientAuthenticationManager(), oAuth2AuthenticationEntryPoint());\n        basicAuthenticationFilter.setAuthenticationDetailsSource(new ClientAwareAuthenticationDetailsSource());\n        oauthServer.addTokenEndpointAuthenticationFilter(basicAuthenticationFilter);\n    }\n\n    @Bean\n    public OAuth2AuthenticationEntryPoint oAuth2AuthenticationEntryPoint() {\n        OAuth2AuthenticationEntryPoint oAuth2AuthenticationEntryPoint = new OAuth2AuthenticationEntryPoint();\n        oAuth2AuthenticationEntryPoint.setRealmName(\"realm/\" + domain.getName());\n        oAuth2AuthenticationEntryPoint.setTypeName(\"Basic\");\n\n        return oAuth2AuthenticationEntryPoint;\n    }\n\n    @Bean\n    public OAuth2AccessDeniedHandler oAuth2AccessDeniedHandler() {\n        return new OAuth2AccessDeniedHandler();\n    }\n\n    private TokenGranter tokenGranter(final AuthorizationServerEndpointsConfigurer endpoints) {\n        List<TokenGranter> granters = new ArrayList<>(Arrays.asList(endpoints.getTokenGranter()));\n        extensionGrantManager.providers().forEach((id, tokenGranterProvider) -> {\n            CustomTokenGranter customTokenGranter = new CustomTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory(), extensionGrantManager.getTokenGranter(id));\n            customTokenGranter.setExtensionGrantProvider(tokenGranterProvider);\n            customTokenGranter.setAuthenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n            granters.add(customTokenGranter);\n        });\n        return new CompositeTokenGranter(granters);\n    }\n\n    @Bean\n    public UserApprovalHandler userApprovalHandler() {\n        DefaultApprovalStoreUserApprovalHandler approvalHandler = new DefaultApprovalStoreUserApprovalHandler();\n        approvalHandler.setClientDetailsService(clientDetailsService);\n        approvalHandler.setApprovalStore(approvalStore());\n        approvalHandler.setRequestFactory(new CustomOAuth2RequestFactory(clientDetailsService));\n        return approvalHandler;\n    }\n\n    @Bean\n    public ApprovalStore approvalStore() {\n        return new DefaultApprovalStore();\n    }\n\n}",
        "start_point": {
            "row": 67,
            "column": 0
        },
        "end_point": {
            "row": 202,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n    clients.withClientDetails(clientDetailsService);\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ClientDetailsServiceConfigurer",
                        "name": "clients"
                    }
                ],
                "body": "{\n    clients.withClientDetails(clientDetailsService);\n}",
                "start_point": {
                    "row": 97,
                    "column": 4
                },
                "end_point": {
                    "row": 100,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic ClientDetailsUserDetailsService clientDetailsUserDetailsService() {\n    return new ClientDetailsUserDetailsService(clientDetailsService);\n}",
                "name": "clientDetailsUserDetailsService",
                "modifiers": "@Bean\n    public",
                "return_type": "ClientDetailsUserDetailsService",
                "parameters": [],
                "body": "{\n    return new ClientDetailsUserDetailsService(clientDetailsService);\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthenticationManager clientAuthenticationManager() {\n    DaoAuthenticationProvider clientAuthenticationProvider = new DaoAuthenticationProvider();\n    clientAuthenticationProvider.setUserDetailsService(clientDetailsUserDetailsService());\n    clientAuthenticationProvider.setHideUserNotFoundExceptions(false);\n    return new ProviderManager(Collections.singletonList(clientAuthenticationProvider));\n}",
                "name": "clientAuthenticationManager",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthenticationManager",
                "parameters": [],
                "body": "{\n    DaoAuthenticationProvider clientAuthenticationProvider = new DaoAuthenticationProvider();\n    clientAuthenticationProvider.setUserDetailsService(clientDetailsUserDetailsService());\n    clientAuthenticationProvider.setHideUserNotFoundExceptions(false);\n    return new ProviderManager(Collections.singletonList(clientAuthenticationProvider));\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AccessTokenConverter accessTokenConverter() {\n    return new DefaultIntrospectionAccessTokenConverter();\n}",
                "name": "accessTokenConverter",
                "modifiers": "@Bean\n    public",
                "return_type": "AccessTokenConverter",
                "parameters": [],
                "body": "{\n    return new DefaultIntrospectionAccessTokenConverter();\n}",
                "start_point": {
                    "row": 115,
                    "column": 4
                },
                "end_point": {
                    "row": 118,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\n}",
                "name": "tokenEnhancer",
                "modifiers": "@Bean\n    public",
                "return_type": "TokenEnhancer",
                "parameters": [],
                "body": "{ return new CustomTokenEnhancer(); }",
                "start_point": {
                    "row": 120,
                    "column": 4
                },
                "end_point": {
                    "row": 121,
                    "column": 78
                }
            },
            {
                "definition": "@Override\npublic void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n    endpoints\n        .tokenStore(tokenStore)\n        .accessTokenConverter(accessTokenConverter())\n        .tokenEnhancer(tokenEnhancer())\n        .reuseRefreshTokens(false)\n        .userDetailsService(userDetailsService)\n        .authorizationCodeServices(authorizationCodeServices)\n        .requestFactory(new CustomOAuth2RequestFactory(clientDetailsService))\n        .authenticationManager(authenticationManager)\n        .userApprovalHandler(userApprovalHandler())\n        .approvalStore(approvalStore())\n        .tokenGranter(tokenGranter(endpoints))\n            .addInterceptor(new HandlerInterceptorAdapter() {\n                @Override\n                public boolean preHandle(HttpServletRequest hsr, HttpServletResponse rs, Object o) throws Exception {\n                    rs.setHeader(\"Access-Control-Allow-Origin\", hsr.getHeader(\"origin\"));\n                    rs.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n                    rs.setHeader(\"Access-Control-Max-Age\", \"3600\");\n                    rs.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization\");\n                    return true;\n                }\n            });\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthorizationServerEndpointsConfigurer",
                        "name": "endpoints"
                    }
                ],
                "body": "{\n    endpoints\n        .tokenStore(tokenStore)\n        .accessTokenConverter(accessTokenConverter())\n        .tokenEnhancer(tokenEnhancer())\n        .reuseRefreshTokens(false)\n        .userDetailsService(userDetailsService)\n        .authorizationCodeServices(authorizationCodeServices)\n        .requestFactory(new CustomOAuth2RequestFactory(clientDetailsService))\n        .authenticationManager(authenticationManager)\n        .userApprovalHandler(userApprovalHandler())\n        .approvalStore(approvalStore())\n        .tokenGranter(tokenGranter(endpoints))\n            .addInterceptor(new HandlerInterceptorAdapter() {\n                @Override\n                public boolean preHandle(HttpServletRequest hsr, HttpServletResponse rs, Object o) throws Exception {\n                    rs.setHeader(\"Access-Control-Allow-Origin\", hsr.getHeader(\"origin\"));\n                    rs.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS\");\n                    rs.setHeader(\"Access-Control-Max-Age\", \"3600\");\n                    rs.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization\");\n                    return true;\n                }\n            });\n}",
                "start_point": {
                    "row": 123,
                    "column": 4
                },
                "end_point": {
                    "row": 147,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {\n    oauthServer\n            .realm(\"realm/\" + domain.getName())\n            .checkTokenAccess(\"isAuthenticated()\")\n            .accessDeniedHandler(oAuth2AccessDeniedHandler())\n            .allowFormAuthenticationForClients()\n            .authenticationEntryPoint(oAuth2AuthenticationEntryPoint());\n\n    BasicAuthenticationFilter basicAuthenticationFilter = new BasicAuthenticationFilter(clientAuthenticationManager(), oAuth2AuthenticationEntryPoint());\n    basicAuthenticationFilter.setAuthenticationDetailsSource(new ClientAwareAuthenticationDetailsSource());\n    oauthServer.addTokenEndpointAuthenticationFilter(basicAuthenticationFilter);\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthorizationServerSecurityConfigurer",
                        "name": "oauthServer"
                    }
                ],
                "body": "{\n    oauthServer\n            .realm(\"realm/\" + domain.getName())\n            .checkTokenAccess(\"isAuthenticated()\")\n            .accessDeniedHandler(oAuth2AccessDeniedHandler())\n            .allowFormAuthenticationForClients()\n            .authenticationEntryPoint(oAuth2AuthenticationEntryPoint());\n\n    BasicAuthenticationFilter basicAuthenticationFilter = new BasicAuthenticationFilter(clientAuthenticationManager(), oAuth2AuthenticationEntryPoint());\n    basicAuthenticationFilter.setAuthenticationDetailsSource(new ClientAwareAuthenticationDetailsSource());\n    oauthServer.addTokenEndpointAuthenticationFilter(basicAuthenticationFilter);\n}",
                "start_point": {
                    "row": 149,
                    "column": 4
                },
                "end_point": {
                    "row": 161,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic OAuth2AuthenticationEntryPoint oAuth2AuthenticationEntryPoint() {\n    OAuth2AuthenticationEntryPoint oAuth2AuthenticationEntryPoint = new OAuth2AuthenticationEntryPoint();\n    oAuth2AuthenticationEntryPoint.setRealmName(\"realm/\" + domain.getName());\n    oAuth2AuthenticationEntryPoint.setTypeName(\"Basic\");\n\n    return oAuth2AuthenticationEntryPoint;\n}",
                "name": "oAuth2AuthenticationEntryPoint",
                "modifiers": "@Bean\n    public",
                "return_type": "OAuth2AuthenticationEntryPoint",
                "parameters": [],
                "body": "{\n    OAuth2AuthenticationEntryPoint oAuth2AuthenticationEntryPoint = new OAuth2AuthenticationEntryPoint();\n    oAuth2AuthenticationEntryPoint.setRealmName(\"realm/\" + domain.getName());\n    oAuth2AuthenticationEntryPoint.setTypeName(\"Basic\");\n\n    return oAuth2AuthenticationEntryPoint;\n}",
                "start_point": {
                    "row": 163,
                    "column": 4
                },
                "end_point": {
                    "row": 170,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic OAuth2AccessDeniedHandler oAuth2AccessDeniedHandler() {\n    return new OAuth2AccessDeniedHandler();\n}",
                "name": "oAuth2AccessDeniedHandler",
                "modifiers": "@Bean\n    public",
                "return_type": "OAuth2AccessDeniedHandler",
                "parameters": [],
                "body": "{\n    return new OAuth2AccessDeniedHandler();\n}",
                "start_point": {
                    "row": 172,
                    "column": 4
                },
                "end_point": {
                    "row": 175,
                    "column": 5
                }
            },
            {
                "definition": "private TokenGranter tokenGranter(final AuthorizationServerEndpointsConfigurer endpoints) {\n    List<TokenGranter> granters = new ArrayList<>(Arrays.asList(endpoints.getTokenGranter()));\n    extensionGrantManager.providers().forEach((id, tokenGranterProvider) -> {\n        CustomTokenGranter customTokenGranter = new CustomTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory(), extensionGrantManager.getTokenGranter(id));\n        customTokenGranter.setExtensionGrantProvider(tokenGranterProvider);\n        customTokenGranter.setAuthenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n        granters.add(customTokenGranter);\n    });\n    return new CompositeTokenGranter(granters);\n}",
                "name": "tokenGranter",
                "modifiers": "private",
                "return_type": "TokenGranter",
                "parameters": [
                    {
                        "type": "final",
                        "name": "AuthorizationServerEndpointsConfigurer"
                    }
                ],
                "body": "{\n    List<TokenGranter> granters = new ArrayList<>(Arrays.asList(endpoints.getTokenGranter()));\n    extensionGrantManager.providers().forEach((id, tokenGranterProvider) -> {\n        CustomTokenGranter customTokenGranter = new CustomTokenGranter(endpoints.getTokenServices(), endpoints.getClientDetailsService(), endpoints.getOAuth2RequestFactory(), extensionGrantManager.getTokenGranter(id));\n        customTokenGranter.setExtensionGrantProvider(tokenGranterProvider);\n        customTokenGranter.setAuthenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n        granters.add(customTokenGranter);\n    });\n    return new CompositeTokenGranter(granters);\n}",
                "start_point": {
                    "row": 177,
                    "column": 4
                },
                "end_point": {
                    "row": 186,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic UserApprovalHandler userApprovalHandler() {\n    DefaultApprovalStoreUserApprovalHandler approvalHandler = new DefaultApprovalStoreUserApprovalHandler();\n    approvalHandler.setClientDetailsService(clientDetailsService);\n    approvalHandler.setApprovalStore(approvalStore());\n    approvalHandler.setRequestFactory(new CustomOAuth2RequestFactory(clientDetailsService));\n    return approvalHandler;\n}",
                "name": "userApprovalHandler",
                "modifiers": "@Bean\n    public",
                "return_type": "UserApprovalHandler",
                "parameters": [],
                "body": "{\n    DefaultApprovalStoreUserApprovalHandler approvalHandler = new DefaultApprovalStoreUserApprovalHandler();\n    approvalHandler.setClientDetailsService(clientDetailsService);\n    approvalHandler.setApprovalStore(approvalStore());\n    approvalHandler.setRequestFactory(new CustomOAuth2RequestFactory(clientDetailsService));\n    return approvalHandler;\n}",
                "start_point": {
                    "row": 188,
                    "column": 4
                },
                "end_point": {
                    "row": 195,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic ApprovalStore approvalStore() {\n    return new DefaultApprovalStore();\n}",
                "name": "approvalStore",
                "modifiers": "@Bean\n    public",
                "return_type": "ApprovalStore",
                "parameters": [],
                "body": "{\n    return new DefaultApprovalStore();\n}",
                "start_point": {
                    "row": 197,
                    "column": 4
                },
                "end_point": {
                    "row": 200,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/CustomAuthorizationServerSecurityConfiguration.java",
        "definition": "@Configuration\n@Order(0)\n@Import({ ClientDetailsServiceConfiguration.class})\npublic class CustomAuthorizationServerSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Autowired\n    private List<AuthorizationServerConfigurer> configurers = Collections.emptyList();\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Autowired\n    private AuthorizationServerEndpointsConfiguration endpoints;\n\n    @Autowired\n    public void configure(ClientDetailsServiceConfigurer clientDetails) throws Exception {\n        for (AuthorizationServerConfigurer configurer : configurers) {\n            configurer.configure(clientDetails);\n        }\n    }\n\n    @Override\n    protected void configure(final HttpSecurity http) throws Exception {\n        AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer();\n        FrameworkEndpointHandlerMapping handlerMapping = endpoints.oauth2EndpointHandlerMapping();\n        http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping);\n        configure(configurer);\n        http.apply(configurer);\n        String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\");\n        String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\");\n        String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\");\n        String revokeTokenPath = handlerMapping.getServletPath(\"/oauth/revoke\");\n        if (!endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) {\n            UserDetailsService userDetailsService = http.getSharedObject(UserDetailsService.class);\n            endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService);\n        }\n        // @formatter:off\n        http\n                .authorizeRequests()\n                // Per the OAuth2 spec, we should only allow POST to the token endpoint.\n                // See: https://github.com/spring-projects/spring-security-oauth/issues/327\n                .antMatchers(HttpMethod.GET, tokenEndpointPath).denyAll()\n                .antMatchers(HttpMethod.PUT, tokenEndpointPath).denyAll()\n                .antMatchers(HttpMethod.PATCH, tokenEndpointPath).denyAll()\n                .antMatchers(HttpMethod.DELETE, tokenEndpointPath).denyAll()\n                .and()\n                .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .antMatchers(tokenEndpointPath).fullyAuthenticated()\n                .antMatchers(tokenKeyPath).access(configurer.getTokenKeyAccess())\n                .antMatchers(checkTokenPath).access(configurer.getCheckTokenAccess())\n                .antMatchers(revokeTokenPath).access(configurer.getCheckTokenAccess())\n                .and()\n                .requestMatchers()\n                .antMatchers(tokenEndpointPath, tokenKeyPath, checkTokenPath, revokeTokenPath)\n                .and()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER);\n        // @formatter:on\n        http.setSharedObject(ClientDetailsService.class, clientDetailsService);\n    }\n\n    protected void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {\n        for (AuthorizationServerConfigurer configurer : configurers) {\n            configurer.configure(oauthServer);\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2;",
        "tree_path": "CustomAuthorizationServerSecurityConfiguration",
        "name": "CustomAuthorizationServerSecurityConfiguration",
        "modifiers": "@Configuration\n@Order(0)\n@Import({ ClientDetailsServiceConfiguration.class})\npublic",
        "superclass": "extends WebSecurityConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private List<AuthorizationServerConfigurer> configurers = Collections.emptyList();\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Autowired\n    private AuthorizationServerEndpointsConfiguration endpoints;\n\n    @Autowired\n    public void configure(ClientDetailsServiceConfigurer clientDetails) throws Exception {\n        for (AuthorizationServerConfigurer configurer : configurers) {\n            configurer.configure(clientDetails);\n        }\n    }\n\n    @Override\n    protected void configure(final HttpSecurity http) throws Exception {\n        AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer();\n        FrameworkEndpointHandlerMapping handlerMapping = endpoints.oauth2EndpointHandlerMapping();\n        http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping);\n        configure(configurer);\n        http.apply(configurer);\n        String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\");\n        String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\");\n        String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\");\n        String revokeTokenPath = handlerMapping.getServletPath(\"/oauth/revoke\");\n        if (!endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) {\n            UserDetailsService userDetailsService = http.getSharedObject(UserDetailsService.class);\n            endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService);\n        }\n        // @formatter:off\n        http\n                .authorizeRequests()\n                // Per the OAuth2 spec, we should only allow POST to the token endpoint.\n                // See: https://github.com/spring-projects/spring-security-oauth/issues/327\n                .antMatchers(HttpMethod.GET, tokenEndpointPath).denyAll()\n                .antMatchers(HttpMethod.PUT, tokenEndpointPath).denyAll()\n                .antMatchers(HttpMethod.PATCH, tokenEndpointPath).denyAll()\n                .antMatchers(HttpMethod.DELETE, tokenEndpointPath).denyAll()\n                .and()\n                .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .antMatchers(tokenEndpointPath).fullyAuthenticated()\n                .antMatchers(tokenKeyPath).access(configurer.getTokenKeyAccess())\n                .antMatchers(checkTokenPath).access(configurer.getCheckTokenAccess())\n                .antMatchers(revokeTokenPath).access(configurer.getCheckTokenAccess())\n                .and()\n                .requestMatchers()\n                .antMatchers(tokenEndpointPath, tokenKeyPath, checkTokenPath, revokeTokenPath)\n                .and()\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER);\n        // @formatter:on\n        http.setSharedObject(ClientDetailsService.class, clientDetailsService);\n    }\n\n    protected void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {\n        for (AuthorizationServerConfigurer configurer : configurers) {\n            configurer.configure(oauthServer);\n        }\n    }\n}",
        "start_point": {
            "row": 41,
            "column": 0
        },
        "end_point": {
            "row": 107,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Autowired\npublic void configure(ClientDetailsServiceConfigurer clientDetails) throws Exception {\n    for (AuthorizationServerConfigurer configurer : configurers) {\n        configurer.configure(clientDetails);\n    }\n}",
                "name": "configure",
                "modifiers": "@Autowired\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ClientDetailsServiceConfigurer",
                        "name": "clientDetails"
                    }
                ],
                "body": "{\n    for (AuthorizationServerConfigurer configurer : configurers) {\n        configurer.configure(clientDetails);\n    }\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 60,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected void configure(final HttpSecurity http) throws Exception {\n    AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer();\n    FrameworkEndpointHandlerMapping handlerMapping = endpoints.oauth2EndpointHandlerMapping();\n    http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping);\n    configure(configurer);\n    http.apply(configurer);\n    String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\");\n    String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\");\n    String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\");\n    String revokeTokenPath = handlerMapping.getServletPath(\"/oauth/revoke\");\n    if (!endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) {\n        UserDetailsService userDetailsService = http.getSharedObject(UserDetailsService.class);\n        endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService);\n    }\n    // @formatter:off\n    http\n            .authorizeRequests()\n            // Per the OAuth2 spec, we should only allow POST to the token endpoint.\n            // See: https://github.com/spring-projects/spring-security-oauth/issues/327\n            .antMatchers(HttpMethod.GET, tokenEndpointPath).denyAll()\n            .antMatchers(HttpMethod.PUT, tokenEndpointPath).denyAll()\n            .antMatchers(HttpMethod.PATCH, tokenEndpointPath).denyAll()\n            .antMatchers(HttpMethod.DELETE, tokenEndpointPath).denyAll()\n            .and()\n            .authorizeRequests()\n            .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n            .antMatchers(tokenEndpointPath).fullyAuthenticated()\n            .antMatchers(tokenKeyPath).access(configurer.getTokenKeyAccess())\n            .antMatchers(checkTokenPath).access(configurer.getCheckTokenAccess())\n            .antMatchers(revokeTokenPath).access(configurer.getCheckTokenAccess())\n            .and()\n            .requestMatchers()\n            .antMatchers(tokenEndpointPath, tokenKeyPath, checkTokenPath, revokeTokenPath)\n            .and()\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER);\n    // @formatter:on\n    http.setSharedObject(ClientDetailsService.class, clientDetailsService);\n}",
                "name": "configure",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "HttpSecurity"
                    }
                ],
                "body": "{\n    AuthorizationServerSecurityConfigurer configurer = new AuthorizationServerSecurityConfigurer();\n    FrameworkEndpointHandlerMapping handlerMapping = endpoints.oauth2EndpointHandlerMapping();\n    http.setSharedObject(FrameworkEndpointHandlerMapping.class, handlerMapping);\n    configure(configurer);\n    http.apply(configurer);\n    String tokenEndpointPath = handlerMapping.getServletPath(\"/oauth/token\");\n    String tokenKeyPath = handlerMapping.getServletPath(\"/oauth/token_key\");\n    String checkTokenPath = handlerMapping.getServletPath(\"/oauth/check_token\");\n    String revokeTokenPath = handlerMapping.getServletPath(\"/oauth/revoke\");\n    if (!endpoints.getEndpointsConfigurer().isUserDetailsServiceOverride()) {\n        UserDetailsService userDetailsService = http.getSharedObject(UserDetailsService.class);\n        endpoints.getEndpointsConfigurer().userDetailsService(userDetailsService);\n    }\n    // @formatter:off\n    http\n            .authorizeRequests()\n            // Per the OAuth2 spec, we should only allow POST to the token endpoint.\n            // See: https://github.com/spring-projects/spring-security-oauth/issues/327\n            .antMatchers(HttpMethod.GET, tokenEndpointPath).denyAll()\n            .antMatchers(HttpMethod.PUT, tokenEndpointPath).denyAll()\n            .antMatchers(HttpMethod.PATCH, tokenEndpointPath).denyAll()\n            .antMatchers(HttpMethod.DELETE, tokenEndpointPath).denyAll()\n            .and()\n            .authorizeRequests()\n            .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n            .antMatchers(tokenEndpointPath).fullyAuthenticated()\n            .antMatchers(tokenKeyPath).access(configurer.getTokenKeyAccess())\n            .antMatchers(checkTokenPath).access(configurer.getCheckTokenAccess())\n            .antMatchers(revokeTokenPath).access(configurer.getCheckTokenAccess())\n            .and()\n            .requestMatchers()\n            .antMatchers(tokenEndpointPath, tokenKeyPath, checkTokenPath, revokeTokenPath)\n            .and()\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER);\n    // @formatter:on\n    http.setSharedObject(ClientDetailsService.class, clientDetailsService);\n}",
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 100,
                    "column": 5
                }
            },
            {
                "definition": "protected void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception {\n    for (AuthorizationServerConfigurer configurer : configurers) {\n        configurer.configure(oauthServer);\n    }\n}",
                "name": "configure",
                "modifiers": "protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthorizationServerSecurityConfigurer",
                        "name": "oauthServer"
                    }
                ],
                "body": "{\n    for (AuthorizationServerConfigurer configurer : configurers) {\n        configurer.configure(oauthServer);\n    }\n}",
                "start_point": {
                    "row": 102,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/OAuth2SecurityConfiguration.java",
        "definition": "@Configuration\n@EnableWebSecurity\npublic class OAuth2SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(OAuth2SecurityConfiguration.class);\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Autowired\n    protected void globalUserDetails(AuthenticationManagerBuilder auth) throws Exception {\n        logger.info(\"Loading identity providers to handle user authentication\");\n\n        // By default we are associating users added to the domain\n        auth.authenticationProvider(userAuthenticationProvider());\n        auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.\n            requestMatchers()\n                .antMatchers(\"/oauth/**\", \"/login\", \"/login/callback\", \"/logout\")\n                .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .antMatchers(\"/login\").permitAll()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .authenticationDetailsSource(new ClientAwareAuthenticationDetailsSource())\n                .failureHandler(authenticationFailureHandler())\n                .successHandler(authenticationSuccessHandler())\n                .permitAll()\n                .and()\n            .logout()\n                .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n                .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n                .and()\n            .exceptionHandling()\n                .authenticationEntryPoint(new OAuth2LoginUrlAuthenticationEntryPoint(\"/login\"))\n                .and()\n            .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class)\n            .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n    }\n\n    @Override\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    @Override\n    @Bean\n    public UserDetailsService userDetailsServiceBean() throws Exception {\n        // Do not use userDetailsService from WebSecurityConfigurerAdapter because this later\n        // register only the latest UserDetailsService even we have multiple authentication providers.\n        return new CustomUserDetailsService();\n    }\n\n    @Bean\n    public TokenStore tokenStore() {\n        return new RepositoryTokenStore();\n    }\n\n    @Bean\n    public AuthenticationKeyGenerator authenticationKeyGenerator() {\n        return new DefaultAuthenticationKeyGenerator();\n    }\n\n    @Bean\n    public AuthorizationCodeServices authorizationCodeServices() {\n        return new RepositoryAuthorizationCodeServices();\n    }\n\n    @Bean\n    public ClientBasedAuthenticationProvider userAuthenticationProvider() {\n        return new ClientBasedAuthenticationProvider();\n    }\n\n    @Bean\n    public Filter corsFilter() {\n        return new CORSFilter();\n    }\n\n    @Bean\n    public Filter clientOAuth2Filter() {\n        OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n        oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n        return oAuth2ClientAuthenticationFilter;\n    }\n\n    @Bean\n    public AuthenticationFailureHandler authenticationFailureHandler() {\n        return new ClientAwareAuthenticationFailureHandler(\"/login?error\");\n    }\n\n    @Bean\n    public AuthenticationSuccessListener authenticationSuccessListener() {\n        return new AuthenticationSuccessListener();\n    }\n\n    private AuthenticationSuccessHandler authenticationSuccessHandler() {\n        SavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n        successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n        return successHandler;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2;",
        "tree_path": "OAuth2SecurityConfiguration",
        "name": "OAuth2SecurityConfiguration",
        "modifiers": "@Configuration\n@EnableWebSecurity\npublic",
        "superclass": "extends WebSecurityConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(OAuth2SecurityConfiguration.class);\n\n    @Autowired\n    private ApplicationEventPublisher applicationEventPublisher;\n\n    @Autowired\n    protected void globalUserDetails(AuthenticationManagerBuilder auth) throws Exception {\n        logger.info(\"Loading identity providers to handle user authentication\");\n\n        // By default we are associating users added to the domain\n        auth.authenticationProvider(userAuthenticationProvider());\n        auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.\n            requestMatchers()\n                .antMatchers(\"/oauth/**\", \"/login\", \"/login/callback\", \"/logout\")\n                .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .antMatchers(\"/login\").permitAll()\n                .anyRequest().authenticated()\n                .and()\n            .formLogin()\n                .authenticationDetailsSource(new ClientAwareAuthenticationDetailsSource())\n                .failureHandler(authenticationFailureHandler())\n                .successHandler(authenticationSuccessHandler())\n                .permitAll()\n                .and()\n            .logout()\n                .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n                .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n                .and()\n            .exceptionHandling()\n                .authenticationEntryPoint(new OAuth2LoginUrlAuthenticationEntryPoint(\"/login\"))\n                .and()\n            .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class)\n            .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n    }\n\n    @Override\n    @Bean\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    @Override\n    @Bean\n    public UserDetailsService userDetailsServiceBean() throws Exception {\n        // Do not use userDetailsService from WebSecurityConfigurerAdapter because this later\n        // register only the latest UserDetailsService even we have multiple authentication providers.\n        return new CustomUserDetailsService();\n    }\n\n    @Bean\n    public TokenStore tokenStore() {\n        return new RepositoryTokenStore();\n    }\n\n    @Bean\n    public AuthenticationKeyGenerator authenticationKeyGenerator() {\n        return new DefaultAuthenticationKeyGenerator();\n    }\n\n    @Bean\n    public AuthorizationCodeServices authorizationCodeServices() {\n        return new RepositoryAuthorizationCodeServices();\n    }\n\n    @Bean\n    public ClientBasedAuthenticationProvider userAuthenticationProvider() {\n        return new ClientBasedAuthenticationProvider();\n    }\n\n    @Bean\n    public Filter corsFilter() {\n        return new CORSFilter();\n    }\n\n    @Bean\n    public Filter clientOAuth2Filter() {\n        OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n        oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n        return oAuth2ClientAuthenticationFilter;\n    }\n\n    @Bean\n    public AuthenticationFailureHandler authenticationFailureHandler() {\n        return new ClientAwareAuthenticationFailureHandler(\"/login?error\");\n    }\n\n    @Bean\n    public AuthenticationSuccessListener authenticationSuccessListener() {\n        return new AuthenticationSuccessListener();\n    }\n\n    private AuthenticationSuccessHandler authenticationSuccessHandler() {\n        SavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n        successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n        return successHandler;\n    }\n}",
        "start_point": {
            "row": 60,
            "column": 0
        },
        "end_point": {
            "row": 171,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Autowired\nprotected void globalUserDetails(AuthenticationManagerBuilder auth) throws Exception {\n    logger.info(\"Loading identity providers to handle user authentication\");\n\n    // By default we are associating users added to the domain\n    auth.authenticationProvider(userAuthenticationProvider());\n    auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n}",
                "name": "globalUserDetails",
                "modifiers": "@Autowired\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthenticationManagerBuilder",
                        "name": "auth"
                    }
                ],
                "body": "{\n    logger.info(\"Loading identity providers to handle user authentication\");\n\n    // By default we are associating users added to the domain\n    auth.authenticationProvider(userAuthenticationProvider());\n    auth.authenticationEventPublisher(new DefaultAuthenticationEventPublisher(applicationEventPublisher));\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected void configure(HttpSecurity http) throws Exception {\n    http.\n        requestMatchers()\n            .antMatchers(\"/oauth/**\", \"/login\", \"/login/callback\", \"/logout\")\n            .and()\n        .authorizeRequests()\n            .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n            .antMatchers(\"/login\").permitAll()\n            .anyRequest().authenticated()\n            .and()\n        .formLogin()\n            .authenticationDetailsSource(new ClientAwareAuthenticationDetailsSource())\n            .failureHandler(authenticationFailureHandler())\n            .successHandler(authenticationSuccessHandler())\n            .permitAll()\n            .and()\n        .logout()\n            .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n            .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n            .and()\n        .exceptionHandling()\n            .authenticationEntryPoint(new OAuth2LoginUrlAuthenticationEntryPoint(\"/login\"))\n            .and()\n        .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class)\n        .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n}",
                "name": "configure",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpSecurity",
                        "name": "http"
                    }
                ],
                "body": "{\n    http.\n        requestMatchers()\n            .antMatchers(\"/oauth/**\", \"/login\", \"/login/callback\", \"/logout\")\n            .and()\n        .authorizeRequests()\n            .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n            .antMatchers(\"/login\").permitAll()\n            .anyRequest().authenticated()\n            .and()\n        .formLogin()\n            .authenticationDetailsSource(new ClientAwareAuthenticationDetailsSource())\n            .failureHandler(authenticationFailureHandler())\n            .successHandler(authenticationSuccessHandler())\n            .permitAll()\n            .and()\n        .logout()\n            .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\"))\n            .logoutSuccessHandler(new CustomLogoutSuccessHandler())\n            .and()\n        .exceptionHandling()\n            .authenticationEntryPoint(new OAuth2LoginUrlAuthenticationEntryPoint(\"/login\"))\n            .and()\n        .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class)\n        .addFilterBefore(clientOAuth2Filter(), AbstractPreAuthenticatedProcessingFilter.class);\n\n}",
                "start_point": {
                    "row": 81,
                    "column": 4
                },
                "end_point": {
                    "row": 108,
                    "column": 5
                }
            },
            {
                "definition": "@Override\n@Bean\npublic AuthenticationManager authenticationManagerBean() throws Exception {\n    return super.authenticationManagerBean();\n}",
                "name": "authenticationManagerBean",
                "modifiers": "@Override\n    @Bean\n    public",
                "return_type": "AuthenticationManager",
                "parameters": [],
                "body": "{\n    return super.authenticationManagerBean();\n}",
                "start_point": {
                    "row": 110,
                    "column": 4
                },
                "end_point": {
                    "row": 114,
                    "column": 5
                }
            },
            {
                "definition": "@Override\n@Bean\npublic UserDetailsService userDetailsServiceBean() throws Exception {\n    // Do not use userDetailsService from WebSecurityConfigurerAdapter because this later\n    // register only the latest UserDetailsService even we have multiple authentication providers.\n    return new CustomUserDetailsService();\n}",
                "name": "userDetailsServiceBean",
                "modifiers": "@Override\n    @Bean\n    public",
                "return_type": "UserDetailsService",
                "parameters": [],
                "body": "{\n    // Do not use userDetailsService from WebSecurityConfigurerAdapter because this later\n    // register only the latest UserDetailsService even we have multiple authentication providers.\n    return new CustomUserDetailsService();\n}",
                "start_point": {
                    "row": 116,
                    "column": 4
                },
                "end_point": {
                    "row": 122,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic TokenStore tokenStore() {\n    return new RepositoryTokenStore();\n}",
                "name": "tokenStore",
                "modifiers": "@Bean\n    public",
                "return_type": "TokenStore",
                "parameters": [],
                "body": "{\n    return new RepositoryTokenStore();\n}",
                "start_point": {
                    "row": 124,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthenticationKeyGenerator authenticationKeyGenerator() {\n    return new DefaultAuthenticationKeyGenerator();\n}",
                "name": "authenticationKeyGenerator",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthenticationKeyGenerator",
                "parameters": [],
                "body": "{\n    return new DefaultAuthenticationKeyGenerator();\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 132,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthorizationCodeServices authorizationCodeServices() {\n    return new RepositoryAuthorizationCodeServices();\n}",
                "name": "authorizationCodeServices",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthorizationCodeServices",
                "parameters": [],
                "body": "{\n    return new RepositoryAuthorizationCodeServices();\n}",
                "start_point": {
                    "row": 134,
                    "column": 4
                },
                "end_point": {
                    "row": 137,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic ClientBasedAuthenticationProvider userAuthenticationProvider() {\n    return new ClientBasedAuthenticationProvider();\n}",
                "name": "userAuthenticationProvider",
                "modifiers": "@Bean\n    public",
                "return_type": "ClientBasedAuthenticationProvider",
                "parameters": [],
                "body": "{\n    return new ClientBasedAuthenticationProvider();\n}",
                "start_point": {
                    "row": 139,
                    "column": 4
                },
                "end_point": {
                    "row": 142,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic Filter corsFilter() {\n    return new CORSFilter();\n}",
                "name": "corsFilter",
                "modifiers": "@Bean\n    public",
                "return_type": "Filter",
                "parameters": [],
                "body": "{\n    return new CORSFilter();\n}",
                "start_point": {
                    "row": 144,
                    "column": 4
                },
                "end_point": {
                    "row": 147,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic Filter clientOAuth2Filter() {\n    OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n    oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n    return oAuth2ClientAuthenticationFilter;\n}",
                "name": "clientOAuth2Filter",
                "modifiers": "@Bean\n    public",
                "return_type": "Filter",
                "parameters": [],
                "body": "{\n    OAuth2ClientAuthenticationFilter oAuth2ClientAuthenticationFilter = new OAuth2ClientAuthenticationFilter(\"/login/callback\");\n    oAuth2ClientAuthenticationFilter.setApplicationEventPublisher(applicationEventPublisher);\n    return oAuth2ClientAuthenticationFilter;\n}",
                "start_point": {
                    "row": 149,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthenticationFailureHandler authenticationFailureHandler() {\n    return new ClientAwareAuthenticationFailureHandler(\"/login?error\");\n}",
                "name": "authenticationFailureHandler",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthenticationFailureHandler",
                "parameters": [],
                "body": "{\n    return new ClientAwareAuthenticationFailureHandler(\"/login?error\");\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 159,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic AuthenticationSuccessListener authenticationSuccessListener() {\n    return new AuthenticationSuccessListener();\n}",
                "name": "authenticationSuccessListener",
                "modifiers": "@Bean\n    public",
                "return_type": "AuthenticationSuccessListener",
                "parameters": [],
                "body": "{\n    return new AuthenticationSuccessListener();\n}",
                "start_point": {
                    "row": 161,
                    "column": 4
                },
                "end_point": {
                    "row": 164,
                    "column": 5
                }
            },
            {
                "definition": "private AuthenticationSuccessHandler authenticationSuccessHandler() {\n    SavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n    successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n    return successHandler;\n}",
                "name": "authenticationSuccessHandler",
                "modifiers": "private",
                "return_type": "AuthenticationSuccessHandler",
                "parameters": [],
                "body": "{\n    SavedRequestAwareAuthenticationSuccessHandler successHandler = new CustomSavedRequestAwareAuthenticationSuccessHandler();\n    successHandler.setRedirectStrategy(new XForwardedAwareRedirectStrategy());\n    return successHandler;\n}",
                "start_point": {
                    "row": 166,
                    "column": 4
                },
                "end_point": {
                    "row": 170,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/OpenIDResourceServerConfiguration.java",
        "definition": "@Configuration\n@EnableResourceServer\npublic class OpenIDResourceServerConfiguration extends ResourceServerConfigurerAdapter {\n\n    @Bean\n    public UserInfoEndpoint userInfoEndpoint() {\n        return new UserInfoEndpoint();\n    }\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n                .requestMatchers()\n                    .antMatchers(\"/userinfo\")\n                .and()\n                .authorizeRequests()\n                    .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                    .antMatchers(HttpMethod.GET, \"/userinfo\").access(\"#oauth2.hasScope('openid')\")\n                    .and()\n                .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class);\n    }\n\n    @Override\n    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n        resources.resourceId(\"openid\");\n    }\n\n    @Bean\n    public Filter corsFilter() {\n        return new CORSFilter();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2;",
        "tree_path": "OpenIDResourceServerConfiguration",
        "name": "OpenIDResourceServerConfiguration",
        "modifiers": "@Configuration\n@EnableResourceServer\npublic",
        "superclass": "extends ResourceServerConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    @Bean\n    public UserInfoEndpoint userInfoEndpoint() {\n        return new UserInfoEndpoint();\n    }\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http\n                .requestMatchers()\n                    .antMatchers(\"/userinfo\")\n                .and()\n                .authorizeRequests()\n                    .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                    .antMatchers(HttpMethod.GET, \"/userinfo\").access(\"#oauth2.hasScope('openid')\")\n                    .and()\n                .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class);\n    }\n\n    @Override\n    public void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n        resources.resourceId(\"openid\");\n    }\n\n    @Bean\n    public Filter corsFilter() {\n        return new CORSFilter();\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 0
        },
        "end_point": {
            "row": 65,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Bean\npublic UserInfoEndpoint userInfoEndpoint() {\n    return new UserInfoEndpoint();\n}",
                "name": "userInfoEndpoint",
                "modifiers": "@Bean\n    public",
                "return_type": "UserInfoEndpoint",
                "parameters": [],
                "body": "{\n    return new UserInfoEndpoint();\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 41,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void configure(HttpSecurity http) throws Exception {\n    http\n            .requestMatchers()\n                .antMatchers(\"/userinfo\")\n            .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .antMatchers(HttpMethod.GET, \"/userinfo\").access(\"#oauth2.hasScope('openid')\")\n                .and()\n            .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class);\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpSecurity",
                        "name": "http"
                    }
                ],
                "body": "{\n    http\n            .requestMatchers()\n                .antMatchers(\"/userinfo\")\n            .and()\n            .authorizeRequests()\n                .antMatchers(HttpMethod.OPTIONS, \"**\").permitAll()\n                .antMatchers(HttpMethod.GET, \"/userinfo\").access(\"#oauth2.hasScope('openid')\")\n                .and()\n            .addFilterAfter(corsFilter(), AbstractPreAuthenticatedProcessingFilter.class);\n}",
                "start_point": {
                    "row": 43,
                    "column": 4
                },
                "end_point": {
                    "row": 54,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void configure(ResourceServerSecurityConfigurer resources) throws Exception {\n    resources.resourceId(\"openid\");\n}",
                "name": "configure",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ResourceServerSecurityConfigurer",
                        "name": "resources"
                    }
                ],
                "body": "{\n    resources.resourceId(\"openid\");\n}",
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 59,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic Filter corsFilter() {\n    return new CORSFilter();\n}",
                "name": "corsFilter",
                "modifiers": "@Bean\n    public",
                "return_type": "Filter",
                "parameters": [],
                "body": "{\n    return new CORSFilter();\n}",
                "start_point": {
                    "row": 61,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/filter/CORSFilter.java",
        "definition": "public class CORSFilter implements Filter {\n\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletResponse response = (HttpServletResponse) res;\n        HttpServletRequest request = (HttpServletRequest) req;\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n        if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n            chain.doFilter(req, res);\n        }\n    }\n\n    public void init(FilterConfig filterConfig) {\n    }\n\n    public void destroy() {\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.filter;",
        "tree_path": "CORSFilter",
        "name": "CORSFilter",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements Filter",
        "body": "{\n\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletResponse response = (HttpServletResponse) res;\n        HttpServletRequest request = (HttpServletRequest) req;\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n        response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n        if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n            chain.doFilter(req, res);\n        }\n    }\n\n    public void init(FilterConfig filterConfig) {\n    }\n\n    public void destroy() {\n    }\n\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 51,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n    HttpServletResponse response = (HttpServletResponse) res;\n    HttpServletRequest request = (HttpServletRequest) req;\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n    if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n        chain.doFilter(req, res);\n    }\n}",
                "name": "doFilter",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ServletRequest",
                        "name": "req"
                    },
                    {
                        "type": "ServletResponse",
                        "name": "res"
                    },
                    {
                        "type": "FilterChain",
                        "name": "chain"
                    }
                ],
                "body": "{\n    HttpServletResponse response = (HttpServletResponse) res;\n    HttpServletRequest request = (HttpServletRequest) req;\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, request.getHeader(\"origin\"));\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, \"true\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, \"Cache-Control, Pragma, Origin, Authorization, Content-Type, X-Requested-With\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, \"POST, PUT, GET, OPTIONS, DELETE, X-XSRF-TOKEN\");\n    response.setHeader(HttpHeaders.ACCESS_CONTROL_MAX_AGE, \"1209600\");\n\n    if (!HttpMethod.OPTIONS.equals(request.getMethod())) {\n        chain.doFilter(req, res);\n    }\n}",
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            },
            {
                "definition": "public void init(FilterConfig filterConfig) {\n}",
                "name": "init",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "FilterConfig",
                        "name": "filterConfig"
                    }
                ],
                "body": "{\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "public void destroy() {\n}",
                "name": "destroy",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/RepositoryProviderUtils.java",
        "definition": "public class RepositoryProviderUtils {\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    public static final String SOURCE = \"source\";\n\n    public static io.gravitee.am.repository.oauth2.model.OAuth2Authentication convert(OAuth2Authentication _oAuth2Authentication) {\n        // oauth2 request\n        OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n        io.gravitee.am.repository.oauth2.model.request.OAuth2Request oAuth2Request =\n                new io.gravitee.am.repository.oauth2.model.request.OAuth2Request();\n        oAuth2Request.setRequestParameters(_oAuth2Request.getRequestParameters());\n        oAuth2Request.setClientId(_oAuth2Request.getClientId());\n        oAuth2Request.setAuthorities(convert(_oAuth2Request.getAuthorities()));\n        oAuth2Request.setApproved(_oAuth2Request.isApproved());\n        oAuth2Request.setScope(_oAuth2Request.getScope());\n        oAuth2Request.setResourceIds(_oAuth2Request.getResourceIds());\n        oAuth2Request.setRedirectUri(_oAuth2Request.getRedirectUri());\n        oAuth2Request.setResponseTypes(_oAuth2Request.getResponseTypes());\n        oAuth2Request.setExtensions(_oAuth2Request.getExtensions());\n\n        // user authentication\n        io.gravitee.am.repository.oauth2.model.authentication.Authentication userAuthentication = null;\n        Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n        if (_userAuthentication != null) {\n            Object principal = _userAuthentication.getPrincipal();\n            Object credentials = _userAuthentication.getCredentials();\n            Collection<? extends GrantedAuthority> authorities = convert(_userAuthentication.getAuthorities());\n            userAuthentication =\n                    new io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken(\n                            _userAuthentication.getName(), principal, credentials, authorities);\n        }\n\n        io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication =\n                new io.gravitee.am.repository.oauth2.model.OAuth2Authentication(oAuth2Request, userAuthentication);\n\n        return oAuth2Authentication;\n    }\n\n    public static OAuth2Authentication convert(io.gravitee.am.repository.oauth2.model.OAuth2Authentication _oAuth2Authentication) {\n        // oauth2 request\n        io.gravitee.am.repository.oauth2.model.request.OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n\n        Map<String, String> requestParameters = _oAuth2Request.getRequestParameters();\n        String clientId = _oAuth2Request.getClientId();\n        Collection<? extends org.springframework.security.core.GrantedAuthority> authorities = map(_oAuth2Request.getAuthorities());\n        boolean approved = _oAuth2Request.isApproved();\n        Set<String> scope = _oAuth2Request.getScope();\n        Set<String> resourceIds = _oAuth2Request.getResourceIds();\n        String redirectUri = _oAuth2Request.getRedirectUri();\n        Set<String> responseTypes = _oAuth2Request.getResponseTypes();\n        Map<String, Serializable> extensions = _oAuth2Request.getExtensions();\n\n        OAuth2Request oAuth2Request =\n                new OAuth2Request(requestParameters, clientId, authorities, approved, scope, resourceIds, redirectUri, responseTypes, extensions);\n\n        // user authentication\n        Authentication userAuthentication = null;\n        io.gravitee.am.repository.oauth2.model.authentication.Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n\n        if (_userAuthentication != null && _userAuthentication instanceof io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken) {\n            Object principal = _userAuthentication.getPrincipal();\n            Object credentials = _userAuthentication.getCredentials();\n            Collection<? extends org.springframework.security.core.GrantedAuthority> userAuthorities = map(_userAuthentication.getAuthorities());\n            userAuthentication =\n                    new UsernamePasswordAuthenticationToken(principal, credentials, userAuthorities);\n        }\n\n        OAuth2Authentication oAuth2Authentication =\n                new OAuth2Authentication(oAuth2Request, userAuthentication);\n\n        return oAuth2Authentication;\n    }\n\n    private static Collection<? extends org.springframework.security.core.GrantedAuthority> map(Collection<? extends GrantedAuthority> _authorities) {\n        if (_authorities == null) {\n            return null;\n        }\n        return _authorities.stream().map(a -> new SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n    }\n\n    private static Collection<? extends GrantedAuthority> convert(Collection<? extends org.springframework.security.core.GrantedAuthority> _authorities) {\n        if (_authorities == null) {\n            return null;\n        }\n        return _authorities.stream().map(a -> new io.gravitee.am.repository.oauth2.model.authority.SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider;",
        "tree_path": "RepositoryProviderUtils",
        "name": "RepositoryProviderUtils",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * Constant to use while setting identity provider used to authenticate a user\n     */\n    public static final String SOURCE = \"source\";\n\n    public static io.gravitee.am.repository.oauth2.model.OAuth2Authentication convert(OAuth2Authentication _oAuth2Authentication) {\n        // oauth2 request\n        OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n        io.gravitee.am.repository.oauth2.model.request.OAuth2Request oAuth2Request =\n                new io.gravitee.am.repository.oauth2.model.request.OAuth2Request();\n        oAuth2Request.setRequestParameters(_oAuth2Request.getRequestParameters());\n        oAuth2Request.setClientId(_oAuth2Request.getClientId());\n        oAuth2Request.setAuthorities(convert(_oAuth2Request.getAuthorities()));\n        oAuth2Request.setApproved(_oAuth2Request.isApproved());\n        oAuth2Request.setScope(_oAuth2Request.getScope());\n        oAuth2Request.setResourceIds(_oAuth2Request.getResourceIds());\n        oAuth2Request.setRedirectUri(_oAuth2Request.getRedirectUri());\n        oAuth2Request.setResponseTypes(_oAuth2Request.getResponseTypes());\n        oAuth2Request.setExtensions(_oAuth2Request.getExtensions());\n\n        // user authentication\n        io.gravitee.am.repository.oauth2.model.authentication.Authentication userAuthentication = null;\n        Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n        if (_userAuthentication != null) {\n            Object principal = _userAuthentication.getPrincipal();\n            Object credentials = _userAuthentication.getCredentials();\n            Collection<? extends GrantedAuthority> authorities = convert(_userAuthentication.getAuthorities());\n            userAuthentication =\n                    new io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken(\n                            _userAuthentication.getName(), principal, credentials, authorities);\n        }\n\n        io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication =\n                new io.gravitee.am.repository.oauth2.model.OAuth2Authentication(oAuth2Request, userAuthentication);\n\n        return oAuth2Authentication;\n    }\n\n    public static OAuth2Authentication convert(io.gravitee.am.repository.oauth2.model.OAuth2Authentication _oAuth2Authentication) {\n        // oauth2 request\n        io.gravitee.am.repository.oauth2.model.request.OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n\n        Map<String, String> requestParameters = _oAuth2Request.getRequestParameters();\n        String clientId = _oAuth2Request.getClientId();\n        Collection<? extends org.springframework.security.core.GrantedAuthority> authorities = map(_oAuth2Request.getAuthorities());\n        boolean approved = _oAuth2Request.isApproved();\n        Set<String> scope = _oAuth2Request.getScope();\n        Set<String> resourceIds = _oAuth2Request.getResourceIds();\n        String redirectUri = _oAuth2Request.getRedirectUri();\n        Set<String> responseTypes = _oAuth2Request.getResponseTypes();\n        Map<String, Serializable> extensions = _oAuth2Request.getExtensions();\n\n        OAuth2Request oAuth2Request =\n                new OAuth2Request(requestParameters, clientId, authorities, approved, scope, resourceIds, redirectUri, responseTypes, extensions);\n\n        // user authentication\n        Authentication userAuthentication = null;\n        io.gravitee.am.repository.oauth2.model.authentication.Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n\n        if (_userAuthentication != null && _userAuthentication instanceof io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken) {\n            Object principal = _userAuthentication.getPrincipal();\n            Object credentials = _userAuthentication.getCredentials();\n            Collection<? extends org.springframework.security.core.GrantedAuthority> userAuthorities = map(_userAuthentication.getAuthorities());\n            userAuthentication =\n                    new UsernamePasswordAuthenticationToken(principal, credentials, userAuthorities);\n        }\n\n        OAuth2Authentication oAuth2Authentication =\n                new OAuth2Authentication(oAuth2Request, userAuthentication);\n\n        return oAuth2Authentication;\n    }\n\n    private static Collection<? extends org.springframework.security.core.GrantedAuthority> map(Collection<? extends GrantedAuthority> _authorities) {\n        if (_authorities == null) {\n            return null;\n        }\n        return _authorities.stream().map(a -> new SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n    }\n\n    private static Collection<? extends GrantedAuthority> convert(Collection<? extends org.springframework.security.core.GrantedAuthority> _authorities) {\n        if (_authorities == null) {\n            return null;\n        }\n        return _authorities.stream().map(a -> new io.gravitee.am.repository.oauth2.model.authority.SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n    }\n}",
        "start_point": {
            "row": 34,
            "column": 1
        },
        "end_point": {
            "row": 122,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public static io.gravitee.am.repository.oauth2.model.OAuth2Authentication convert(OAuth2Authentication _oAuth2Authentication) {\n    // oauth2 request\n    OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n    io.gravitee.am.repository.oauth2.model.request.OAuth2Request oAuth2Request =\n            new io.gravitee.am.repository.oauth2.model.request.OAuth2Request();\n    oAuth2Request.setRequestParameters(_oAuth2Request.getRequestParameters());\n    oAuth2Request.setClientId(_oAuth2Request.getClientId());\n    oAuth2Request.setAuthorities(convert(_oAuth2Request.getAuthorities()));\n    oAuth2Request.setApproved(_oAuth2Request.isApproved());\n    oAuth2Request.setScope(_oAuth2Request.getScope());\n    oAuth2Request.setResourceIds(_oAuth2Request.getResourceIds());\n    oAuth2Request.setRedirectUri(_oAuth2Request.getRedirectUri());\n    oAuth2Request.setResponseTypes(_oAuth2Request.getResponseTypes());\n    oAuth2Request.setExtensions(_oAuth2Request.getExtensions());\n\n    // user authentication\n    io.gravitee.am.repository.oauth2.model.authentication.Authentication userAuthentication = null;\n    Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n    if (_userAuthentication != null) {\n        Object principal = _userAuthentication.getPrincipal();\n        Object credentials = _userAuthentication.getCredentials();\n        Collection<? extends GrantedAuthority> authorities = convert(_userAuthentication.getAuthorities());\n        userAuthentication =\n                new io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken(\n                        _userAuthentication.getName(), principal, credentials, authorities);\n    }\n\n    io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication =\n            new io.gravitee.am.repository.oauth2.model.OAuth2Authentication(oAuth2Request, userAuthentication);\n\n    return oAuth2Authentication;\n}",
                "name": "convert",
                "modifiers": "public static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2Authentication",
                        "name": "_oAuth2Authentication"
                    }
                ],
                "body": "{\n    // oauth2 request\n    OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n    io.gravitee.am.repository.oauth2.model.request.OAuth2Request oAuth2Request =\n            new io.gravitee.am.repository.oauth2.model.request.OAuth2Request();\n    oAuth2Request.setRequestParameters(_oAuth2Request.getRequestParameters());\n    oAuth2Request.setClientId(_oAuth2Request.getClientId());\n    oAuth2Request.setAuthorities(convert(_oAuth2Request.getAuthorities()));\n    oAuth2Request.setApproved(_oAuth2Request.isApproved());\n    oAuth2Request.setScope(_oAuth2Request.getScope());\n    oAuth2Request.setResourceIds(_oAuth2Request.getResourceIds());\n    oAuth2Request.setRedirectUri(_oAuth2Request.getRedirectUri());\n    oAuth2Request.setResponseTypes(_oAuth2Request.getResponseTypes());\n    oAuth2Request.setExtensions(_oAuth2Request.getExtensions());\n\n    // user authentication\n    io.gravitee.am.repository.oauth2.model.authentication.Authentication userAuthentication = null;\n    Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n    if (_userAuthentication != null) {\n        Object principal = _userAuthentication.getPrincipal();\n        Object credentials = _userAuthentication.getCredentials();\n        Collection<? extends GrantedAuthority> authorities = convert(_userAuthentication.getAuthorities());\n        userAuthentication =\n                new io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken(\n                        _userAuthentication.getName(), principal, credentials, authorities);\n    }\n\n    io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication =\n            new io.gravitee.am.repository.oauth2.model.OAuth2Authentication(oAuth2Request, userAuthentication);\n\n    return oAuth2Authentication;\n}",
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 72,
                    "column": 5
                }
            },
            {
                "definition": "public static OAuth2Authentication convert(io.gravitee.am.repository.oauth2.model.OAuth2Authentication _oAuth2Authentication) {\n    // oauth2 request\n    io.gravitee.am.repository.oauth2.model.request.OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n\n    Map<String, String> requestParameters = _oAuth2Request.getRequestParameters();\n    String clientId = _oAuth2Request.getClientId();\n    Collection<? extends org.springframework.security.core.GrantedAuthority> authorities = map(_oAuth2Request.getAuthorities());\n    boolean approved = _oAuth2Request.isApproved();\n    Set<String> scope = _oAuth2Request.getScope();\n    Set<String> resourceIds = _oAuth2Request.getResourceIds();\n    String redirectUri = _oAuth2Request.getRedirectUri();\n    Set<String> responseTypes = _oAuth2Request.getResponseTypes();\n    Map<String, Serializable> extensions = _oAuth2Request.getExtensions();\n\n    OAuth2Request oAuth2Request =\n            new OAuth2Request(requestParameters, clientId, authorities, approved, scope, resourceIds, redirectUri, responseTypes, extensions);\n\n    // user authentication\n    Authentication userAuthentication = null;\n    io.gravitee.am.repository.oauth2.model.authentication.Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n\n    if (_userAuthentication != null && _userAuthentication instanceof io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken) {\n        Object principal = _userAuthentication.getPrincipal();\n        Object credentials = _userAuthentication.getCredentials();\n        Collection<? extends org.springframework.security.core.GrantedAuthority> userAuthorities = map(_userAuthentication.getAuthorities());\n        userAuthentication =\n                new UsernamePasswordAuthenticationToken(principal, credentials, userAuthorities);\n    }\n\n    OAuth2Authentication oAuth2Authentication =\n            new OAuth2Authentication(oAuth2Request, userAuthentication);\n\n    return oAuth2Authentication;\n}",
                "name": "convert",
                "modifiers": "public static",
                "return_type": "OAuth2Authentication",
                "parameters": [
                    {
                        "type": "io.gravitee.am.repository.oauth2.model.OAuth2Authentication",
                        "name": "_oAuth2Authentication"
                    }
                ],
                "body": "{\n    // oauth2 request\n    io.gravitee.am.repository.oauth2.model.request.OAuth2Request _oAuth2Request = _oAuth2Authentication.getOAuth2Request();\n\n    Map<String, String> requestParameters = _oAuth2Request.getRequestParameters();\n    String clientId = _oAuth2Request.getClientId();\n    Collection<? extends org.springframework.security.core.GrantedAuthority> authorities = map(_oAuth2Request.getAuthorities());\n    boolean approved = _oAuth2Request.isApproved();\n    Set<String> scope = _oAuth2Request.getScope();\n    Set<String> resourceIds = _oAuth2Request.getResourceIds();\n    String redirectUri = _oAuth2Request.getRedirectUri();\n    Set<String> responseTypes = _oAuth2Request.getResponseTypes();\n    Map<String, Serializable> extensions = _oAuth2Request.getExtensions();\n\n    OAuth2Request oAuth2Request =\n            new OAuth2Request(requestParameters, clientId, authorities, approved, scope, resourceIds, redirectUri, responseTypes, extensions);\n\n    // user authentication\n    Authentication userAuthentication = null;\n    io.gravitee.am.repository.oauth2.model.authentication.Authentication _userAuthentication = _oAuth2Authentication.getUserAuthentication();\n\n    if (_userAuthentication != null && _userAuthentication instanceof io.gravitee.am.repository.oauth2.model.authentication.UsernamePasswordAuthenticationToken) {\n        Object principal = _userAuthentication.getPrincipal();\n        Object credentials = _userAuthentication.getCredentials();\n        Collection<? extends org.springframework.security.core.GrantedAuthority> userAuthorities = map(_userAuthentication.getAuthorities());\n        userAuthentication =\n                new UsernamePasswordAuthenticationToken(principal, credentials, userAuthorities);\n    }\n\n    OAuth2Authentication oAuth2Authentication =\n            new OAuth2Authentication(oAuth2Request, userAuthentication);\n\n    return oAuth2Authentication;\n}",
                "start_point": {
                    "row": 74,
                    "column": 4
                },
                "end_point": {
                    "row": 107,
                    "column": 5
                }
            },
            {
                "definition": "private static Collection<? extends org.springframework.security.core.GrantedAuthority> map(Collection<? extends GrantedAuthority> _authorities) {\n    if (_authorities == null) {\n        return null;\n    }\n    return _authorities.stream().map(a -> new SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n}",
                "name": "map",
                "modifiers": "private static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<? extends GrantedAuthority>",
                        "name": "_authorities"
                    }
                ],
                "body": "{\n    if (_authorities == null) {\n        return null;\n    }\n    return _authorities.stream().map(a -> new SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n}",
                "start_point": {
                    "row": 109,
                    "column": 4
                },
                "end_point": {
                    "row": 114,
                    "column": 5
                }
            },
            {
                "definition": "private static Collection<? extends GrantedAuthority> convert(Collection<? extends org.springframework.security.core.GrantedAuthority> _authorities) {\n    if (_authorities == null) {\n        return null;\n    }\n    return _authorities.stream().map(a -> new io.gravitee.am.repository.oauth2.model.authority.SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n}",
                "name": "convert",
                "modifiers": "private static",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<? extends org.springframework.security.core.GrantedAuthority>",
                        "name": "_authorities"
                    }
                ],
                "body": "{\n    if (_authorities == null) {\n        return null;\n    }\n    return _authorities.stream().map(a -> new io.gravitee.am.repository.oauth2.model.authority.SimpleGrantedAuthority(a.getAuthority())).collect(Collectors.toList());\n}",
                "start_point": {
                    "row": 116,
                    "column": 4
                },
                "end_point": {
                    "row": 121,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/approval/DefaultApprovalStore.java",
        "definition": "public class DefaultApprovalStore implements ApprovalStore {\n\n    @Autowired\n    private ScopeApprovalService scopeApprovalService;\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    public boolean addApprovals(Collection<Approval> approvals) {\n        for (Approval approval : approvals) {\n            scopeApprovalService.create(map(approval));\n        }\n\n        return true;\n    }\n\n    @Override\n    public boolean revokeApprovals(Collection<Approval> approvals) {\n        for (Approval approval : approvals) {\n            scopeApprovalService.revoke(map(approval));\n        }\n\n        return true;\n    }\n\n    @Override\n    public Collection<Approval> getApprovals(String userId, String clientId) {\n        // TODO async call\n        return scopeApprovalService.findByUserAndClient(domain.getId(), userId, clientId).blockingGet()\n                .stream()\n                .map(this::map)\n                .collect(Collectors.toList());\n    }\n\n    private ScopeApproval map(Approval approval) {\n        ScopeApproval scopeApproval = new ScopeApproval();\n        scopeApproval.setDomain(domain.getId());\n        scopeApproval.setClientId(approval.getClientId());\n        scopeApproval.setUserId(approval.getUserId());\n        scopeApproval.setScope(approval.getScope());\n        scopeApproval.setUpdatedAt(approval.getLastUpdatedAt());\n        scopeApproval.setExpiresAt(approval.getExpiresAt());\n        scopeApproval.setStatus(ScopeApproval.ApprovalStatus.valueOf(approval.getStatus().name().toUpperCase()));\n        return scopeApproval;\n    }\n\n    private Approval map(ScopeApproval scopeApproval) {\n        return new Approval(\n                scopeApproval.getUserId(),\n                scopeApproval.getClientId(),\n                scopeApproval.getScope(),\n                scopeApproval.getExpiresAt(),\n                Approval.ApprovalStatus.valueOf(scopeApproval.getStatus().name().toUpperCase()),\n                scopeApproval.getUpdatedAt());\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.approval;",
        "tree_path": "DefaultApprovalStore",
        "name": "DefaultApprovalStore",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements ApprovalStore",
        "body": "{\n\n    @Autowired\n    private ScopeApprovalService scopeApprovalService;\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    public boolean addApprovals(Collection<Approval> approvals) {\n        for (Approval approval : approvals) {\n            scopeApprovalService.create(map(approval));\n        }\n\n        return true;\n    }\n\n    @Override\n    public boolean revokeApprovals(Collection<Approval> approvals) {\n        for (Approval approval : approvals) {\n            scopeApprovalService.revoke(map(approval));\n        }\n\n        return true;\n    }\n\n    @Override\n    public Collection<Approval> getApprovals(String userId, String clientId) {\n        // TODO async call\n        return scopeApprovalService.findByUserAndClient(domain.getId(), userId, clientId).blockingGet()\n                .stream()\n                .map(this::map)\n                .collect(Collectors.toList());\n    }\n\n    private ScopeApproval map(Approval approval) {\n        ScopeApproval scopeApproval = new ScopeApproval();\n        scopeApproval.setDomain(domain.getId());\n        scopeApproval.setClientId(approval.getClientId());\n        scopeApproval.setUserId(approval.getUserId());\n        scopeApproval.setScope(approval.getScope());\n        scopeApproval.setUpdatedAt(approval.getLastUpdatedAt());\n        scopeApproval.setExpiresAt(approval.getExpiresAt());\n        scopeApproval.setStatus(ScopeApproval.ApprovalStatus.valueOf(approval.getStatus().name().toUpperCase()));\n        return scopeApproval;\n    }\n\n    private Approval map(ScopeApproval scopeApproval) {\n        return new Approval(\n                scopeApproval.getUserId(),\n                scopeApproval.getClientId(),\n                scopeApproval.getScope(),\n                scopeApproval.getExpiresAt(),\n                Approval.ApprovalStatus.valueOf(scopeApproval.getStatus().name().toUpperCase()),\n                scopeApproval.getUpdatedAt());\n    }\n}",
        "start_point": {
            "row": 31,
            "column": 0
        },
        "end_point": {
            "row": 87,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic boolean addApprovals(Collection<Approval> approvals) {\n    for (Approval approval : approvals) {\n        scopeApprovalService.create(map(approval));\n    }\n\n    return true;\n}",
                "name": "addApprovals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<Approval>",
                        "name": "approvals"
                    }
                ],
                "body": "{\n    for (Approval approval : approvals) {\n        scopeApprovalService.create(map(approval));\n    }\n\n    return true;\n}",
                "start_point": {
                    "row": 39,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean revokeApprovals(Collection<Approval> approvals) {\n    for (Approval approval : approvals) {\n        scopeApprovalService.revoke(map(approval));\n    }\n\n    return true;\n}",
                "name": "revokeApprovals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Collection<Approval>",
                        "name": "approvals"
                    }
                ],
                "body": "{\n    for (Approval approval : approvals) {\n        scopeApprovalService.revoke(map(approval));\n    }\n\n    return true;\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 55,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Collection<Approval> getApprovals(String userId, String clientId) {\n    // TODO async call\n    return scopeApprovalService.findByUserAndClient(domain.getId(), userId, clientId).blockingGet()\n            .stream()\n            .map(this::map)\n            .collect(Collectors.toList());\n}",
                "name": "getApprovals",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "userId"
                    },
                    {
                        "type": "String",
                        "name": "clientId"
                    }
                ],
                "body": "{\n    // TODO async call\n    return scopeApprovalService.findByUserAndClient(domain.getId(), userId, clientId).blockingGet()\n            .stream()\n            .map(this::map)\n            .collect(Collectors.toList());\n}",
                "start_point": {
                    "row": 57,
                    "column": 4
                },
                "end_point": {
                    "row": 64,
                    "column": 5
                }
            },
            {
                "definition": "private ScopeApproval map(Approval approval) {\n    ScopeApproval scopeApproval = new ScopeApproval();\n    scopeApproval.setDomain(domain.getId());\n    scopeApproval.setClientId(approval.getClientId());\n    scopeApproval.setUserId(approval.getUserId());\n    scopeApproval.setScope(approval.getScope());\n    scopeApproval.setUpdatedAt(approval.getLastUpdatedAt());\n    scopeApproval.setExpiresAt(approval.getExpiresAt());\n    scopeApproval.setStatus(ScopeApproval.ApprovalStatus.valueOf(approval.getStatus().name().toUpperCase()));\n    return scopeApproval;\n}",
                "name": "map",
                "modifiers": "private",
                "return_type": "ScopeApproval",
                "parameters": [
                    {
                        "type": "Approval",
                        "name": "approval"
                    }
                ],
                "body": "{\n    ScopeApproval scopeApproval = new ScopeApproval();\n    scopeApproval.setDomain(domain.getId());\n    scopeApproval.setClientId(approval.getClientId());\n    scopeApproval.setUserId(approval.getUserId());\n    scopeApproval.setScope(approval.getScope());\n    scopeApproval.setUpdatedAt(approval.getLastUpdatedAt());\n    scopeApproval.setExpiresAt(approval.getExpiresAt());\n    scopeApproval.setStatus(ScopeApproval.ApprovalStatus.valueOf(approval.getStatus().name().toUpperCase()));\n    return scopeApproval;\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 76,
                    "column": 5
                }
            },
            {
                "definition": "private Approval map(ScopeApproval scopeApproval) {\n    return new Approval(\n            scopeApproval.getUserId(),\n            scopeApproval.getClientId(),\n            scopeApproval.getScope(),\n            scopeApproval.getExpiresAt(),\n            Approval.ApprovalStatus.valueOf(scopeApproval.getStatus().name().toUpperCase()),\n            scopeApproval.getUpdatedAt());\n}",
                "name": "map",
                "modifiers": "private",
                "return_type": "Approval",
                "parameters": [
                    {
                        "type": "ScopeApproval",
                        "name": "scopeApproval"
                    }
                ],
                "body": "{\n    return new Approval(\n            scopeApproval.getUserId(),\n            scopeApproval.getClientId(),\n            scopeApproval.getScope(),\n            scopeApproval.getExpiresAt(),\n            Approval.ApprovalStatus.valueOf(scopeApproval.getStatus().name().toUpperCase()),\n            scopeApproval.getUpdatedAt());\n}",
                "start_point": {
                    "row": 78,
                    "column": 4
                },
                "end_point": {
                    "row": 86,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/approval/DefaultApprovalStoreUserApprovalHandler.java",
        "definition": "public class DefaultApprovalStoreUserApprovalHandler extends ApprovalStoreUserApprovalHandler {\n\n    private String approvalParameter = OAuth2Utils.USER_OAUTH_APPROVAL;\n\n    @Override\n    public AuthorizationRequest updateAfterApproval(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {\n        Map<String, String> approvalParameters = authorizationRequest.getApprovalParameters();\n        String flag = approvalParameters.get(approvalParameter);\n        boolean approved = flag != null && flag.toLowerCase().equals(\"true\");\n        authorizationRequest.setApproved(approved);\n        if (approved) {\n            super.updateAfterApproval(authorizationRequest, userAuthentication);\n        }\n\n        return authorizationRequest;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.approval;",
        "tree_path": "DefaultApprovalStoreUserApprovalHandler",
        "name": "DefaultApprovalStoreUserApprovalHandler",
        "modifiers": "public",
        "superclass": "extends ApprovalStoreUserApprovalHandler",
        "super_interfaces": null,
        "body": "{\n\n    private String approvalParameter = OAuth2Utils.USER_OAUTH_APPROVAL;\n\n    @Override\n    public AuthorizationRequest updateAfterApproval(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {\n        Map<String, String> approvalParameters = authorizationRequest.getApprovalParameters();\n        String flag = approvalParameters.get(approvalParameter);\n        boolean approved = flag != null && flag.toLowerCase().equals(\"true\");\n        authorizationRequest.setApproved(approved);\n        if (approved) {\n            super.updateAfterApproval(authorizationRequest, userAuthentication);\n        }\n\n        return authorizationRequest;\n    }\n}",
        "start_point": {
            "row": 28,
            "column": 0
        },
        "end_point": {
            "row": 44,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic AuthorizationRequest updateAfterApproval(AuthorizationRequest authorizationRequest, Authentication userAuthentication) {\n    Map<String, String> approvalParameters = authorizationRequest.getApprovalParameters();\n    String flag = approvalParameters.get(approvalParameter);\n    boolean approved = flag != null && flag.toLowerCase().equals(\"true\");\n    authorizationRequest.setApproved(approved);\n    if (approved) {\n        super.updateAfterApproval(authorizationRequest, userAuthentication);\n    }\n\n    return authorizationRequest;\n}",
                "name": "updateAfterApproval",
                "modifiers": "@Override\n    public",
                "return_type": "AuthorizationRequest",
                "parameters": [
                    {
                        "type": "AuthorizationRequest",
                        "name": "authorizationRequest"
                    },
                    {
                        "type": "Authentication",
                        "name": "userAuthentication"
                    }
                ],
                "body": "{\n    Map<String, String> approvalParameters = authorizationRequest.getApprovalParameters();\n    String flag = approvalParameters.get(approvalParameter);\n    boolean approved = flag != null && flag.toLowerCase().equals(\"true\");\n    authorizationRequest.setApproved(approved);\n    if (approved) {\n        super.updateAfterApproval(authorizationRequest, userAuthentication);\n    }\n\n    return authorizationRequest;\n}",
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/client/DelegateClientDetails.java",
        "definition": "public class DelegateClientDetails extends BaseClientDetails {\n\n    private final Client client;\n\n    DelegateClientDetails(Client client) {\n        super();\n        this.client = client;\n        setAccessTokenValiditySeconds(client.getAccessTokenValiditySeconds());\n        setRefreshTokenValiditySeconds(client\n                .getRefreshTokenValiditySeconds());\n        setAuthorizedGrantTypes(client.getAuthorizedGrantTypes().stream().map(grantType -> grantType.toLowerCase()).collect(Collectors.toSet()));\n        setClientId(client.getClientId());\n        setClientSecret(client.getClientSecret());\n        setRegisteredRedirectUri(client.getRedirectUris() != null ? new HashSet<>(client.getRedirectUris()) : null);\n        setScope(client.getScopes());\n        setAutoApproveScopes(client.getAutoApproveScopes() != null ? new HashSet<>(client.getAutoApproveScopes()) : Collections.emptySet());\n//        setResourceIds(client.getResourceIds());\n    }\n\n    public Client getClient() {\n        return client;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.client;",
        "tree_path": "DelegateClientDetails",
        "name": "DelegateClientDetails",
        "modifiers": "public",
        "superclass": "extends BaseClientDetails",
        "super_interfaces": null,
        "body": "{\n\n    private final Client client;\n\n    DelegateClientDetails(Client client) {\n        super();\n        this.client = client;\n        setAccessTokenValiditySeconds(client.getAccessTokenValiditySeconds());\n        setRefreshTokenValiditySeconds(client\n                .getRefreshTokenValiditySeconds());\n        setAuthorizedGrantTypes(client.getAuthorizedGrantTypes().stream().map(grantType -> grantType.toLowerCase()).collect(Collectors.toSet()));\n        setClientId(client.getClientId());\n        setClientSecret(client.getClientSecret());\n        setRegisteredRedirectUri(client.getRedirectUris() != null ? new HashSet<>(client.getRedirectUris()) : null);\n        setScope(client.getScopes());\n        setAutoApproveScopes(client.getAutoApproveScopes() != null ? new HashSet<>(client.getAutoApproveScopes()) : Collections.emptySet());\n//        setResourceIds(client.getResourceIds());\n    }\n\n    public Client getClient() {\n        return client;\n    }\n}",
        "start_point": {
            "row": 28,
            "column": 0
        },
        "end_point": {
            "row": 50,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "DelegateClientDetails(Client client) {\n    super();\n    this.client = client;\n    setAccessTokenValiditySeconds(client.getAccessTokenValiditySeconds());\n    setRefreshTokenValiditySeconds(client\n            .getRefreshTokenValiditySeconds());\n    setAuthorizedGrantTypes(client.getAuthorizedGrantTypes().stream().map(grantType -> grantType.toLowerCase()).collect(Collectors.toSet()));\n    setClientId(client.getClientId());\n    setClientSecret(client.getClientSecret());\n    setRegisteredRedirectUri(client.getRedirectUris() != null ? new HashSet<>(client.getRedirectUris()) : null);\n    setScope(client.getScopes());\n    setAutoApproveScopes(client.getAutoApproveScopes() != null ? new HashSet<>(client.getAutoApproveScopes()) : Collections.emptySet());\n      setResourceIds(client.getResourceIds());\n}",
                "name": "DelegateClientDetails",
                "modifiers": null,
                "parameters": [
                    {
                        "type": "Client",
                        "name": "client"
                    }
                ],
                "body": "{\n    super();\n    this.client = client;\n    setAccessTokenValiditySeconds(client.getAccessTokenValiditySeconds());\n    setRefreshTokenValiditySeconds(client\n            .getRefreshTokenValiditySeconds());\n    setAuthorizedGrantTypes(client.getAuthorizedGrantTypes().stream().map(grantType -> grantType.toLowerCase()).collect(Collectors.toSet()));\n    setClientId(client.getClientId());\n    setClientSecret(client.getClientSecret());\n    setRegisteredRedirectUri(client.getRedirectUris() != null ? new HashSet<>(client.getRedirectUris()) : null);\n    setScope(client.getScopes());\n    setAutoApproveScopes(client.getAutoApproveScopes() != null ? new HashSet<>(client.getAutoApproveScopes()) : Collections.emptySet());\n      setResourceIds(client.getResourceIds());\n}",
                "constructor": true,
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 45,
                    "column": 5
                }
            },
            {
                "definition": "public Client getClient() {\n    return client;\n}",
                "name": "getClient",
                "modifiers": "public",
                "return_type": "Client",
                "parameters": [],
                "body": "{\n    return client;\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/client/DomainBasedClientDetailsService.java",
        "definition": "public class DomainBasedClientDetailsService implements ClientDetailsService {\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    public org.springframework.security.oauth2.provider.ClientDetails loadClientByClientId(String clientId) throws ClientRegistrationException {\n        try {\n            // TODO async call\n            Client client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n\n            if (client != null && client.isEnabled()) {\n                return new DelegateClientDetails(client);\n            }\n        } catch (ClientNotFoundException ignored) {\n        }\n\n        throw new NoSuchClientException(\"No client with requested id: \" + clientId);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.client;",
        "tree_path": "DomainBasedClientDetailsService",
        "name": "DomainBasedClientDetailsService",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements ClientDetailsService",
        "body": "{\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    public org.springframework.security.oauth2.provider.ClientDetails loadClientByClientId(String clientId) throws ClientRegistrationException {\n        try {\n            // TODO async call\n            Client client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n\n            if (client != null && client.isEnabled()) {\n                return new DelegateClientDetails(client);\n            }\n        } catch (ClientNotFoundException ignored) {\n        }\n\n        throw new NoSuchClientException(\"No client with requested id: \" + clientId);\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 52,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic org.springframework.security.oauth2.provider.ClientDetails loadClientByClientId(String clientId) throws ClientRegistrationException {\n    try {\n        // TODO async call\n        Client client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n\n        if (client != null && client.isEnabled()) {\n            return new DelegateClientDetails(client);\n        }\n    } catch (ClientNotFoundException ignored) {\n    }\n\n    throw new NoSuchClientException(\"No client with requested id: \" + clientId);\n}",
                "name": "loadClientByClientId",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "clientId"
                    }
                ],
                "body": "{\n    try {\n        // TODO async call\n        Client client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n\n        if (client != null && client.isEnabled()) {\n            return new DelegateClientDetails(client);\n        }\n    } catch (ClientNotFoundException ignored) {\n    }\n\n    throw new NoSuchClientException(\"No client with requested id: \" + clientId);\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/code/RepositoryAuthorizationCodeServices.java",
        "definition": "@Component\npublic class RepositoryAuthorizationCodeServices extends RandomValueAuthorizationCodeServices {\n\n    @Value(\"${authorization.code.validity:60000}\")\n    private int authorizationCodeValidity;\n\n    @Autowired\n    private AuthorizationCodeRepository authorizationCodeRepository;\n\n    @Override\n    protected void store(String code, OAuth2Authentication oAuth2Authentication) {\n        OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n        oAuth2AuthorizationCode.setCode(code);\n        oAuth2AuthorizationCode.setOAuth2Authentication(RepositoryProviderUtils.convert(oAuth2Authentication));\n        oAuth2AuthorizationCode.setExpiration(new Date(System.currentTimeMillis() + authorizationCodeValidity));\n        oAuth2AuthorizationCode.setCreatedAt(new Date());\n        oAuth2AuthorizationCode.setUpdatedAt(oAuth2AuthorizationCode.getCreatedAt());\n\n        // TODO move to async call\n        authorizationCodeRepository.store(oAuth2AuthorizationCode).subscribe();\n    }\n\n    @Override\n    protected OAuth2Authentication remove(String code) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication = Optional.ofNullable(authorizationCodeRepository.remove(code).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.code;",
        "tree_path": "RepositoryAuthorizationCodeServices",
        "name": "RepositoryAuthorizationCodeServices",
        "modifiers": "@Component\npublic",
        "superclass": "extends RandomValueAuthorizationCodeServices",
        "super_interfaces": null,
        "body": "{\n\n    @Value(\"${authorization.code.validity:60000}\")\n    private int authorizationCodeValidity;\n\n    @Autowired\n    private AuthorizationCodeRepository authorizationCodeRepository;\n\n    @Override\n    protected void store(String code, OAuth2Authentication oAuth2Authentication) {\n        OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n        oAuth2AuthorizationCode.setCode(code);\n        oAuth2AuthorizationCode.setOAuth2Authentication(RepositoryProviderUtils.convert(oAuth2Authentication));\n        oAuth2AuthorizationCode.setExpiration(new Date(System.currentTimeMillis() + authorizationCodeValidity));\n        oAuth2AuthorizationCode.setCreatedAt(new Date());\n        oAuth2AuthorizationCode.setUpdatedAt(oAuth2AuthorizationCode.getCreatedAt());\n\n        // TODO move to async call\n        authorizationCodeRepository.store(oAuth2AuthorizationCode).subscribe();\n    }\n\n    @Override\n    protected OAuth2Authentication remove(String code) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication = Optional.ofNullable(authorizationCodeRepository.remove(code).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n}",
        "start_point": {
            "row": 33,
            "column": 0
        },
        "end_point": {
            "row": 66,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\nprotected void store(String code, OAuth2Authentication oAuth2Authentication) {\n    OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n    oAuth2AuthorizationCode.setCode(code);\n    oAuth2AuthorizationCode.setOAuth2Authentication(RepositoryProviderUtils.convert(oAuth2Authentication));\n    oAuth2AuthorizationCode.setExpiration(new Date(System.currentTimeMillis() + authorizationCodeValidity));\n    oAuth2AuthorizationCode.setCreatedAt(new Date());\n    oAuth2AuthorizationCode.setUpdatedAt(oAuth2AuthorizationCode.getCreatedAt());\n\n    // TODO move to async call\n    authorizationCodeRepository.store(oAuth2AuthorizationCode).subscribe();\n}",
                "name": "store",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "code"
                    },
                    {
                        "type": "OAuth2Authentication",
                        "name": "oAuth2Authentication"
                    }
                ],
                "body": "{\n    OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n    oAuth2AuthorizationCode.setCode(code);\n    oAuth2AuthorizationCode.setOAuth2Authentication(RepositoryProviderUtils.convert(oAuth2Authentication));\n    oAuth2AuthorizationCode.setExpiration(new Date(System.currentTimeMillis() + authorizationCodeValidity));\n    oAuth2AuthorizationCode.setCreatedAt(new Date());\n    oAuth2AuthorizationCode.setUpdatedAt(oAuth2AuthorizationCode.getCreatedAt());\n\n    // TODO move to async call\n    authorizationCodeRepository.store(oAuth2AuthorizationCode).subscribe();\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected OAuth2Authentication remove(String code) {\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication = Optional.ofNullable(authorizationCodeRepository.remove(code).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "name": "remove",
                "modifiers": "@Override\n    protected",
                "return_type": "OAuth2Authentication",
                "parameters": [
                    {
                        "type": "String",
                        "name": "code"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication = Optional.ofNullable(authorizationCodeRepository.remove(code).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/endpoint/RevokeTokenEndpoint.java",
        "definition": "@FrameworkEndpoint\npublic class RevokeTokenEndpoint {\n\n    private ResourceServerTokenServices resourceServerTokenServices;\n\n    private TokenStore tokenStore;\n\n    protected final Logger logger = LoggerFactory.getLogger(RevokeTokenEndpoint.class);\n\n    private WebResponseExceptionTranslator exceptionTranslator = new DefaultWebResponseExceptionTranslator();\n\n    public RevokeTokenEndpoint(TokenStore tokenStore, ResourceServerTokenServices resourceServerTokenServices) {\n        this.tokenStore = tokenStore;\n        this.resourceServerTokenServices = resourceServerTokenServices;\n    }\n\n    /**\n     * @param exceptionTranslator the exception translator to set\n     */\n    public void setExceptionTranslator(WebResponseExceptionTranslator exceptionTranslator) {\n        this.exceptionTranslator = exceptionTranslator;\n    }\n\n    @RequestMapping(value = \"/oauth/revoke\")\n    @ResponseBody\n    public ResponseEntity<Void> revokeToken(\n            @RequestParam(\"token\") String token,\n            @RequestParam(value = \"token_hint\", required = false) final String tokenHint,\n            final Principal principal) {\n        logger.info(\"POST {}, /oauth/revoke; token = {}, tokenHint = {}\", token, tokenHint);\n\n        // Invalid token revocations (token does not exist) still respond\n        // with HTTP 200. Still, log the result anyway for posterity.\n        // See: https://tools.ietf.org/html/rfc7009#section-2.2\n        if (!revokeToken(token, tokenHint, (Authentication) principal)) {\n            logger.debug(\"No token with value {} was revoked.\", token);\n        }\n        return new ResponseEntity<>(HttpStatus.OK);\n    }\n\n    private boolean revokeToken(final String token, final String tokenHint, final Authentication clientAuth) {\n        logger.debug(\"revokeToken; token = {}, tokenHint = {}, clientAuth = {}\", token, tokenHint, clientAuth);\n\n        // Check the refresh_token store first. Fall back to the access token store if we don't\n        // find anything. See RFC 7009, Sec 2.1: https://tools.ietf.org/html/rfc7009#section-2.1\n        if (tokenHint != null && tokenHint.equals(\"refresh_token\")) {\n            return revokeRefreshToken(token, clientAuth) || revokeAccessToken(token, clientAuth);\n        }\n\n        // The user didn't hint that this is a refresh token, so it MAY be an access\n        // token. If we don't find an access token... check if it's a refresh token.\n        return revokeAccessToken(token, clientAuth) || revokeRefreshToken(token, clientAuth);\n    }\n\n    private boolean revokeRefreshToken(final String token, final Authentication clientAuth) {\n        final OAuth2RefreshToken refreshToken = tokenStore.readRefreshToken(token);\n        if (refreshToken != null) {\n            logger.debug(\"Found refresh token {}.\", token);\n            final OAuth2Authentication authToRevoke = tokenStore.readAuthenticationForRefreshToken(refreshToken);\n            checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n            tokenStore.removeAccessTokenUsingRefreshToken(refreshToken);\n            tokenStore.removeRefreshToken(refreshToken);\n            logger.debug(\"Successfully removed refresh token {} (and any associated access token).\", refreshToken);\n            return true;\n        }\n\n        logger.debug(\"No refresh token {} found in the token store.\", token);\n        return false;\n    }\n\n    private boolean revokeAccessToken(final String token, final Authentication clientAuth) {\n        final OAuth2AccessToken accessToken = resourceServerTokenServices.readAccessToken(token);\n        if (accessToken != null) {\n            logger.debug(\"Found access token {}.\", token);\n            final OAuth2Authentication authToRevoke = resourceServerTokenServices.loadAuthentication(token);\n            checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n            if (accessToken.getRefreshToken() != null) {\n                tokenStore.removeRefreshToken(accessToken.getRefreshToken());\n            }\n            tokenStore.removeAccessToken(accessToken);\n            logger.debug(\"Successfully removed access token {} (and any associated refresh token).\", token);\n            return true;\n        }\n\n        logger.debug(\"No access token {} found in the token store.\", token);\n        return false;\n    }\n\n\n    private void checkIfTokenIsIssuedToClient(final Authentication clientAuth,\n                                              final OAuth2Authentication authToRevoke) {\n        final String requestingClientId = clientAuth.getName();\n        final String tokenClientId = authToRevoke.getOAuth2Request().getClientId();\n        if (!requestingClientId.equals(tokenClientId)) {\n            logger.debug(\"Revoke FAILED: requesting client = {}, token's client = {}.\", requestingClientId, tokenClientId);\n            throw new InvalidGrantException(\"Cannot revoke tokens issued to other clients.\");\n        }\n        logger.debug(\"OK to revoke; token is issued to client \\\"{}\\\"\", requestingClientId);\n    }\n\n\n    @ExceptionHandler(InvalidTokenException.class)\n    public ResponseEntity<OAuth2Exception> handleException(Exception e) throws Exception {\n        logger.info(\"Handling error: \" + e.getClass().getSimpleName() + \", \" + e.getMessage());\n        // This isn't an oauth resource, so we don't want to send an\n        // unauthorized code here. The client has already authenticated\n        // successfully with basic auth and should just\n        // get back the invalid token error.\n        @SuppressWarnings(\"serial\")\n        InvalidTokenException e400 = new InvalidTokenException(e.getMessage()) {\n            @Override\n            public int getHttpErrorCode() {\n                return 400;\n            }\n        };\n        return exceptionTranslator.translate(e400);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.endpoint;",
        "tree_path": "RevokeTokenEndpoint",
        "name": "RevokeTokenEndpoint",
        "modifiers": "@FrameworkEndpoint\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private ResourceServerTokenServices resourceServerTokenServices;\n\n    private TokenStore tokenStore;\n\n    protected final Logger logger = LoggerFactory.getLogger(RevokeTokenEndpoint.class);\n\n    private WebResponseExceptionTranslator exceptionTranslator = new DefaultWebResponseExceptionTranslator();\n\n    public RevokeTokenEndpoint(TokenStore tokenStore, ResourceServerTokenServices resourceServerTokenServices) {\n        this.tokenStore = tokenStore;\n        this.resourceServerTokenServices = resourceServerTokenServices;\n    }\n\n    /**\n     * @param exceptionTranslator the exception translator to set\n     */\n    public void setExceptionTranslator(WebResponseExceptionTranslator exceptionTranslator) {\n        this.exceptionTranslator = exceptionTranslator;\n    }\n\n    @RequestMapping(value = \"/oauth/revoke\")\n    @ResponseBody\n    public ResponseEntity<Void> revokeToken(\n            @RequestParam(\"token\") String token,\n            @RequestParam(value = \"token_hint\", required = false) final String tokenHint,\n            final Principal principal) {\n        logger.info(\"POST {}, /oauth/revoke; token = {}, tokenHint = {}\", token, tokenHint);\n\n        // Invalid token revocations (token does not exist) still respond\n        // with HTTP 200. Still, log the result anyway for posterity.\n        // See: https://tools.ietf.org/html/rfc7009#section-2.2\n        if (!revokeToken(token, tokenHint, (Authentication) principal)) {\n            logger.debug(\"No token with value {} was revoked.\", token);\n        }\n        return new ResponseEntity<>(HttpStatus.OK);\n    }\n\n    private boolean revokeToken(final String token, final String tokenHint, final Authentication clientAuth) {\n        logger.debug(\"revokeToken; token = {}, tokenHint = {}, clientAuth = {}\", token, tokenHint, clientAuth);\n\n        // Check the refresh_token store first. Fall back to the access token store if we don't\n        // find anything. See RFC 7009, Sec 2.1: https://tools.ietf.org/html/rfc7009#section-2.1\n        if (tokenHint != null && tokenHint.equals(\"refresh_token\")) {\n            return revokeRefreshToken(token, clientAuth) || revokeAccessToken(token, clientAuth);\n        }\n\n        // The user didn't hint that this is a refresh token, so it MAY be an access\n        // token. If we don't find an access token... check if it's a refresh token.\n        return revokeAccessToken(token, clientAuth) || revokeRefreshToken(token, clientAuth);\n    }\n\n    private boolean revokeRefreshToken(final String token, final Authentication clientAuth) {\n        final OAuth2RefreshToken refreshToken = tokenStore.readRefreshToken(token);\n        if (refreshToken != null) {\n            logger.debug(\"Found refresh token {}.\", token);\n            final OAuth2Authentication authToRevoke = tokenStore.readAuthenticationForRefreshToken(refreshToken);\n            checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n            tokenStore.removeAccessTokenUsingRefreshToken(refreshToken);\n            tokenStore.removeRefreshToken(refreshToken);\n            logger.debug(\"Successfully removed refresh token {} (and any associated access token).\", refreshToken);\n            return true;\n        }\n\n        logger.debug(\"No refresh token {} found in the token store.\", token);\n        return false;\n    }\n\n    private boolean revokeAccessToken(final String token, final Authentication clientAuth) {\n        final OAuth2AccessToken accessToken = resourceServerTokenServices.readAccessToken(token);\n        if (accessToken != null) {\n            logger.debug(\"Found access token {}.\", token);\n            final OAuth2Authentication authToRevoke = resourceServerTokenServices.loadAuthentication(token);\n            checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n            if (accessToken.getRefreshToken() != null) {\n                tokenStore.removeRefreshToken(accessToken.getRefreshToken());\n            }\n            tokenStore.removeAccessToken(accessToken);\n            logger.debug(\"Successfully removed access token {} (and any associated refresh token).\", token);\n            return true;\n        }\n\n        logger.debug(\"No access token {} found in the token store.\", token);\n        return false;\n    }\n\n\n    private void checkIfTokenIsIssuedToClient(final Authentication clientAuth,\n                                              final OAuth2Authentication authToRevoke) {\n        final String requestingClientId = clientAuth.getName();\n        final String tokenClientId = authToRevoke.getOAuth2Request().getClientId();\n        if (!requestingClientId.equals(tokenClientId)) {\n            logger.debug(\"Revoke FAILED: requesting client = {}, token's client = {}.\", requestingClientId, tokenClientId);\n            throw new InvalidGrantException(\"Cannot revoke tokens issued to other clients.\");\n        }\n        logger.debug(\"OK to revoke; token is issued to client \\\"{}\\\"\", requestingClientId);\n    }\n\n\n    @ExceptionHandler(InvalidTokenException.class)\n    public ResponseEntity<OAuth2Exception> handleException(Exception e) throws Exception {\n        logger.info(\"Handling error: \" + e.getClass().getSimpleName() + \", \" + e.getMessage());\n        // This isn't an oauth resource, so we don't want to send an\n        // unauthorized code here. The client has already authenticated\n        // successfully with basic auth and should just\n        // get back the invalid token error.\n        @SuppressWarnings(\"serial\")\n        InvalidTokenException e400 = new InvalidTokenException(e.getMessage()) {\n            @Override\n            public int getHttpErrorCode() {\n                return 400;\n            }\n        };\n        return exceptionTranslator.translate(e400);\n    }\n}",
        "start_point": {
            "row": 44,
            "column": 0
        },
        "end_point": {
            "row": 161,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public RevokeTokenEndpoint(TokenStore tokenStore, ResourceServerTokenServices resourceServerTokenServices) {\n    this.tokenStore = tokenStore;\n    this.resourceServerTokenServices = resourceServerTokenServices;\n}",
                "name": "RevokeTokenEndpoint",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "TokenStore",
                        "name": "tokenStore"
                    },
                    {
                        "type": "ResourceServerTokenServices",
                        "name": "resourceServerTokenServices"
                    }
                ],
                "body": "{\n    this.tokenStore = tokenStore;\n    this.resourceServerTokenServices = resourceServerTokenServices;\n}",
                "constructor": true,
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "public void setExceptionTranslator(WebResponseExceptionTranslator exceptionTranslator) {\n    this.exceptionTranslator = exceptionTranslator;\n}",
                "name": "setExceptionTranslator",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "WebResponseExceptionTranslator",
                        "name": "exceptionTranslator"
                    }
                ],
                "body": "{\n    this.exceptionTranslator = exceptionTranslator;\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/oauth/revoke\")\n@ResponseBody\npublic ResponseEntity<Void> revokeToken(\n        @RequestParam(\"token\") String token,\n        @RequestParam(value = \"token_hint\", required = false) final String tokenHint,\n        final Principal principal) {\n    logger.info(\"POST {}, /oauth/revoke; token = {}, tokenHint = {}\", token, tokenHint);\n\n    // Invalid token revocations (token does not exist) still respond\n    // with HTTP 200. Still, log the result anyway for posterity.\n    // See: https://tools.ietf.org/html/rfc7009#section-2.2\n    if (!revokeToken(token, tokenHint, (Authentication) principal)) {\n        logger.debug(\"No token with value {} was revoked.\", token);\n    }\n    return new ResponseEntity<>(HttpStatus.OK);\n}",
                "name": "revokeToken",
                "modifiers": "@RequestMapping(value = \"/oauth/revoke\")\n    @ResponseBody\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@RequestParam(\"token\")",
                        "name": "String"
                    },
                    {
                        "type": "@RequestParam(value = \"token_hint\", required = false) final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "Principal"
                    }
                ],
                "body": "{\n    logger.info(\"POST {}, /oauth/revoke; token = {}, tokenHint = {}\", token, tokenHint);\n\n    // Invalid token revocations (token does not exist) still respond\n    // with HTTP 200. Still, log the result anyway for posterity.\n    // See: https://tools.ietf.org/html/rfc7009#section-2.2\n    if (!revokeToken(token, tokenHint, (Authentication) principal)) {\n        logger.debug(\"No token with value {} was revoked.\", token);\n    }\n    return new ResponseEntity<>(HttpStatus.OK);\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 82,
                    "column": 5
                }
            },
            {
                "definition": "private boolean revokeToken(final String token, final String tokenHint, final Authentication clientAuth) {\n    logger.debug(\"revokeToken; token = {}, tokenHint = {}, clientAuth = {}\", token, tokenHint, clientAuth);\n\n    // Check the refresh_token store first. Fall back to the access token store if we don't\n    // find anything. See RFC 7009, Sec 2.1: https://tools.ietf.org/html/rfc7009#section-2.1\n    if (tokenHint != null && tokenHint.equals(\"refresh_token\")) {\n        return revokeRefreshToken(token, clientAuth) || revokeAccessToken(token, clientAuth);\n    }\n\n    // The user didn't hint that this is a refresh token, so it MAY be an access\n    // token. If we don't find an access token... check if it's a refresh token.\n    return revokeAccessToken(token, clientAuth) || revokeRefreshToken(token, clientAuth);\n}",
                "name": "revokeToken",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "Authentication"
                    }
                ],
                "body": "{\n    logger.debug(\"revokeToken; token = {}, tokenHint = {}, clientAuth = {}\", token, tokenHint, clientAuth);\n\n    // Check the refresh_token store first. Fall back to the access token store if we don't\n    // find anything. See RFC 7009, Sec 2.1: https://tools.ietf.org/html/rfc7009#section-2.1\n    if (tokenHint != null && tokenHint.equals(\"refresh_token\")) {\n        return revokeRefreshToken(token, clientAuth) || revokeAccessToken(token, clientAuth);\n    }\n\n    // The user didn't hint that this is a refresh token, so it MAY be an access\n    // token. If we don't find an access token... check if it's a refresh token.\n    return revokeAccessToken(token, clientAuth) || revokeRefreshToken(token, clientAuth);\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 96,
                    "column": 5
                }
            },
            {
                "definition": "private boolean revokeRefreshToken(final String token, final Authentication clientAuth) {\n    final OAuth2RefreshToken refreshToken = tokenStore.readRefreshToken(token);\n    if (refreshToken != null) {\n        logger.debug(\"Found refresh token {}.\", token);\n        final OAuth2Authentication authToRevoke = tokenStore.readAuthenticationForRefreshToken(refreshToken);\n        checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n        tokenStore.removeAccessTokenUsingRefreshToken(refreshToken);\n        tokenStore.removeRefreshToken(refreshToken);\n        logger.debug(\"Successfully removed refresh token {} (and any associated access token).\", refreshToken);\n        return true;\n    }\n\n    logger.debug(\"No refresh token {} found in the token store.\", token);\n    return false;\n}",
                "name": "revokeRefreshToken",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "Authentication"
                    }
                ],
                "body": "{\n    final OAuth2RefreshToken refreshToken = tokenStore.readRefreshToken(token);\n    if (refreshToken != null) {\n        logger.debug(\"Found refresh token {}.\", token);\n        final OAuth2Authentication authToRevoke = tokenStore.readAuthenticationForRefreshToken(refreshToken);\n        checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n        tokenStore.removeAccessTokenUsingRefreshToken(refreshToken);\n        tokenStore.removeRefreshToken(refreshToken);\n        logger.debug(\"Successfully removed refresh token {} (and any associated access token).\", refreshToken);\n        return true;\n    }\n\n    logger.debug(\"No refresh token {} found in the token store.\", token);\n    return false;\n}",
                "start_point": {
                    "row": 98,
                    "column": 4
                },
                "end_point": {
                    "row": 112,
                    "column": 5
                }
            },
            {
                "definition": "private boolean revokeAccessToken(final String token, final Authentication clientAuth) {\n    final OAuth2AccessToken accessToken = resourceServerTokenServices.readAccessToken(token);\n    if (accessToken != null) {\n        logger.debug(\"Found access token {}.\", token);\n        final OAuth2Authentication authToRevoke = resourceServerTokenServices.loadAuthentication(token);\n        checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n        if (accessToken.getRefreshToken() != null) {\n            tokenStore.removeRefreshToken(accessToken.getRefreshToken());\n        }\n        tokenStore.removeAccessToken(accessToken);\n        logger.debug(\"Successfully removed access token {} (and any associated refresh token).\", token);\n        return true;\n    }\n\n    logger.debug(\"No access token {} found in the token store.\", token);\n    return false;\n}",
                "name": "revokeAccessToken",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "String"
                    },
                    {
                        "type": "final",
                        "name": "Authentication"
                    }
                ],
                "body": "{\n    final OAuth2AccessToken accessToken = resourceServerTokenServices.readAccessToken(token);\n    if (accessToken != null) {\n        logger.debug(\"Found access token {}.\", token);\n        final OAuth2Authentication authToRevoke = resourceServerTokenServices.loadAuthentication(token);\n        checkIfTokenIsIssuedToClient(clientAuth, authToRevoke);\n        if (accessToken.getRefreshToken() != null) {\n            tokenStore.removeRefreshToken(accessToken.getRefreshToken());\n        }\n        tokenStore.removeAccessToken(accessToken);\n        logger.debug(\"Successfully removed access token {} (and any associated refresh token).\", token);\n        return true;\n    }\n\n    logger.debug(\"No access token {} found in the token store.\", token);\n    return false;\n}",
                "start_point": {
                    "row": 114,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "private void checkIfTokenIsIssuedToClient(final Authentication clientAuth,\n                                          final OAuth2Authentication authToRevoke) {\n    final String requestingClientId = clientAuth.getName();\n    final String tokenClientId = authToRevoke.getOAuth2Request().getClientId();\n    if (!requestingClientId.equals(tokenClientId)) {\n        logger.debug(\"Revoke FAILED: requesting client = {}, token's client = {}.\", requestingClientId, tokenClientId);\n        throw new InvalidGrantException(\"Cannot revoke tokens issued to other clients.\");\n    }\n    logger.debug(\"OK to revoke; token is issued to client \\\"{}\\\"\", requestingClientId);\n}",
                "name": "checkIfTokenIsIssuedToClient",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Authentication"
                    },
                    {
                        "type": "final",
                        "name": "OAuth2Authentication"
                    }
                ],
                "body": "{\n    final String requestingClientId = clientAuth.getName();\n    final String tokenClientId = authToRevoke.getOAuth2Request().getClientId();\n    if (!requestingClientId.equals(tokenClientId)) {\n        logger.debug(\"Revoke FAILED: requesting client = {}, token's client = {}.\", requestingClientId, tokenClientId);\n        throw new InvalidGrantException(\"Cannot revoke tokens issued to other clients.\");\n    }\n    logger.debug(\"OK to revoke; token is issued to client \\\"{}\\\"\", requestingClientId);\n}",
                "start_point": {
                    "row": 133,
                    "column": 4
                },
                "end_point": {
                    "row": 142,
                    "column": 5
                }
            },
            {
                "definition": "@ExceptionHandler(InvalidTokenException.class)\npublic ResponseEntity<OAuth2Exception> handleException(Exception e) throws Exception {\n    logger.info(\"Handling error: \" + e.getClass().getSimpleName() + \", \" + e.getMessage());\n    // This isn't an oauth resource, so we don't want to send an\n    // unauthorized code here. The client has already authenticated\n    // successfully with basic auth and should just\n    // get back the invalid token error.\n    @SuppressWarnings(\"serial\")\n    InvalidTokenException e400 = new InvalidTokenException(e.getMessage()) {\n        @Override\n        public int getHttpErrorCode() {\n            return 400;\n        }\n    };\n    return exceptionTranslator.translate(e400);\n}",
                "name": "handleException",
                "modifiers": "@ExceptionHandler(InvalidTokenException.class)\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Exception",
                        "name": "e"
                    }
                ],
                "body": "{\n    logger.info(\"Handling error: \" + e.getClass().getSimpleName() + \", \" + e.getMessage());\n    // This isn't an oauth resource, so we don't want to send an\n    // unauthorized code here. The client has already authenticated\n    // successfully with basic auth and should just\n    // get back the invalid token error.\n    @SuppressWarnings(\"serial\")\n    InvalidTokenException e400 = new InvalidTokenException(e.getMessage()) {\n        @Override\n        public int getHttpErrorCode() {\n            return 400;\n        }\n    };\n    return exceptionTranslator.translate(e400);\n}",
                "start_point": {
                    "row": 145,
                    "column": 4
                },
                "end_point": {
                    "row": 160,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/endpoint/ScopeApprovalEndpoint.java",
        "definition": "@Controller\n@SessionAttributes(\"authorizationRequest\")\npublic class ScopeApprovalEndpoint {\n\n    private ClientDetailsService clientDetailsService;\n\n    private ApprovalStore approvalStore;\n\n    private DomainScopeService scopeService;\n\n    @RequestMapping(\"/oauth/confirm_access\")\n    public ModelAndView getAccessConfirmation(Map<String, Object> model, HttpServletRequest request, Principal principal) throws Exception {\n        AuthorizationRequest clientAuth = (AuthorizationRequest) model.remove(\"authorizationRequest\");\n        model.put(\"auth_request\", clientAuth);\n        if (request.getAttribute(\"_csrf\") != null) {\n            model.put(\"_csrf\", request.getAttribute(\"_csrf\"));\n        }\n\n\n        ClientDetails client = clientDetailsService.loadClientByClientId(clientAuth.getClientId());\n        model.put(\"client\", client);\n\n        Set<Scope> scopes = scopeService.getAll();\n        Set<ClientScope> requestedScopes = new HashSet<>();\n\n        // Set scopes asked by the client\n        for (String requestScope : clientAuth.getScope()) {\n            scopes\n                    .stream()\n                    .filter(scope -> scope.getKey().equalsIgnoreCase(requestScope))\n                    .distinct()\n                    .forEach(scope -> requestedScopes.add(new ClientScope(scope)));\n        }\n\n        // Get scope approvals\n        for (Approval approval : approvalStore.getApprovals(principal.getName(), client.getClientId())) {\n            if (clientAuth.getScope().contains(approval.getScope())) {\n                requestedScopes\n                        .stream()\n                        .filter(scope -> scope.getKey().equalsIgnoreCase(approval.getScope()))\n                        .distinct()\n                        .forEach(clientScope -> clientScope.setChecked(approval.getStatus() == Approval.ApprovalStatus.APPROVED));\n            }\n        }\n\n        model.put(\"scopes\", requestedScopes);\n        return new ModelAndView(\"access_confirmation\", model);\n    }\n\n    @RequestMapping(\"/oauth/error\")\n    public String handleError(Map<String, Object> model) throws Exception {\n        // We can add more stuff to the model here for JSP rendering. If the client was a machine then\n        // the JSON will already have been rendered.\n        model.put(\"message\", \"There was a problem with the OAuth2 protocol\");\n        return \"access_error\";\n    }\n\n    public void setClientDetailsService(ClientDetailsService clientDetailsService) {\n        this.clientDetailsService = clientDetailsService;\n    }\n\n    public void setApprovalStore(ApprovalStore approvalStore) {\n        this.approvalStore = approvalStore;\n    }\n\n    public void setScopeService(DomainScopeService scopeService) {\n        this.scopeService = scopeService;\n    }\n\n    private static class ClientScope {\n        private String key;\n        private String name;\n        private String description;\n        private boolean checked;\n\n        ClientScope (final Scope scope) {\n            this.key = scope.getKey();\n            this.name = scope.getName();\n            this.description = scope.getDescription();\n        }\n\n        public String getKey() {\n            return key;\n        }\n\n        public void setKey(String key) {\n            this.key = key;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getDescription() {\n            return description;\n        }\n\n        public void setDescription(String description) {\n            this.description = description;\n        }\n\n        public boolean isChecked() {\n            return checked;\n        }\n\n        public void setChecked(boolean checked) {\n            this.checked = checked;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            ClientScope that = (ClientScope) o;\n\n            return key.equals(that.key);\n        }\n\n        @Override\n        public int hashCode() {\n            return key.hashCode();\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.endpoint;",
        "tree_path": "ScopeApprovalEndpoint",
        "name": "ScopeApprovalEndpoint",
        "modifiers": "@Controller\n@SessionAttributes(\"authorizationRequest\")\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private ClientDetailsService clientDetailsService;\n\n    private ApprovalStore approvalStore;\n\n    private DomainScopeService scopeService;\n\n    @RequestMapping(\"/oauth/confirm_access\")\n    public ModelAndView getAccessConfirmation(Map<String, Object> model, HttpServletRequest request, Principal principal) throws Exception {\n        AuthorizationRequest clientAuth = (AuthorizationRequest) model.remove(\"authorizationRequest\");\n        model.put(\"auth_request\", clientAuth);\n        if (request.getAttribute(\"_csrf\") != null) {\n            model.put(\"_csrf\", request.getAttribute(\"_csrf\"));\n        }\n\n\n        ClientDetails client = clientDetailsService.loadClientByClientId(clientAuth.getClientId());\n        model.put(\"client\", client);\n\n        Set<Scope> scopes = scopeService.getAll();\n        Set<ClientScope> requestedScopes = new HashSet<>();\n\n        // Set scopes asked by the client\n        for (String requestScope : clientAuth.getScope()) {\n            scopes\n                    .stream()\n                    .filter(scope -> scope.getKey().equalsIgnoreCase(requestScope))\n                    .distinct()\n                    .forEach(scope -> requestedScopes.add(new ClientScope(scope)));\n        }\n\n        // Get scope approvals\n        for (Approval approval : approvalStore.getApprovals(principal.getName(), client.getClientId())) {\n            if (clientAuth.getScope().contains(approval.getScope())) {\n                requestedScopes\n                        .stream()\n                        .filter(scope -> scope.getKey().equalsIgnoreCase(approval.getScope()))\n                        .distinct()\n                        .forEach(clientScope -> clientScope.setChecked(approval.getStatus() == Approval.ApprovalStatus.APPROVED));\n            }\n        }\n\n        model.put(\"scopes\", requestedScopes);\n        return new ModelAndView(\"access_confirmation\", model);\n    }\n\n    @RequestMapping(\"/oauth/error\")\n    public String handleError(Map<String, Object> model) throws Exception {\n        // We can add more stuff to the model here for JSP rendering. If the client was a machine then\n        // the JSON will already have been rendered.\n        model.put(\"message\", \"There was a problem with the OAuth2 protocol\");\n        return \"access_error\";\n    }\n\n    public void setClientDetailsService(ClientDetailsService clientDetailsService) {\n        this.clientDetailsService = clientDetailsService;\n    }\n\n    public void setApprovalStore(ApprovalStore approvalStore) {\n        this.approvalStore = approvalStore;\n    }\n\n    public void setScopeService(DomainScopeService scopeService) {\n        this.scopeService = scopeService;\n    }\n\n    private static class ClientScope {\n        private String key;\n        private String name;\n        private String description;\n        private boolean checked;\n\n        ClientScope (final Scope scope) {\n            this.key = scope.getKey();\n            this.name = scope.getName();\n            this.description = scope.getDescription();\n        }\n\n        public String getKey() {\n            return key;\n        }\n\n        public void setKey(String key) {\n            this.key = key;\n        }\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getDescription() {\n            return description;\n        }\n\n        public void setDescription(String description) {\n            this.description = description;\n        }\n\n        public boolean isChecked() {\n            return checked;\n        }\n\n        public void setChecked(boolean checked) {\n            this.checked = checked;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            ClientScope that = (ClientScope) o;\n\n            return key.equals(that.key);\n        }\n\n        @Override\n        public int hashCode() {\n            return key.hashCode();\n        }\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 167,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@RequestMapping(\"/oauth/confirm_access\")\npublic ModelAndView getAccessConfirmation(Map<String, Object> model, HttpServletRequest request, Principal principal) throws Exception {\n    AuthorizationRequest clientAuth = (AuthorizationRequest) model.remove(\"authorizationRequest\");\n    model.put(\"auth_request\", clientAuth);\n    if (request.getAttribute(\"_csrf\") != null) {\n        model.put(\"_csrf\", request.getAttribute(\"_csrf\"));\n    }\n\n\n    ClientDetails client = clientDetailsService.loadClientByClientId(clientAuth.getClientId());\n    model.put(\"client\", client);\n\n    Set<Scope> scopes = scopeService.getAll();\n    Set<ClientScope> requestedScopes = new HashSet<>();\n\n    // Set scopes asked by the client\n    for (String requestScope : clientAuth.getScope()) {\n        scopes\n                .stream()\n                .filter(scope -> scope.getKey().equalsIgnoreCase(requestScope))\n                .distinct()\n                .forEach(scope -> requestedScopes.add(new ClientScope(scope)));\n    }\n\n    // Get scope approvals\n    for (Approval approval : approvalStore.getApprovals(principal.getName(), client.getClientId())) {\n        if (clientAuth.getScope().contains(approval.getScope())) {\n            requestedScopes\n                    .stream()\n                    .filter(scope -> scope.getKey().equalsIgnoreCase(approval.getScope()))\n                    .distinct()\n                    .forEach(clientScope -> clientScope.setChecked(approval.getStatus() == Approval.ApprovalStatus.APPROVED));\n        }\n    }\n\n    model.put(\"scopes\", requestedScopes);\n    return new ModelAndView(\"access_confirmation\", model);\n}",
                "name": "getAccessConfirmation",
                "modifiers": "@RequestMapping(\"/oauth/confirm_access\")\n    public",
                "return_type": "ModelAndView",
                "parameters": [
                    {
                        "type": "Map<String, Object>",
                        "name": "model"
                    },
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "Principal",
                        "name": "principal"
                    }
                ],
                "body": "{\n    AuthorizationRequest clientAuth = (AuthorizationRequest) model.remove(\"authorizationRequest\");\n    model.put(\"auth_request\", clientAuth);\n    if (request.getAttribute(\"_csrf\") != null) {\n        model.put(\"_csrf\", request.getAttribute(\"_csrf\"));\n    }\n\n\n    ClientDetails client = clientDetailsService.loadClientByClientId(clientAuth.getClientId());\n    model.put(\"client\", client);\n\n    Set<Scope> scopes = scopeService.getAll();\n    Set<ClientScope> requestedScopes = new HashSet<>();\n\n    // Set scopes asked by the client\n    for (String requestScope : clientAuth.getScope()) {\n        scopes\n                .stream()\n                .filter(scope -> scope.getKey().equalsIgnoreCase(requestScope))\n                .distinct()\n                .forEach(scope -> requestedScopes.add(new ClientScope(scope)));\n    }\n\n    // Get scope approvals\n    for (Approval approval : approvalStore.getApprovals(principal.getName(), client.getClientId())) {\n        if (clientAuth.getScope().contains(approval.getScope())) {\n            requestedScopes\n                    .stream()\n                    .filter(scope -> scope.getKey().equalsIgnoreCase(approval.getScope()))\n                    .distinct()\n                    .forEach(clientScope -> clientScope.setChecked(approval.getStatus() == Approval.ApprovalStatus.APPROVED));\n        }\n    }\n\n    model.put(\"scopes\", requestedScopes);\n    return new ModelAndView(\"access_confirmation\", model);\n}",
                "start_point": {
                    "row": 49,
                    "column": 4
                },
                "end_point": {
                    "row": 86,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(\"/oauth/error\")\npublic String handleError(Map<String, Object> model) throws Exception {\n    // We can add more stuff to the model here for JSP rendering. If the client was a machine then\n    // the JSON will already have been rendered.\n    model.put(\"message\", \"There was a problem with the OAuth2 protocol\");\n    return \"access_error\";\n}",
                "name": "handleError",
                "modifiers": "@RequestMapping(\"/oauth/error\")\n    public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "Map<String, Object>",
                        "name": "model"
                    }
                ],
                "body": "{\n    // We can add more stuff to the model here for JSP rendering. If the client was a machine then\n    // the JSON will already have been rendered.\n    model.put(\"message\", \"There was a problem with the OAuth2 protocol\");\n    return \"access_error\";\n}",
                "start_point": {
                    "row": 88,
                    "column": 4
                },
                "end_point": {
                    "row": 94,
                    "column": 5
                }
            },
            {
                "definition": "public void setClientDetailsService(ClientDetailsService clientDetailsService) {\n    this.clientDetailsService = clientDetailsService;\n}",
                "name": "setClientDetailsService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ClientDetailsService",
                        "name": "clientDetailsService"
                    }
                ],
                "body": "{\n    this.clientDetailsService = clientDetailsService;\n}",
                "start_point": {
                    "row": 96,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            },
            {
                "definition": "public void setApprovalStore(ApprovalStore approvalStore) {\n    this.approvalStore = approvalStore;\n}",
                "name": "setApprovalStore",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ApprovalStore",
                        "name": "approvalStore"
                    }
                ],
                "body": "{\n    this.approvalStore = approvalStore;\n}",
                "start_point": {
                    "row": 100,
                    "column": 4
                },
                "end_point": {
                    "row": 102,
                    "column": 5
                }
            },
            {
                "definition": "public void setScopeService(DomainScopeService scopeService) {\n    this.scopeService = scopeService;\n}",
                "name": "setScopeService",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "DomainScopeService",
                        "name": "scopeService"
                    }
                ],
                "body": "{\n    this.scopeService = scopeService;\n}",
                "start_point": {
                    "row": 104,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/endpoint/ScopeApprovalEndpoint.java",
        "definition": "private static class ClientScope {\n    private String key;\n    private String name;\n    private String description;\n    private boolean checked;\n\n    ClientScope (final Scope scope) {\n        this.key = scope.getKey();\n        this.name = scope.getName();\n        this.description = scope.getDescription();\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isChecked() {\n        return checked;\n    }\n\n    public void setChecked(boolean checked) {\n        this.checked = checked;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        ClientScope that = (ClientScope) o;\n\n        return key.equals(that.key);\n    }\n\n    @Override\n    public int hashCode() {\n        return key.hashCode();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.endpoint;",
        "tree_path": "ScopeApprovalEndpoint.ClientScope",
        "name": "ClientScope",
        "modifiers": "private static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    private String key;\n    private String name;\n    private String description;\n    private boolean checked;\n\n    ClientScope (final Scope scope) {\n        this.key = scope.getKey();\n        this.name = scope.getName();\n        this.description = scope.getDescription();\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    public boolean isChecked() {\n        return checked;\n    }\n\n    public void setChecked(boolean checked) {\n        this.checked = checked;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        ClientScope that = (ClientScope) o;\n\n        return key.equals(that.key);\n    }\n\n    @Override\n    public int hashCode() {\n        return key.hashCode();\n    }\n}",
        "start_point": {
            "row": 108,
            "column": 4
        },
        "end_point": {
            "row": 166,
            "column": 5
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "ClientScope (final Scope scope) {\n    this.key = scope.getKey();\n    this.name = scope.getName();\n    this.description = scope.getDescription();\n}",
                "name": "ClientScope",
                "modifiers": null,
                "parameters": [
                    {
                        "type": "final",
                        "name": "Scope"
                    }
                ],
                "body": "{\n    this.key = scope.getKey();\n    this.name = scope.getName();\n    this.description = scope.getDescription();\n}",
                "constructor": true,
                "start_point": {
                    "row": 114,
                    "column": 8
                },
                "end_point": {
                    "row": 118,
                    "column": 9
                }
            },
            {
                "definition": "public String getKey() {\n    return key;\n}",
                "name": "getKey",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return key;\n}",
                "start_point": {
                    "row": 120,
                    "column": 8
                },
                "end_point": {
                    "row": 122,
                    "column": 9
                }
            },
            {
                "definition": "public void setKey(String key) {\n    this.key = key;\n}",
                "name": "setKey",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "key"
                    }
                ],
                "body": "{\n    this.key = key;\n}",
                "start_point": {
                    "row": 124,
                    "column": 8
                },
                "end_point": {
                    "row": 126,
                    "column": 9
                }
            },
            {
                "definition": "public String getName() {\n    return name;\n}",
                "name": "getName",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return name;\n}",
                "start_point": {
                    "row": 128,
                    "column": 8
                },
                "end_point": {
                    "row": 130,
                    "column": 9
                }
            },
            {
                "definition": "public void setName(String name) {\n    this.name = name;\n}",
                "name": "setName",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "name"
                    }
                ],
                "body": "{\n    this.name = name;\n}",
                "start_point": {
                    "row": 132,
                    "column": 8
                },
                "end_point": {
                    "row": 134,
                    "column": 9
                }
            },
            {
                "definition": "public String getDescription() {\n    return description;\n}",
                "name": "getDescription",
                "modifiers": "public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return description;\n}",
                "start_point": {
                    "row": 136,
                    "column": 8
                },
                "end_point": {
                    "row": 138,
                    "column": 9
                }
            },
            {
                "definition": "public void setDescription(String description) {\n    this.description = description;\n}",
                "name": "setDescription",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "description"
                    }
                ],
                "body": "{\n    this.description = description;\n}",
                "start_point": {
                    "row": 140,
                    "column": 8
                },
                "end_point": {
                    "row": 142,
                    "column": 9
                }
            },
            {
                "definition": "public boolean isChecked() {\n    return checked;\n}",
                "name": "isChecked",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return checked;\n}",
                "start_point": {
                    "row": 144,
                    "column": 8
                },
                "end_point": {
                    "row": 146,
                    "column": 9
                }
            },
            {
                "definition": "public void setChecked(boolean checked) {\n    this.checked = checked;\n}",
                "name": "setChecked",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "checked"
                    }
                ],
                "body": "{\n    this.checked = checked;\n}",
                "start_point": {
                    "row": 148,
                    "column": 8
                },
                "end_point": {
                    "row": 150,
                    "column": 9
                }
            },
            {
                "definition": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    ClientScope that = (ClientScope) o;\n\n    return key.equals(that.key);\n}",
                "name": "equals",
                "modifiers": "@Override\n        public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Object",
                        "name": "o"
                    }
                ],
                "body": "{\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    ClientScope that = (ClientScope) o;\n\n    return key.equals(that.key);\n}",
                "start_point": {
                    "row": 152,
                    "column": 8
                },
                "end_point": {
                    "row": 160,
                    "column": 9
                }
            },
            {
                "definition": "@Override\npublic int hashCode() {\n    return key.hashCode();\n}",
                "name": "hashCode",
                "modifiers": "@Override\n        public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return key.hashCode();\n}",
                "start_point": {
                    "row": 162,
                    "column": 8
                },
                "end_point": {
                    "row": 165,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/endpoint/TokenIntrospectEndpoint.java",
        "definition": "public class TokenIntrospectEndpoint {\n    private ResourceServerTokenServices resourceServerTokenServices;\n    private AccessTokenConverter accessTokenConverter = new DefaultIntrospectionAccessTokenConverter();\n\n    protected final Logger logger = LoggerFactory.getLogger(TokenIntrospectEndpoint.class);\n\n    public TokenIntrospectEndpoint(ResourceServerTokenServices resourceServerTokenServices) {\n        this.resourceServerTokenServices = resourceServerTokenServices;\n    }\n\n    /**\n     * @param accessTokenConverter the accessTokenConverter to set\n     */\n    public void setAccessTokenConverter(AccessTokenConverter accessTokenConverter) {\n        this.accessTokenConverter = accessTokenConverter;\n    }\n\n    @RequestMapping(value = \"/introspect\")\n    @ResponseBody\n    public Map<String, ?> introspectToken(@RequestParam(\"token\") String value,\n                                          @RequestParam(value = \"resource_id\", required = false) String resourceId,\n                                          @RequestParam(value = \"token_type_hint\", required = false) String tokenType) {\n\n        OAuth2AccessToken token = resourceServerTokenServices.readAccessToken(value);\n        if (token == null || token.isExpired()) {\n            Map<String, Object> response = new HashMap<>();\n            response.put(\"active\",false);\n            return response;\n        }\n\n        OAuth2Authentication authentication = resourceServerTokenServices.loadAuthentication(token.getValue());\n\n        return accessTokenConverter.convertAccessToken(token, authentication);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.endpoint;",
        "tree_path": "TokenIntrospectEndpoint",
        "name": "TokenIntrospectEndpoint",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n    private ResourceServerTokenServices resourceServerTokenServices;\n    private AccessTokenConverter accessTokenConverter = new DefaultIntrospectionAccessTokenConverter();\n\n    protected final Logger logger = LoggerFactory.getLogger(TokenIntrospectEndpoint.class);\n\n    public TokenIntrospectEndpoint(ResourceServerTokenServices resourceServerTokenServices) {\n        this.resourceServerTokenServices = resourceServerTokenServices;\n    }\n\n    /**\n     * @param accessTokenConverter the accessTokenConverter to set\n     */\n    public void setAccessTokenConverter(AccessTokenConverter accessTokenConverter) {\n        this.accessTokenConverter = accessTokenConverter;\n    }\n\n    @RequestMapping(value = \"/introspect\")\n    @ResponseBody\n    public Map<String, ?> introspectToken(@RequestParam(\"token\") String value,\n                                          @RequestParam(value = \"resource_id\", required = false) String resourceId,\n                                          @RequestParam(value = \"token_type_hint\", required = false) String tokenType) {\n\n        OAuth2AccessToken token = resourceServerTokenServices.readAccessToken(value);\n        if (token == null || token.isExpired()) {\n            Map<String, Object> response = new HashMap<>();\n            response.put(\"active\",false);\n            return response;\n        }\n\n        OAuth2Authentication authentication = resourceServerTokenServices.loadAuthentication(token.getValue());\n\n        return accessTokenConverter.convertAccessToken(token, authentication);\n    }\n}",
        "start_point": {
            "row": 36,
            "column": 0
        },
        "end_point": {
            "row": 70,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public TokenIntrospectEndpoint(ResourceServerTokenServices resourceServerTokenServices) {\n    this.resourceServerTokenServices = resourceServerTokenServices;\n}",
                "name": "TokenIntrospectEndpoint",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "ResourceServerTokenServices",
                        "name": "resourceServerTokenServices"
                    }
                ],
                "body": "{\n    this.resourceServerTokenServices = resourceServerTokenServices;\n}",
                "constructor": true,
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            },
            {
                "definition": "public void setAccessTokenConverter(AccessTokenConverter accessTokenConverter) {\n    this.accessTokenConverter = accessTokenConverter;\n}",
                "name": "setAccessTokenConverter",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AccessTokenConverter",
                        "name": "accessTokenConverter"
                    }
                ],
                "body": "{\n    this.accessTokenConverter = accessTokenConverter;\n}",
                "start_point": {
                    "row": 49,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/introspect\")\n@ResponseBody\npublic Map<String, ?> introspectToken(@RequestParam(\"token\") String value,\n                                      @RequestParam(value = \"resource_id\", required = false) String resourceId,\n                                      @RequestParam(value = \"token_type_hint\", required = false) String tokenType) {\n\n    OAuth2AccessToken token = resourceServerTokenServices.readAccessToken(value);\n    if (token == null || token.isExpired()) {\n        Map<String, Object> response = new HashMap<>();\n        response.put(\"active\",false);\n        return response;\n    }\n\n    OAuth2Authentication authentication = resourceServerTokenServices.loadAuthentication(token.getValue());\n\n    return accessTokenConverter.convertAccessToken(token, authentication);\n}",
                "name": "introspectToken",
                "modifiers": "@RequestMapping(value = \"/introspect\")\n    @ResponseBody\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "@RequestParam(\"token\")",
                        "name": "String"
                    },
                    {
                        "type": "@RequestParam(value = \"resource_id\", required = false)",
                        "name": "String"
                    },
                    {
                        "type": "@RequestParam(value = \"token_type_hint\", required = false)",
                        "name": "String"
                    }
                ],
                "body": "{\n\n    OAuth2AccessToken token = resourceServerTokenServices.readAccessToken(value);\n    if (token == null || token.isExpired()) {\n        Map<String, Object> response = new HashMap<>();\n        response.put(\"active\",false);\n        return response;\n    }\n\n    OAuth2Authentication authentication = resourceServerTokenServices.loadAuthentication(token.getValue());\n\n    return accessTokenConverter.convertAccessToken(token, authentication);\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 69,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/endpoint/UserInfoEndpoint.java",
        "definition": "@Controller\n@RequestMapping(\"/userinfo\")\npublic class UserInfoEndpoint {\n\n    private final Logger logger = LoggerFactory.getLogger(UserInfoEndpoint.class);\n\n    @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    @ResponseBody\n    public Object loginInfo(OAuth2Authentication oAuth2Authentication) {\n        if (oAuth2Authentication == null) {\n            return null;\n        }\n\n        try {\n            User user = (User) oAuth2Authentication.getUserAuthentication().getPrincipal();\n            return user.getAdditionalInformation();\n        } catch (Exception e) {\n            logger.warn(\"Failed to get user profile information, fallback to default user authentication\", e);\n            return oAuth2Authentication.getUserAuthentication().getPrincipal();\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.endpoint;",
        "tree_path": "UserInfoEndpoint",
        "name": "UserInfoEndpoint",
        "modifiers": "@Controller\n@RequestMapping(\"/userinfo\")\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(UserInfoEndpoint.class);\n\n    @RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    @ResponseBody\n    public Object loginInfo(OAuth2Authentication oAuth2Authentication) {\n        if (oAuth2Authentication == null) {\n            return null;\n        }\n\n        try {\n            User user = (User) oAuth2Authentication.getUserAuthentication().getPrincipal();\n            return user.getAdditionalInformation();\n        } catch (Exception e) {\n            logger.warn(\"Failed to get user profile information, fallback to default user authentication\", e);\n            return oAuth2Authentication.getUserAuthentication().getPrincipal();\n        }\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 51,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n@ResponseBody\npublic Object loginInfo(OAuth2Authentication oAuth2Authentication) {\n    if (oAuth2Authentication == null) {\n        return null;\n    }\n\n    try {\n        User user = (User) oAuth2Authentication.getUserAuthentication().getPrincipal();\n        return user.getAdditionalInformation();\n    } catch (Exception e) {\n        logger.warn(\"Failed to get user profile information, fallback to default user authentication\", e);\n        return oAuth2Authentication.getUserAuthentication().getPrincipal();\n    }\n}",
                "name": "loginInfo",
                "modifiers": "@RequestMapping(method = {RequestMethod.GET, RequestMethod.POST})\n    @ResponseBody\n    public",
                "return_type": "Object",
                "parameters": [
                    {
                        "type": "OAuth2Authentication",
                        "name": "oAuth2Authentication"
                    }
                ],
                "body": "{\n    if (oAuth2Authentication == null) {\n        return null;\n    }\n\n    try {\n        User user = (User) oAuth2Authentication.getUserAuthentication().getPrincipal();\n        return user.getAdditionalInformation();\n    } catch (Exception e) {\n        logger.warn(\"Failed to get user profile information, fallback to default user authentication\", e);\n        return oAuth2Authentication.getUserAuthentication().getPrincipal();\n    }\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 50,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/jwt/CustomTokenEnhancer.java",
        "definition": "public class CustomTokenEnhancer implements InitializingBean, TokenEnhancer {\n\n    @Value(\"${oidc.iss:http://gravitee.am}\")\n    private String iss;\n\n    @Autowired\n    private KeyPair keyPair;\n\n    @Autowired\n    private ClientDetailsService clientService;\n\n    @Autowired\n    private CertificateManager certificateManager;\n\n    @Autowired\n    private RoleService roleService;\n\n    private Signer signer;\n\n    private JsonParser objectMapper = JsonParserFactory.create();\n\n    private ClientDetails clientDetails;\n\n    private static final int defaultIDTokenExpireIn = 14400;\n\n    private static final String OPEN_ID = \"openid\";\n\n    private static final String ID_TOKEN = \"id_token\";\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        PrivateKey privateKey = keyPair.getPrivate();\n        signer = new RsaSigner((RSAPrivateKey) privateKey);\n    }\n\n    @Override\n    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        // fetch client details\n        setClientDetails(authentication.getOAuth2Request().getClientId());\n\n        // enhance token scopes\n        enhanceTokenScopes(accessToken, authentication);\n\n        // enhance token with ID token\n        if (authentication.getOAuth2Request().getScope() != null && authentication.getOAuth2Request().getScope().contains(OPEN_ID)) {\n            enhance0(accessToken, authentication);\n        }\n\n        return accessToken;\n    }\n\n    private OAuth2AccessToken enhance0(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        // create ID token\n        Map<String, Object> IDToken = new HashMap<>();\n        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n        IDToken.put(OIDCClaims.iss, iss);\n        IDToken.put(OIDCClaims.sub, authentication.isClientOnly() ? ((String) authentication.getPrincipal()) : authentication.getName());\n        IDToken.put(OIDCClaims.aud, authentication.getOAuth2Request().getClientId());\n        IDToken.put(OIDCClaims.iat, calendar.getTimeInMillis() / 1000l);\n        calendar.add(Calendar.SECOND, defaultIDTokenExpireIn);\n        IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n\n        // enhance ID token with OAuth client information\n        CertificateProvider certificateProvider = null;\n        if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n            Client client = ((DelegateClientDetails) clientDetails).getClient();\n            calendar.setTimeInMillis((long) IDToken.get(OIDCClaims.iat) * 1000l);\n            calendar.add(Calendar.SECOND, client.getIdTokenValiditySeconds());\n            IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n            // we only override claims for an end-user (grant_type != client_credentials)\n            if (!authentication.isClientOnly()\n                    && client.getIdTokenCustomClaims() != null\n                    && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n                // retrieve user attributes\n                User user = (User) authentication.getUserAuthentication().getPrincipal();\n                if (user.getAdditionalInformation() != null && !user.getAdditionalInformation().isEmpty()) {\n                    final Map<String, Object> userAdditionalInformation = user.getAdditionalInformation();\n                    client.getIdTokenCustomClaims().forEach((key, value) -> {\n                        if (userAdditionalInformation.get(value) != null) {\n                            IDToken.put(key, userAdditionalInformation.get(value));\n                        }\n                    });\n                }\n            }\n            // get client certificate provider if any\n            if (client.getCertificate() != null) {\n                certificateProvider = certificateManager.get(client.getCertificate());\n            }\n        }\n\n        // generate ID Token payload\n        String payload = objectMapper.formatMap(IDToken);\n\n        // encode ID Token\n        if (certificateProvider != null) {\n            payload = certificateProvider.sign(payload);\n        } else {\n            // default encoding\n            payload = JwtHelper.encode(payload, signer).getEncoded();\n        }\n\n        // enhance access token\n        Map<String, Object> additionalInformation = new HashMap<>(accessToken.getAdditionalInformation());\n        additionalInformation.put(ID_TOKEN, payload);\n        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInformation);\n\n        return accessToken;\n    }\n\n    private void setClientDetails(String clientId) {\n        try {\n            clientDetails = clientService.loadClientByClientId(clientId);\n        } catch (Exception ex) {\n        }\n    }\n\n    private OAuth2AccessToken enhanceTokenScopes(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        // enhance token scopes with user permissions\n        if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n            Client client = ((DelegateClientDetails) clientDetails).getClient();\n            if (!authentication.isClientOnly()\n                    && client.isEnhanceScopesWithUserPermissions()\n                    && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n                User user = (User) authentication.getUserAuthentication().getPrincipal();\n                if (user.getRoles() != null && !user.getRoles().isEmpty()) {\n                    // TODO async call\n                    Set<Role> roles = roleService.findByIdIn(user.getRoles()).blockingGet();\n                    Set<String> requestedScopes = OAuth2Utils.parseParameterList(authentication.getOAuth2Request().getRequestParameters().get(OAuth2Utils.SCOPE));\n                    Set<String> enhanceScopes = new HashSet<>(accessToken.getScope());\n                    enhanceScopes.addAll(roles.stream()\n                            .map(r -> r.getPermissions())\n                            .flatMap(List::stream)\n                            .filter(permission -> {\n                                if (requestedScopes != null && !requestedScopes.isEmpty()) {\n                                    return requestedScopes.contains(permission);\n                                }\n                                // if no query param scope, accept all enhance scopes\n                                return true;\n                            })\n                            .collect(Collectors.toList()));\n                    ((DefaultOAuth2AccessToken) accessToken).setScope(enhanceScopes);\n                }\n            }\n        }\n\n        return accessToken;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.jwt;",
        "tree_path": "CustomTokenEnhancer",
        "name": "CustomTokenEnhancer",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements InitializingBean, TokenEnhancer",
        "body": "{\n\n    @Value(\"${oidc.iss:http://gravitee.am}\")\n    private String iss;\n\n    @Autowired\n    private KeyPair keyPair;\n\n    @Autowired\n    private ClientDetailsService clientService;\n\n    @Autowired\n    private CertificateManager certificateManager;\n\n    @Autowired\n    private RoleService roleService;\n\n    private Signer signer;\n\n    private JsonParser objectMapper = JsonParserFactory.create();\n\n    private ClientDetails clientDetails;\n\n    private static final int defaultIDTokenExpireIn = 14400;\n\n    private static final String OPEN_ID = \"openid\";\n\n    private static final String ID_TOKEN = \"id_token\";\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        PrivateKey privateKey = keyPair.getPrivate();\n        signer = new RsaSigner((RSAPrivateKey) privateKey);\n    }\n\n    @Override\n    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        // fetch client details\n        setClientDetails(authentication.getOAuth2Request().getClientId());\n\n        // enhance token scopes\n        enhanceTokenScopes(accessToken, authentication);\n\n        // enhance token with ID token\n        if (authentication.getOAuth2Request().getScope() != null && authentication.getOAuth2Request().getScope().contains(OPEN_ID)) {\n            enhance0(accessToken, authentication);\n        }\n\n        return accessToken;\n    }\n\n    private OAuth2AccessToken enhance0(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        // create ID token\n        Map<String, Object> IDToken = new HashMap<>();\n        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n        IDToken.put(OIDCClaims.iss, iss);\n        IDToken.put(OIDCClaims.sub, authentication.isClientOnly() ? ((String) authentication.getPrincipal()) : authentication.getName());\n        IDToken.put(OIDCClaims.aud, authentication.getOAuth2Request().getClientId());\n        IDToken.put(OIDCClaims.iat, calendar.getTimeInMillis() / 1000l);\n        calendar.add(Calendar.SECOND, defaultIDTokenExpireIn);\n        IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n\n        // enhance ID token with OAuth client information\n        CertificateProvider certificateProvider = null;\n        if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n            Client client = ((DelegateClientDetails) clientDetails).getClient();\n            calendar.setTimeInMillis((long) IDToken.get(OIDCClaims.iat) * 1000l);\n            calendar.add(Calendar.SECOND, client.getIdTokenValiditySeconds());\n            IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n            // we only override claims for an end-user (grant_type != client_credentials)\n            if (!authentication.isClientOnly()\n                    && client.getIdTokenCustomClaims() != null\n                    && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n                // retrieve user attributes\n                User user = (User) authentication.getUserAuthentication().getPrincipal();\n                if (user.getAdditionalInformation() != null && !user.getAdditionalInformation().isEmpty()) {\n                    final Map<String, Object> userAdditionalInformation = user.getAdditionalInformation();\n                    client.getIdTokenCustomClaims().forEach((key, value) -> {\n                        if (userAdditionalInformation.get(value) != null) {\n                            IDToken.put(key, userAdditionalInformation.get(value));\n                        }\n                    });\n                }\n            }\n            // get client certificate provider if any\n            if (client.getCertificate() != null) {\n                certificateProvider = certificateManager.get(client.getCertificate());\n            }\n        }\n\n        // generate ID Token payload\n        String payload = objectMapper.formatMap(IDToken);\n\n        // encode ID Token\n        if (certificateProvider != null) {\n            payload = certificateProvider.sign(payload);\n        } else {\n            // default encoding\n            payload = JwtHelper.encode(payload, signer).getEncoded();\n        }\n\n        // enhance access token\n        Map<String, Object> additionalInformation = new HashMap<>(accessToken.getAdditionalInformation());\n        additionalInformation.put(ID_TOKEN, payload);\n        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInformation);\n\n        return accessToken;\n    }\n\n    private void setClientDetails(String clientId) {\n        try {\n            clientDetails = clientService.loadClientByClientId(clientId);\n        } catch (Exception ex) {\n        }\n    }\n\n    private OAuth2AccessToken enhanceTokenScopes(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n        // enhance token scopes with user permissions\n        if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n            Client client = ((DelegateClientDetails) clientDetails).getClient();\n            if (!authentication.isClientOnly()\n                    && client.isEnhanceScopesWithUserPermissions()\n                    && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n                User user = (User) authentication.getUserAuthentication().getPrincipal();\n                if (user.getRoles() != null && !user.getRoles().isEmpty()) {\n                    // TODO async call\n                    Set<Role> roles = roleService.findByIdIn(user.getRoles()).blockingGet();\n                    Set<String> requestedScopes = OAuth2Utils.parseParameterList(authentication.getOAuth2Request().getRequestParameters().get(OAuth2Utils.SCOPE));\n                    Set<String> enhanceScopes = new HashSet<>(accessToken.getScope());\n                    enhanceScopes.addAll(roles.stream()\n                            .map(r -> r.getPermissions())\n                            .flatMap(List::stream)\n                            .filter(permission -> {\n                                if (requestedScopes != null && !requestedScopes.isEmpty()) {\n                                    return requestedScopes.contains(permission);\n                                }\n                                // if no query param scope, accept all enhance scopes\n                                return true;\n                            })\n                            .collect(Collectors.toList()));\n                    ((DefaultOAuth2AccessToken) accessToken).setScope(enhanceScopes);\n                }\n            }\n        }\n\n        return accessToken;\n    }\n}",
        "start_point": {
            "row": 52,
            "column": 0
        },
        "end_point": {
            "row": 199,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic void afterPropertiesSet() throws Exception {\n    PrivateKey privateKey = keyPair.getPrivate();\n    signer = new RsaSigner((RSAPrivateKey) privateKey);\n}",
                "name": "afterPropertiesSet",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    PrivateKey privateKey = keyPair.getPrivate();\n    signer = new RsaSigner((RSAPrivateKey) privateKey);\n}",
                "start_point": {
                    "row": 81,
                    "column": 4
                },
                "end_point": {
                    "row": 85,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n    // fetch client details\n    setClientDetails(authentication.getOAuth2Request().getClientId());\n\n    // enhance token scopes\n    enhanceTokenScopes(accessToken, authentication);\n\n    // enhance token with ID token\n    if (authentication.getOAuth2Request().getScope() != null && authentication.getOAuth2Request().getScope().contains(OPEN_ID)) {\n        enhance0(accessToken, authentication);\n    }\n\n    return accessToken;\n}",
                "name": "enhance",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2AccessToken",
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "accessToken"
                    },
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    // fetch client details\n    setClientDetails(authentication.getOAuth2Request().getClientId());\n\n    // enhance token scopes\n    enhanceTokenScopes(accessToken, authentication);\n\n    // enhance token with ID token\n    if (authentication.getOAuth2Request().getScope() != null && authentication.getOAuth2Request().getScope().contains(OPEN_ID)) {\n        enhance0(accessToken, authentication);\n    }\n\n    return accessToken;\n}",
                "start_point": {
                    "row": 87,
                    "column": 4
                },
                "end_point": {
                    "row": 101,
                    "column": 5
                }
            },
            {
                "definition": "private OAuth2AccessToken enhance0(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n    // create ID token\n    Map<String, Object> IDToken = new HashMap<>();\n    Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n    IDToken.put(OIDCClaims.iss, iss);\n    IDToken.put(OIDCClaims.sub, authentication.isClientOnly() ? ((String) authentication.getPrincipal()) : authentication.getName());\n    IDToken.put(OIDCClaims.aud, authentication.getOAuth2Request().getClientId());\n    IDToken.put(OIDCClaims.iat, calendar.getTimeInMillis() / 1000l);\n    calendar.add(Calendar.SECOND, defaultIDTokenExpireIn);\n    IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n\n    // enhance ID token with OAuth client information\n    CertificateProvider certificateProvider = null;\n    if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n        Client client = ((DelegateClientDetails) clientDetails).getClient();\n        calendar.setTimeInMillis((long) IDToken.get(OIDCClaims.iat) * 1000l);\n        calendar.add(Calendar.SECOND, client.getIdTokenValiditySeconds());\n        IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n        // we only override claims for an end-user (grant_type != client_credentials)\n        if (!authentication.isClientOnly()\n                && client.getIdTokenCustomClaims() != null\n                && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n            // retrieve user attributes\n            User user = (User) authentication.getUserAuthentication().getPrincipal();\n            if (user.getAdditionalInformation() != null && !user.getAdditionalInformation().isEmpty()) {\n                final Map<String, Object> userAdditionalInformation = user.getAdditionalInformation();\n                client.getIdTokenCustomClaims().forEach((key, value) -> {\n                    if (userAdditionalInformation.get(value) != null) {\n                        IDToken.put(key, userAdditionalInformation.get(value));\n                    }\n                });\n            }\n        }\n        // get client certificate provider if any\n        if (client.getCertificate() != null) {\n            certificateProvider = certificateManager.get(client.getCertificate());\n        }\n    }\n\n    // generate ID Token payload\n    String payload = objectMapper.formatMap(IDToken);\n\n    // encode ID Token\n    if (certificateProvider != null) {\n        payload = certificateProvider.sign(payload);\n    } else {\n        // default encoding\n        payload = JwtHelper.encode(payload, signer).getEncoded();\n    }\n\n    // enhance access token\n    Map<String, Object> additionalInformation = new HashMap<>(accessToken.getAdditionalInformation());\n    additionalInformation.put(ID_TOKEN, payload);\n    ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInformation);\n\n    return accessToken;\n}",
                "name": "enhance0",
                "modifiers": "private",
                "return_type": "OAuth2AccessToken",
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "accessToken"
                    },
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    // create ID token\n    Map<String, Object> IDToken = new HashMap<>();\n    Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n    IDToken.put(OIDCClaims.iss, iss);\n    IDToken.put(OIDCClaims.sub, authentication.isClientOnly() ? ((String) authentication.getPrincipal()) : authentication.getName());\n    IDToken.put(OIDCClaims.aud, authentication.getOAuth2Request().getClientId());\n    IDToken.put(OIDCClaims.iat, calendar.getTimeInMillis() / 1000l);\n    calendar.add(Calendar.SECOND, defaultIDTokenExpireIn);\n    IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n\n    // enhance ID token with OAuth client information\n    CertificateProvider certificateProvider = null;\n    if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n        Client client = ((DelegateClientDetails) clientDetails).getClient();\n        calendar.setTimeInMillis((long) IDToken.get(OIDCClaims.iat) * 1000l);\n        calendar.add(Calendar.SECOND, client.getIdTokenValiditySeconds());\n        IDToken.put(OIDCClaims.exp, calendar.getTimeInMillis() / 1000l);\n        // we only override claims for an end-user (grant_type != client_credentials)\n        if (!authentication.isClientOnly()\n                && client.getIdTokenCustomClaims() != null\n                && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n            // retrieve user attributes\n            User user = (User) authentication.getUserAuthentication().getPrincipal();\n            if (user.getAdditionalInformation() != null && !user.getAdditionalInformation().isEmpty()) {\n                final Map<String, Object> userAdditionalInformation = user.getAdditionalInformation();\n                client.getIdTokenCustomClaims().forEach((key, value) -> {\n                    if (userAdditionalInformation.get(value) != null) {\n                        IDToken.put(key, userAdditionalInformation.get(value));\n                    }\n                });\n            }\n        }\n        // get client certificate provider if any\n        if (client.getCertificate() != null) {\n            certificateProvider = certificateManager.get(client.getCertificate());\n        }\n    }\n\n    // generate ID Token payload\n    String payload = objectMapper.formatMap(IDToken);\n\n    // encode ID Token\n    if (certificateProvider != null) {\n        payload = certificateProvider.sign(payload);\n    } else {\n        // default encoding\n        payload = JwtHelper.encode(payload, signer).getEncoded();\n    }\n\n    // enhance access token\n    Map<String, Object> additionalInformation = new HashMap<>(accessToken.getAdditionalInformation());\n    additionalInformation.put(ID_TOKEN, payload);\n    ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInformation);\n\n    return accessToken;\n}",
                "start_point": {
                    "row": 103,
                    "column": 4
                },
                "end_point": {
                    "row": 159,
                    "column": 5
                }
            },
            {
                "definition": "private void setClientDetails(String clientId) {\n    try {\n        clientDetails = clientService.loadClientByClientId(clientId);\n    } catch (Exception ex) {\n    }\n}",
                "name": "setClientDetails",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "clientId"
                    }
                ],
                "body": "{\n    try {\n        clientDetails = clientService.loadClientByClientId(clientId);\n    } catch (Exception ex) {\n    }\n}",
                "start_point": {
                    "row": 161,
                    "column": 4
                },
                "end_point": {
                    "row": 166,
                    "column": 5
                }
            },
            {
                "definition": "private OAuth2AccessToken enhanceTokenScopes(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {\n    // enhance token scopes with user permissions\n    if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n        Client client = ((DelegateClientDetails) clientDetails).getClient();\n        if (!authentication.isClientOnly()\n                && client.isEnhanceScopesWithUserPermissions()\n                && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n            User user = (User) authentication.getUserAuthentication().getPrincipal();\n            if (user.getRoles() != null && !user.getRoles().isEmpty()) {\n                // TODO async call\n                Set<Role> roles = roleService.findByIdIn(user.getRoles()).blockingGet();\n                Set<String> requestedScopes = OAuth2Utils.parseParameterList(authentication.getOAuth2Request().getRequestParameters().get(OAuth2Utils.SCOPE));\n                Set<String> enhanceScopes = new HashSet<>(accessToken.getScope());\n                enhanceScopes.addAll(roles.stream()\n                        .map(r -> r.getPermissions())\n                        .flatMap(List::stream)\n                        .filter(permission -> {\n                            if (requestedScopes != null && !requestedScopes.isEmpty()) {\n                                return requestedScopes.contains(permission);\n                            }\n                            // if no query param scope, accept all enhance scopes\n                            return true;\n                        })\n                        .collect(Collectors.toList()));\n                ((DefaultOAuth2AccessToken) accessToken).setScope(enhanceScopes);\n            }\n        }\n    }\n\n    return accessToken;\n}",
                "name": "enhanceTokenScopes",
                "modifiers": "private",
                "return_type": "OAuth2AccessToken",
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "accessToken"
                    },
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    // enhance token scopes with user permissions\n    if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n        Client client = ((DelegateClientDetails) clientDetails).getClient();\n        if (!authentication.isClientOnly()\n                && client.isEnhanceScopesWithUserPermissions()\n                && authentication.getUserAuthentication().getPrincipal() instanceof User) {\n            User user = (User) authentication.getUserAuthentication().getPrincipal();\n            if (user.getRoles() != null && !user.getRoles().isEmpty()) {\n                // TODO async call\n                Set<Role> roles = roleService.findByIdIn(user.getRoles()).blockingGet();\n                Set<String> requestedScopes = OAuth2Utils.parseParameterList(authentication.getOAuth2Request().getRequestParameters().get(OAuth2Utils.SCOPE));\n                Set<String> enhanceScopes = new HashSet<>(accessToken.getScope());\n                enhanceScopes.addAll(roles.stream()\n                        .map(r -> r.getPermissions())\n                        .flatMap(List::stream)\n                        .filter(permission -> {\n                            if (requestedScopes != null && !requestedScopes.isEmpty()) {\n                                return requestedScopes.contains(permission);\n                            }\n                            // if no query param scope, accept all enhance scopes\n                            return true;\n                        })\n                        .collect(Collectors.toList()));\n                ((DefaultOAuth2AccessToken) accessToken).setScope(enhanceScopes);\n            }\n        }\n    }\n\n    return accessToken;\n}",
                "start_point": {
                    "row": 168,
                    "column": 4
                },
                "end_point": {
                    "row": 198,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/jwt/JwtKeyPairFactory.java",
        "definition": "public class JwtKeyPairFactory extends AbstractAutowiringFactoryBean<KeyPair> {\n\n    /**\n     * How to generate a new keystore:\n     *\n     * keytool -genkeypair -alias mytestkey -keyalg RSA -dname \"CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US\"\n     *          -keypass changeme -keystore server.jks -storepass letmein\n     */\n\n    @Override\n    protected KeyPair doCreateInstance() throws Exception {\n        return new KeyStoreKeyFactory(new ClassPathResource(\"server.jks\"), \"letmein\".toCharArray())\n                .getKeyPair(\"mytestkey\", \"changeme\".toCharArray());\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return KeyPair.class;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.jwt;",
        "tree_path": "JwtKeyPairFactory",
        "name": "JwtKeyPairFactory",
        "modifiers": "public",
        "superclass": "extends AbstractAutowiringFactoryBean<KeyPair>",
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * How to generate a new keystore:\n     *\n     * keytool -genkeypair -alias mytestkey -keyalg RSA -dname \"CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US\"\n     *          -keypass changeme -keystore server.jks -storepass letmein\n     */\n\n    @Override\n    protected KeyPair doCreateInstance() throws Exception {\n        return new KeyStoreKeyFactory(new ClassPathResource(\"server.jks\"), \"letmein\".toCharArray())\n                .getKeyPair(\"mytestkey\", \"changeme\".toCharArray());\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return KeyPair.class;\n    }\n}",
        "start_point": {
            "row": 27,
            "column": 0
        },
        "end_point": {
            "row": 46,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\nprotected KeyPair doCreateInstance() throws Exception {\n    return new KeyStoreKeyFactory(new ClassPathResource(\"server.jks\"), \"letmein\".toCharArray())\n            .getKeyPair(\"mytestkey\", \"changeme\".toCharArray());\n}",
                "name": "doCreateInstance",
                "modifiers": "@Override\n    protected",
                "return_type": "KeyPair",
                "parameters": [],
                "body": "{\n    return new KeyStoreKeyFactory(new ClassPathResource(\"server.jks\"), \"letmein\".toCharArray())\n            .getKeyPair(\"mytestkey\", \"changeme\".toCharArray());\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 40,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Class<?> getObjectType() {\n    return KeyPair.class;\n}",
                "name": "getObjectType",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return KeyPair.class;\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 45,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/request/CustomOAuth2RequestFactory.java",
        "definition": "public class CustomOAuth2RequestFactory extends DefaultOAuth2RequestFactory {\n\n    public CustomOAuth2RequestFactory(ClientDetailsService clientDetailsService) {\n        super(clientDetailsService);\n    }\n\n    @Override\n    public TokenRequest createTokenRequest(Map<String, String> requestParameters, ClientDetails authenticatedClient) {\n        TokenRequest tokenRequest = super.createTokenRequest(requestParameters, authenticatedClient);\n\n        Map<String, String> enhancedRequestParameters = new HashMap<>(tokenRequest.getRequestParameters());\n        enhancedRequestParameters.put(OAuth2Utils.CLIENT_ID, authenticatedClient.getClientId());\n        tokenRequest.setRequestParameters(enhancedRequestParameters);\n\n        return tokenRequest;\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.request;",
        "tree_path": "CustomOAuth2RequestFactory",
        "name": "CustomOAuth2RequestFactory",
        "modifiers": "public",
        "superclass": "extends DefaultOAuth2RequestFactory",
        "super_interfaces": null,
        "body": "{\n\n    public CustomOAuth2RequestFactory(ClientDetailsService clientDetailsService) {\n        super(clientDetailsService);\n    }\n\n    @Override\n    public TokenRequest createTokenRequest(Map<String, String> requestParameters, ClientDetails authenticatedClient) {\n        TokenRequest tokenRequest = super.createTokenRequest(requestParameters, authenticatedClient);\n\n        Map<String, String> enhancedRequestParameters = new HashMap<>(tokenRequest.getRequestParameters());\n        enhancedRequestParameters.put(OAuth2Utils.CLIENT_ID, authenticatedClient.getClientId());\n        tokenRequest.setRequestParameters(enhancedRequestParameters);\n\n        return tokenRequest;\n    }\n\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 47,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public CustomOAuth2RequestFactory(ClientDetailsService clientDetailsService) {\n    super(clientDetailsService);\n}",
                "name": "CustomOAuth2RequestFactory",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "ClientDetailsService",
                        "name": "clientDetailsService"
                    }
                ],
                "body": "{\n    super(clientDetailsService);\n}",
                "constructor": true,
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 34,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic TokenRequest createTokenRequest(Map<String, String> requestParameters, ClientDetails authenticatedClient) {\n    TokenRequest tokenRequest = super.createTokenRequest(requestParameters, authenticatedClient);\n\n    Map<String, String> enhancedRequestParameters = new HashMap<>(tokenRequest.getRequestParameters());\n    enhancedRequestParameters.put(OAuth2Utils.CLIENT_ID, authenticatedClient.getClientId());\n    tokenRequest.setRequestParameters(enhancedRequestParameters);\n\n    return tokenRequest;\n}",
                "name": "createTokenRequest",
                "modifiers": "@Override\n    public",
                "return_type": "TokenRequest",
                "parameters": [
                    {
                        "type": "Map<String, String>",
                        "name": "requestParameters"
                    },
                    {
                        "type": "ClientDetails",
                        "name": "authenticatedClient"
                    }
                ],
                "body": "{\n    TokenRequest tokenRequest = super.createTokenRequest(requestParameters, authenticatedClient);\n\n    Map<String, String> enhancedRequestParameters = new HashMap<>(tokenRequest.getRequestParameters());\n    enhancedRequestParameters.put(OAuth2Utils.CLIENT_ID, authenticatedClient.getClientId());\n    tokenRequest.setRequestParameters(enhancedRequestParameters);\n\n    return tokenRequest;\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 45,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/security/ClientBasedAuthenticationProvider.java",
        "definition": "public class ClientBasedAuthenticationProvider implements AuthenticationProvider {\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(ClientBasedAuthenticationProvider.class);\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        Map<String, String> details = (Map<String, String>) authentication.getDetails();\n        if (details != null && details.containsKey(OAuth2Utils.CLIENT_ID)) {\n            String clientId = details.get(OAuth2Utils.CLIENT_ID);\n\n            // TODO: is there an other way to access client details without calling storage again ?\n            try {\n                ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n                if (clientDetails instanceof DelegateClientDetails) {\n                    Set<String> identities = ((DelegateClientDetails) clientDetails).getClient().getIdentities();\n                    Iterator<String> iter = identities.iterator();\n                    io.gravitee.am.identityprovider.api.User user = null;\n\n                    // Create a end-user authentication for underlying providers associated to the client\n                    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n                            authentication.getName(),\n                            authentication.getCredentials());\n\n                    while (iter.hasNext() && user == null) {\n                        String provider = iter.next();\n                        io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                                identityProviderManager.get(provider);\n\n                        if (authenticationProvider == null) {\n                            throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n                        }\n\n                        try {\n                            user = authenticationProvider.loadUserByUsername(provAuthentication);\n                            // set user identity provider source\n                            details.put(RepositoryProviderUtils.SOURCE, provider);\n                        } catch (Exception ex) {\n                            logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n                            throw new BadCredentialsException(ex.getMessage(), ex);\n                        }\n                    }\n\n                    if (user != null) {\n                        return new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(),\n                                AuthorityUtils.NO_AUTHORITIES);\n                    }\n                    throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n                }\n            } catch (Exception ex) {\n                throw new BadCredentialsException(ex.getMessage(), ex);\n            }\n        }\n\n        throw new BadCredentialsException(\"No client found for authentication \" + authentication.getName());\n    }\n\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return authentication.equals(\n                UsernamePasswordAuthenticationToken.class);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.security;",
        "tree_path": "ClientBasedAuthenticationProvider",
        "name": "ClientBasedAuthenticationProvider",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements AuthenticationProvider",
        "body": "{\n\n    /**\n     * Logger.\n     */\n    private final Logger logger = LoggerFactory.getLogger(ClientBasedAuthenticationProvider.class);\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        Map<String, String> details = (Map<String, String>) authentication.getDetails();\n        if (details != null && details.containsKey(OAuth2Utils.CLIENT_ID)) {\n            String clientId = details.get(OAuth2Utils.CLIENT_ID);\n\n            // TODO: is there an other way to access client details without calling storage again ?\n            try {\n                ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n                if (clientDetails instanceof DelegateClientDetails) {\n                    Set<String> identities = ((DelegateClientDetails) clientDetails).getClient().getIdentities();\n                    Iterator<String> iter = identities.iterator();\n                    io.gravitee.am.identityprovider.api.User user = null;\n\n                    // Create a end-user authentication for underlying providers associated to the client\n                    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n                            authentication.getName(),\n                            authentication.getCredentials());\n\n                    while (iter.hasNext() && user == null) {\n                        String provider = iter.next();\n                        io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                                identityProviderManager.get(provider);\n\n                        if (authenticationProvider == null) {\n                            throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n                        }\n\n                        try {\n                            user = authenticationProvider.loadUserByUsername(provAuthentication);\n                            // set user identity provider source\n                            details.put(RepositoryProviderUtils.SOURCE, provider);\n                        } catch (Exception ex) {\n                            logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n                            throw new BadCredentialsException(ex.getMessage(), ex);\n                        }\n                    }\n\n                    if (user != null) {\n                        return new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(),\n                                AuthorityUtils.NO_AUTHORITIES);\n                    }\n                    throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n                }\n            } catch (Exception ex) {\n                throw new BadCredentialsException(ex.getMessage(), ex);\n            }\n        }\n\n        throw new BadCredentialsException(\"No client found for authentication \" + authentication.getName());\n    }\n\n    @Override\n    public boolean supports(Class<?> authentication) {\n        return authentication.equals(\n                UsernamePasswordAuthenticationToken.class);\n    }\n}",
        "start_point": {
            "row": 43,
            "column": 0
        },
        "end_point": {
            "row": 113,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Authentication authenticate(Authentication authentication) throws AuthenticationException {\n    Map<String, String> details = (Map<String, String>) authentication.getDetails();\n    if (details != null && details.containsKey(OAuth2Utils.CLIENT_ID)) {\n        String clientId = details.get(OAuth2Utils.CLIENT_ID);\n\n        // TODO: is there an other way to access client details without calling storage again ?\n        try {\n            ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n            if (clientDetails instanceof DelegateClientDetails) {\n                Set<String> identities = ((DelegateClientDetails) clientDetails).getClient().getIdentities();\n                Iterator<String> iter = identities.iterator();\n                io.gravitee.am.identityprovider.api.User user = null;\n\n                // Create a end-user authentication for underlying providers associated to the client\n                io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n                        authentication.getName(),\n                        authentication.getCredentials());\n\n                while (iter.hasNext() && user == null) {\n                    String provider = iter.next();\n                    io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                            identityProviderManager.get(provider);\n\n                    if (authenticationProvider == null) {\n                        throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n                    }\n\n                    try {\n                        user = authenticationProvider.loadUserByUsername(provAuthentication);\n                        // set user identity provider source\n                        details.put(RepositoryProviderUtils.SOURCE, provider);\n                    } catch (Exception ex) {\n                        logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n                        throw new BadCredentialsException(ex.getMessage(), ex);\n                    }\n                }\n\n                if (user != null) {\n                    return new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(),\n                            AuthorityUtils.NO_AUTHORITIES);\n                }\n                throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n            }\n        } catch (Exception ex) {\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    throw new BadCredentialsException(\"No client found for authentication \" + authentication.getName());\n}",
                "name": "authenticate",
                "modifiers": "@Override\n    public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    Map<String, String> details = (Map<String, String>) authentication.getDetails();\n    if (details != null && details.containsKey(OAuth2Utils.CLIENT_ID)) {\n        String clientId = details.get(OAuth2Utils.CLIENT_ID);\n\n        // TODO: is there an other way to access client details without calling storage again ?\n        try {\n            ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);\n            if (clientDetails instanceof DelegateClientDetails) {\n                Set<String> identities = ((DelegateClientDetails) clientDetails).getClient().getIdentities();\n                Iterator<String> iter = identities.iterator();\n                io.gravitee.am.identityprovider.api.User user = null;\n\n                // Create a end-user authentication for underlying providers associated to the client\n                io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(\n                        authentication.getName(),\n                        authentication.getCredentials());\n\n                while (iter.hasNext() && user == null) {\n                    String provider = iter.next();\n                    io.gravitee.am.identityprovider.api.AuthenticationProvider authenticationProvider =\n                            identityProviderManager.get(provider);\n\n                    if (authenticationProvider == null) {\n                        throw new BadCredentialsException(\"Unable to load authentication provider \" + provider + \", an error occurred during the initialization stage\");\n                    }\n\n                    try {\n                        user = authenticationProvider.loadUserByUsername(provAuthentication);\n                        // set user identity provider source\n                        details.put(RepositoryProviderUtils.SOURCE, provider);\n                    } catch (Exception ex) {\n                        logger.info(\"Unable to authenticate user {} with provider {}\", authentication.getName(), provider, ex);\n                        throw new BadCredentialsException(ex.getMessage(), ex);\n                    }\n                }\n\n                if (user != null) {\n                    return new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(),\n                            AuthorityUtils.NO_AUTHORITIES);\n                }\n                throw new BadCredentialsException(\"No user found for providers \" + StringUtils.collectionToDelimitedString(identities, \",\"));\n            }\n        } catch (Exception ex) {\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    throw new BadCredentialsException(\"No client found for authentication \" + authentication.getName());\n}",
                "start_point": {
                    "row": 56,
                    "column": 4
                },
                "end_point": {
                    "row": 106,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean supports(Class<?> authentication) {\n    return authentication.equals(\n            UsernamePasswordAuthenticationToken.class);\n}",
                "name": "supports",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Class<?>",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    return authentication.equals(\n            UsernamePasswordAuthenticationToken.class);\n}",
                "start_point": {
                    "row": 108,
                    "column": 4
                },
                "end_point": {
                    "row": 112,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/security/web/authentication/ClientAwareAuthenticationDetailsSource.java",
        "definition": "public class ClientAwareAuthenticationDetailsSource implements AuthenticationDetailsSource<HttpServletRequest, Map<String, String>> {\n\n    public ClientAwareAuthenticationDetailsSource() {\n    }\n\n    public Map<String, String> buildDetails(HttpServletRequest request) {\n        Map<String, String> mapDetails = new HashMap<>();\n        mapDetails.put(\"remote_address\", request.getRemoteAddr());\n\n        HttpSession session = request.getSession(false);\n        mapDetails.put(\"session_id\",  (session != null) ? session.getId() : null);\n\n        String clientId = request.getParameter(OAuth2Utils.CLIENT_ID);\n\n        // In case of basic authentication, extract client_id from authorization header\n        if (clientId == null || clientId.isEmpty()) {\n            String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n            if (header != null && header.startsWith(\"Basic \")) {\n                try {\n                    String[] tokens = extractAndDecodeHeader(header);\n                    clientId = tokens[0];\n                } catch (IOException ioe) {\n                    // Nothing to do\n                }\n            }\n        }\n\n        mapDetails.put(OAuth2Utils.CLIENT_ID, clientId);\n\n        return mapDetails;\n    }\n\n    private String[] extractAndDecodeHeader(String header) throws IOException {\n\n        byte[] base64Token = header.substring(6).getBytes(\"UTF-8\");\n        byte[] decoded;\n        try {\n            decoded = Base64.decode(base64Token);\n        } catch (IllegalArgumentException e) {\n            throw new BadCredentialsException(\"Failed to decode basic authentication token\");\n        }\n\n        String token = new String(decoded, \"UTF-8\");\n\n        int delim = token.indexOf(\":\");\n\n        if (delim == -1) {\n            throw new BadCredentialsException(\"Invalid basic authentication token\");\n        }\n        return new String[] {token.substring(0, delim), token.substring(delim + 1)};\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.security.web.authentication;",
        "tree_path": "ClientAwareAuthenticationDetailsSource",
        "name": "ClientAwareAuthenticationDetailsSource",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements AuthenticationDetailsSource<HttpServletRequest, Map<String, String>>",
        "body": "{\n\n    public ClientAwareAuthenticationDetailsSource() {\n    }\n\n    public Map<String, String> buildDetails(HttpServletRequest request) {\n        Map<String, String> mapDetails = new HashMap<>();\n        mapDetails.put(\"remote_address\", request.getRemoteAddr());\n\n        HttpSession session = request.getSession(false);\n        mapDetails.put(\"session_id\",  (session != null) ? session.getId() : null);\n\n        String clientId = request.getParameter(OAuth2Utils.CLIENT_ID);\n\n        // In case of basic authentication, extract client_id from authorization header\n        if (clientId == null || clientId.isEmpty()) {\n            String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n            if (header != null && header.startsWith(\"Basic \")) {\n                try {\n                    String[] tokens = extractAndDecodeHeader(header);\n                    clientId = tokens[0];\n                } catch (IOException ioe) {\n                    // Nothing to do\n                }\n            }\n        }\n\n        mapDetails.put(OAuth2Utils.CLIENT_ID, clientId);\n\n        return mapDetails;\n    }\n\n    private String[] extractAndDecodeHeader(String header) throws IOException {\n\n        byte[] base64Token = header.substring(6).getBytes(\"UTF-8\");\n        byte[] decoded;\n        try {\n            decoded = Base64.decode(base64Token);\n        } catch (IllegalArgumentException e) {\n            throw new BadCredentialsException(\"Failed to decode basic authentication token\");\n        }\n\n        String token = new String(decoded, \"UTF-8\");\n\n        int delim = token.indexOf(\":\");\n\n        if (delim == -1) {\n            throw new BadCredentialsException(\"Invalid basic authentication token\");\n        }\n        return new String[] {token.substring(0, delim), token.substring(delim + 1)};\n    }\n}",
        "start_point": {
            "row": 33,
            "column": 0
        },
        "end_point": {
            "row": 84,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public ClientAwareAuthenticationDetailsSource() {\n}",
                "name": "ClientAwareAuthenticationDetailsSource",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 36,
                    "column": 5
                }
            },
            {
                "definition": "public Map<String, String> buildDetails(HttpServletRequest request) {\n    Map<String, String> mapDetails = new HashMap<>();\n    mapDetails.put(\"remote_address\", request.getRemoteAddr());\n\n    HttpSession session = request.getSession(false);\n    mapDetails.put(\"session_id\",  (session != null) ? session.getId() : null);\n\n    String clientId = request.getParameter(OAuth2Utils.CLIENT_ID);\n\n    // In case of basic authentication, extract client_id from authorization header\n    if (clientId == null || clientId.isEmpty()) {\n        String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n        if (header != null && header.startsWith(\"Basic \")) {\n            try {\n                String[] tokens = extractAndDecodeHeader(header);\n                clientId = tokens[0];\n            } catch (IOException ioe) {\n                // Nothing to do\n            }\n        }\n    }\n\n    mapDetails.put(OAuth2Utils.CLIENT_ID, clientId);\n\n    return mapDetails;\n}",
                "name": "buildDetails",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    }
                ],
                "body": "{\n    Map<String, String> mapDetails = new HashMap<>();\n    mapDetails.put(\"remote_address\", request.getRemoteAddr());\n\n    HttpSession session = request.getSession(false);\n    mapDetails.put(\"session_id\",  (session != null) ? session.getId() : null);\n\n    String clientId = request.getParameter(OAuth2Utils.CLIENT_ID);\n\n    // In case of basic authentication, extract client_id from authorization header\n    if (clientId == null || clientId.isEmpty()) {\n        String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n        if (header != null && header.startsWith(\"Basic \")) {\n            try {\n                String[] tokens = extractAndDecodeHeader(header);\n                clientId = tokens[0];\n            } catch (IOException ioe) {\n                // Nothing to do\n            }\n        }\n    }\n\n    mapDetails.put(OAuth2Utils.CLIENT_ID, clientId);\n\n    return mapDetails;\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 63,
                    "column": 5
                }
            },
            {
                "definition": "private String[] extractAndDecodeHeader(String header) throws IOException {\n\n    byte[] base64Token = header.substring(6).getBytes(\"UTF-8\");\n    byte[] decoded;\n    try {\n        decoded = Base64.decode(base64Token);\n    } catch (IllegalArgumentException e) {\n        throw new BadCredentialsException(\"Failed to decode basic authentication token\");\n    }\n\n    String token = new String(decoded, \"UTF-8\");\n\n    int delim = token.indexOf(\":\");\n\n    if (delim == -1) {\n        throw new BadCredentialsException(\"Invalid basic authentication token\");\n    }\n    return new String[] {token.substring(0, delim), token.substring(delim + 1)};\n}",
                "name": "extractAndDecodeHeader",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "header"
                    }
                ],
                "body": "{\n\n    byte[] base64Token = header.substring(6).getBytes(\"UTF-8\");\n    byte[] decoded;\n    try {\n        decoded = Base64.decode(base64Token);\n    } catch (IllegalArgumentException e) {\n        throw new BadCredentialsException(\"Failed to decode basic authentication token\");\n    }\n\n    String token = new String(decoded, \"UTF-8\");\n\n    int delim = token.indexOf(\":\");\n\n    if (delim == -1) {\n        throw new BadCredentialsException(\"Invalid basic authentication token\");\n    }\n    return new String[] {token.substring(0, delim), token.substring(delim + 1)};\n}",
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 83,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/security/web/authentication/ClientAwareAuthenticationFailureHandler.java",
        "definition": "public class ClientAwareAuthenticationFailureHandler implements AuthenticationFailureHandler {\n\n    private final Logger logger = LoggerFactory.getLogger(ClientAwareAuthenticationFailureHandler.class);\n\n    private String defaultFailureUrl;\n    private boolean forwardToDestination = false;\n    private boolean allowSessionCreation = true;\n    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();\n\n    public ClientAwareAuthenticationFailureHandler() {\n    }\n\n    public ClientAwareAuthenticationFailureHandler(String defaultFailureUrl) {\n        setDefaultFailureUrl(defaultFailureUrl);\n    }\n\n    /**\n     * Performs the redirect or forward to the {@code defaultFailureUrl} if set, otherwise returns a 401 error code.\n     * <p>\n     * If redirecting or forwarding, {@code saveException} will be called to cache the exception for use in\n     * the target view.\n     */\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,\n                                        AuthenticationException exception) throws IOException, ServletException {\n\n        if (defaultFailureUrl == null) {\n            logger.debug(\"No failure URL set, sending 401 Unauthorized error\");\n\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Authentication Failed: \" + exception.getMessage());\n        } else {\n            saveException(request, exception);\n\n            if (forwardToDestination) {\n                logger.debug(\"Forwarding to \" + defaultFailureUrl);\n\n                request.getRequestDispatcher(defaultFailureUrl).forward(request, response);\n            } else {\n                logger.debug(\"Redirecting to \" + defaultFailureUrl);\n                redirectStrategy.sendRedirect(request, response, defaultFailureUrl + \"&client_id=\" + request.getParameter(OAuth2Utils.CLIENT_ID));\n            }\n        }\n    }\n\n    /**\n     * Caches the {@code AuthenticationException} for use in view rendering.\n     * <p>\n     * If {@code forwardToDestination} is set to true, request scope will be used, otherwise it will attempt to store\n     * the exception in the session. If there is no session and {@code allowSessionCreation} is {@code true} a session\n     * will be created. Otherwise the exception will not be stored.\n     */\n    protected final void saveException(HttpServletRequest request, AuthenticationException exception) {\n        if (forwardToDestination) {\n            request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n        } else {\n            HttpSession session = request.getSession(false);\n\n            if (session != null || allowSessionCreation) {\n                request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n            }\n        }\n    }\n\n    /**\n     * The URL which will be used as the failure destination.\n     *\n     * @param defaultFailureUrl the failure URL, for example \"/loginFailed.jsp\".\n     */\n    public void setDefaultFailureUrl(String defaultFailureUrl) {\n        Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl),\n                \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\");\n        this.defaultFailureUrl = defaultFailureUrl;\n    }\n\n    protected boolean isUseForward() {\n        return forwardToDestination;\n    }\n\n    /**\n     * If set to <tt>true</tt>, performs a forward to the failure destination URL instead of a redirect. Defaults to\n     * <tt>false</tt>.\n     */\n    public void setUseForward(boolean forwardToDestination) {\n        this.forwardToDestination = forwardToDestination;\n    }\n\n    /**\n     * Allows overriding of the behaviour when redirecting to a target URL.\n     */\n    public void setRedirectStrategy(RedirectStrategy redirectStrategy) {\n        this.redirectStrategy = redirectStrategy;\n    }\n\n    protected RedirectStrategy getRedirectStrategy() {\n        return redirectStrategy;\n    }\n\n    protected boolean isAllowSessionCreation() {\n        return allowSessionCreation;\n    }\n\n    public void setAllowSessionCreation(boolean allowSessionCreation) {\n        this.allowSessionCreation = allowSessionCreation;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.security.web.authentication;",
        "tree_path": "ClientAwareAuthenticationFailureHandler",
        "name": "ClientAwareAuthenticationFailureHandler",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements AuthenticationFailureHandler",
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(ClientAwareAuthenticationFailureHandler.class);\n\n    private String defaultFailureUrl;\n    private boolean forwardToDestination = false;\n    private boolean allowSessionCreation = true;\n    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();\n\n    public ClientAwareAuthenticationFailureHandler() {\n    }\n\n    public ClientAwareAuthenticationFailureHandler(String defaultFailureUrl) {\n        setDefaultFailureUrl(defaultFailureUrl);\n    }\n\n    /**\n     * Performs the redirect or forward to the {@code defaultFailureUrl} if set, otherwise returns a 401 error code.\n     * <p>\n     * If redirecting or forwarding, {@code saveException} will be called to cache the exception for use in\n     * the target view.\n     */\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,\n                                        AuthenticationException exception) throws IOException, ServletException {\n\n        if (defaultFailureUrl == null) {\n            logger.debug(\"No failure URL set, sending 401 Unauthorized error\");\n\n            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Authentication Failed: \" + exception.getMessage());\n        } else {\n            saveException(request, exception);\n\n            if (forwardToDestination) {\n                logger.debug(\"Forwarding to \" + defaultFailureUrl);\n\n                request.getRequestDispatcher(defaultFailureUrl).forward(request, response);\n            } else {\n                logger.debug(\"Redirecting to \" + defaultFailureUrl);\n                redirectStrategy.sendRedirect(request, response, defaultFailureUrl + \"&client_id=\" + request.getParameter(OAuth2Utils.CLIENT_ID));\n            }\n        }\n    }\n\n    /**\n     * Caches the {@code AuthenticationException} for use in view rendering.\n     * <p>\n     * If {@code forwardToDestination} is set to true, request scope will be used, otherwise it will attempt to store\n     * the exception in the session. If there is no session and {@code allowSessionCreation} is {@code true} a session\n     * will be created. Otherwise the exception will not be stored.\n     */\n    protected final void saveException(HttpServletRequest request, AuthenticationException exception) {\n        if (forwardToDestination) {\n            request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n        } else {\n            HttpSession session = request.getSession(false);\n\n            if (session != null || allowSessionCreation) {\n                request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n            }\n        }\n    }\n\n    /**\n     * The URL which will be used as the failure destination.\n     *\n     * @param defaultFailureUrl the failure URL, for example \"/loginFailed.jsp\".\n     */\n    public void setDefaultFailureUrl(String defaultFailureUrl) {\n        Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl),\n                \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\");\n        this.defaultFailureUrl = defaultFailureUrl;\n    }\n\n    protected boolean isUseForward() {\n        return forwardToDestination;\n    }\n\n    /**\n     * If set to <tt>true</tt>, performs a forward to the failure destination URL instead of a redirect. Defaults to\n     * <tt>false</tt>.\n     */\n    public void setUseForward(boolean forwardToDestination) {\n        this.forwardToDestination = forwardToDestination;\n    }\n\n    /**\n     * Allows overriding of the behaviour when redirecting to a target URL.\n     */\n    public void setRedirectStrategy(RedirectStrategy redirectStrategy) {\n        this.redirectStrategy = redirectStrategy;\n    }\n\n    protected RedirectStrategy getRedirectStrategy() {\n        return redirectStrategy;\n    }\n\n    protected boolean isAllowSessionCreation() {\n        return allowSessionCreation;\n    }\n\n    public void setAllowSessionCreation(boolean allowSessionCreation) {\n        this.allowSessionCreation = allowSessionCreation;\n    }\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 141,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public ClientAwareAuthenticationFailureHandler() {\n}",
                "name": "ClientAwareAuthenticationFailureHandler",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n}",
                "constructor": true,
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 48,
                    "column": 5
                }
            },
            {
                "definition": "public ClientAwareAuthenticationFailureHandler(String defaultFailureUrl) {\n    setDefaultFailureUrl(defaultFailureUrl);\n}",
                "name": "ClientAwareAuthenticationFailureHandler",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "defaultFailureUrl"
                    }
                ],
                "body": "{\n    setDefaultFailureUrl(defaultFailureUrl);\n}",
                "constructor": true,
                "start_point": {
                    "row": 50,
                    "column": 4
                },
                "end_point": {
                    "row": 52,
                    "column": 5
                }
            },
            {
                "definition": "public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,\n                                    AuthenticationException exception) throws IOException, ServletException {\n\n    if (defaultFailureUrl == null) {\n        logger.debug(\"No failure URL set, sending 401 Unauthorized error\");\n\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Authentication Failed: \" + exception.getMessage());\n    } else {\n        saveException(request, exception);\n\n        if (forwardToDestination) {\n            logger.debug(\"Forwarding to \" + defaultFailureUrl);\n\n            request.getRequestDispatcher(defaultFailureUrl).forward(request, response);\n        } else {\n            logger.debug(\"Redirecting to \" + defaultFailureUrl);\n            redirectStrategy.sendRedirect(request, response, defaultFailureUrl + \"&client_id=\" + request.getParameter(OAuth2Utils.CLIENT_ID));\n        }\n    }\n}",
                "name": "onAuthenticationFailure",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "AuthenticationException",
                        "name": "exception"
                    }
                ],
                "body": "{\n\n    if (defaultFailureUrl == null) {\n        logger.debug(\"No failure URL set, sending 401 Unauthorized error\");\n\n        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Authentication Failed: \" + exception.getMessage());\n    } else {\n        saveException(request, exception);\n\n        if (forwardToDestination) {\n            logger.debug(\"Forwarding to \" + defaultFailureUrl);\n\n            request.getRequestDispatcher(defaultFailureUrl).forward(request, response);\n        } else {\n            logger.debug(\"Redirecting to \" + defaultFailureUrl);\n            redirectStrategy.sendRedirect(request, response, defaultFailureUrl + \"&client_id=\" + request.getParameter(OAuth2Utils.CLIENT_ID));\n        }\n    }\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            },
            {
                "definition": "protected final void saveException(HttpServletRequest request, AuthenticationException exception) {\n    if (forwardToDestination) {\n        request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n    } else {\n        HttpSession session = request.getSession(false);\n\n        if (session != null || allowSessionCreation) {\n            request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n        }\n    }\n}",
                "name": "saveException",
                "modifiers": "protected final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "AuthenticationException",
                        "name": "exception"
                    }
                ],
                "body": "{\n    if (forwardToDestination) {\n        request.setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n    } else {\n        HttpSession session = request.getSession(false);\n\n        if (session != null || allowSessionCreation) {\n            request.getSession().setAttribute(WebAttributes.AUTHENTICATION_EXCEPTION, exception);\n        }\n    }\n}",
                "start_point": {
                    "row": 88,
                    "column": 4
                },
                "end_point": {
                    "row": 98,
                    "column": 5
                }
            },
            {
                "definition": "public void setDefaultFailureUrl(String defaultFailureUrl) {\n    Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl),\n            \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\");\n    this.defaultFailureUrl = defaultFailureUrl;\n}",
                "name": "setDefaultFailureUrl",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "defaultFailureUrl"
                    }
                ],
                "body": "{\n    Assert.isTrue(UrlUtils.isValidRedirectUrl(defaultFailureUrl),\n            \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\");\n    this.defaultFailureUrl = defaultFailureUrl;\n}",
                "start_point": {
                    "row": 105,
                    "column": 4
                },
                "end_point": {
                    "row": 109,
                    "column": 5
                }
            },
            {
                "definition": "protected boolean isUseForward() {\n    return forwardToDestination;\n}",
                "name": "isUseForward",
                "modifiers": "protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return forwardToDestination;\n}",
                "start_point": {
                    "row": 111,
                    "column": 4
                },
                "end_point": {
                    "row": 113,
                    "column": 5
                }
            },
            {
                "definition": "public void setUseForward(boolean forwardToDestination) {\n    this.forwardToDestination = forwardToDestination;\n}",
                "name": "setUseForward",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "forwardToDestination"
                    }
                ],
                "body": "{\n    this.forwardToDestination = forwardToDestination;\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 121,
                    "column": 5
                }
            },
            {
                "definition": "public void setRedirectStrategy(RedirectStrategy redirectStrategy) {\n    this.redirectStrategy = redirectStrategy;\n}",
                "name": "setRedirectStrategy",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "RedirectStrategy",
                        "name": "redirectStrategy"
                    }
                ],
                "body": "{\n    this.redirectStrategy = redirectStrategy;\n}",
                "start_point": {
                    "row": 126,
                    "column": 4
                },
                "end_point": {
                    "row": 128,
                    "column": 5
                }
            },
            {
                "definition": "protected RedirectStrategy getRedirectStrategy() {\n    return redirectStrategy;\n}",
                "name": "getRedirectStrategy",
                "modifiers": "protected",
                "return_type": "RedirectStrategy",
                "parameters": [],
                "body": "{\n    return redirectStrategy;\n}",
                "start_point": {
                    "row": 130,
                    "column": 4
                },
                "end_point": {
                    "row": 132,
                    "column": 5
                }
            },
            {
                "definition": "protected boolean isAllowSessionCreation() {\n    return allowSessionCreation;\n}",
                "name": "isAllowSessionCreation",
                "modifiers": "protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return allowSessionCreation;\n}",
                "start_point": {
                    "row": 134,
                    "column": 4
                },
                "end_point": {
                    "row": 136,
                    "column": 5
                }
            },
            {
                "definition": "public void setAllowSessionCreation(boolean allowSessionCreation) {\n    this.allowSessionCreation = allowSessionCreation;\n}",
                "name": "setAllowSessionCreation",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "allowSessionCreation"
                    }
                ],
                "body": "{\n    this.allowSessionCreation = allowSessionCreation;\n}",
                "start_point": {
                    "row": 138,
                    "column": 4
                },
                "end_point": {
                    "row": 140,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/token/CustomTokenGranter.java",
        "definition": "public class CustomTokenGranter extends AbstractTokenGranter {\n\n    private ExtensionGrant extensionGrant;\n\n    private ExtensionGrantProvider extensionGrantProvider;\n\n    private AuthenticationEventPublisher eventPublisher;\n\n    public CustomTokenGranter(AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, ExtensionGrant extensionGrant) {\n        super(tokenServices, clientDetailsService, requestFactory, extensionGrant.getGrantType());\n        this.extensionGrant = extensionGrant;\n    }\n\n    @Override\n    protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {\n        try {\n            Authentication userAuth = null;\n            User user = extensionGrantProvider.grant(convert(tokenRequest));\n            if (user != null) {\n                userAuth = new UsernamePasswordAuthenticationToken(user, \"\", AuthorityUtils.NO_AUTHORITIES);\n                if (extensionGrant.isCreateUser()) {\n                    Map<String, String> parameters = new LinkedHashMap<String, String>(tokenRequest.getRequestParameters());\n                    parameters.put(RepositoryProviderUtils.SOURCE, extensionGrant.getIdentityProvider());\n                    ((AbstractAuthenticationToken) userAuth).setDetails(parameters);\n                    eventPublisher.publishAuthenticationSuccess(userAuth);\n                }\n            }\n\n            OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);\n            return new OAuth2Authentication(storedOAuth2Request, userAuth);\n        } catch (InvalidGrantException e) {\n            throw new org.springframework.security.oauth2.common.exceptions.InvalidGrantException(e.getMessage(), e);\n        }\n    }\n\n    public void setExtensionGrantProvider(ExtensionGrantProvider extensionGrantProvider) {\n        Assert.notNull(extensionGrantProvider, \"Extension Grant provider must not be null\");\n        this.extensionGrantProvider = extensionGrantProvider;\n    }\n\n    public void setAuthenticationEventPublisher(AuthenticationEventPublisher eventPublisher) {\n        Assert.notNull(eventPublisher, \"AuthenticationEventPublisher cannot be null\");\n        this.eventPublisher = eventPublisher;\n    }\n\n    private io.gravitee.am.repository.oauth2.model.request.TokenRequest convert(TokenRequest request) {\n        io.gravitee.am.repository.oauth2.model.request.TokenRequest tokenRequest = new io.gravitee.am.repository.oauth2.model.request.TokenRequest();\n        tokenRequest.setGrantType(request.getGrantType());\n        tokenRequest.setClientId(request.getClientId());\n        tokenRequest.setScope(request.getScope());\n        tokenRequest.setRequestParameters(request.getRequestParameters());\n        return tokenRequest;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.token;",
        "tree_path": "CustomTokenGranter",
        "name": "CustomTokenGranter",
        "modifiers": "public",
        "superclass": "extends AbstractTokenGranter",
        "super_interfaces": null,
        "body": "{\n\n    private ExtensionGrant extensionGrant;\n\n    private ExtensionGrantProvider extensionGrantProvider;\n\n    private AuthenticationEventPublisher eventPublisher;\n\n    public CustomTokenGranter(AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, ExtensionGrant extensionGrant) {\n        super(tokenServices, clientDetailsService, requestFactory, extensionGrant.getGrantType());\n        this.extensionGrant = extensionGrant;\n    }\n\n    @Override\n    protected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {\n        try {\n            Authentication userAuth = null;\n            User user = extensionGrantProvider.grant(convert(tokenRequest));\n            if (user != null) {\n                userAuth = new UsernamePasswordAuthenticationToken(user, \"\", AuthorityUtils.NO_AUTHORITIES);\n                if (extensionGrant.isCreateUser()) {\n                    Map<String, String> parameters = new LinkedHashMap<String, String>(tokenRequest.getRequestParameters());\n                    parameters.put(RepositoryProviderUtils.SOURCE, extensionGrant.getIdentityProvider());\n                    ((AbstractAuthenticationToken) userAuth).setDetails(parameters);\n                    eventPublisher.publishAuthenticationSuccess(userAuth);\n                }\n            }\n\n            OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);\n            return new OAuth2Authentication(storedOAuth2Request, userAuth);\n        } catch (InvalidGrantException e) {\n            throw new org.springframework.security.oauth2.common.exceptions.InvalidGrantException(e.getMessage(), e);\n        }\n    }\n\n    public void setExtensionGrantProvider(ExtensionGrantProvider extensionGrantProvider) {\n        Assert.notNull(extensionGrantProvider, \"Extension Grant provider must not be null\");\n        this.extensionGrantProvider = extensionGrantProvider;\n    }\n\n    public void setAuthenticationEventPublisher(AuthenticationEventPublisher eventPublisher) {\n        Assert.notNull(eventPublisher, \"AuthenticationEventPublisher cannot be null\");\n        this.eventPublisher = eventPublisher;\n    }\n\n    private io.gravitee.am.repository.oauth2.model.request.TokenRequest convert(TokenRequest request) {\n        io.gravitee.am.repository.oauth2.model.request.TokenRequest tokenRequest = new io.gravitee.am.repository.oauth2.model.request.TokenRequest();\n        tokenRequest.setGrantType(request.getGrantType());\n        tokenRequest.setClientId(request.getClientId());\n        tokenRequest.setScope(request.getScope());\n        tokenRequest.setRequestParameters(request.getRequestParameters());\n        return tokenRequest;\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 92,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public CustomTokenGranter(AuthorizationServerTokenServices tokenServices, ClientDetailsService clientDetailsService, OAuth2RequestFactory requestFactory, ExtensionGrant extensionGrant) {\n    super(tokenServices, clientDetailsService, requestFactory, extensionGrant.getGrantType());\n    this.extensionGrant = extensionGrant;\n}",
                "name": "CustomTokenGranter",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "AuthorizationServerTokenServices",
                        "name": "tokenServices"
                    },
                    {
                        "type": "ClientDetailsService",
                        "name": "clientDetailsService"
                    },
                    {
                        "type": "OAuth2RequestFactory",
                        "name": "requestFactory"
                    },
                    {
                        "type": "ExtensionGrant",
                        "name": "extensionGrant"
                    }
                ],
                "body": "{\n    super(tokenServices, clientDetailsService, requestFactory, extensionGrant.getGrantType());\n    this.extensionGrant = extensionGrant;\n}",
                "constructor": true,
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 50,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected OAuth2Authentication getOAuth2Authentication(ClientDetails client, TokenRequest tokenRequest) {\n    try {\n        Authentication userAuth = null;\n        User user = extensionGrantProvider.grant(convert(tokenRequest));\n        if (user != null) {\n            userAuth = new UsernamePasswordAuthenticationToken(user, \"\", AuthorityUtils.NO_AUTHORITIES);\n            if (extensionGrant.isCreateUser()) {\n                Map<String, String> parameters = new LinkedHashMap<String, String>(tokenRequest.getRequestParameters());\n                parameters.put(RepositoryProviderUtils.SOURCE, extensionGrant.getIdentityProvider());\n                ((AbstractAuthenticationToken) userAuth).setDetails(parameters);\n                eventPublisher.publishAuthenticationSuccess(userAuth);\n            }\n        }\n\n        OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);\n        return new OAuth2Authentication(storedOAuth2Request, userAuth);\n    } catch (InvalidGrantException e) {\n        throw new org.springframework.security.oauth2.common.exceptions.InvalidGrantException(e.getMessage(), e);\n    }\n}",
                "name": "getOAuth2Authentication",
                "modifiers": "@Override\n    protected",
                "return_type": "OAuth2Authentication",
                "parameters": [
                    {
                        "type": "ClientDetails",
                        "name": "client"
                    },
                    {
                        "type": "TokenRequest",
                        "name": "tokenRequest"
                    }
                ],
                "body": "{\n    try {\n        Authentication userAuth = null;\n        User user = extensionGrantProvider.grant(convert(tokenRequest));\n        if (user != null) {\n            userAuth = new UsernamePasswordAuthenticationToken(user, \"\", AuthorityUtils.NO_AUTHORITIES);\n            if (extensionGrant.isCreateUser()) {\n                Map<String, String> parameters = new LinkedHashMap<String, String>(tokenRequest.getRequestParameters());\n                parameters.put(RepositoryProviderUtils.SOURCE, extensionGrant.getIdentityProvider());\n                ((AbstractAuthenticationToken) userAuth).setDetails(parameters);\n                eventPublisher.publishAuthenticationSuccess(userAuth);\n            }\n        }\n\n        OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);\n        return new OAuth2Authentication(storedOAuth2Request, userAuth);\n    } catch (InvalidGrantException e) {\n        throw new org.springframework.security.oauth2.common.exceptions.InvalidGrantException(e.getMessage(), e);\n    }\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 72,
                    "column": 5
                }
            },
            {
                "definition": "public void setExtensionGrantProvider(ExtensionGrantProvider extensionGrantProvider) {\n    Assert.notNull(extensionGrantProvider, \"Extension Grant provider must not be null\");\n    this.extensionGrantProvider = extensionGrantProvider;\n}",
                "name": "setExtensionGrantProvider",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ExtensionGrantProvider",
                        "name": "extensionGrantProvider"
                    }
                ],
                "body": "{\n    Assert.notNull(extensionGrantProvider, \"Extension Grant provider must not be null\");\n    this.extensionGrantProvider = extensionGrantProvider;\n}",
                "start_point": {
                    "row": 74,
                    "column": 4
                },
                "end_point": {
                    "row": 77,
                    "column": 5
                }
            },
            {
                "definition": "public void setAuthenticationEventPublisher(AuthenticationEventPublisher eventPublisher) {\n    Assert.notNull(eventPublisher, \"AuthenticationEventPublisher cannot be null\");\n    this.eventPublisher = eventPublisher;\n}",
                "name": "setAuthenticationEventPublisher",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthenticationEventPublisher",
                        "name": "eventPublisher"
                    }
                ],
                "body": "{\n    Assert.notNull(eventPublisher, \"AuthenticationEventPublisher cannot be null\");\n    this.eventPublisher = eventPublisher;\n}",
                "start_point": {
                    "row": 79,
                    "column": 4
                },
                "end_point": {
                    "row": 82,
                    "column": 5
                }
            },
            {
                "definition": "private io.gravitee.am.repository.oauth2.model.request.TokenRequest convert(TokenRequest request) {\n    io.gravitee.am.repository.oauth2.model.request.TokenRequest tokenRequest = new io.gravitee.am.repository.oauth2.model.request.TokenRequest();\n    tokenRequest.setGrantType(request.getGrantType());\n    tokenRequest.setClientId(request.getClientId());\n    tokenRequest.setScope(request.getScope());\n    tokenRequest.setRequestParameters(request.getRequestParameters());\n    return tokenRequest;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "TokenRequest",
                        "name": "request"
                    }
                ],
                "body": "{\n    io.gravitee.am.repository.oauth2.model.request.TokenRequest tokenRequest = new io.gravitee.am.repository.oauth2.model.request.TokenRequest();\n    tokenRequest.setGrantType(request.getGrantType());\n    tokenRequest.setClientId(request.getClientId());\n    tokenRequest.setScope(request.getScope());\n    tokenRequest.setRequestParameters(request.getRequestParameters());\n    return tokenRequest;\n}",
                "start_point": {
                    "row": 84,
                    "column": 4
                },
                "end_point": {
                    "row": 91,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/token/DefaultAuthenticationKeyGenerator.java",
        "definition": "@Component\npublic class DefaultAuthenticationKeyGenerator implements AuthenticationKeyGenerator {\n\n    private static final String CLIENT_ID = \"client_id\";\n\n    private static final String SCOPE = \"scope\";\n\n    private static final String USERNAME = \"username\";\n\n    private static final String UUID_KEY = \"uuid\";\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Override\n    public String extractKey(OAuth2Authentication authentication) {\n        Map<String, String> values = new LinkedHashMap<>();\n        OAuth2Request authorizationRequest = authentication.getOAuth2Request();\n        if (!authentication.isClientOnly()) {\n            values.put(USERNAME, authentication.getName());\n        }\n        values.put(CLIENT_ID, authorizationRequest.getClientId());\n        if (authorizationRequest.getScope() != null) {\n            values.put(SCOPE, OAuth2Utils.formatParameterList(authorizationRequest.getScope()));\n        }\n        // retrieve client unique access token option\n        ClientDetails clientDetails = clientDetailsService.loadClientByClientId(authorizationRequest.getClientId());\n        if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n            Client client = ((DelegateClientDetails) clientDetails).getClient();\n            if (client.isGenerateNewTokenPerRequest()) {\n                String uuid = UUID.random().toString();\n                values.put(UUID_KEY, uuid);\n            }\n        }\n\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"MD5 algorithm not available.  Fatal (should be in the JDK).\");\n        }\n\n        try {\n            byte[] bytes = digest.digest(values.toString().getBytes(\"UTF-8\"));\n            return String.format(\"%032x\", new BigInteger(1, bytes));\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 encoding not available.  Fatal (should be in the JDK).\");\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.token;",
        "tree_path": "DefaultAuthenticationKeyGenerator",
        "name": "DefaultAuthenticationKeyGenerator",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements AuthenticationKeyGenerator",
        "body": "{\n\n    private static final String CLIENT_ID = \"client_id\";\n\n    private static final String SCOPE = \"scope\";\n\n    private static final String USERNAME = \"username\";\n\n    private static final String UUID_KEY = \"uuid\";\n\n    @Autowired\n    private ClientDetailsService clientDetailsService;\n\n    @Override\n    public String extractKey(OAuth2Authentication authentication) {\n        Map<String, String> values = new LinkedHashMap<>();\n        OAuth2Request authorizationRequest = authentication.getOAuth2Request();\n        if (!authentication.isClientOnly()) {\n            values.put(USERNAME, authentication.getName());\n        }\n        values.put(CLIENT_ID, authorizationRequest.getClientId());\n        if (authorizationRequest.getScope() != null) {\n            values.put(SCOPE, OAuth2Utils.formatParameterList(authorizationRequest.getScope()));\n        }\n        // retrieve client unique access token option\n        ClientDetails clientDetails = clientDetailsService.loadClientByClientId(authorizationRequest.getClientId());\n        if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n            Client client = ((DelegateClientDetails) clientDetails).getClient();\n            if (client.isGenerateNewTokenPerRequest()) {\n                String uuid = UUID.random().toString();\n                values.put(UUID_KEY, uuid);\n            }\n        }\n\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(\"MD5\");\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"MD5 algorithm not available.  Fatal (should be in the JDK).\");\n        }\n\n        try {\n            byte[] bytes = digest.digest(values.toString().getBytes(\"UTF-8\"));\n            return String.format(\"%032x\", new BigInteger(1, bytes));\n        }\n        catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"UTF-8 encoding not available.  Fatal (should be in the JDK).\");\n        }\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 90,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic String extractKey(OAuth2Authentication authentication) {\n    Map<String, String> values = new LinkedHashMap<>();\n    OAuth2Request authorizationRequest = authentication.getOAuth2Request();\n    if (!authentication.isClientOnly()) {\n        values.put(USERNAME, authentication.getName());\n    }\n    values.put(CLIENT_ID, authorizationRequest.getClientId());\n    if (authorizationRequest.getScope() != null) {\n        values.put(SCOPE, OAuth2Utils.formatParameterList(authorizationRequest.getScope()));\n    }\n    // retrieve client unique access token option\n    ClientDetails clientDetails = clientDetailsService.loadClientByClientId(authorizationRequest.getClientId());\n    if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n        Client client = ((DelegateClientDetails) clientDetails).getClient();\n        if (client.isGenerateNewTokenPerRequest()) {\n            String uuid = UUID.random().toString();\n            values.put(UUID_KEY, uuid);\n        }\n    }\n\n    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance(\"MD5\");\n    }\n    catch (NoSuchAlgorithmException e) {\n        throw new IllegalStateException(\"MD5 algorithm not available.  Fatal (should be in the JDK).\");\n    }\n\n    try {\n        byte[] bytes = digest.digest(values.toString().getBytes(\"UTF-8\"));\n        return String.format(\"%032x\", new BigInteger(1, bytes));\n    }\n    catch (UnsupportedEncodingException e) {\n        throw new IllegalStateException(\"UTF-8 encoding not available.  Fatal (should be in the JDK).\");\n    }\n}",
                "name": "extractKey",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    Map<String, String> values = new LinkedHashMap<>();\n    OAuth2Request authorizationRequest = authentication.getOAuth2Request();\n    if (!authentication.isClientOnly()) {\n        values.put(USERNAME, authentication.getName());\n    }\n    values.put(CLIENT_ID, authorizationRequest.getClientId());\n    if (authorizationRequest.getScope() != null) {\n        values.put(SCOPE, OAuth2Utils.formatParameterList(authorizationRequest.getScope()));\n    }\n    // retrieve client unique access token option\n    ClientDetails clientDetails = clientDetailsService.loadClientByClientId(authorizationRequest.getClientId());\n    if (clientDetails != null && clientDetails instanceof DelegateClientDetails) {\n        Client client = ((DelegateClientDetails) clientDetails).getClient();\n        if (client.isGenerateNewTokenPerRequest()) {\n            String uuid = UUID.random().toString();\n            values.put(UUID_KEY, uuid);\n        }\n    }\n\n    MessageDigest digest;\n    try {\n        digest = MessageDigest.getInstance(\"MD5\");\n    }\n    catch (NoSuchAlgorithmException e) {\n        throw new IllegalStateException(\"MD5 algorithm not available.  Fatal (should be in the JDK).\");\n    }\n\n    try {\n        byte[] bytes = digest.digest(values.toString().getBytes(\"UTF-8\"));\n        return String.format(\"%032x\", new BigInteger(1, bytes));\n    }\n    catch (UnsupportedEncodingException e) {\n        throw new IllegalStateException(\"UTF-8 encoding not available.  Fatal (should be in the JDK).\");\n    }\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 89,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/token/DefaultIntrospectionAccessTokenConverter.java",
        "definition": "public class DefaultIntrospectionAccessTokenConverter extends DefaultAccessTokenConverter {\n\n    /**\n     * Boolean indicator of whether or not the presented token is currently active as described by\n     * <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-22#section-3.3\">Section 3.3</a>\n     */\n    public static String ACTIVE = \"active\";\n\n    /**\n     * Human-readable identifier for the resource owner who\n     * authorized this token as described by <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">Section 2.2</a>\n     */\n    public static String USERNAME = \"username\";\n\n    @Override\n    public Map<String, ?> convertAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {\n        Map<String, Object> response = (Map<String, Object>) super.convertAccessToken(token, authentication);\n\n        response.put(ACTIVE, !token.isExpired());\n        response.put(OAuth2AccessToken.TOKEN_TYPE, \"bearer\");\n\n        Authentication userAuth = authentication.getUserAuthentication();\n        if (userAuth != null) {\n            response.remove(UserAuthenticationConverter.USERNAME);\n            response.put(USERNAME, userAuth.getName());\n            response.remove(UserAuthenticationConverter.AUTHORITIES);\n        }\n\n        Object rawScopes = response.remove(OAuth2AccessToken.SCOPE);\n        StringBuilder sb = new StringBuilder();\n        if (rawScopes != null && rawScopes instanceof Collection) {\n            Collection scopes = (Collection)rawScopes;\n            for (Object scope : scopes) {\n                sb.append(scope).append(\" \");\n            }\n        }\n\n        response.put(OAuth2AccessToken.SCOPE, sb.toString().trim());\n\n        return response;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.token;",
        "tree_path": "DefaultIntrospectionAccessTokenConverter",
        "name": "DefaultIntrospectionAccessTokenConverter",
        "modifiers": "public",
        "superclass": "extends DefaultAccessTokenConverter",
        "super_interfaces": null,
        "body": "{\n\n    /**\n     * Boolean indicator of whether or not the presented token is currently active as described by\n     * <a href=\"http://tools.ietf.org/html/draft-ietf-oauth-v2-22#section-3.3\">Section 3.3</a>\n     */\n    public static String ACTIVE = \"active\";\n\n    /**\n     * Human-readable identifier for the resource owner who\n     * authorized this token as described by <a href=\"https://tools.ietf.org/html/rfc7662#section-2.2\">Section 2.2</a>\n     */\n    public static String USERNAME = \"username\";\n\n    @Override\n    public Map<String, ?> convertAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {\n        Map<String, Object> response = (Map<String, Object>) super.convertAccessToken(token, authentication);\n\n        response.put(ACTIVE, !token.isExpired());\n        response.put(OAuth2AccessToken.TOKEN_TYPE, \"bearer\");\n\n        Authentication userAuth = authentication.getUserAuthentication();\n        if (userAuth != null) {\n            response.remove(UserAuthenticationConverter.USERNAME);\n            response.put(USERNAME, userAuth.getName());\n            response.remove(UserAuthenticationConverter.AUTHORITIES);\n        }\n\n        Object rawScopes = response.remove(OAuth2AccessToken.SCOPE);\n        StringBuilder sb = new StringBuilder();\n        if (rawScopes != null && rawScopes instanceof Collection) {\n            Collection scopes = (Collection)rawScopes;\n            for (Object scope : scopes) {\n                sb.append(scope).append(\" \");\n            }\n        }\n\n        response.put(OAuth2AccessToken.SCOPE, sb.toString().trim());\n\n        return response;\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 71,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic Map<String, ?> convertAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {\n    Map<String, Object> response = (Map<String, Object>) super.convertAccessToken(token, authentication);\n\n    response.put(ACTIVE, !token.isExpired());\n    response.put(OAuth2AccessToken.TOKEN_TYPE, \"bearer\");\n\n    Authentication userAuth = authentication.getUserAuthentication();\n    if (userAuth != null) {\n        response.remove(UserAuthenticationConverter.USERNAME);\n        response.put(USERNAME, userAuth.getName());\n        response.remove(UserAuthenticationConverter.AUTHORITIES);\n    }\n\n    Object rawScopes = response.remove(OAuth2AccessToken.SCOPE);\n    StringBuilder sb = new StringBuilder();\n    if (rawScopes != null && rawScopes instanceof Collection) {\n        Collection scopes = (Collection)rawScopes;\n        for (Object scope : scopes) {\n            sb.append(scope).append(\" \");\n        }\n    }\n\n    response.put(OAuth2AccessToken.SCOPE, sb.toString().trim());\n\n    return response;\n}",
                "name": "convertAccessToken",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "token"
                    },
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    Map<String, Object> response = (Map<String, Object>) super.convertAccessToken(token, authentication);\n\n    response.put(ACTIVE, !token.isExpired());\n    response.put(OAuth2AccessToken.TOKEN_TYPE, \"bearer\");\n\n    Authentication userAuth = authentication.getUserAuthentication();\n    if (userAuth != null) {\n        response.remove(UserAuthenticationConverter.USERNAME);\n        response.put(USERNAME, userAuth.getName());\n        response.remove(UserAuthenticationConverter.AUTHORITIES);\n    }\n\n    Object rawScopes = response.remove(OAuth2AccessToken.SCOPE);\n    StringBuilder sb = new StringBuilder();\n    if (rawScopes != null && rawScopes instanceof Collection) {\n        Collection scopes = (Collection)rawScopes;\n        for (Object scope : scopes) {\n            sb.append(scope).append(\" \");\n        }\n    }\n\n    response.put(OAuth2AccessToken.SCOPE, sb.toString().trim());\n\n    return response;\n}",
                "start_point": {
                    "row": 44,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/token/RepositoryTokenStore.java",
        "definition": "@Component\npublic class RepositoryTokenStore implements TokenStore {\n\n    @Autowired\n    private TokenRepository tokenRepository;\n\n    @Autowired\n    private AuthenticationKeyGenerator authenticationKeyGenerator;\n\n    @Override\n    public OAuth2Authentication readAuthentication(OAuth2AccessToken token) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n                = Optional.ofNullable(tokenRepository.readAuthentication(convert(token)).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public OAuth2Authentication readAuthentication(String token) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n                = Optional.ofNullable(tokenRepository.readAuthentication(token).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void storeAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {\n        io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = convert(token);\n\n        // extract authentication key\n        io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n        String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        // store date information\n        accessToken.setCreatedAt(new Date());\n        accessToken.setUpdatedAt(accessToken.getCreatedAt());\n\n        // TODO move to async call\n        tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n    }\n\n    @Override\n    public OAuth2AccessToken readAccessToken(String tokenValue) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.readAccessToken(tokenValue).blockingGet());\n\n        if (oAuth2AccessToken.isPresent()) {\n            return convert(oAuth2AccessToken.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void removeAccessToken(OAuth2AccessToken token) {\n        // TODO move to async call\n        tokenRepository.removeAccessToken(convert(token)).subscribe();\n    }\n\n    @Override\n    public void storeRefreshToken(OAuth2RefreshToken _refreshToken, OAuth2Authentication authentication) {\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken refreshToken = convert(_refreshToken);\n\n        // store date information\n        refreshToken.setCreatedAt(new Date());\n        refreshToken.setUpdatedAt(refreshToken.getCreatedAt());\n\n        // TODO move to async call\n        tokenRepository.storeRefreshToken(refreshToken, RepositoryProviderUtils.convert(authentication)).subscribe();\n    }\n\n    @Override\n    public OAuth2RefreshToken readRefreshToken(String tokenValue) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken> oAuth2RefreshToken\n                = Optional.ofNullable(tokenRepository.readRefreshToken(tokenValue).blockingGet());\n\n        if(oAuth2RefreshToken.isPresent()) {\n            return convert(oAuth2RefreshToken.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public OAuth2Authentication readAuthenticationForRefreshToken(OAuth2RefreshToken token) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n                = Optional.ofNullable(tokenRepository.readAuthenticationForRefreshToken(convert(token)).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void removeRefreshToken(OAuth2RefreshToken token) {\n        // TODO move to async call\n        tokenRepository.removeRefreshToken(convert(token)).subscribe();\n    }\n\n    @Override\n    public void removeAccessTokenUsingRefreshToken(OAuth2RefreshToken refreshToken) {\n        tokenRepository.removeAccessTokenUsingRefreshToken(convert(refreshToken));\n    }\n\n    @Override\n    public OAuth2AccessToken getAccessToken(OAuth2Authentication authentication) {\n        // extract authentication key\n        io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n        String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        // get access token\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.getAccessToken(authenticationKey).blockingGet());\n\n        if (oAuth2AccessToken.isPresent()) {\n            io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = oAuth2AccessToken.get();\n            Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> optExtractedAuthentication = Optional.ofNullable(tokenRepository.readAuthentication(accessToken.getValue()).blockingGet());\n            if ((!optExtractedAuthentication.isPresent() || !authenticationKey.equals(authenticationKeyGenerator.extractKey(optExtractedAuthentication.get())))) {\n                // TODO move to async call\n                tokenRepository.removeAccessToken(accessToken.getValue()).subscribe();\n                // Keep the store consistent (maybe the same user is represented by this authentication but the details have\n                // changed)\n                // TODO move to async call\n                tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n\n                // something happens with authentication (different serialization object)\n                // Keep the refresh token consistent\n                if (!optExtractedAuthentication.isPresent() && accessToken.getRefreshToken() != null) {\n                    // TODO move to async call\n                    tokenRepository.storeRefreshToken(accessToken.getRefreshToken(), oAuth2Authentication).subscribe();\n                }\n            }\n            return convert(accessToken);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public Collection<OAuth2AccessToken> findTokensByClientIdAndUserName(String clientId, String userName) {\n        // TODO move to async call\n        Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n                tokenRepository.findTokensByClientIdAndUserName(clientId, userName).blockingGet();\n\n        if (accessTokens != null) {\n            return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    @Override\n    public Collection<OAuth2AccessToken> findTokensByClientId(String clientId) {\n        // TODO move to async call\n        Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n                tokenRepository.findTokensByClientId(clientId).blockingGet();\n\n        if (accessTokens != null) {\n            return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    private io.gravitee.am.repository.oauth2.model.OAuth2AccessToken convert(OAuth2AccessToken _oAuth2AccessToken) {\n        io.gravitee.am.repository.oauth2.model.OAuth2AccessToken oAuth2AccessToken =\n                new io.gravitee.am.repository.oauth2.model.OAuth2AccessToken(_oAuth2AccessToken.getValue());\n        oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n        oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n        oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n        oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n        // refresh token\n        OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n        if (_oAuth2RefreshToken != null) {\n            io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken =\n                    new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue());\n            if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n                Date expiration = ((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration();\n                oAuth2RefreshToken.setExpiration(expiration);\n            }\n            oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n        }\n\n        return oAuth2AccessToken;\n    }\n\n    private OAuth2AccessToken convert(io.gravitee.am.repository.oauth2.model.OAuth2AccessToken _oAuth2AccessToken) {\n        DefaultOAuth2AccessToken oAuth2AccessToken = new DefaultOAuth2AccessToken(_oAuth2AccessToken.getValue());\n        oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n        oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n        oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n        oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n        // refresh token\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n        if (_oAuth2RefreshToken != null) {\n            DefaultExpiringOAuth2RefreshToken oAuth2RefreshToken =\n                    new DefaultExpiringOAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue(), _oAuth2AccessToken.getRefreshToken().getExpiration());\n            oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n        }\n\n        return oAuth2AccessToken;\n    }\n\n    private io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken convert(OAuth2RefreshToken _oAuth2RefreshToken) {\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken = new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2RefreshToken.getValue());\n        if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n            oAuth2RefreshToken.setExpiration(((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration());\n        }\n        return oAuth2RefreshToken;\n    }\n\n    private OAuth2RefreshToken convert(io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken _oAuth2RefreshToken) {\n        return new DefaultExpiringOAuth2RefreshToken(_oAuth2RefreshToken.getValue(), _oAuth2RefreshToken.getExpiration());\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.token;",
        "tree_path": "RepositoryTokenStore",
        "name": "RepositoryTokenStore",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": "implements TokenStore",
        "body": "{\n\n    @Autowired\n    private TokenRepository tokenRepository;\n\n    @Autowired\n    private AuthenticationKeyGenerator authenticationKeyGenerator;\n\n    @Override\n    public OAuth2Authentication readAuthentication(OAuth2AccessToken token) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n                = Optional.ofNullable(tokenRepository.readAuthentication(convert(token)).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public OAuth2Authentication readAuthentication(String token) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n                = Optional.ofNullable(tokenRepository.readAuthentication(token).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void storeAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {\n        io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = convert(token);\n\n        // extract authentication key\n        io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n        String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        // store date information\n        accessToken.setCreatedAt(new Date());\n        accessToken.setUpdatedAt(accessToken.getCreatedAt());\n\n        // TODO move to async call\n        tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n    }\n\n    @Override\n    public OAuth2AccessToken readAccessToken(String tokenValue) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.readAccessToken(tokenValue).blockingGet());\n\n        if (oAuth2AccessToken.isPresent()) {\n            return convert(oAuth2AccessToken.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void removeAccessToken(OAuth2AccessToken token) {\n        // TODO move to async call\n        tokenRepository.removeAccessToken(convert(token)).subscribe();\n    }\n\n    @Override\n    public void storeRefreshToken(OAuth2RefreshToken _refreshToken, OAuth2Authentication authentication) {\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken refreshToken = convert(_refreshToken);\n\n        // store date information\n        refreshToken.setCreatedAt(new Date());\n        refreshToken.setUpdatedAt(refreshToken.getCreatedAt());\n\n        // TODO move to async call\n        tokenRepository.storeRefreshToken(refreshToken, RepositoryProviderUtils.convert(authentication)).subscribe();\n    }\n\n    @Override\n    public OAuth2RefreshToken readRefreshToken(String tokenValue) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken> oAuth2RefreshToken\n                = Optional.ofNullable(tokenRepository.readRefreshToken(tokenValue).blockingGet());\n\n        if(oAuth2RefreshToken.isPresent()) {\n            return convert(oAuth2RefreshToken.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public OAuth2Authentication readAuthenticationForRefreshToken(OAuth2RefreshToken token) {\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n                = Optional.ofNullable(tokenRepository.readAuthenticationForRefreshToken(convert(token)).blockingGet());\n\n        if (oAuth2Authentication.isPresent()) {\n            return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void removeRefreshToken(OAuth2RefreshToken token) {\n        // TODO move to async call\n        tokenRepository.removeRefreshToken(convert(token)).subscribe();\n    }\n\n    @Override\n    public void removeAccessTokenUsingRefreshToken(OAuth2RefreshToken refreshToken) {\n        tokenRepository.removeAccessTokenUsingRefreshToken(convert(refreshToken));\n    }\n\n    @Override\n    public OAuth2AccessToken getAccessToken(OAuth2Authentication authentication) {\n        // extract authentication key\n        io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n        String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        // get access token\n        // TODO move to async call\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.getAccessToken(authenticationKey).blockingGet());\n\n        if (oAuth2AccessToken.isPresent()) {\n            io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = oAuth2AccessToken.get();\n            Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> optExtractedAuthentication = Optional.ofNullable(tokenRepository.readAuthentication(accessToken.getValue()).blockingGet());\n            if ((!optExtractedAuthentication.isPresent() || !authenticationKey.equals(authenticationKeyGenerator.extractKey(optExtractedAuthentication.get())))) {\n                // TODO move to async call\n                tokenRepository.removeAccessToken(accessToken.getValue()).subscribe();\n                // Keep the store consistent (maybe the same user is represented by this authentication but the details have\n                // changed)\n                // TODO move to async call\n                tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n\n                // something happens with authentication (different serialization object)\n                // Keep the refresh token consistent\n                if (!optExtractedAuthentication.isPresent() && accessToken.getRefreshToken() != null) {\n                    // TODO move to async call\n                    tokenRepository.storeRefreshToken(accessToken.getRefreshToken(), oAuth2Authentication).subscribe();\n                }\n            }\n            return convert(accessToken);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public Collection<OAuth2AccessToken> findTokensByClientIdAndUserName(String clientId, String userName) {\n        // TODO move to async call\n        Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n                tokenRepository.findTokensByClientIdAndUserName(clientId, userName).blockingGet();\n\n        if (accessTokens != null) {\n            return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    @Override\n    public Collection<OAuth2AccessToken> findTokensByClientId(String clientId) {\n        // TODO move to async call\n        Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n                tokenRepository.findTokensByClientId(clientId).blockingGet();\n\n        if (accessTokens != null) {\n            return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    private io.gravitee.am.repository.oauth2.model.OAuth2AccessToken convert(OAuth2AccessToken _oAuth2AccessToken) {\n        io.gravitee.am.repository.oauth2.model.OAuth2AccessToken oAuth2AccessToken =\n                new io.gravitee.am.repository.oauth2.model.OAuth2AccessToken(_oAuth2AccessToken.getValue());\n        oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n        oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n        oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n        oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n        // refresh token\n        OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n        if (_oAuth2RefreshToken != null) {\n            io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken =\n                    new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue());\n            if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n                Date expiration = ((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration();\n                oAuth2RefreshToken.setExpiration(expiration);\n            }\n            oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n        }\n\n        return oAuth2AccessToken;\n    }\n\n    private OAuth2AccessToken convert(io.gravitee.am.repository.oauth2.model.OAuth2AccessToken _oAuth2AccessToken) {\n        DefaultOAuth2AccessToken oAuth2AccessToken = new DefaultOAuth2AccessToken(_oAuth2AccessToken.getValue());\n        oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n        oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n        oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n        oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n        // refresh token\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n        if (_oAuth2RefreshToken != null) {\n            DefaultExpiringOAuth2RefreshToken oAuth2RefreshToken =\n                    new DefaultExpiringOAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue(), _oAuth2AccessToken.getRefreshToken().getExpiration());\n            oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n        }\n\n        return oAuth2AccessToken;\n    }\n\n    private io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken convert(OAuth2RefreshToken _oAuth2RefreshToken) {\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken = new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2RefreshToken.getValue());\n        if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n            oAuth2RefreshToken.setExpiration(((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration());\n        }\n        return oAuth2RefreshToken;\n    }\n\n    private OAuth2RefreshToken convert(io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken _oAuth2RefreshToken) {\n        return new DefaultExpiringOAuth2RefreshToken(_oAuth2RefreshToken.getValue(), _oAuth2RefreshToken.getExpiration());\n    }\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 268,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic OAuth2Authentication readAuthentication(OAuth2AccessToken token) {\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n            = Optional.ofNullable(tokenRepository.readAuthentication(convert(token)).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "name": "readAuthentication",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2Authentication",
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "token"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n            = Optional.ofNullable(tokenRepository.readAuthentication(convert(token)).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 47,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2Authentication readAuthentication(String token) {\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n            = Optional.ofNullable(tokenRepository.readAuthentication(token).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "name": "readAuthentication",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2Authentication",
                "parameters": [
                    {
                        "type": "String",
                        "name": "token"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n            = Optional.ofNullable(tokenRepository.readAuthentication(token).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void storeAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {\n    io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = convert(token);\n\n    // extract authentication key\n    io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n    String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    // store date information\n    accessToken.setCreatedAt(new Date());\n    accessToken.setUpdatedAt(accessToken.getCreatedAt());\n\n    // TODO move to async call\n    tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n}",
                "name": "storeAccessToken",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "token"
                    },
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = convert(token);\n\n    // extract authentication key\n    io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n    String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    // store date information\n    accessToken.setCreatedAt(new Date());\n    accessToken.setUpdatedAt(accessToken.getCreatedAt());\n\n    // TODO move to async call\n    tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 87,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2AccessToken readAccessToken(String tokenValue) {\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.readAccessToken(tokenValue).blockingGet());\n\n    if (oAuth2AccessToken.isPresent()) {\n        return convert(oAuth2AccessToken.get());\n    } else {\n        return null;\n    }\n}",
                "name": "readAccessToken",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2AccessToken",
                "parameters": [
                    {
                        "type": "String",
                        "name": "tokenValue"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.readAccessToken(tokenValue).blockingGet());\n\n    if (oAuth2AccessToken.isPresent()) {\n        return convert(oAuth2AccessToken.get());\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 89,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void removeAccessToken(OAuth2AccessToken token) {\n    // TODO move to async call\n    tokenRepository.removeAccessToken(convert(token)).subscribe();\n}",
                "name": "removeAccessToken",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "token"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    tokenRepository.removeAccessToken(convert(token)).subscribe();\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 105,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void storeRefreshToken(OAuth2RefreshToken _refreshToken, OAuth2Authentication authentication) {\n    io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken refreshToken = convert(_refreshToken);\n\n    // store date information\n    refreshToken.setCreatedAt(new Date());\n    refreshToken.setUpdatedAt(refreshToken.getCreatedAt());\n\n    // TODO move to async call\n    tokenRepository.storeRefreshToken(refreshToken, RepositoryProviderUtils.convert(authentication)).subscribe();\n}",
                "name": "storeRefreshToken",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2RefreshToken",
                        "name": "_refreshToken"
                    },
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken refreshToken = convert(_refreshToken);\n\n    // store date information\n    refreshToken.setCreatedAt(new Date());\n    refreshToken.setUpdatedAt(refreshToken.getCreatedAt());\n\n    // TODO move to async call\n    tokenRepository.storeRefreshToken(refreshToken, RepositoryProviderUtils.convert(authentication)).subscribe();\n}",
                "start_point": {
                    "row": 107,
                    "column": 4
                },
                "end_point": {
                    "row": 117,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2RefreshToken readRefreshToken(String tokenValue) {\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken> oAuth2RefreshToken\n            = Optional.ofNullable(tokenRepository.readRefreshToken(tokenValue).blockingGet());\n\n    if(oAuth2RefreshToken.isPresent()) {\n        return convert(oAuth2RefreshToken.get());\n    } else {\n        return null;\n    }\n}",
                "name": "readRefreshToken",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2RefreshToken",
                "parameters": [
                    {
                        "type": "String",
                        "name": "tokenValue"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken> oAuth2RefreshToken\n            = Optional.ofNullable(tokenRepository.readRefreshToken(tokenValue).blockingGet());\n\n    if(oAuth2RefreshToken.isPresent()) {\n        return convert(oAuth2RefreshToken.get());\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 130,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2Authentication readAuthenticationForRefreshToken(OAuth2RefreshToken token) {\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n            = Optional.ofNullable(tokenRepository.readAuthenticationForRefreshToken(convert(token)).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "name": "readAuthenticationForRefreshToken",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2Authentication",
                "parameters": [
                    {
                        "type": "OAuth2RefreshToken",
                        "name": "token"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> oAuth2Authentication\n            = Optional.ofNullable(tokenRepository.readAuthenticationForRefreshToken(convert(token)).blockingGet());\n\n    if (oAuth2Authentication.isPresent()) {\n        return RepositoryProviderUtils.convert(oAuth2Authentication.get());\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 132,
                    "column": 4
                },
                "end_point": {
                    "row": 143,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void removeRefreshToken(OAuth2RefreshToken token) {\n    // TODO move to async call\n    tokenRepository.removeRefreshToken(convert(token)).subscribe();\n}",
                "name": "removeRefreshToken",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2RefreshToken",
                        "name": "token"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    tokenRepository.removeRefreshToken(convert(token)).subscribe();\n}",
                "start_point": {
                    "row": 145,
                    "column": 4
                },
                "end_point": {
                    "row": 149,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void removeAccessTokenUsingRefreshToken(OAuth2RefreshToken refreshToken) {\n    tokenRepository.removeAccessTokenUsingRefreshToken(convert(refreshToken));\n}",
                "name": "removeAccessTokenUsingRefreshToken",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2RefreshToken",
                        "name": "refreshToken"
                    }
                ],
                "body": "{\n    tokenRepository.removeAccessTokenUsingRefreshToken(convert(refreshToken));\n}",
                "start_point": {
                    "row": 151,
                    "column": 4
                },
                "end_point": {
                    "row": 154,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic OAuth2AccessToken getAccessToken(OAuth2Authentication authentication) {\n    // extract authentication key\n    io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n    String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    // get access token\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.getAccessToken(authenticationKey).blockingGet());\n\n    if (oAuth2AccessToken.isPresent()) {\n        io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = oAuth2AccessToken.get();\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> optExtractedAuthentication = Optional.ofNullable(tokenRepository.readAuthentication(accessToken.getValue()).blockingGet());\n        if ((!optExtractedAuthentication.isPresent() || !authenticationKey.equals(authenticationKeyGenerator.extractKey(optExtractedAuthentication.get())))) {\n            // TODO move to async call\n            tokenRepository.removeAccessToken(accessToken.getValue()).subscribe();\n            // Keep the store consistent (maybe the same user is represented by this authentication but the details have\n            // changed)\n            // TODO move to async call\n            tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n\n            // something happens with authentication (different serialization object)\n            // Keep the refresh token consistent\n            if (!optExtractedAuthentication.isPresent() && accessToken.getRefreshToken() != null) {\n                // TODO move to async call\n                tokenRepository.storeRefreshToken(accessToken.getRefreshToken(), oAuth2Authentication).subscribe();\n            }\n        }\n        return convert(accessToken);\n    } else {\n        return null;\n    }\n}",
                "name": "getAccessToken",
                "modifiers": "@Override\n    public",
                "return_type": "OAuth2AccessToken",
                "parameters": [
                    {
                        "type": "OAuth2Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    // extract authentication key\n    io.gravitee.am.repository.oauth2.model.OAuth2Authentication oAuth2Authentication = RepositoryProviderUtils.convert(authentication);\n    String authenticationKey = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    // get access token\n    // TODO move to async call\n    Optional<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> oAuth2AccessToken = Optional.ofNullable(tokenRepository.getAccessToken(authenticationKey).blockingGet());\n\n    if (oAuth2AccessToken.isPresent()) {\n        io.gravitee.am.repository.oauth2.model.OAuth2AccessToken accessToken = oAuth2AccessToken.get();\n        Optional<io.gravitee.am.repository.oauth2.model.OAuth2Authentication> optExtractedAuthentication = Optional.ofNullable(tokenRepository.readAuthentication(accessToken.getValue()).blockingGet());\n        if ((!optExtractedAuthentication.isPresent() || !authenticationKey.equals(authenticationKeyGenerator.extractKey(optExtractedAuthentication.get())))) {\n            // TODO move to async call\n            tokenRepository.removeAccessToken(accessToken.getValue()).subscribe();\n            // Keep the store consistent (maybe the same user is represented by this authentication but the details have\n            // changed)\n            // TODO move to async call\n            tokenRepository.storeAccessToken(accessToken, oAuth2Authentication, authenticationKey).subscribe();\n\n            // something happens with authentication (different serialization object)\n            // Keep the refresh token consistent\n            if (!optExtractedAuthentication.isPresent() && accessToken.getRefreshToken() != null) {\n                // TODO move to async call\n                tokenRepository.storeRefreshToken(accessToken.getRefreshToken(), oAuth2Authentication).subscribe();\n            }\n        }\n        return convert(accessToken);\n    } else {\n        return null;\n    }\n}",
                "start_point": {
                    "row": 156,
                    "column": 4
                },
                "end_point": {
                    "row": 188,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Collection<OAuth2AccessToken> findTokensByClientIdAndUserName(String clientId, String userName) {\n    // TODO move to async call\n    Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n            tokenRepository.findTokensByClientIdAndUserName(clientId, userName).blockingGet();\n\n    if (accessTokens != null) {\n        return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}",
                "name": "findTokensByClientIdAndUserName",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "clientId"
                    },
                    {
                        "type": "String",
                        "name": "userName"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n            tokenRepository.findTokensByClientIdAndUserName(clientId, userName).blockingGet();\n\n    if (accessTokens != null) {\n        return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}",
                "start_point": {
                    "row": 190,
                    "column": 4
                },
                "end_point": {
                    "row": 201,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Collection<OAuth2AccessToken> findTokensByClientId(String clientId) {\n    // TODO move to async call\n    Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n            tokenRepository.findTokensByClientId(clientId).blockingGet();\n\n    if (accessTokens != null) {\n        return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}",
                "name": "findTokensByClientId",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "String",
                        "name": "clientId"
                    }
                ],
                "body": "{\n    // TODO move to async call\n    Collection<io.gravitee.am.repository.oauth2.model.OAuth2AccessToken> accessTokens =\n            tokenRepository.findTokensByClientId(clientId).blockingGet();\n\n    if (accessTokens != null) {\n        return accessTokens.stream().map(this::convert).collect(Collectors.toList());\n    } else {\n        return Collections.emptyList();\n    }\n}",
                "start_point": {
                    "row": 203,
                    "column": 4
                },
                "end_point": {
                    "row": 214,
                    "column": 5
                }
            },
            {
                "definition": "private io.gravitee.am.repository.oauth2.model.OAuth2AccessToken convert(OAuth2AccessToken _oAuth2AccessToken) {\n    io.gravitee.am.repository.oauth2.model.OAuth2AccessToken oAuth2AccessToken =\n            new io.gravitee.am.repository.oauth2.model.OAuth2AccessToken(_oAuth2AccessToken.getValue());\n    oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n    oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n    oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n    oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n    // refresh token\n    OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n    if (_oAuth2RefreshToken != null) {\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken =\n                new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue());\n        if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n            Date expiration = ((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration();\n            oAuth2RefreshToken.setExpiration(expiration);\n        }\n        oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n    }\n\n    return oAuth2AccessToken;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2AccessToken",
                        "name": "_oAuth2AccessToken"
                    }
                ],
                "body": "{\n    io.gravitee.am.repository.oauth2.model.OAuth2AccessToken oAuth2AccessToken =\n            new io.gravitee.am.repository.oauth2.model.OAuth2AccessToken(_oAuth2AccessToken.getValue());\n    oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n    oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n    oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n    oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n    // refresh token\n    OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n    if (_oAuth2RefreshToken != null) {\n        io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken =\n                new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue());\n        if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n            Date expiration = ((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration();\n            oAuth2RefreshToken.setExpiration(expiration);\n        }\n        oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n    }\n\n    return oAuth2AccessToken;\n}",
                "start_point": {
                    "row": 216,
                    "column": 4
                },
                "end_point": {
                    "row": 237,
                    "column": 5
                }
            },
            {
                "definition": "private OAuth2AccessToken convert(io.gravitee.am.repository.oauth2.model.OAuth2AccessToken _oAuth2AccessToken) {\n    DefaultOAuth2AccessToken oAuth2AccessToken = new DefaultOAuth2AccessToken(_oAuth2AccessToken.getValue());\n    oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n    oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n    oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n    oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n    // refresh token\n    io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n    if (_oAuth2RefreshToken != null) {\n        DefaultExpiringOAuth2RefreshToken oAuth2RefreshToken =\n                new DefaultExpiringOAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue(), _oAuth2AccessToken.getRefreshToken().getExpiration());\n        oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n    }\n\n    return oAuth2AccessToken;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "OAuth2AccessToken",
                "parameters": [
                    {
                        "type": "io.gravitee.am.repository.oauth2.model.OAuth2AccessToken",
                        "name": "_oAuth2AccessToken"
                    }
                ],
                "body": "{\n    DefaultOAuth2AccessToken oAuth2AccessToken = new DefaultOAuth2AccessToken(_oAuth2AccessToken.getValue());\n    oAuth2AccessToken.setAdditionalInformation(_oAuth2AccessToken.getAdditionalInformation());\n    oAuth2AccessToken.setExpiration(_oAuth2AccessToken.getExpiration());\n    oAuth2AccessToken.setScope(_oAuth2AccessToken.getScope());\n    oAuth2AccessToken.setTokenType(_oAuth2AccessToken.getTokenType());\n\n    // refresh token\n    io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken _oAuth2RefreshToken = _oAuth2AccessToken.getRefreshToken();\n    if (_oAuth2RefreshToken != null) {\n        DefaultExpiringOAuth2RefreshToken oAuth2RefreshToken =\n                new DefaultExpiringOAuth2RefreshToken(_oAuth2AccessToken.getRefreshToken().getValue(), _oAuth2AccessToken.getRefreshToken().getExpiration());\n        oAuth2AccessToken.setRefreshToken(oAuth2RefreshToken);\n    }\n\n    return oAuth2AccessToken;\n}",
                "start_point": {
                    "row": 239,
                    "column": 4
                },
                "end_point": {
                    "row": 255,
                    "column": 5
                }
            },
            {
                "definition": "private io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken convert(OAuth2RefreshToken _oAuth2RefreshToken) {\n    io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken = new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2RefreshToken.getValue());\n    if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n        oAuth2RefreshToken.setExpiration(((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration());\n    }\n    return oAuth2RefreshToken;\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": null,
                "parameters": [
                    {
                        "type": "OAuth2RefreshToken",
                        "name": "_oAuth2RefreshToken"
                    }
                ],
                "body": "{\n    io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken oAuth2RefreshToken = new io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken(_oAuth2RefreshToken.getValue());\n    if (_oAuth2RefreshToken instanceof DefaultExpiringOAuth2RefreshToken) {\n        oAuth2RefreshToken.setExpiration(((DefaultExpiringOAuth2RefreshToken) _oAuth2RefreshToken).getExpiration());\n    }\n    return oAuth2RefreshToken;\n}",
                "start_point": {
                    "row": 257,
                    "column": 4
                },
                "end_point": {
                    "row": 263,
                    "column": 5
                }
            },
            {
                "definition": "private OAuth2RefreshToken convert(io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken _oAuth2RefreshToken) {\n    return new DefaultExpiringOAuth2RefreshToken(_oAuth2RefreshToken.getValue(), _oAuth2RefreshToken.getExpiration());\n}",
                "name": "convert",
                "modifiers": "private",
                "return_type": "OAuth2RefreshToken",
                "parameters": [
                    {
                        "type": "io.gravitee.am.repository.oauth2.model.OAuth2RefreshToken",
                        "name": "_oAuth2RefreshToken"
                    }
                ],
                "body": "{\n    return new DefaultExpiringOAuth2RefreshToken(_oAuth2RefreshToken.getValue(), _oAuth2RefreshToken.getExpiration());\n}",
                "start_point": {
                    "row": 265,
                    "column": 4
                },
                "end_point": {
                    "row": 267,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/impl/CertificateManagerImpl.java",
        "definition": "public class CertificateManagerImpl implements CertificateManager, InitializingBean {\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(CertificateManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private CertificatePluginManager certificatePluginManager;\n\n    @Autowired\n    private CertificateService certificateService;\n\n    private Map<String, CertificateProvider> certificateProviders = new HashMap<>();\n\n    @Override\n    public CertificateProvider get(String id) {\n        return certificateProviders.get(id);\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing certificates for domain {}\", domain.getName());\n        // TODO async call\n        List<Certificate> certificates = certificateService.findByDomain(domain.getId()).blockingGet();\n\n        certificates.forEach(certificate -> {\n            logger.info(\"\\tInitializing certificate: {} [{}]\", certificate.getName(), certificate.getType());\n\n            CertificateProvider certificateProvider =\n                    certificatePluginManager.create(certificate.getType(), certificate.getConfiguration());\n            certificateProviders.put(certificate.getId(), certificateProvider);\n        });\n\n        certificateService.setCertificateProviders(domain.getId(), certificateProviders);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.security.impl;",
        "tree_path": "CertificateManagerImpl",
        "name": "CertificateManagerImpl",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements CertificateManager, InitializingBean",
        "body": "{\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(CertificateManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private CertificatePluginManager certificatePluginManager;\n\n    @Autowired\n    private CertificateService certificateService;\n\n    private Map<String, CertificateProvider> certificateProviders = new HashMap<>();\n\n    @Override\n    public CertificateProvider get(String id) {\n        return certificateProviders.get(id);\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing certificates for domain {}\", domain.getName());\n        // TODO async call\n        List<Certificate> certificates = certificateService.findByDomain(domain.getId()).blockingGet();\n\n        certificates.forEach(certificate -> {\n            logger.info(\"\\tInitializing certificate: {} [{}]\", certificate.getName(), certificate.getType());\n\n            CertificateProvider certificateProvider =\n                    certificatePluginManager.create(certificate.getType(), certificate.getConfiguration());\n            certificateProviders.put(certificate.getId(), certificateProvider);\n        });\n\n        certificateService.setCertificateProviders(domain.getId(), certificateProviders);\n    }\n}",
        "start_point": {
            "row": 36,
            "column": 0
        },
        "end_point": {
            "row": 75,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic CertificateProvider get(String id) {\n    return certificateProviders.get(id);\n}",
                "name": "get",
                "modifiers": "@Override\n    public",
                "return_type": "CertificateProvider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return certificateProviders.get(id);\n}",
                "start_point": {
                    "row": 54,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void afterPropertiesSet() throws Exception {\n    logger.info(\"Initializing certificates for domain {}\", domain.getName());\n    // TODO async call\n    List<Certificate> certificates = certificateService.findByDomain(domain.getId()).blockingGet();\n\n    certificates.forEach(certificate -> {\n        logger.info(\"\\tInitializing certificate: {} [{}]\", certificate.getName(), certificate.getType());\n\n        CertificateProvider certificateProvider =\n                certificatePluginManager.create(certificate.getType(), certificate.getConfiguration());\n        certificateProviders.put(certificate.getId(), certificateProvider);\n    });\n\n    certificateService.setCertificateProviders(domain.getId(), certificateProviders);\n}",
                "name": "afterPropertiesSet",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Initializing certificates for domain {}\", domain.getName());\n    // TODO async call\n    List<Certificate> certificates = certificateService.findByDomain(domain.getId()).blockingGet();\n\n    certificates.forEach(certificate -> {\n        logger.info(\"\\tInitializing certificate: {} [{}]\", certificate.getName(), certificate.getType());\n\n        CertificateProvider certificateProvider =\n                certificatePluginManager.create(certificate.getType(), certificate.getConfiguration());\n        certificateProviders.put(certificate.getId(), certificateProvider);\n    });\n\n    certificateService.setCertificateProviders(domain.getId(), certificateProviders);\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 74,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/impl/ExtensionGrantManagerImpl.java",
        "definition": "public class ExtensionGrantManagerImpl implements ExtensionGrantManager, InitializingBean {\n\n    private final Logger logger = LoggerFactory.getLogger(ExtensionGrantManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private ExtensionGrantPluginManager extensionGrantPluginManager;\n\n    @Autowired\n    private ExtensionGrantService extensionGrantService;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    private Map<String, ExtensionGrantProvider> providers = new HashMap<>();\n\n    private Map<String, ExtensionGrant> grantTypes = new HashMap<>();\n\n    @Override\n    public ExtensionGrantProvider get(String id) {\n        return providers.get(id);\n    }\n\n    @Override\n    public ExtensionGrant getTokenGranter(String id) {\n        return grantTypes.get(id);\n    }\n\n    @Override\n    public Map<String, ExtensionGrantProvider> providers() {\n        return providers;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing extension grants for domain {}\", domain.getName());\n        // TODO async call\n        List<ExtensionGrant> extensionGrants = extensionGrantService.findByDomain(domain.getId()).blockingGet();\n\n        extensionGrants.forEach(extensionGrant -> {\n            logger.info(\"\\tInitializing extension grant : {} [{}]\", extensionGrant.getName(), extensionGrant.getType());\n\n            AuthenticationProvider authenticationProvider = null;\n            if (extensionGrant.getIdentityProvider() != null) {\n                logger.info(\"\\tLooking for extension grant identity provider: {}\", extensionGrant.getIdentityProvider());\n                authenticationProvider = identityProviderManager.get(extensionGrant.getIdentityProvider());\n                if (authenticationProvider != null) {\n                    logger.info(\"\\tExtension grant identity provider: {}, loaded\", extensionGrant.getIdentityProvider());\n                }\n            }\n\n            ExtensionGrantProvider extensionGrantProvider =\n                    extensionGrantPluginManager.create(extensionGrant.getType(), extensionGrant.getConfiguration(), authenticationProvider);\n            grantTypes.put(extensionGrant.getId(), extensionGrant);\n            providers.put(extensionGrant.getId(), extensionGrantProvider);\n        });\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.security.impl;",
        "tree_path": "ExtensionGrantManagerImpl",
        "name": "ExtensionGrantManagerImpl",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements ExtensionGrantManager, InitializingBean",
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(ExtensionGrantManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private ExtensionGrantPluginManager extensionGrantPluginManager;\n\n    @Autowired\n    private ExtensionGrantService extensionGrantService;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    private Map<String, ExtensionGrantProvider> providers = new HashMap<>();\n\n    private Map<String, ExtensionGrant> grantTypes = new HashMap<>();\n\n    @Override\n    public ExtensionGrantProvider get(String id) {\n        return providers.get(id);\n    }\n\n    @Override\n    public ExtensionGrant getTokenGranter(String id) {\n        return grantTypes.get(id);\n    }\n\n    @Override\n    public Map<String, ExtensionGrantProvider> providers() {\n        return providers;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing extension grants for domain {}\", domain.getName());\n        // TODO async call\n        List<ExtensionGrant> extensionGrants = extensionGrantService.findByDomain(domain.getId()).blockingGet();\n\n        extensionGrants.forEach(extensionGrant -> {\n            logger.info(\"\\tInitializing extension grant : {} [{}]\", extensionGrant.getName(), extensionGrant.getType());\n\n            AuthenticationProvider authenticationProvider = null;\n            if (extensionGrant.getIdentityProvider() != null) {\n                logger.info(\"\\tLooking for extension grant identity provider: {}\", extensionGrant.getIdentityProvider());\n                authenticationProvider = identityProviderManager.get(extensionGrant.getIdentityProvider());\n                if (authenticationProvider != null) {\n                    logger.info(\"\\tExtension grant identity provider: {}, loaded\", extensionGrant.getIdentityProvider());\n                }\n            }\n\n            ExtensionGrantProvider extensionGrantProvider =\n                    extensionGrantPluginManager.create(extensionGrant.getType(), extensionGrant.getConfiguration(), authenticationProvider);\n            grantTypes.put(extensionGrant.getId(), extensionGrant);\n            providers.put(extensionGrant.getId(), extensionGrantProvider);\n        });\n    }\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 97,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic ExtensionGrantProvider get(String id) {\n    return providers.get(id);\n}",
                "name": "get",
                "modifiers": "@Override\n    public",
                "return_type": "ExtensionGrantProvider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return providers.get(id);\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic ExtensionGrant getTokenGranter(String id) {\n    return grantTypes.get(id);\n}",
                "name": "getTokenGranter",
                "modifiers": "@Override\n    public",
                "return_type": "ExtensionGrant",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return grantTypes.get(id);\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 66,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Map<String, ExtensionGrantProvider> providers() {\n    return providers;\n}",
                "name": "providers",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return providers;\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void afterPropertiesSet() throws Exception {\n    logger.info(\"Initializing extension grants for domain {}\", domain.getName());\n    // TODO async call\n    List<ExtensionGrant> extensionGrants = extensionGrantService.findByDomain(domain.getId()).blockingGet();\n\n    extensionGrants.forEach(extensionGrant -> {\n        logger.info(\"\\tInitializing extension grant : {} [{}]\", extensionGrant.getName(), extensionGrant.getType());\n\n        AuthenticationProvider authenticationProvider = null;\n        if (extensionGrant.getIdentityProvider() != null) {\n            logger.info(\"\\tLooking for extension grant identity provider: {}\", extensionGrant.getIdentityProvider());\n            authenticationProvider = identityProviderManager.get(extensionGrant.getIdentityProvider());\n            if (authenticationProvider != null) {\n                logger.info(\"\\tExtension grant identity provider: {}, loaded\", extensionGrant.getIdentityProvider());\n            }\n        }\n\n        ExtensionGrantProvider extensionGrantProvider =\n                extensionGrantPluginManager.create(extensionGrant.getType(), extensionGrant.getConfiguration(), authenticationProvider);\n        grantTypes.put(extensionGrant.getId(), extensionGrant);\n        providers.put(extensionGrant.getId(), extensionGrantProvider);\n    });\n}",
                "name": "afterPropertiesSet",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Initializing extension grants for domain {}\", domain.getName());\n    // TODO async call\n    List<ExtensionGrant> extensionGrants = extensionGrantService.findByDomain(domain.getId()).blockingGet();\n\n    extensionGrants.forEach(extensionGrant -> {\n        logger.info(\"\\tInitializing extension grant : {} [{}]\", extensionGrant.getName(), extensionGrant.getType());\n\n        AuthenticationProvider authenticationProvider = null;\n        if (extensionGrant.getIdentityProvider() != null) {\n            logger.info(\"\\tLooking for extension grant identity provider: {}\", extensionGrant.getIdentityProvider());\n            authenticationProvider = identityProviderManager.get(extensionGrant.getIdentityProvider());\n            if (authenticationProvider != null) {\n                logger.info(\"\\tExtension grant identity provider: {}, loaded\", extensionGrant.getIdentityProvider());\n            }\n        }\n\n        ExtensionGrantProvider extensionGrantProvider =\n                extensionGrantPluginManager.create(extensionGrant.getType(), extensionGrant.getConfiguration(), authenticationProvider);\n        grantTypes.put(extensionGrant.getId(), extensionGrant);\n        providers.put(extensionGrant.getId(), extensionGrantProvider);\n    });\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 96,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/service/DomainScopeService.java",
        "definition": "@Component\npublic class DomainScopeService {\n\n    private final Logger logger = LoggerFactory.getLogger(DomainScopeService.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    public Set<Scope> getAll() {\n        logger.debug(\"Loading scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n        // TODO async call\n        return scopeService.findByDomain(domain.getId()).blockingGet();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.service;",
        "tree_path": "DomainScopeService",
        "name": "DomainScopeService",
        "modifiers": "@Component\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(DomainScopeService.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private ScopeService scopeService;\n\n    public Set<Scope> getAll() {\n        logger.debug(\"Loading scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n        // TODO async call\n        return scopeService.findByDomain(domain.getId()).blockingGet();\n    }\n}",
        "start_point": {
            "row": 31,
            "column": 0
        },
        "end_point": {
            "row": 47,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public Set<Scope> getAll() {\n    logger.debug(\"Loading scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n    // TODO async call\n    return scopeService.findByDomain(domain.getId()).blockingGet();\n}",
                "name": "getAll",
                "modifiers": "public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.debug(\"Loading scopes for domain id[{}] name[{}]\", domain.getId(), domain.getName());\n    // TODO async call\n    return scopeService.findByDomain(domain.getId()).blockingGet();\n}",
                "start_point": {
                    "row": 42,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/spring/OAuth2Configuration.java",
        "definition": "@Configuration\n@Import({\n        WebMvcConfiguration.class,\n        AuthorizationServerConfiguration.class,\n        OAuth2SecurityConfiguration.class,\n        OpenIDResourceServerConfiguration.class\n})\npublic class OAuth2Configuration {\n\n    @Bean\n    public ClientDetailsService clientDetailsService() {\n        return new DomainBasedClientDetailsService();\n    }\n\n    @Bean\n    public JwtKeyPairFactory jwtKeyPairFactory() {\n        return new JwtKeyPairFactory();\n    }\n\n    @Bean\n    public IdentityProviderManager identityProviderManager() {\n        return new IdentityProviderManagerImpl();\n    }\n\n    @Bean\n    public CertificateManager certificateManager() {\n        return new CertificateManagerImpl();\n    }\n\n    @Bean\n    public ExtensionGrantManager tokenGranterManager() {\n        return new ExtensionGrantManagerImpl();\n    }\n\n    @Bean\n    public DomainScopeService scopeService() {\n        return new DomainScopeService();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.spring;",
        "tree_path": "OAuth2Configuration",
        "name": "OAuth2Configuration",
        "modifiers": "@Configuration\n@Import({\n        WebMvcConfiguration.class,\n        AuthorizationServerConfiguration.class,\n        OAuth2SecurityConfiguration.class,\n        OpenIDResourceServerConfiguration.class\n})\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @Bean\n    public ClientDetailsService clientDetailsService() {\n        return new DomainBasedClientDetailsService();\n    }\n\n    @Bean\n    public JwtKeyPairFactory jwtKeyPairFactory() {\n        return new JwtKeyPairFactory();\n    }\n\n    @Bean\n    public IdentityProviderManager identityProviderManager() {\n        return new IdentityProviderManagerImpl();\n    }\n\n    @Bean\n    public CertificateManager certificateManager() {\n        return new CertificateManagerImpl();\n    }\n\n    @Bean\n    public ExtensionGrantManager tokenGranterManager() {\n        return new ExtensionGrantManagerImpl();\n    }\n\n    @Bean\n    public DomainScopeService scopeService() {\n        return new DomainScopeService();\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 77,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Bean\npublic ClientDetailsService clientDetailsService() {\n    return new DomainBasedClientDetailsService();\n}",
                "name": "clientDetailsService",
                "modifiers": "@Bean\n    public",
                "return_type": "ClientDetailsService",
                "parameters": [],
                "body": "{\n    return new DomainBasedClientDetailsService();\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic JwtKeyPairFactory jwtKeyPairFactory() {\n    return new JwtKeyPairFactory();\n}",
                "name": "jwtKeyPairFactory",
                "modifiers": "@Bean\n    public",
                "return_type": "JwtKeyPairFactory",
                "parameters": [],
                "body": "{\n    return new JwtKeyPairFactory();\n}",
                "start_point": {
                    "row": 53,
                    "column": 4
                },
                "end_point": {
                    "row": 56,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic IdentityProviderManager identityProviderManager() {\n    return new IdentityProviderManagerImpl();\n}",
                "name": "identityProviderManager",
                "modifiers": "@Bean\n    public",
                "return_type": "IdentityProviderManager",
                "parameters": [],
                "body": "{\n    return new IdentityProviderManagerImpl();\n}",
                "start_point": {
                    "row": 58,
                    "column": 4
                },
                "end_point": {
                    "row": 61,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic CertificateManager certificateManager() {\n    return new CertificateManagerImpl();\n}",
                "name": "certificateManager",
                "modifiers": "@Bean\n    public",
                "return_type": "CertificateManager",
                "parameters": [],
                "body": "{\n    return new CertificateManagerImpl();\n}",
                "start_point": {
                    "row": 63,
                    "column": 4
                },
                "end_point": {
                    "row": 66,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic ExtensionGrantManager tokenGranterManager() {\n    return new ExtensionGrantManagerImpl();\n}",
                "name": "tokenGranterManager",
                "modifiers": "@Bean\n    public",
                "return_type": "ExtensionGrantManager",
                "parameters": [],
                "body": "{\n    return new ExtensionGrantManagerImpl();\n}",
                "start_point": {
                    "row": 68,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic DomainScopeService scopeService() {\n    return new DomainScopeService();\n}",
                "name": "scopeService",
                "modifiers": "@Bean\n    public",
                "return_type": "DomainScopeService",
                "parameters": [],
                "body": "{\n    return new DomainScopeService();\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 76,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/userdetails/CustomUserDetails.java",
        "definition": "public class CustomUserDetails extends DefaultUser implements UserDetails, Serializable {\n\n    private static final long serialVersionUID = 1L;\n    private Collection<? extends GrantedAuthority> authorities;\n    private boolean accountNonExpired;\n    private boolean accountNonLocked;\n    private boolean credentialsNonExpired;\n\n    public CustomUserDetails(String username) {\n        super(username);\n    }\n\n    public CustomUserDetails(User user, io.gravitee.am.identityprovider.api.User idpUser) {\n        this(user.getUsername());\n        setAdditonalInformation(user.getAdditionalInformation());\n        setAccountExpired(!user.isAccountNonExpired());\n        setEnabled(user.isEnabled());\n        setRoles(idpUser.getRoles());\n        accountNonExpired = user.isAccountNonExpired();\n        accountNonLocked = user.isAccountNonLocked();\n        credentialsNonExpired = user.isCredentialsNonExpired();\n        if (idpUser.getRoles() != null) {\n            authorities = idpUser.getRoles().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());\n        }\n    }\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return \"\";\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return accountNonExpired;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return accountNonLocked;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return credentialsNonExpired;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.userdetails;",
        "tree_path": "CustomUserDetails",
        "name": "CustomUserDetails",
        "modifiers": "public",
        "superclass": "extends DefaultUser",
        "super_interfaces": "implements UserDetails, Serializable",
        "body": "{\n\n    private static final long serialVersionUID = 1L;\n    private Collection<? extends GrantedAuthority> authorities;\n    private boolean accountNonExpired;\n    private boolean accountNonLocked;\n    private boolean credentialsNonExpired;\n\n    public CustomUserDetails(String username) {\n        super(username);\n    }\n\n    public CustomUserDetails(User user, io.gravitee.am.identityprovider.api.User idpUser) {\n        this(user.getUsername());\n        setAdditonalInformation(user.getAdditionalInformation());\n        setAccountExpired(!user.isAccountNonExpired());\n        setEnabled(user.isEnabled());\n        setRoles(idpUser.getRoles());\n        accountNonExpired = user.isAccountNonExpired();\n        accountNonLocked = user.isAccountNonLocked();\n        credentialsNonExpired = user.isCredentialsNonExpired();\n        if (idpUser.getRoles() != null) {\n            authorities = idpUser.getRoles().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());\n        }\n    }\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return authorities;\n    }\n\n    @Override\n    public String getPassword() {\n        return \"\";\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return accountNonExpired;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return accountNonLocked;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return credentialsNonExpired;\n    }\n}",
        "start_point": {
            "row": 31,
            "column": 0
        },
        "end_point": {
            "row": 81,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "public CustomUserDetails(String username) {\n    super(username);\n}",
                "name": "CustomUserDetails",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    super(username);\n}",
                "constructor": true,
                "start_point": {
                    "row": 39,
                    "column": 4
                },
                "end_point": {
                    "row": 41,
                    "column": 5
                }
            },
            {
                "definition": "public CustomUserDetails(User user, io.gravitee.am.identityprovider.api.User idpUser) {\n    this(user.getUsername());\n    setAdditonalInformation(user.getAdditionalInformation());\n    setAccountExpired(!user.isAccountNonExpired());\n    setEnabled(user.isEnabled());\n    setRoles(idpUser.getRoles());\n    accountNonExpired = user.isAccountNonExpired();\n    accountNonLocked = user.isAccountNonLocked();\n    credentialsNonExpired = user.isCredentialsNonExpired();\n    if (idpUser.getRoles() != null) {\n        authorities = idpUser.getRoles().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());\n    }\n}",
                "name": "CustomUserDetails",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "User",
                        "name": "user"
                    },
                    {
                        "type": "io.gravitee.am.identityprovider.api.User",
                        "name": "idpUser"
                    }
                ],
                "body": "{\n    this(user.getUsername());\n    setAdditonalInformation(user.getAdditionalInformation());\n    setAccountExpired(!user.isAccountNonExpired());\n    setEnabled(user.isEnabled());\n    setRoles(idpUser.getRoles());\n    accountNonExpired = user.isAccountNonExpired();\n    accountNonLocked = user.isAccountNonLocked();\n    credentialsNonExpired = user.isCredentialsNonExpired();\n    if (idpUser.getRoles() != null) {\n        authorities = idpUser.getRoles().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());\n    }\n}",
                "constructor": true,
                "start_point": {
                    "row": 43,
                    "column": 4
                },
                "end_point": {
                    "row": 55,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Collection<? extends GrantedAuthority> getAuthorities() {\n    return authorities;\n}",
                "name": "getAuthorities",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return authorities;\n}",
                "start_point": {
                    "row": 57,
                    "column": 4
                },
                "end_point": {
                    "row": 60,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String getPassword() {\n    return \"\";\n}",
                "name": "getPassword",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return \"\";\n}",
                "start_point": {
                    "row": 62,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean isAccountNonExpired() {\n    return accountNonExpired;\n}",
                "name": "isAccountNonExpired",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return accountNonExpired;\n}",
                "start_point": {
                    "row": 67,
                    "column": 4
                },
                "end_point": {
                    "row": 70,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean isAccountNonLocked() {\n    return accountNonLocked;\n}",
                "name": "isAccountNonLocked",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return accountNonLocked;\n}",
                "start_point": {
                    "row": 72,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic boolean isCredentialsNonExpired() {\n    return credentialsNonExpired;\n}",
                "name": "isCredentialsNonExpired",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return credentialsNonExpired;\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 80,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/userdetails/CustomUserDetailsService.java",
        "definition": "public class CustomUserDetailsService implements UserDetailsService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(CustomUserDetailsService.class);\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // use to find a pre-authenticated user\n        // The user should be present in gravitee repository and should be retrieved from the user last identity provider\n        try {\n            User user;\n            try {\n                // TODO async call\n                user = userService.loadUserByUsernameAndDomain(domain.getId(), username).blockingGet();\n            } catch (UserNotFoundException e) {\n                LOGGER.info(\"User with username : {} and for domain : {} not found\", username, domain.getId(), e);\n                throw new UsernameNotFoundException(username);\n            } catch (TechnicalManagementException e) {\n                LOGGER.error(\"Failed to find user by username {} and domain {}\", username, domain.getId(), e);\n                throw new UsernameNotFoundException(username);\n            }\n\n            AuthenticationProvider authenticationprovider = identityProviderManager.get(user.getSource());\n\n            if (authenticationprovider == null) {\n                LOGGER.info(\"Registered identity provider : {} not found for username : {}\", user.getSource(), username);\n                throw new UsernameNotFoundException(\"Registered identity provider : \" + user.getSource() + \" not found for username : \" + username);\n            }\n\n            io.gravitee.am.identityprovider.api.User idpUser;\n            try {\n                idpUser = authenticationprovider.loadUserByUsername(username);\n            } catch (Exception e) {\n                LOGGER.info(\"User with username : {} and for domain : {} and identity provider : {} not found\", username, domain.getId(), user.getSource(), e);\n                throw new UsernameNotFoundException(username);\n            }\n\n            return new CustomUserDetails(user, idpUser);\n        } catch (UsernameNotFoundException e) {\n            LOGGER.info(\"User not found while obtaining a renewed access token, return default user\");\n            return new org.springframework.security.core.userdetails.User(username, \"\", Collections.emptyList());\n        }\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.userdetails;",
        "tree_path": "CustomUserDetailsService",
        "name": "CustomUserDetailsService",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements UserDetailsService",
        "body": "{\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(CustomUserDetailsService.class);\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // use to find a pre-authenticated user\n        // The user should be present in gravitee repository and should be retrieved from the user last identity provider\n        try {\n            User user;\n            try {\n                // TODO async call\n                user = userService.loadUserByUsernameAndDomain(domain.getId(), username).blockingGet();\n            } catch (UserNotFoundException e) {\n                LOGGER.info(\"User with username : {} and for domain : {} not found\", username, domain.getId(), e);\n                throw new UsernameNotFoundException(username);\n            } catch (TechnicalManagementException e) {\n                LOGGER.error(\"Failed to find user by username {} and domain {}\", username, domain.getId(), e);\n                throw new UsernameNotFoundException(username);\n            }\n\n            AuthenticationProvider authenticationprovider = identityProviderManager.get(user.getSource());\n\n            if (authenticationprovider == null) {\n                LOGGER.info(\"Registered identity provider : {} not found for username : {}\", user.getSource(), username);\n                throw new UsernameNotFoundException(\"Registered identity provider : \" + user.getSource() + \" not found for username : \" + username);\n            }\n\n            io.gravitee.am.identityprovider.api.User idpUser;\n            try {\n                idpUser = authenticationprovider.loadUserByUsername(username);\n            } catch (Exception e) {\n                LOGGER.info(\"User with username : {} and for domain : {} and identity provider : {} not found\", username, domain.getId(), user.getSource(), e);\n                throw new UsernameNotFoundException(username);\n            }\n\n            return new CustomUserDetails(user, idpUser);\n        } catch (UsernameNotFoundException e) {\n            LOGGER.info(\"User not found while obtaining a renewed access token, return default user\");\n            return new org.springframework.security.core.userdetails.User(username, \"\", Collections.emptyList());\n        }\n    }\n\n}",
        "start_point": {
            "row": 38,
            "column": 0
        },
        "end_point": {
            "row": 90,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Override\npublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n    // use to find a pre-authenticated user\n    // The user should be present in gravitee repository and should be retrieved from the user last identity provider\n    try {\n        User user;\n        try {\n            // TODO async call\n            user = userService.loadUserByUsernameAndDomain(domain.getId(), username).blockingGet();\n        } catch (UserNotFoundException e) {\n            LOGGER.info(\"User with username : {} and for domain : {} not found\", username, domain.getId(), e);\n            throw new UsernameNotFoundException(username);\n        } catch (TechnicalManagementException e) {\n            LOGGER.error(\"Failed to find user by username {} and domain {}\", username, domain.getId(), e);\n            throw new UsernameNotFoundException(username);\n        }\n\n        AuthenticationProvider authenticationprovider = identityProviderManager.get(user.getSource());\n\n        if (authenticationprovider == null) {\n            LOGGER.info(\"Registered identity provider : {} not found for username : {}\", user.getSource(), username);\n            throw new UsernameNotFoundException(\"Registered identity provider : \" + user.getSource() + \" not found for username : \" + username);\n        }\n\n        io.gravitee.am.identityprovider.api.User idpUser;\n        try {\n            idpUser = authenticationprovider.loadUserByUsername(username);\n        } catch (Exception e) {\n            LOGGER.info(\"User with username : {} and for domain : {} and identity provider : {} not found\", username, domain.getId(), user.getSource(), e);\n            throw new UsernameNotFoundException(username);\n        }\n\n        return new CustomUserDetails(user, idpUser);\n    } catch (UsernameNotFoundException e) {\n        LOGGER.info(\"User not found while obtaining a renewed access token, return default user\");\n        return new org.springframework.security.core.userdetails.User(username, \"\", Collections.emptyList());\n    }\n}",
                "name": "loadUserByUsername",
                "modifiers": "@Override\n    public",
                "return_type": "UserDetails",
                "parameters": [
                    {
                        "type": "String",
                        "name": "username"
                    }
                ],
                "body": "{\n    // use to find a pre-authenticated user\n    // The user should be present in gravitee repository and should be retrieved from the user last identity provider\n    try {\n        User user;\n        try {\n            // TODO async call\n            user = userService.loadUserByUsernameAndDomain(domain.getId(), username).blockingGet();\n        } catch (UserNotFoundException e) {\n            LOGGER.info(\"User with username : {} and for domain : {} not found\", username, domain.getId(), e);\n            throw new UsernameNotFoundException(username);\n        } catch (TechnicalManagementException e) {\n            LOGGER.error(\"Failed to find user by username {} and domain {}\", username, domain.getId(), e);\n            throw new UsernameNotFoundException(username);\n        }\n\n        AuthenticationProvider authenticationprovider = identityProviderManager.get(user.getSource());\n\n        if (authenticationprovider == null) {\n            LOGGER.info(\"Registered identity provider : {} not found for username : {}\", user.getSource(), username);\n            throw new UsernameNotFoundException(\"Registered identity provider : \" + user.getSource() + \" not found for username : \" + username);\n        }\n\n        io.gravitee.am.identityprovider.api.User idpUser;\n        try {\n            idpUser = authenticationprovider.loadUserByUsername(username);\n        } catch (Exception e) {\n            LOGGER.info(\"User with username : {} and for domain : {} and identity provider : {} not found\", username, domain.getId(), user.getSource(), e);\n            throw new UsernameNotFoundException(username);\n        }\n\n        return new CustomUserDetails(user, idpUser);\n    } catch (UsernameNotFoundException e) {\n        LOGGER.info(\"User not found while obtaining a renewed access token, return default user\");\n        return new org.springframework.security.core.userdetails.User(username, \"\", Collections.emptyList());\n    }\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 88,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/test/java/io/gravitee/am/management/handlers/oauth2/provider/code/RepositoryAuthorizationCodeServicesTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic class RepositoryAuthorizationCodeServicesTest {\n\n    @InjectMocks\n    private RepositoryAuthorizationCodeServices authorizationCodeServices = new RepositoryAuthorizationCodeServices();\n\n    @Mock\n    private AuthorizationCodeRepository authorizationCodeRepository;\n\n    @Mock\n    private OAuth2Authentication oAuth2Authentication;\n\n    @Mock\n    private OAuth2Request oAuth2Request;\n\n    @Test\n    public void shouldStore() {\n        // prepare OAuth2AuthorizationCode\n        final String codeId = \"test-code\";\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(authorizationCodeRepository.store(any(OAuth2AuthorizationCode.class))).thenReturn(Single.just(new OAuth2AuthorizationCode()));\n\n        // Run\n        authorizationCodeServices.store(codeId, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(authorizationCodeRepository, times(1)).store(any());\n    }\n\n    @Test\n    public void shouldRemove() {\n        // prepare OAuth2AuthorizationCode\n        final String codeId = \"test-code\";\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(authorizationCodeRepository.remove(codeId)).thenReturn(Maybe.just(oAuth2Authentication));\n\n        // Run\n        final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n                authorizationCodeServices.remove(codeId);\n\n        // Verify\n        verify(authorizationCodeRepository, times(1)).remove(codeId);\n        assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n    }\n\n    @Test(expected = InvalidGrantException.class)\n    public void shouldNotConsumeNonExistingCode() {\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n        oAuth2AuthorizationCode.setCode(\"test-code\");\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(authorizationCodeRepository.store(any())).thenReturn(Single.just(oAuth2AuthorizationCode));\n\n        // Run\n        String code = authorizationCodeServices.createAuthorizationCode(RepositoryProviderUtils.convert(oAuth2Authentication));\n        assertNotNull(code);\n        when(authorizationCodeRepository.remove(code)).thenReturn(Maybe.empty());\n        authorizationCodeServices.consumeAuthorizationCode(code);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.code;",
        "tree_path": "RepositoryAuthorizationCodeServicesTest",
        "name": "RepositoryAuthorizationCodeServicesTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private RepositoryAuthorizationCodeServices authorizationCodeServices = new RepositoryAuthorizationCodeServices();\n\n    @Mock\n    private AuthorizationCodeRepository authorizationCodeRepository;\n\n    @Mock\n    private OAuth2Authentication oAuth2Authentication;\n\n    @Mock\n    private OAuth2Request oAuth2Request;\n\n    @Test\n    public void shouldStore() {\n        // prepare OAuth2AuthorizationCode\n        final String codeId = \"test-code\";\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(authorizationCodeRepository.store(any(OAuth2AuthorizationCode.class))).thenReturn(Single.just(new OAuth2AuthorizationCode()));\n\n        // Run\n        authorizationCodeServices.store(codeId, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(authorizationCodeRepository, times(1)).store(any());\n    }\n\n    @Test\n    public void shouldRemove() {\n        // prepare OAuth2AuthorizationCode\n        final String codeId = \"test-code\";\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(authorizationCodeRepository.remove(codeId)).thenReturn(Maybe.just(oAuth2Authentication));\n\n        // Run\n        final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n                authorizationCodeServices.remove(codeId);\n\n        // Verify\n        verify(authorizationCodeRepository, times(1)).remove(codeId);\n        assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n    }\n\n    @Test(expected = InvalidGrantException.class)\n    public void shouldNotConsumeNonExistingCode() {\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n        oAuth2AuthorizationCode.setCode(\"test-code\");\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(authorizationCodeRepository.store(any())).thenReturn(Single.just(oAuth2AuthorizationCode));\n\n        // Run\n        String code = authorizationCodeServices.createAuthorizationCode(RepositoryProviderUtils.convert(oAuth2Authentication));\n        assertNotNull(code);\n        when(authorizationCodeRepository.remove(code)).thenReturn(Maybe.empty());\n        authorizationCodeServices.consumeAuthorizationCode(code);\n    }\n}",
        "start_point": {
            "row": 43,
            "column": 0
        },
        "end_point": {
            "row": 113,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldStore() {\n    // prepare OAuth2AuthorizationCode\n    final String codeId = \"test-code\";\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(authorizationCodeRepository.store(any(OAuth2AuthorizationCode.class))).thenReturn(Single.just(new OAuth2AuthorizationCode()));\n\n    // Run\n    authorizationCodeServices.store(codeId, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(authorizationCodeRepository, times(1)).store(any());\n}",
                "name": "shouldStore",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AuthorizationCode\n    final String codeId = \"test-code\";\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(authorizationCodeRepository.store(any(OAuth2AuthorizationCode.class))).thenReturn(Single.just(new OAuth2AuthorizationCode()));\n\n    // Run\n    authorizationCodeServices.store(codeId, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(authorizationCodeRepository, times(1)).store(any());\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 75,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldRemove() {\n    // prepare OAuth2AuthorizationCode\n    final String codeId = \"test-code\";\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(authorizationCodeRepository.remove(codeId)).thenReturn(Maybe.just(oAuth2Authentication));\n\n    // Run\n    final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n            authorizationCodeServices.remove(codeId);\n\n    // Verify\n    verify(authorizationCodeRepository, times(1)).remove(codeId);\n    assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n}",
                "name": "shouldRemove",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AuthorizationCode\n    final String codeId = \"test-code\";\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(authorizationCodeRepository.remove(codeId)).thenReturn(Maybe.just(oAuth2Authentication));\n\n    // Run\n    final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n            authorizationCodeServices.remove(codeId);\n\n    // Verify\n    verify(authorizationCodeRepository, times(1)).remove(codeId);\n    assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n}",
                "start_point": {
                    "row": 77,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "@Test(expected = InvalidGrantException.class)\npublic void shouldNotConsumeNonExistingCode() {\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n    oAuth2AuthorizationCode.setCode(\"test-code\");\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(authorizationCodeRepository.store(any())).thenReturn(Single.just(oAuth2AuthorizationCode));\n\n    // Run\n    String code = authorizationCodeServices.createAuthorizationCode(RepositoryProviderUtils.convert(oAuth2Authentication));\n    assertNotNull(code);\n    when(authorizationCodeRepository.remove(code)).thenReturn(Maybe.empty());\n    authorizationCodeServices.consumeAuthorizationCode(code);\n}",
                "name": "shouldNotConsumeNonExistingCode",
                "modifiers": "@Test(expected = InvalidGrantException.class)\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    OAuth2AuthorizationCode oAuth2AuthorizationCode = new OAuth2AuthorizationCode();\n    oAuth2AuthorizationCode.setCode(\"test-code\");\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(authorizationCodeRepository.store(any())).thenReturn(Single.just(oAuth2AuthorizationCode));\n\n    // Run\n    String code = authorizationCodeServices.createAuthorizationCode(RepositoryProviderUtils.convert(oAuth2Authentication));\n    assertNotNull(code);\n    when(authorizationCodeRepository.remove(code)).thenReturn(Maybe.empty());\n    authorizationCodeServices.consumeAuthorizationCode(code);\n}",
                "start_point": {
                    "row": 97,
                    "column": 4
                },
                "end_point": {
                    "row": 112,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/test/java/io/gravitee/am/management/handlers/oauth2/provider/token/AuthenticationKeyGeneratorTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic class AuthenticationKeyGeneratorTest {\n\n    @InjectMocks\n    private AuthenticationKeyGenerator authenticationKeyGenerator = new DefaultAuthenticationKeyGenerator();\n\n    @Mock\n    private OAuth2Authentication oAuth2Authentication;\n\n    @Mock\n    private OAuth2Request oAuth2Request;\n\n    @Mock\n    private DomainBasedClientDetailsService clientDetailsService;\n\n    @Mock\n    private DelegateClientDetails clientDetails;\n\n    @Mock\n    private Client client;\n\n    @Mock\n    private Domain domain;\n\n    @Test\n    public void shouldExtractTheSameKeyForTheSameAuthentication() {\n        when(domain.getId()).thenReturn(\"domain-test\");\n        when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n        when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n        when(client.isGenerateNewTokenPerRequest()).thenReturn(false);\n        when(clientDetails.getClient()).thenReturn(client);\n        when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n        String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n        String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        Assert.assertEquals(key1, key2);\n    }\n\n    @Test\n    public void shouldNotExtractTheSameKeyForTheSameAuthentication() {\n        when(domain.getId()).thenReturn(\"domain-test\");\n        when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n        when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n        when(client.isGenerateNewTokenPerRequest()).thenReturn(true);\n        when(clientDetails.getClient()).thenReturn(client);\n        when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n        String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n        String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        Assert.assertNotEquals(key1, key2);\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.token;",
        "tree_path": "AuthenticationKeyGeneratorTest",
        "name": "AuthenticationKeyGeneratorTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private AuthenticationKeyGenerator authenticationKeyGenerator = new DefaultAuthenticationKeyGenerator();\n\n    @Mock\n    private OAuth2Authentication oAuth2Authentication;\n\n    @Mock\n    private OAuth2Request oAuth2Request;\n\n    @Mock\n    private DomainBasedClientDetailsService clientDetailsService;\n\n    @Mock\n    private DelegateClientDetails clientDetails;\n\n    @Mock\n    private Client client;\n\n    @Mock\n    private Domain domain;\n\n    @Test\n    public void shouldExtractTheSameKeyForTheSameAuthentication() {\n        when(domain.getId()).thenReturn(\"domain-test\");\n        when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n        when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n        when(client.isGenerateNewTokenPerRequest()).thenReturn(false);\n        when(clientDetails.getClient()).thenReturn(client);\n        when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n        String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n        String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        Assert.assertEquals(key1, key2);\n    }\n\n    @Test\n    public void shouldNotExtractTheSameKeyForTheSameAuthentication() {\n        when(domain.getId()).thenReturn(\"domain-test\");\n        when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n        when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n        when(client.isGenerateNewTokenPerRequest()).thenReturn(true);\n        when(clientDetails.getClient()).thenReturn(client);\n        when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n        String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n        String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n        Assert.assertNotEquals(key1, key2);\n    }\n\n}",
        "start_point": {
            "row": 40,
            "column": 0
        },
        "end_point": {
            "row": 99,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldExtractTheSameKeyForTheSameAuthentication() {\n    when(domain.getId()).thenReturn(\"domain-test\");\n    when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n    when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n    when(client.isGenerateNewTokenPerRequest()).thenReturn(false);\n    when(clientDetails.getClient()).thenReturn(client);\n    when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n    String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n    String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    Assert.assertEquals(key1, key2);\n}",
                "name": "shouldExtractTheSameKeyForTheSameAuthentication",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(domain.getId()).thenReturn(\"domain-test\");\n    when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n    when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n    when(client.isGenerateNewTokenPerRequest()).thenReturn(false);\n    when(clientDetails.getClient()).thenReturn(client);\n    when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n    String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n    String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    Assert.assertEquals(key1, key2);\n}",
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 80,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldNotExtractTheSameKeyForTheSameAuthentication() {\n    when(domain.getId()).thenReturn(\"domain-test\");\n    when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n    when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n    when(client.isGenerateNewTokenPerRequest()).thenReturn(true);\n    when(clientDetails.getClient()).thenReturn(client);\n    when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n    String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n    String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    Assert.assertNotEquals(key1, key2);\n}",
                "name": "shouldNotExtractTheSameKeyForTheSameAuthentication",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(domain.getId()).thenReturn(\"domain-test\");\n    when(oAuth2Request.getClientId()).thenReturn(\"client-test\");\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(oAuth2Authentication.isClientOnly()).thenReturn(false);\n    when(oAuth2Authentication.getName()).thenReturn(\"user-test\");\n    when(client.isGenerateNewTokenPerRequest()).thenReturn(true);\n    when(clientDetails.getClient()).thenReturn(client);\n    when(clientDetailsService.loadClientByClientId(oAuth2Request.getClientId())).thenReturn(clientDetails);\n\n    String key1 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n    String key2 = authenticationKeyGenerator.extractKey(oAuth2Authentication);\n\n    Assert.assertNotEquals(key1, key2);\n}",
                "start_point": {
                    "row": 82,
                    "column": 4
                },
                "end_point": {
                    "row": 97,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/test/java/io/gravitee/am/management/handlers/oauth2/provider/token/RepositoryTokenStoreTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic class RepositoryTokenStoreTest {\n\n    @InjectMocks\n    private RepositoryTokenStore tokenStore = new RepositoryTokenStore();\n\n    @Mock\n    private TokenRepository tokenRepository;\n\n    @Mock\n    private OAuth2AccessToken oAuth2AccessToken;\n\n    @Mock\n    private org.springframework.security.oauth2.common.OAuth2AccessToken springOAuth2AccessToken;\n\n    @Mock\n    private OAuth2RefreshToken oAuth2RefreshToken;\n\n    @Mock\n    private org.springframework.security.oauth2.common.OAuth2RefreshToken springOAuth2RefreshToken;\n\n    @Mock\n    private OAuth2Authentication oAuth2Authentication;\n\n    @Mock\n    private OAuth2Authentication extractedOAuth2Authentication;\n\n    @Mock\n    private OAuth2Request oAuth2Request;\n\n    @Mock\n    private AuthenticationKeyGenerator authenticationKeyGenerator;\n\n    @Test\n    public void shouldReadAuthentication() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.readAuthentication(any(OAuth2AccessToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n        // Run\n        final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n                tokenStore.readAuthentication(springOAuth2AccessToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).readAuthentication(any(OAuth2AccessToken.class));\n        assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n    }\n\n    @Test\n    public void shouldStoreAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n\n        // prepare authentication key\n        when(authenticationKeyGenerator.extractKey(oAuth2Authentication)).thenReturn(\"test-key\");\n        when(tokenRepository.storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString())).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n        // Run\n        tokenStore.storeAccessToken(springOAuth2AccessToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString());\n    }\n\n    @Test\n    public void shouldReadAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.readAccessToken(tokenId)).thenReturn(Maybe.just(oAuth2AccessToken));\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n                tokenStore.readAccessToken(tokenId);\n\n        // Verify\n        verify(tokenRepository, times(1)).readAccessToken(anyString());\n        assertEquals(tokenId, oAuth2AccessToken.getValue());\n    }\n\n    @Test\n    public void shouldRemoveAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.removeAccessToken(any(OAuth2AccessToken.class))).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n\n        // Run\n        tokenStore.removeAccessToken(springOAuth2AccessToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).removeAccessToken(any(OAuth2AccessToken.class));\n    }\n\n    @Test\n    public void shouldStoreRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.storeRefreshToken(any(OAuth2RefreshToken.class), any())).thenReturn(Single.just(new OAuth2RefreshToken(tokenId)));\n\n        // Run\n        tokenStore.storeRefreshToken(springOAuth2RefreshToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).storeRefreshToken(any(OAuth2RefreshToken.class), any());\n    }\n\n    @Test\n    public void shouldReadRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(oAuth2RefreshToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.readRefreshToken(tokenId)).thenReturn(Maybe.just(oAuth2RefreshToken));\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2RefreshToken oAuth2RefreshToken =\n                tokenStore.readRefreshToken(tokenId);\n\n        // Verify\n        verify(tokenRepository, times(1)).readRefreshToken(tokenId);\n        assertEquals(tokenId, oAuth2RefreshToken.getValue());\n    }\n\n    @Test\n    public void shouldReadAuthenticationForRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n        // Run\n        final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n                tokenStore.readAuthenticationForRefreshToken(springOAuth2RefreshToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class));\n        assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n    }\n\n    @Test\n    public void shouldRemoveRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.removeRefreshToken(any())).thenReturn(Single.just(Irrelevant.OAUTH2_REFRESH_TOKEN));\n\n        // Run\n        tokenStore.removeRefreshToken(springOAuth2RefreshToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).removeRefreshToken(any(OAuth2RefreshToken.class));\n    }\n\n    @Test\n    public void shouldRemoveAccessTokenUsingRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n        // Run\n        tokenStore.removeAccessTokenUsingRefreshToken(springOAuth2RefreshToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).removeAccessTokenUsingRefreshToken(any(OAuth2RefreshToken.class));\n    }\n\n    @Test\n    public void shouldGetAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n        when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n\n        // prepare authentication key\n        when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key\");\n        when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n                tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).getAccessToken(any());\n        assertEquals(tokenId, oAuth2AccessToken.getValue());\n    }\n\n    @Test\n    public void shouldGetNewAccessTokenIfAuthenticationKeyHasChanged() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare authentication key\n        when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key-new\");\n        when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n        when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n        when(tokenRepository.removeAccessToken(tokenId)).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n        when(tokenRepository.storeAccessToken(any(), any(), eq(\"test-key-new\"))).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n                tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).getAccessToken(any());\n        verify(tokenRepository, times(1)).removeAccessToken(tokenId);\n        verify(tokenRepository, times( 1)).storeAccessToken(any(), any(), eq(\"test-key-new\"));\n\n    }\n\n    @Test\n    public void shouldFindTokensByClientIdAndUserName() {\n        // prepare OAuth2AccessTokens\n        final String tokenId = \"test-token\";\n        final String clientId = \"test-client\";\n        final String username = \"test-username\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.findTokensByClientIdAndUserName(clientId, username)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n        // Run\n        final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n                (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientIdAndUserName(clientId, username);\n\n        // Verify\n        verify(tokenRepository, times(1)).findTokensByClientIdAndUserName(clientId, username);\n        assertEquals(1, oAuth2AccessTokens.size());\n        assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n    }\n\n    @Test\n    public void shouldFindTokensByClientId() {\n        // prepare OAuth2AccessTokens\n        final String tokenId = \"test-token\";\n        final String clientId = \"test-client\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.findTokensByClientId(clientId)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n        // Run\n        final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n                (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientId(clientId);\n\n        // Verify\n        verify(tokenRepository, times(1)).findTokensByClientId(clientId);\n        assertEquals(1, oAuth2AccessTokens.size());\n        assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.token;",
        "tree_path": "RepositoryTokenStoreTest",
        "name": "RepositoryTokenStoreTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private RepositoryTokenStore tokenStore = new RepositoryTokenStore();\n\n    @Mock\n    private TokenRepository tokenRepository;\n\n    @Mock\n    private OAuth2AccessToken oAuth2AccessToken;\n\n    @Mock\n    private org.springframework.security.oauth2.common.OAuth2AccessToken springOAuth2AccessToken;\n\n    @Mock\n    private OAuth2RefreshToken oAuth2RefreshToken;\n\n    @Mock\n    private org.springframework.security.oauth2.common.OAuth2RefreshToken springOAuth2RefreshToken;\n\n    @Mock\n    private OAuth2Authentication oAuth2Authentication;\n\n    @Mock\n    private OAuth2Authentication extractedOAuth2Authentication;\n\n    @Mock\n    private OAuth2Request oAuth2Request;\n\n    @Mock\n    private AuthenticationKeyGenerator authenticationKeyGenerator;\n\n    @Test\n    public void shouldReadAuthentication() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.readAuthentication(any(OAuth2AccessToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n        // Run\n        final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n                tokenStore.readAuthentication(springOAuth2AccessToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).readAuthentication(any(OAuth2AccessToken.class));\n        assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n    }\n\n    @Test\n    public void shouldStoreAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n\n        // prepare authentication key\n        when(authenticationKeyGenerator.extractKey(oAuth2Authentication)).thenReturn(\"test-key\");\n        when(tokenRepository.storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString())).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n        // Run\n        tokenStore.storeAccessToken(springOAuth2AccessToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString());\n    }\n\n    @Test\n    public void shouldReadAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.readAccessToken(tokenId)).thenReturn(Maybe.just(oAuth2AccessToken));\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n                tokenStore.readAccessToken(tokenId);\n\n        // Verify\n        verify(tokenRepository, times(1)).readAccessToken(anyString());\n        assertEquals(tokenId, oAuth2AccessToken.getValue());\n    }\n\n    @Test\n    public void shouldRemoveAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.removeAccessToken(any(OAuth2AccessToken.class))).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n\n        // Run\n        tokenStore.removeAccessToken(springOAuth2AccessToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).removeAccessToken(any(OAuth2AccessToken.class));\n    }\n\n    @Test\n    public void shouldStoreRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.storeRefreshToken(any(OAuth2RefreshToken.class), any())).thenReturn(Single.just(new OAuth2RefreshToken(tokenId)));\n\n        // Run\n        tokenStore.storeRefreshToken(springOAuth2RefreshToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).storeRefreshToken(any(OAuth2RefreshToken.class), any());\n    }\n\n    @Test\n    public void shouldReadRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(oAuth2RefreshToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.readRefreshToken(tokenId)).thenReturn(Maybe.just(oAuth2RefreshToken));\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2RefreshToken oAuth2RefreshToken =\n                tokenStore.readRefreshToken(tokenId);\n\n        // Verify\n        verify(tokenRepository, times(1)).readRefreshToken(tokenId);\n        assertEquals(tokenId, oAuth2RefreshToken.getValue());\n    }\n\n    @Test\n    public void shouldReadAuthenticationForRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n        // Run\n        final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n                tokenStore.readAuthenticationForRefreshToken(springOAuth2RefreshToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class));\n        assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n    }\n\n    @Test\n    public void shouldRemoveRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.removeRefreshToken(any())).thenReturn(Single.just(Irrelevant.OAUTH2_REFRESH_TOKEN));\n\n        // Run\n        tokenStore.removeRefreshToken(springOAuth2RefreshToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).removeRefreshToken(any(OAuth2RefreshToken.class));\n    }\n\n    @Test\n    public void shouldRemoveAccessTokenUsingRefreshToken() {\n        // prepare OAuth2RefreshToken\n        final String tokenId = \"test-token\";\n        when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n        // Run\n        tokenStore.removeAccessTokenUsingRefreshToken(springOAuth2RefreshToken);\n\n        // Verify\n        verify(tokenRepository, times(1)).removeAccessTokenUsingRefreshToken(any(OAuth2RefreshToken.class));\n    }\n\n    @Test\n    public void shouldGetAccessToken() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n        when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n\n        // prepare authentication key\n        when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key\");\n        when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n                tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).getAccessToken(any());\n        assertEquals(tokenId, oAuth2AccessToken.getValue());\n    }\n\n    @Test\n    public void shouldGetNewAccessTokenIfAuthenticationKeyHasChanged() {\n        // prepare OAuth2AccessToken\n        final String tokenId = \"test-token\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n        // prepare authentication key\n        when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key-new\");\n        when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n        // prepare OAuth2Authentication\n        final String clientId = \"test-client\";\n        when(oAuth2Request.getClientId()).thenReturn(clientId);\n        when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n        when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n        when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n        when(tokenRepository.removeAccessToken(tokenId)).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n        when(tokenRepository.storeAccessToken(any(), any(), eq(\"test-key-new\"))).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n        // Run\n        final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n                tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n        // Verify\n        verify(tokenRepository, times(1)).getAccessToken(any());\n        verify(tokenRepository, times(1)).removeAccessToken(tokenId);\n        verify(tokenRepository, times( 1)).storeAccessToken(any(), any(), eq(\"test-key-new\"));\n\n    }\n\n    @Test\n    public void shouldFindTokensByClientIdAndUserName() {\n        // prepare OAuth2AccessTokens\n        final String tokenId = \"test-token\";\n        final String clientId = \"test-client\";\n        final String username = \"test-username\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.findTokensByClientIdAndUserName(clientId, username)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n        // Run\n        final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n                (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientIdAndUserName(clientId, username);\n\n        // Verify\n        verify(tokenRepository, times(1)).findTokensByClientIdAndUserName(clientId, username);\n        assertEquals(1, oAuth2AccessTokens.size());\n        assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n    }\n\n    @Test\n    public void shouldFindTokensByClientId() {\n        // prepare OAuth2AccessTokens\n        final String tokenId = \"test-token\";\n        final String clientId = \"test-client\";\n        when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n        when(tokenRepository.findTokensByClientId(clientId)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n        // Run\n        final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n                (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientId(clientId);\n\n        // Verify\n        verify(tokenRepository, times(1)).findTokensByClientId(clientId);\n        assertEquals(1, oAuth2AccessTokens.size());\n        assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n    }\n}",
        "start_point": {
            "row": 45,
            "column": 0
        },
        "end_point": {
            "row": 328,
            "column": 1
        },
        "file_mode": "Deleted",
        "map_path": null,
        "methods": [
            {
                "definition": "@Test\npublic void shouldReadAuthentication() {\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.readAuthentication(any(OAuth2AccessToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n    // Run\n    final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n            tokenStore.readAuthentication(springOAuth2AccessToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).readAuthentication(any(OAuth2AccessToken.class));\n    assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n}",
                "name": "shouldReadAuthentication",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.readAuthentication(any(OAuth2AccessToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n    // Run\n    final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n            tokenStore.readAuthentication(springOAuth2AccessToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).readAuthentication(any(OAuth2AccessToken.class));\n    assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n}",
                "start_point": {
                    "row": 79,
                    "column": 4
                },
                "end_point": {
                    "row": 99,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldStoreAccessToken() {\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n\n    // prepare authentication key\n    when(authenticationKeyGenerator.extractKey(oAuth2Authentication)).thenReturn(\"test-key\");\n    when(tokenRepository.storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString())).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n    // Run\n    tokenStore.storeAccessToken(springOAuth2AccessToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString());\n}",
                "name": "shouldStoreAccessToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n\n    // prepare authentication key\n    when(authenticationKeyGenerator.extractKey(oAuth2Authentication)).thenReturn(\"test-key\");\n    when(tokenRepository.storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString())).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n    // Run\n    tokenStore.storeAccessToken(springOAuth2AccessToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).storeAccessToken(any(OAuth2AccessToken.class), any(OAuth2Authentication.class), anyString());\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 121,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldReadAccessToken() {\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.readAccessToken(tokenId)).thenReturn(Maybe.just(oAuth2AccessToken));\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n            tokenStore.readAccessToken(tokenId);\n\n    // Verify\n    verify(tokenRepository, times(1)).readAccessToken(anyString());\n    assertEquals(tokenId, oAuth2AccessToken.getValue());\n}",
                "name": "shouldReadAccessToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.readAccessToken(tokenId)).thenReturn(Maybe.just(oAuth2AccessToken));\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n            tokenStore.readAccessToken(tokenId);\n\n    // Verify\n    verify(tokenRepository, times(1)).readAccessToken(anyString());\n    assertEquals(tokenId, oAuth2AccessToken.getValue());\n}",
                "start_point": {
                    "row": 123,
                    "column": 4
                },
                "end_point": {
                    "row": 137,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldRemoveAccessToken() {\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.removeAccessToken(any(OAuth2AccessToken.class))).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n\n    // Run\n    tokenStore.removeAccessToken(springOAuth2AccessToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).removeAccessToken(any(OAuth2AccessToken.class));\n}",
                "name": "shouldRemoveAccessToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.removeAccessToken(any(OAuth2AccessToken.class))).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n\n    // Run\n    tokenStore.removeAccessToken(springOAuth2AccessToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).removeAccessToken(any(OAuth2AccessToken.class));\n}",
                "start_point": {
                    "row": 139,
                    "column": 4
                },
                "end_point": {
                    "row": 151,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldStoreRefreshToken() {\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.storeRefreshToken(any(OAuth2RefreshToken.class), any())).thenReturn(Single.just(new OAuth2RefreshToken(tokenId)));\n\n    // Run\n    tokenStore.storeRefreshToken(springOAuth2RefreshToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).storeRefreshToken(any(OAuth2RefreshToken.class), any());\n}",
                "name": "shouldStoreRefreshToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.storeRefreshToken(any(OAuth2RefreshToken.class), any())).thenReturn(Single.just(new OAuth2RefreshToken(tokenId)));\n\n    // Run\n    tokenStore.storeRefreshToken(springOAuth2RefreshToken, RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).storeRefreshToken(any(OAuth2RefreshToken.class), any());\n}",
                "start_point": {
                    "row": 153,
                    "column": 4
                },
                "end_point": {
                    "row": 170,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldReadRefreshToken() {\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(oAuth2RefreshToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.readRefreshToken(tokenId)).thenReturn(Maybe.just(oAuth2RefreshToken));\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2RefreshToken oAuth2RefreshToken =\n            tokenStore.readRefreshToken(tokenId);\n\n    // Verify\n    verify(tokenRepository, times(1)).readRefreshToken(tokenId);\n    assertEquals(tokenId, oAuth2RefreshToken.getValue());\n}",
                "name": "shouldReadRefreshToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(oAuth2RefreshToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.readRefreshToken(tokenId)).thenReturn(Maybe.just(oAuth2RefreshToken));\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2RefreshToken oAuth2RefreshToken =\n            tokenStore.readRefreshToken(tokenId);\n\n    // Verify\n    verify(tokenRepository, times(1)).readRefreshToken(tokenId);\n    assertEquals(tokenId, oAuth2RefreshToken.getValue());\n}",
                "start_point": {
                    "row": 172,
                    "column": 4
                },
                "end_point": {
                    "row": 186,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldReadAuthenticationForRefreshToken() {\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n    // Run\n    final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n            tokenStore.readAuthenticationForRefreshToken(springOAuth2RefreshToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class));\n    assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n}",
                "name": "shouldReadAuthenticationForRefreshToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class))).thenReturn(Maybe.just(oAuth2Authentication));\n\n    // Run\n    final org.springframework.security.oauth2.provider.OAuth2Authentication oAuth2Authentication =\n            tokenStore.readAuthenticationForRefreshToken(springOAuth2RefreshToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).readAuthenticationForRefreshToken(any(OAuth2RefreshToken.class));\n    assertEquals(clientId, oAuth2Authentication.getOAuth2Request().getClientId());\n}",
                "start_point": {
                    "row": 188,
                    "column": 4
                },
                "end_point": {
                    "row": 207,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldRemoveRefreshToken() {\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.removeRefreshToken(any())).thenReturn(Single.just(Irrelevant.OAUTH2_REFRESH_TOKEN));\n\n    // Run\n    tokenStore.removeRefreshToken(springOAuth2RefreshToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).removeRefreshToken(any(OAuth2RefreshToken.class));\n}",
                "name": "shouldRemoveRefreshToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.removeRefreshToken(any())).thenReturn(Single.just(Irrelevant.OAUTH2_REFRESH_TOKEN));\n\n    // Run\n    tokenStore.removeRefreshToken(springOAuth2RefreshToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).removeRefreshToken(any(OAuth2RefreshToken.class));\n}",
                "start_point": {
                    "row": 209,
                    "column": 4
                },
                "end_point": {
                    "row": 221,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldRemoveAccessTokenUsingRefreshToken() {\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n    // Run\n    tokenStore.removeAccessTokenUsingRefreshToken(springOAuth2RefreshToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).removeAccessTokenUsingRefreshToken(any(OAuth2RefreshToken.class));\n}",
                "name": "shouldRemoveAccessTokenUsingRefreshToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2RefreshToken\n    final String tokenId = \"test-token\";\n    when(springOAuth2RefreshToken.getValue()).thenReturn(tokenId);\n\n    // Run\n    tokenStore.removeAccessTokenUsingRefreshToken(springOAuth2RefreshToken);\n\n    // Verify\n    verify(tokenRepository, times(1)).removeAccessTokenUsingRefreshToken(any(OAuth2RefreshToken.class));\n}",
                "start_point": {
                    "row": 223,
                    "column": 4
                },
                "end_point": {
                    "row": 234,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldGetAccessToken() {\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n    when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n\n    // prepare authentication key\n    when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key\");\n    when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n            tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).getAccessToken(any());\n    assertEquals(tokenId, oAuth2AccessToken.getValue());\n}",
                "name": "shouldGetAccessToken",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n    when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n\n    // prepare authentication key\n    when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key\");\n    when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n            tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).getAccessToken(any());\n    assertEquals(tokenId, oAuth2AccessToken.getValue());\n}",
                "start_point": {
                    "row": 236,
                    "column": 4
                },
                "end_point": {
                    "row": 260,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldGetNewAccessTokenIfAuthenticationKeyHasChanged() {\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare authentication key\n    when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key-new\");\n    when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n    when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n    when(tokenRepository.removeAccessToken(tokenId)).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n    when(tokenRepository.storeAccessToken(any(), any(), eq(\"test-key-new\"))).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n            tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).getAccessToken(any());\n    verify(tokenRepository, times(1)).removeAccessToken(tokenId);\n    verify(tokenRepository, times( 1)).storeAccessToken(any(), any(), eq(\"test-key-new\"));\n\n}",
                "name": "shouldGetNewAccessTokenIfAuthenticationKeyHasChanged",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessToken\n    final String tokenId = \"test-token\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n\n    // prepare authentication key\n    when(authenticationKeyGenerator.extractKey(any())).thenReturn(\"test-key-new\");\n    when(authenticationKeyGenerator.extractKey(extractedOAuth2Authentication)).thenReturn(\"test-key\");\n\n    // prepare OAuth2Authentication\n    final String clientId = \"test-client\";\n    when(oAuth2Request.getClientId()).thenReturn(clientId);\n    when(oAuth2Authentication.getOAuth2Request()).thenReturn(oAuth2Request);\n    when(tokenRepository.getAccessToken(any())).thenReturn(Maybe.just(oAuth2AccessToken));\n    when(tokenRepository.readAuthentication(tokenId)).thenReturn(Maybe.just(extractedOAuth2Authentication));\n    when(tokenRepository.removeAccessToken(tokenId)).thenReturn(Single.just(Irrelevant.OAUTH2_ACCESS_TOKEN));\n    when(tokenRepository.storeAccessToken(any(), any(), eq(\"test-key-new\"))).thenReturn(Single.just(new OAuth2AccessToken(tokenId)));\n\n    // Run\n    final org.springframework.security.oauth2.common.OAuth2AccessToken oAuth2AccessToken =\n            tokenStore.getAccessToken(RepositoryProviderUtils.convert(oAuth2Authentication));\n\n    // Verify\n    verify(tokenRepository, times(1)).getAccessToken(any());\n    verify(tokenRepository, times(1)).removeAccessToken(tokenId);\n    verify(tokenRepository, times( 1)).storeAccessToken(any(), any(), eq(\"test-key-new\"));\n\n}",
                "start_point": {
                    "row": 262,
                    "column": 4
                },
                "end_point": {
                    "row": 290,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindTokensByClientIdAndUserName() {\n    // prepare OAuth2AccessTokens\n    final String tokenId = \"test-token\";\n    final String clientId = \"test-client\";\n    final String username = \"test-username\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.findTokensByClientIdAndUserName(clientId, username)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n    // Run\n    final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n            (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientIdAndUserName(clientId, username);\n\n    // Verify\n    verify(tokenRepository, times(1)).findTokensByClientIdAndUserName(clientId, username);\n    assertEquals(1, oAuth2AccessTokens.size());\n    assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n}",
                "name": "shouldFindTokensByClientIdAndUserName",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessTokens\n    final String tokenId = \"test-token\";\n    final String clientId = \"test-client\";\n    final String username = \"test-username\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.findTokensByClientIdAndUserName(clientId, username)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n    // Run\n    final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n            (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientIdAndUserName(clientId, username);\n\n    // Verify\n    verify(tokenRepository, times(1)).findTokensByClientIdAndUserName(clientId, username);\n    assertEquals(1, oAuth2AccessTokens.size());\n    assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n}",
                "start_point": {
                    "row": 292,
                    "column": 4
                },
                "end_point": {
                    "row": 309,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldFindTokensByClientId() {\n    // prepare OAuth2AccessTokens\n    final String tokenId = \"test-token\";\n    final String clientId = \"test-client\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.findTokensByClientId(clientId)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n    // Run\n    final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n            (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientId(clientId);\n\n    // Verify\n    verify(tokenRepository, times(1)).findTokensByClientId(clientId);\n    assertEquals(1, oAuth2AccessTokens.size());\n    assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n}",
                "name": "shouldFindTokensByClientId",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    // prepare OAuth2AccessTokens\n    final String tokenId = \"test-token\";\n    final String clientId = \"test-client\";\n    when(oAuth2AccessToken.getValue()).thenReturn(tokenId);\n    when(tokenRepository.findTokensByClientId(clientId)).thenReturn(Single.just(Collections.singletonList(oAuth2AccessToken)));\n\n    // Run\n    final List<org.springframework.security.oauth2.common.OAuth2AccessToken> oAuth2AccessTokens =\n            (List<org.springframework.security.oauth2.common.OAuth2AccessToken>) tokenStore.findTokensByClientId(clientId);\n\n    // Verify\n    verify(tokenRepository, times(1)).findTokensByClientId(clientId);\n    assertEquals(1, oAuth2AccessTokens.size());\n    assertEquals(tokenId, oAuth2AccessTokens.get(0).getValue());\n}",
                "start_point": {
                    "row": 311,
                    "column": 4
                },
                "end_point": {
                    "row": 327,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/WebMvcConfiguration.java",
        "definition": "@Configuration\n@ComponentScan(\"io.gravitee.am.management.handlers.oauth2.controller\")\n@EnableWebMvc\n@Import(ThymeleafConfiguration.class)\npublic class WebMvcConfiguration extends WebMvcConfigurerAdapter {\n\n    @Autowired\n    private Domain domain;\n\n    @Bean\n    public ScopeApprovalEndpoint accessConfirmationController(ClientDetailsService clientDetailsService,\n                                                              ApprovalStore approvalStore,\n                                                              DomainScopeService scopeService) {\n        ScopeApprovalEndpoint accessConfirmationController = new ScopeApprovalEndpoint();\n        accessConfirmationController.setClientDetailsService(clientDetailsService);\n        accessConfirmationController.setApprovalStore(approvalStore);\n        accessConfirmationController.setScopeService(scopeService);\n        return accessConfirmationController;\n    }\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        LoginForm loginForm = domain.getLoginForm();\n        if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"file:\" + loginForm.getAssets());\n        } else {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"classpath:/assets/\");\n        }\n    }\n\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer.defaultContentType(MediaType.APPLICATION_JSON);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2;",
        "tree_path": "WebMvcConfiguration",
        "name": "WebMvcConfiguration",
        "modifiers": "@Configuration\n@ComponentScan(\"io.gravitee.am.management.handlers.oauth2.controller\")\n@EnableWebMvc\n@Import(ThymeleafConfiguration.class)\npublic",
        "superclass": "extends WebMvcConfigurerAdapter",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private Domain domain;\n\n    @Bean\n    public ScopeApprovalEndpoint accessConfirmationController(ClientDetailsService clientDetailsService,\n                                                              ApprovalStore approvalStore,\n                                                              DomainScopeService scopeService) {\n        ScopeApprovalEndpoint accessConfirmationController = new ScopeApprovalEndpoint();\n        accessConfirmationController.setClientDetailsService(clientDetailsService);\n        accessConfirmationController.setApprovalStore(approvalStore);\n        accessConfirmationController.setScopeService(scopeService);\n        return accessConfirmationController;\n    }\n\n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        LoginForm loginForm = domain.getLoginForm();\n        if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"file:\" + loginForm.getAssets());\n        } else {\n            registry\n                    .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                    .addResourceLocations(\"classpath:/assets/\");\n        }\n    }\n\n    @Override\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n        configurer.defaultContentType(MediaType.APPLICATION_JSON);\n    }\n}",
        "start_point": {
            "row": 39,
            "column": 0
        },
        "end_point": {
            "row": 77,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/WebMvcConfiguration.java",
        "methods": [
            {
                "definition": "@Bean\npublic ScopeApprovalEndpoint accessConfirmationController(ClientDetailsService clientDetailsService,\n                                                          ApprovalStore approvalStore,\n                                                          DomainScopeService scopeService) {\n    ScopeApprovalEndpoint accessConfirmationController = new ScopeApprovalEndpoint();\n    accessConfirmationController.setClientDetailsService(clientDetailsService);\n    accessConfirmationController.setApprovalStore(approvalStore);\n    accessConfirmationController.setScopeService(scopeService);\n    return accessConfirmationController;\n}",
                "name": "accessConfirmationController",
                "modifiers": "@Bean\n    public",
                "return_type": "ScopeApprovalEndpoint",
                "parameters": [
                    {
                        "type": "ClientDetailsService",
                        "name": "clientDetailsService"
                    },
                    {
                        "type": "ApprovalStore",
                        "name": "approvalStore"
                    },
                    {
                        "type": "DomainScopeService",
                        "name": "scopeService"
                    }
                ],
                "body": "{\n    ScopeApprovalEndpoint accessConfirmationController = new ScopeApprovalEndpoint();\n    accessConfirmationController.setClientDetailsService(clientDetailsService);\n    accessConfirmationController.setApprovalStore(approvalStore);\n    accessConfirmationController.setScopeService(scopeService);\n    return accessConfirmationController;\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 57,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n    LoginForm loginForm = domain.getLoginForm();\n    if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"file:\" + loginForm.getAssets());\n    } else {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"classpath:/assets/\");\n    }\n}",
                "name": "addResourceHandlers",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ResourceHandlerRegistry",
                        "name": "registry"
                    }
                ],
                "body": "{\n    LoginForm loginForm = domain.getLoginForm();\n    if (loginForm != null && loginForm.isEnabled() && loginForm.getAssets() != null) {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"file:\" + loginForm.getAssets());\n    } else {\n        registry\n                .addResourceHandler(\"/oauth/assets/**\", \"/assets/**\")\n                .addResourceLocations(\"classpath:/assets/\");\n    }\n}",
                "start_point": {
                    "row": 59,
                    "column": 4
                },
                "end_point": {
                    "row": 71,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\n    configurer.defaultContentType(MediaType.APPLICATION_JSON);\n}",
                "name": "configureContentNegotiation",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ContentNegotiationConfigurer",
                        "name": "configurer"
                    }
                ],
                "body": "{\n    configurer.defaultContentType(MediaType.APPLICATION_JSON);\n}",
                "start_point": {
                    "row": 73,
                    "column": 4
                },
                "end_point": {
                    "row": 76,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/authentication/CustomSavedRequestAwareAuthenticationSuccessHandler.java",
        "definition": "public class CustomSavedRequestAwareAuthenticationSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {\n    protected final Logger logger = LoggerFactory.getLogger(CustomSavedRequestAwareAuthenticationSuccessHandler.class);\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private RequestCache requestCache = new HttpSessionRequestCache();\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n        if (savedRequest == null) {\n            if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n                super.onAuthenticationSuccess(request, response, authentication);\n\n                return;\n            } else {\n                // fetch saved request from user session\n                savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n            }\n        } else {\n            // Store the saved HTTP request itself for redirection after successful authentication\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        String targetUrlParameter = getTargetUrlParameter();\n        if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n            requestCache.removeRequest(request, response);\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        }\n\n        clearAuthenticationAttributes(request);\n\n        // Use the DefaultSavedRequest URL\n        String targetUrl = savedRequest.getRedirectUrl();\n        logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n        getRedirectStrategy().sendRedirect(request, response, targetUrl);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.authentication;",
        "tree_path": "CustomSavedRequestAwareAuthenticationSuccessHandler",
        "name": "CustomSavedRequestAwareAuthenticationSuccessHandler",
        "modifiers": "public",
        "superclass": "extends SavedRequestAwareAuthenticationSuccessHandler",
        "super_interfaces": null,
        "body": "{\n    protected final Logger logger = LoggerFactory.getLogger(CustomSavedRequestAwareAuthenticationSuccessHandler.class);\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private RequestCache requestCache = new HttpSessionRequestCache();\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                        Authentication authentication) throws ServletException, IOException {\n        SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n        if (savedRequest == null) {\n            if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n                super.onAuthenticationSuccess(request, response, authentication);\n\n                return;\n            } else {\n                // fetch saved request from user session\n                savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n            }\n        } else {\n            // Store the saved HTTP request itself for redirection after successful authentication\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        String targetUrlParameter = getTargetUrlParameter();\n        if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n            requestCache.removeRequest(request, response);\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        }\n\n        clearAuthenticationAttributes(request);\n\n        // Use the DefaultSavedRequest URL\n        String targetUrl = savedRequest.getRedirectUrl();\n        logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n        getRedirectStrategy().sendRedirect(request, response, targetUrl);\n    }\n}",
        "start_point": {
            "row": 35,
            "column": 0
        },
        "end_point": {
            "row": 74,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/authentication/CustomSavedRequestAwareAuthenticationSuccessHandler.java",
        "methods": [
            {
                "definition": "@Override\npublic void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,\n                                    Authentication authentication) throws ServletException, IOException {\n    SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n    if (savedRequest == null) {\n        if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        } else {\n            // fetch saved request from user session\n            savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n        }\n    } else {\n        // Store the saved HTTP request itself for redirection after successful authentication\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    String targetUrlParameter = getTargetUrlParameter();\n    if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n        requestCache.removeRequest(request, response);\n        super.onAuthenticationSuccess(request, response, authentication);\n\n        return;\n    }\n\n    clearAuthenticationAttributes(request);\n\n    // Use the DefaultSavedRequest URL\n    String targetUrl = savedRequest.getRedirectUrl();\n    logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n    getRedirectStrategy().sendRedirect(request, response, targetUrl);\n}",
                "name": "onAuthenticationSuccess",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    SavedRequest savedRequest = requestCache.getRequest(request, response);\n\n    if (savedRequest == null) {\n        if (request.getSession(false).getAttribute(SAVED_REQUEST) == null) {\n            super.onAuthenticationSuccess(request, response, authentication);\n\n            return;\n        } else {\n            // fetch saved request from user session\n            savedRequest = (SavedRequest) request.getSession(false).getAttribute(SAVED_REQUEST);\n        }\n    } else {\n        // Store the saved HTTP request itself for redirection after successful authentication\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    String targetUrlParameter = getTargetUrlParameter();\n    if (isAlwaysUseDefaultTargetUrl() || (targetUrlParameter != null && StringUtils.hasText(request.getParameter(targetUrlParameter)))) {\n        requestCache.removeRequest(request, response);\n        super.onAuthenticationSuccess(request, response, authentication);\n\n        return;\n    }\n\n    clearAuthenticationAttributes(request);\n\n    // Use the DefaultSavedRequest URL\n    String targetUrl = savedRequest.getRedirectUrl();\n    logger.debug(\"Redirecting to DefaultSavedRequest Url: \" + targetUrl);\n    getRedirectStrategy().sendRedirect(request, response, targetUrl);\n}",
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/authentication/OAuth2LoginUrlAuthenticationEntryPoint.java",
        "definition": "public class OAuth2LoginUrlAuthenticationEntryPoint extends LoginUrlAuthenticationEntryPoint {\n\n    public OAuth2LoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n        super(loginFormUrl);\n    }\n\n    @Override\n    protected String determineUrlToUseForThisRequest(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) {\n        String url = super.determineUrlToUseForThisRequest(request, response, exception);\n        return UriComponentsBuilder.fromPath(url).queryParam(\"client_id\", request.getParameter(\"client_id\")).toUriString();\n    }\n\n    @Override\n    protected String buildRedirectUrlToLoginPage(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {\n        String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        return builder.toUriString();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.authentication;",
        "tree_path": "OAuth2LoginUrlAuthenticationEntryPoint",
        "name": "OAuth2LoginUrlAuthenticationEntryPoint",
        "modifiers": "public",
        "superclass": "extends LoginUrlAuthenticationEntryPoint",
        "super_interfaces": null,
        "body": "{\n\n    public OAuth2LoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n        super(loginFormUrl);\n    }\n\n    @Override\n    protected String determineUrlToUseForThisRequest(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) {\n        String url = super.determineUrlToUseForThisRequest(request, response, exception);\n        return UriComponentsBuilder.fromPath(url).queryParam(\"client_id\", request.getParameter(\"client_id\")).toUriString();\n    }\n\n    @Override\n    protected String buildRedirectUrlToLoginPage(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {\n        String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        return builder.toUriString();\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 66,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/authentication/LoginUrlAuthenticationEntryPoint.java",
        "methods": [
            {
                "definition": "public OAuth2LoginUrlAuthenticationEntryPoint(String loginFormUrl) {\n    super(loginFormUrl);\n}",
                "name": "OAuth2LoginUrlAuthenticationEntryPoint",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "loginFormUrl"
                    }
                ],
                "body": "{\n    super(loginFormUrl);\n}",
                "constructor": true,
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 33,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected String determineUrlToUseForThisRequest(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) {\n    String url = super.determineUrlToUseForThisRequest(request, response, exception);\n    return UriComponentsBuilder.fromPath(url).queryParam(\"client_id\", request.getParameter(\"client_id\")).toUriString();\n}",
                "name": "determineUrlToUseForThisRequest",
                "modifiers": "@Override\n    protected",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "AuthenticationException",
                        "name": "exception"
                    }
                ],
                "body": "{\n    String url = super.determineUrlToUseForThisRequest(request, response, exception);\n    return UriComponentsBuilder.fromPath(url).queryParam(\"client_id\", request.getParameter(\"client_id\")).toUriString();\n}",
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 39,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected String buildRedirectUrlToLoginPage(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) {\n    String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    return builder.toUriString();\n}",
                "name": "buildRedirectUrlToLoginPage",
                "modifiers": "@Override\n    protected",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "AuthenticationException",
                        "name": "authException"
                    }
                ],
                "body": "{\n    String url = super.buildRedirectUrlToLoginPage(request, response, authException);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    return builder.toUriString();\n}",
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 65,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2ContextFactory.java",
        "definition": "public class OAuth2ContextFactory implements ServletContextFactory<Domain>, ApplicationContextAware {\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public boolean canHandle(Domain domain) {\n        return domain != null; // && domain.getType() == Type.OAUTH2;\n    }\n\n    @Override\n    public ServletContext<Domain> create(Domain domain) {\n        SpringServletContext servletContext = OAuth2SpringServletContext.create(domain).build();\n        servletContext.setRootApplicationContext(applicationContext);\n\n        return servletContext;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.context;",
        "tree_path": "OAuth2ContextFactory",
        "name": "OAuth2ContextFactory",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements ServletContextFactory<Domain>, ApplicationContextAware",
        "body": "{\n\n    private ApplicationContext applicationContext;\n\n    @Override\n    public boolean canHandle(Domain domain) {\n        return domain != null; // && domain.getType() == Type.OAUTH2;\n    }\n\n    @Override\n    public ServletContext<Domain> create(Domain domain) {\n        SpringServletContext servletContext = OAuth2SpringServletContext.create(domain).build();\n        servletContext.setRootApplicationContext(applicationContext);\n\n        return servletContext;\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        this.applicationContext = applicationContext;\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 50,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminContextFactory.java",
        "methods": [
            {
                "definition": "@Override\npublic boolean canHandle(Domain domain) {\n    return domain != null; // && domain.getType() == Type.OAUTH2;\n}",
                "name": "canHandle",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    return domain != null; // && domain.getType() == Type.OAUTH2;\n}",
                "start_point": {
                    "row": 33,
                    "column": 4
                },
                "end_point": {
                    "row": 36,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic ServletContext<Domain> create(Domain domain) {\n    SpringServletContext servletContext = OAuth2SpringServletContext.create(domain).build();\n    servletContext.setRootApplicationContext(applicationContext);\n\n    return servletContext;\n}",
                "name": "create",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    SpringServletContext servletContext = OAuth2SpringServletContext.create(domain).build();\n    servletContext.setRootApplicationContext(applicationContext);\n\n    return servletContext;\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n    this.applicationContext = applicationContext;\n}",
                "name": "setApplicationContext",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ApplicationContext",
                        "name": "applicationContext"
                    }
                ],
                "body": "{\n    this.applicationContext = applicationContext;\n}",
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2ContextLoaderListener.java",
        "definition": "public class OAuth2ContextLoaderListener extends ContextLoaderListener {\n\n    public OAuth2ContextLoaderListener(WebApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public void contextInitialized(ServletContextEvent event) {\n        super.contextInitialized(event);\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent event) {\n        super.contextDestroyed(event);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.context;",
        "tree_path": "OAuth2ContextLoaderListener",
        "name": "OAuth2ContextLoaderListener",
        "modifiers": "public",
        "superclass": "extends ContextLoaderListener",
        "super_interfaces": null,
        "body": "{\n\n    public OAuth2ContextLoaderListener(WebApplicationContext context) {\n        super(context);\n    }\n\n    @Override\n    public void contextInitialized(ServletContextEvent event) {\n        super.contextInitialized(event);\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent event) {\n        super.contextDestroyed(event);\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 41,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminContextLoaderListener.java",
        "methods": [
            {
                "definition": "public OAuth2ContextLoaderListener(WebApplicationContext context) {\n    super(context);\n}",
                "name": "OAuth2ContextLoaderListener",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "WebApplicationContext",
                        "name": "context"
                    }
                ],
                "body": "{\n    super(context);\n}",
                "constructor": true,
                "start_point": {
                    "row": 28,
                    "column": 4
                },
                "end_point": {
                    "row": 30,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void contextInitialized(ServletContextEvent event) {\n    super.contextInitialized(event);\n}",
                "name": "contextInitialized",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ServletContextEvent",
                        "name": "event"
                    }
                ],
                "body": "{\n    super.contextInitialized(event);\n}",
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 35,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void contextDestroyed(ServletContextEvent event) {\n    super.contextDestroyed(event);\n}",
                "name": "contextDestroyed",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ServletContextEvent",
                        "name": "event"
                    }
                ],
                "body": "{\n    super.contextDestroyed(event);\n}",
                "start_point": {
                    "row": 37,
                    "column": 4
                },
                "end_point": {
                    "row": 40,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2DomainBeanFactoryPostProcessor.java",
        "definition": "class OAuth2DomainBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n\n    private final Domain domain;\n\n    OAuth2DomainBeanFactoryPostProcessor(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n        beanFactory.registerSingleton(\"domain\", domain);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.context;",
        "tree_path": "OAuth2DomainBeanFactoryPostProcessor",
        "name": "OAuth2DomainBeanFactoryPostProcessor",
        "modifiers": null,
        "superclass": null,
        "super_interfaces": "implements BeanFactoryPostProcessor",
        "body": "{\n\n    private final Domain domain;\n\n    OAuth2DomainBeanFactoryPostProcessor(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n        beanFactory.registerSingleton(\"domain\", domain);\n    }\n}",
        "start_point": {
            "row": 27,
            "column": 0
        },
        "end_point": {
            "row": 40,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminDomainBeanFactoryPostProcessor.java",
        "methods": [
            {
                "definition": "OAuth2DomainBeanFactoryPostProcessor(Domain domain) {\n    this.domain = domain;\n}",
                "name": "OAuth2DomainBeanFactoryPostProcessor",
                "modifiers": null,
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    this.domain = domain;\n}",
                "constructor": true,
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 33,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {\n    DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n    beanFactory.registerSingleton(\"domain\", domain);\n}",
                "name": "postProcessBeanFactory",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ConfigurableListableBeanFactory",
                        "name": "configurableListableBeanFactory"
                    }
                ],
                "body": "{\n    DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;\n    beanFactory.registerSingleton(\"domain\", domain);\n}",
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 39,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2SpringServletContext.java",
        "definition": "public class OAuth2SpringServletContext extends SpringServletContext<Domain> {\n\n    private final Domain domain;\n\n    private OAuth2SpringServletContext(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public List<Servlet> servlets() {\n        return Collections.singletonList(new DispatcherServlet(applicationContext()));\n    }\n\n    @Override\n    public List<Filter> filters() {\n        return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n    }\n\n    @Override\n    public List<EventListener> listeners() {\n        return Collections.singletonList(new OAuth2ContextLoaderListener(applicationContext()));\n    }\n\n    @Override\n    public Domain deployable() {\n        return domain;\n    }\n\n    @Override\n    protected Set<Class<?>> annotatedClasses() {\n        return new HashSet<>(Arrays.asList(OAuth2Configuration.class));\n    }\n\n    @Override\n    protected Set<? extends BeanFactoryPostProcessor> beanFactoryPostProcessors() {\n        return Collections.singleton(new OAuth2DomainBeanFactoryPostProcessor((Domain) deployable()));\n    }\n\n    static Builder create(Domain domain) {\n        return new Builder(domain);\n    }\n\n    static class Builder {\n\n        private final Domain domain;\n\n        private Builder(Domain domain) {\n            this.domain = domain;\n        }\n\n        SpringServletContext<Domain> build() {\n            return new OAuth2SpringServletContext(domain);\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.context;",
        "tree_path": "OAuth2SpringServletContext",
        "name": "OAuth2SpringServletContext",
        "modifiers": "public",
        "superclass": "extends SpringServletContext<Domain>",
        "super_interfaces": null,
        "body": "{\n\n    private final Domain domain;\n\n    private OAuth2SpringServletContext(Domain domain) {\n        this.domain = domain;\n    }\n\n    @Override\n    public List<Servlet> servlets() {\n        return Collections.singletonList(new DispatcherServlet(applicationContext()));\n    }\n\n    @Override\n    public List<Filter> filters() {\n        return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n    }\n\n    @Override\n    public List<EventListener> listeners() {\n        return Collections.singletonList(new OAuth2ContextLoaderListener(applicationContext()));\n    }\n\n    @Override\n    public Domain deployable() {\n        return domain;\n    }\n\n    @Override\n    protected Set<Class<?>> annotatedClasses() {\n        return new HashSet<>(Arrays.asList(OAuth2Configuration.class));\n    }\n\n    @Override\n    protected Set<? extends BeanFactoryPostProcessor> beanFactoryPostProcessors() {\n        return Collections.singleton(new OAuth2DomainBeanFactoryPostProcessor((Domain) deployable()));\n    }\n\n    static Builder create(Domain domain) {\n        return new Builder(domain);\n    }\n\n    static class Builder {\n\n        private final Domain domain;\n\n        private Builder(Domain domain) {\n            this.domain = domain;\n        }\n\n        SpringServletContext<Domain> build() {\n            return new OAuth2SpringServletContext(domain);\n        }\n    }\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 86,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminSpringServletContext.java",
        "methods": [
            {
                "definition": "private OAuth2SpringServletContext(Domain domain) {\n    this.domain = domain;\n}",
                "name": "OAuth2SpringServletContext",
                "modifiers": "private",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    this.domain = domain;\n}",
                "constructor": true,
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 38,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic List<Servlet> servlets() {\n    return Collections.singletonList(new DispatcherServlet(applicationContext()));\n}",
                "name": "servlets",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singletonList(new DispatcherServlet(applicationContext()));\n}",
                "start_point": {
                    "row": 40,
                    "column": 4
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic List<Filter> filters() {\n    return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n}",
                "name": "filters",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singletonList(new DelegatingFilterProxy(\"springSecurityFilterChain\"));\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 48,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic List<EventListener> listeners() {\n    return Collections.singletonList(new OAuth2ContextLoaderListener(applicationContext()));\n}",
                "name": "listeners",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singletonList(new OAuth2ContextLoaderListener(applicationContext()));\n}",
                "start_point": {
                    "row": 50,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Domain deployable() {\n    return domain;\n}",
                "name": "deployable",
                "modifiers": "@Override\n    public",
                "return_type": "Domain",
                "parameters": [],
                "body": "{\n    return domain;\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected Set<Class<?>> annotatedClasses() {\n    return new HashSet<>(Arrays.asList(OAuth2Configuration.class));\n}",
                "name": "annotatedClasses",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return new HashSet<>(Arrays.asList(OAuth2Configuration.class));\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 63,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected Set<? extends BeanFactoryPostProcessor> beanFactoryPostProcessors() {\n    return Collections.singleton(new OAuth2DomainBeanFactoryPostProcessor((Domain) deployable()));\n}",
                "name": "beanFactoryPostProcessors",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return Collections.singleton(new OAuth2DomainBeanFactoryPostProcessor((Domain) deployable()));\n}",
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "static Builder create(Domain domain) {\n    return new Builder(domain);\n}",
                "name": "create",
                "modifiers": "static",
                "return_type": "Builder",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    return new Builder(domain);\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 72,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/context/OAuth2SpringServletContext.java",
        "definition": "static class Builder {\n\n    private final Domain domain;\n\n    private Builder(Domain domain) {\n        this.domain = domain;\n    }\n\n    SpringServletContext<Domain> build() {\n        return new OAuth2SpringServletContext(domain);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.context;",
        "tree_path": "OAuth2SpringServletContext.Builder",
        "name": "Builder",
        "modifiers": "static",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final Domain domain;\n\n    private Builder(Domain domain) {\n        this.domain = domain;\n    }\n\n    SpringServletContext<Domain> build() {\n        return new OAuth2SpringServletContext(domain);\n    }\n}",
        "start_point": {
            "row": 74,
            "column": 4
        },
        "end_point": {
            "row": 85,
            "column": 5
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/context/AdminSpringServletContext.java",
        "methods": [
            {
                "definition": "private Builder(Domain domain) {\n    this.domain = domain;\n}",
                "name": "Builder",
                "modifiers": "private",
                "parameters": [
                    {
                        "type": "Domain",
                        "name": "domain"
                    }
                ],
                "body": "{\n    this.domain = domain;\n}",
                "constructor": true,
                "start_point": {
                    "row": 78,
                    "column": 8
                },
                "end_point": {
                    "row": 80,
                    "column": 9
                }
            },
            {
                "definition": "SpringServletContext<Domain> build() {\n    return new OAuth2SpringServletContext(domain);\n}",
                "name": "build",
                "modifiers": null,
                "return_type": null,
                "parameters": [],
                "body": "{\n    return new OAuth2SpringServletContext(domain);\n}",
                "start_point": {
                    "row": 82,
                    "column": 8
                },
                "end_point": {
                    "row": 84,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/controller/LoginController.java",
        "definition": "@Controller\npublic class LoginController {\n\n    private final static Logger logger = LoggerFactory.getLogger(LoginController.class);\n    private final static String LOGIN_VIEW = \"login\";\n    private final static List<String> socialProviders = Arrays.asList(\"github\", \"google\", \"twitter\", \"facebook\", \"bitbucket\");\n    private final static String errorPage = \"forward:/oauth/error\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @RequestMapping(value = \"/login\")\n    public ModelAndView login(\n            @RequestParam(value = OAuth2Utils.CLIENT_ID) String clientId, HttpServletRequest request) {\n        if (clientId == null || clientId.isEmpty()) {\n            logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n        }\n\n        Client client;\n        try {\n            // TODO async call\n            client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n        }\n\n        Map<String, Object> params = new HashMap<>();\n        params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n        params.put(\"domain\", domain);\n\n        Set<String> clientOAuth2Providers = client.getOauth2Identities();\n        if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n            params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n                IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n                String identityProviderType = identityProvider.getType();\n                Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n                if (identityProviderSocialType.isPresent()) {\n                    identityProvider.setType(identityProviderSocialType.get());\n                }\n                return identityProvider;\n            }).collect(Collectors.toSet()));\n\n            Map<String, String> authorizeUrls = new HashMap<>();\n            clientOAuth2Providers.forEach(identity -> {\n                OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n                if (oAuth2AuthenticationProvider != null) {\n                    OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                    builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                    builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                    builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                    if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                        builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                    }\n                    authorizeUrls.put(identity, builder.build(false).toUriString());\n                }\n            });\n            params.put(\"authorizeUrls\", authorizeUrls);\n        }\n\n        return new ModelAndView(LOGIN_VIEW, params);\n    }\n\n    @RequestMapping(value = \"/login/callback\")\n    public void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n        if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n            final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n            response.sendRedirect(savedRequest.getRedirectUrl());\n        } else {\n            response.sendRedirect(\"/login\");\n        }\n    }\n\n    private String buildRedirectUri(HttpServletRequest request, String identity) {\n        UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        } else {\n            builder.scheme(request.getScheme());\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        } else {\n            builder.host(request.getServerName());\n            if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n                builder.port(request.getServerPort());\n            }\n        }\n        // append context path\n        builder.path(request.getContextPath());\n        builder.pathSegment(\"login/callback\");\n\n        // append identity provider id\n        builder.queryParam(\"provider\", identity);\n\n        return builder.build().toUriString();\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.controller;",
        "tree_path": "LoginController",
        "name": "LoginController",
        "modifiers": "@Controller\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    private final static Logger logger = LoggerFactory.getLogger(LoginController.class);\n    private final static String LOGIN_VIEW = \"login\";\n    private final static List<String> socialProviders = Arrays.asList(\"github\", \"google\", \"twitter\", \"facebook\", \"bitbucket\");\n    private final static String errorPage = \"forward:/oauth/error\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n\n    @Autowired\n    private ClientService clientService;\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    @RequestMapping(value = \"/login\")\n    public ModelAndView login(\n            @RequestParam(value = OAuth2Utils.CLIENT_ID) String clientId, HttpServletRequest request) {\n        if (clientId == null || clientId.isEmpty()) {\n            logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n        }\n\n        Client client;\n        try {\n            // TODO async call\n            client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n            return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n        }\n\n        Map<String, Object> params = new HashMap<>();\n        params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n        params.put(\"domain\", domain);\n\n        Set<String> clientOAuth2Providers = client.getOauth2Identities();\n        if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n            params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n                IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n                String identityProviderType = identityProvider.getType();\n                Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n                if (identityProviderSocialType.isPresent()) {\n                    identityProvider.setType(identityProviderSocialType.get());\n                }\n                return identityProvider;\n            }).collect(Collectors.toSet()));\n\n            Map<String, String> authorizeUrls = new HashMap<>();\n            clientOAuth2Providers.forEach(identity -> {\n                OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n                if (oAuth2AuthenticationProvider != null) {\n                    OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                    builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                    builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                    builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                    if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                        builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                    }\n                    authorizeUrls.put(identity, builder.build(false).toUriString());\n                }\n            });\n            params.put(\"authorizeUrls\", authorizeUrls);\n        }\n\n        return new ModelAndView(LOGIN_VIEW, params);\n    }\n\n    @RequestMapping(value = \"/login/callback\")\n    public void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n        if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n            final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n            response.sendRedirect(savedRequest.getRedirectUrl());\n        } else {\n            response.sendRedirect(\"/login\");\n        }\n    }\n\n    private String buildRedirectUri(HttpServletRequest request, String identity) {\n        UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        } else {\n            builder.scheme(request.getScheme());\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        } else {\n            builder.host(request.getServerName());\n            if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n                builder.port(request.getServerPort());\n            }\n        }\n        // append context path\n        builder.path(request.getContextPath());\n        builder.pathSegment(\"login/callback\");\n\n        // append identity provider id\n        builder.queryParam(\"provider\", identity);\n\n        return builder.build().toUriString();\n    }\n\n}",
        "start_point": {
            "row": 47,
            "column": 0
        },
        "end_point": {
            "row": 165,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/controller/LoginController.java",
        "methods": [
            {
                "definition": "@RequestMapping(value = \"/login\")\npublic ModelAndView login(\n        @RequestParam(value = OAuth2Utils.CLIENT_ID) String clientId, HttpServletRequest request) {\n    if (clientId == null || clientId.isEmpty()) {\n        logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n    }\n\n    Client client;\n    try {\n        // TODO async call\n        client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n    }\n\n    Map<String, Object> params = new HashMap<>();\n    params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n    params.put(\"domain\", domain);\n\n    Set<String> clientOAuth2Providers = client.getOauth2Identities();\n    if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n        params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n            IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n            String identityProviderType = identityProvider.getType();\n            Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n            if (identityProviderSocialType.isPresent()) {\n                identityProvider.setType(identityProviderSocialType.get());\n            }\n            return identityProvider;\n        }).collect(Collectors.toSet()));\n\n        Map<String, String> authorizeUrls = new HashMap<>();\n        clientOAuth2Providers.forEach(identity -> {\n            OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n            if (oAuth2AuthenticationProvider != null) {\n                OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                    builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                }\n                authorizeUrls.put(identity, builder.build(false).toUriString());\n            }\n        });\n        params.put(\"authorizeUrls\", authorizeUrls);\n    }\n\n    return new ModelAndView(LOGIN_VIEW, params);\n}",
                "name": "login",
                "modifiers": "@RequestMapping(value = \"/login\")\n    public",
                "return_type": "ModelAndView",
                "parameters": [
                    {
                        "type": "@RequestParam(value = OAuth2Utils.CLIENT_ID)",
                        "name": "String"
                    },
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    }
                ],
                "body": "{\n    if (clientId == null || clientId.isEmpty()) {\n        logger.error(OAuth2Utils.CLIENT_ID + \" parameter is required\");\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", OAuth2Utils.CLIENT_ID + \" parameter is required\"));\n    }\n\n    Client client;\n    try {\n        // TODO async call\n        client = clientService.findByDomainAndClientId(domain.getId(), clientId).blockingGet();\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        return new ModelAndView(errorPage, Collections.singletonMap(\"error\", e.getMessage()));\n    }\n\n    Map<String, Object> params = new HashMap<>();\n    params.put(OAuth2Utils.CLIENT_ID, client.getClientId());\n    params.put(\"domain\", domain);\n\n    Set<String> clientOAuth2Providers = client.getOauth2Identities();\n    if (clientOAuth2Providers != null && !clientOAuth2Providers.isEmpty()) {\n        params.put(\"oauth2Providers\", clientOAuth2Providers.stream().map(id -> {\n            IdentityProvider identityProvider = identityProviderManager.getIdentityProvider(id);\n            String identityProviderType = identityProvider.getType();\n            Optional<String> identityProviderSocialType = socialProviders.stream().filter(socialProvider -> identityProviderType.toLowerCase().contains(socialProvider)).findFirst();\n            if (identityProviderSocialType.isPresent()) {\n                identityProvider.setType(identityProviderSocialType.get());\n            }\n            return identityProvider;\n        }).collect(Collectors.toSet()));\n\n        Map<String, String> authorizeUrls = new HashMap<>();\n        clientOAuth2Providers.forEach(identity -> {\n            OAuth2AuthenticationProvider oAuth2AuthenticationProvider = (OAuth2AuthenticationProvider) identityProviderManager.get(identity);\n            if (oAuth2AuthenticationProvider != null) {\n                OAuth2IdentityProviderConfiguration configuration = oAuth2AuthenticationProvider.configuration();\n                UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(configuration.getUserAuthorizationUri());\n                builder.queryParam(OAuth2Utils.CLIENT_ID, configuration.getClientId());\n                builder.queryParam(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request, identity));\n                builder.queryParam(OAuth2Utils.RESPONSE_TYPE, \"code\");\n                if (configuration.getScopes() != null && !configuration.getScopes().isEmpty()) {\n                    builder.queryParam(OAuth2Utils.SCOPE, String.join(\" \", configuration.getScopes()));\n                }\n                authorizeUrls.put(identity, builder.build(false).toUriString());\n            }\n        });\n        params.put(\"authorizeUrls\", authorizeUrls);\n    }\n\n    return new ModelAndView(LOGIN_VIEW, params);\n}",
                "start_point": {
                    "row": 65,
                    "column": 4
                },
                "end_point": {
                    "row": 117,
                    "column": 5
                }
            },
            {
                "definition": "@RequestMapping(value = \"/login/callback\")\npublic void loginCallback(HttpServletResponse response, HttpSession session) throws IOException {\n    if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n        final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n        response.sendRedirect(savedRequest.getRedirectUrl());\n    } else {\n        response.sendRedirect(\"/login\");\n    }\n}",
                "name": "loginCallback",
                "modifiers": "@RequestMapping(value = \"/login/callback\")\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "HttpSession",
                        "name": "session"
                    }
                ],
                "body": "{\n    if (session != null && session.getAttribute(SAVED_REQUEST) != null) {\n        final SavedRequest savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST);\n        response.sendRedirect(savedRequest.getRedirectUrl());\n    } else {\n        response.sendRedirect(\"/login\");\n    }\n}",
                "start_point": {
                    "row": 119,
                    "column": 4
                },
                "end_point": {
                    "row": 127,
                    "column": 5
                }
            },
            {
                "definition": "private String buildRedirectUri(HttpServletRequest request, String identity) {\n    UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    } else {\n        builder.scheme(request.getScheme());\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    } else {\n        builder.host(request.getServerName());\n        if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n            builder.port(request.getServerPort());\n        }\n    }\n    // append context path\n    builder.path(request.getContextPath());\n    builder.pathSegment(\"login/callback\");\n\n    // append identity provider id\n    builder.queryParam(\"provider\", identity);\n\n    return builder.build().toUriString();\n}",
                "name": "buildRedirectUri",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "String",
                        "name": "identity"
                    }
                ],
                "body": "{\n    UriComponentsBuilder builder = UriComponentsBuilder.newInstance();\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    } else {\n        builder.scheme(request.getScheme());\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    } else {\n        builder.host(request.getServerName());\n        if (request.getServerPort() != 80 && request.getServerPort() != 443) {\n            builder.port(request.getServerPort());\n        }\n    }\n    // append context path\n    builder.path(request.getContextPath());\n    builder.pathSegment(\"login/callback\");\n\n    // append identity provider id\n    builder.queryParam(\"provider\", identity);\n\n    return builder.build().toUriString();\n}",
                "start_point": {
                    "row": 129,
                    "column": 4
                },
                "end_point": {
                    "row": 163,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/filter/OAuth2ClientAuthenticationFilter.java",
        "definition": "public class OAuth2ClientAuthenticationFilter extends AbstractAuthenticationProcessingFilter {\n\n    private final Logger logger = LoggerFactory.getLogger(OAuth2ClientAuthenticationFilter.class);\n    private static final String OAUTH2_IDENTIFIER = \"_oauth2_\";\n    private static final String PROVIDER_PARAMETER = \"provider\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private static final String errorPage = \"/oauth/error\";\n    private AuthenticationEventPublisher authenticationEventPublisher;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    public OAuth2ClientAuthenticationFilter(String defaultFilterProcessesUrl) {\n        super(defaultFilterProcessesUrl);\n        setAuthenticationManager(new NoopAuthenticationManager());\n        setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n        // get oauth2 provider\n        String providerId = request.getParameter(PROVIDER_PARAMETER);\n        AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n        if (authenticationProvider == null) {\n            throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n        }\n\n        if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n            throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n        }\n\n        String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n        io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n        ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request)));\n        try {\n            User user = authenticationProvider.loadUserByUsername(provAuthentication);\n            if (user == null) {\n                logger.error(\"User is null, fail to authenticate user\");\n                throw new BadCredentialsException(\"User is null after authentication process\");\n            }\n\n            // set user identity provider source\n            Map<String, String> details = new LinkedHashMap<>();\n            details.put(RepositoryProviderUtils.SOURCE, providerId);\n            UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n            usernamePasswordAuthenticationToken.setDetails(details);\n            return usernamePasswordAuthenticationToken;\n        } catch (Exception ex) {\n            logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    @Override\n    protected final void successfulAuthentication(HttpServletRequest request,\n                                                  HttpServletResponse response, FilterChain chain, Authentication authResult)\n            throws IOException, ServletException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                    + authResult);\n        }\n\n        SecurityContextHolder.getContext().setAuthentication(authResult);\n\n        // Fire event\n        if (this.authenticationEventPublisher != null) {\n            authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n        }\n\n        // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n        // for redirection after successful authentication\n        SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n        if (savedRequest != null && request.getSession(false) != null) {\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {\n        super.setApplicationEventPublisher(eventPublisher);\n        this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n    }\n\n    @Override\n    protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {\n        return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n    }\n\n    /**\n     * Determines if a user is already authenticated.\n     * @return\n     */\n    private boolean authenticated() {\n        Authentication authentication = SecurityContextHolder.getContext()\n                .getAuthentication();\n        return authentication != null && authentication.isAuthenticated()\n                && !(authentication instanceof AnonymousAuthenticationToken);\n    }\n\n    private String buildRedirectUri(HttpServletRequest request) {\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n        // append provider query param to avoid redirect mismatch exception\n        builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n        return builder.build(false).toUriString();\n    }\n\n\n    private static class NoopAuthenticationManager implements AuthenticationManager {\n\n        @Override\n        public Authentication authenticate(Authentication authentication)\n                throws AuthenticationException {\n            throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n        }\n\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.filter;",
        "tree_path": "OAuth2ClientAuthenticationFilter",
        "name": "OAuth2ClientAuthenticationFilter",
        "modifiers": "public",
        "superclass": "extends AbstractAuthenticationProcessingFilter",
        "super_interfaces": null,
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(OAuth2ClientAuthenticationFilter.class);\n    private static final String OAUTH2_IDENTIFIER = \"_oauth2_\";\n    private static final String PROVIDER_PARAMETER = \"provider\";\n    private static final String SAVED_REQUEST = \"GRAVITEEIO_AM_SAVED_REQUEST\";\n    private static final String errorPage = \"/oauth/error\";\n    private AuthenticationEventPublisher authenticationEventPublisher;\n\n    @Autowired\n    private IdentityProviderManager identityProviderManager;\n\n    public OAuth2ClientAuthenticationFilter(String defaultFilterProcessesUrl) {\n        super(defaultFilterProcessesUrl);\n        setAuthenticationManager(new NoopAuthenticationManager());\n        setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n        // get oauth2 provider\n        String providerId = request.getParameter(PROVIDER_PARAMETER);\n        AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n        if (authenticationProvider == null) {\n            throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n        }\n\n        if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n            throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n        }\n\n        String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n        io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n        ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request)));\n        try {\n            User user = authenticationProvider.loadUserByUsername(provAuthentication);\n            if (user == null) {\n                logger.error(\"User is null, fail to authenticate user\");\n                throw new BadCredentialsException(\"User is null after authentication process\");\n            }\n\n            // set user identity provider source\n            Map<String, String> details = new LinkedHashMap<>();\n            details.put(RepositoryProviderUtils.SOURCE, providerId);\n            UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n            usernamePasswordAuthenticationToken.setDetails(details);\n            return usernamePasswordAuthenticationToken;\n        } catch (Exception ex) {\n            logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n    }\n\n    @Override\n    protected final void successfulAuthentication(HttpServletRequest request,\n                                                  HttpServletResponse response, FilterChain chain, Authentication authResult)\n            throws IOException, ServletException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                    + authResult);\n        }\n\n        SecurityContextHolder.getContext().setAuthentication(authResult);\n\n        // Fire event\n        if (this.authenticationEventPublisher != null) {\n            authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n        }\n\n        // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n        // for redirection after successful authentication\n        SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n        if (savedRequest != null && request.getSession(false) != null) {\n            request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {\n        super.setApplicationEventPublisher(eventPublisher);\n        this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n    }\n\n    @Override\n    protected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {\n        return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n    }\n\n    /**\n     * Determines if a user is already authenticated.\n     * @return\n     */\n    private boolean authenticated() {\n        Authentication authentication = SecurityContextHolder.getContext()\n                .getAuthentication();\n        return authentication != null && authentication.isAuthenticated()\n                && !(authentication instanceof AnonymousAuthenticationToken);\n    }\n\n    private String buildRedirectUri(HttpServletRequest request) {\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n        // append provider query param to avoid redirect mismatch exception\n        builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n        return builder.build(false).toUriString();\n    }\n\n\n    private static class NoopAuthenticationManager implements AuthenticationManager {\n\n        @Override\n        public Authentication authenticate(Authentication authentication)\n                throws AuthenticationException {\n            throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n        }\n\n    }\n\n}",
        "start_point": {
            "row": 52,
            "column": 0
        },
        "end_point": {
            "row": 174,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/filter/OAuth2ClientAuthenticationFilter.java",
        "methods": [
            {
                "definition": "public OAuth2ClientAuthenticationFilter(String defaultFilterProcessesUrl) {\n    super(defaultFilterProcessesUrl);\n    setAuthenticationManager(new NoopAuthenticationManager());\n    setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n}",
                "name": "OAuth2ClientAuthenticationFilter",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "String",
                        "name": "defaultFilterProcessesUrl"
                    }
                ],
                "body": "{\n    super(defaultFilterProcessesUrl);\n    setAuthenticationManager(new NoopAuthenticationManager());\n    setAuthenticationFailureHandler(new SimpleUrlAuthenticationFailureHandler(errorPage));\n}",
                "constructor": true,
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {\n    // get oauth2 provider\n    String providerId = request.getParameter(PROVIDER_PARAMETER);\n    AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n    if (authenticationProvider == null) {\n        throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n    }\n\n    if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n        throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n    }\n\n    String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n    ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request)));\n    try {\n        User user = authenticationProvider.loadUserByUsername(provAuthentication);\n        if (user == null) {\n            logger.error(\"User is null, fail to authenticate user\");\n            throw new BadCredentialsException(\"User is null after authentication process\");\n        }\n\n        // set user identity provider source\n        Map<String, String> details = new LinkedHashMap<>();\n        details.put(RepositoryProviderUtils.SOURCE, providerId);\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n        usernamePasswordAuthenticationToken.setDetails(details);\n        return usernamePasswordAuthenticationToken;\n    } catch (Exception ex) {\n        logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n        throw new BadCredentialsException(ex.getMessage(), ex);\n    }\n}",
                "name": "attemptAuthentication",
                "modifiers": "@Override\n    public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    // get oauth2 provider\n    String providerId = request.getParameter(PROVIDER_PARAMETER);\n    AuthenticationProvider authenticationProvider = identityProviderManager.get(providerId);\n\n    if (authenticationProvider == null) {\n        throw new ProviderNotFoundException(\"OAuth2 Provider \" + providerId + \" not found\");\n    }\n\n    if (!(authenticationProvider instanceof OAuth2AuthenticationProvider)) {\n        throw new AuthenticationServiceException(\"OAuth2 Provider \" + providerId + \"is not social\");\n    }\n\n    String password = request.getParameter(((OAuth2AuthenticationProvider) authenticationProvider).configuration().getCodeParameter());\n    io.gravitee.am.identityprovider.api.Authentication provAuthentication = new EndUserAuthentication(OAUTH2_IDENTIFIER, password);\n    ((EndUserAuthentication) provAuthentication).setAdditionalInformation(Collections.singletonMap(OAuth2Utils.REDIRECT_URI, buildRedirectUri(request)));\n    try {\n        User user = authenticationProvider.loadUserByUsername(provAuthentication);\n        if (user == null) {\n            logger.error(\"User is null, fail to authenticate user\");\n            throw new BadCredentialsException(\"User is null after authentication process\");\n        }\n\n        // set user identity provider source\n        Map<String, String> details = new LinkedHashMap<>();\n        details.put(RepositoryProviderUtils.SOURCE, providerId);\n        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(user, provAuthentication.getCredentials(), AuthorityUtils.NO_AUTHORITIES);\n        usernamePasswordAuthenticationToken.setDetails(details);\n        return usernamePasswordAuthenticationToken;\n    } catch (Exception ex) {\n        logger.error(\"Unable to authenticate with oauth2 provider {}\", providerId, ex);\n        throw new BadCredentialsException(ex.getMessage(), ex);\n    }\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 104,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected final void successfulAuthentication(HttpServletRequest request,\n                                              HttpServletResponse response, FilterChain chain, Authentication authResult)\n        throws IOException, ServletException {\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                + authResult);\n    }\n\n    SecurityContextHolder.getContext().setAuthentication(authResult);\n\n    // Fire event\n    if (this.authenticationEventPublisher != null) {\n        authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n    }\n\n    // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n    // for redirection after successful authentication\n    SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n    if (savedRequest != null && request.getSession(false) != null) {\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    chain.doFilter(request, response);\n}",
                "name": "successfulAuthentication",
                "modifiers": "@Override\n    protected final",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "FilterChain",
                        "name": "chain"
                    },
                    {
                        "type": "Authentication",
                        "name": "authResult"
                    }
                ],
                "body": "{\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Authentication success. Updating SecurityContextHolder to contain: \"\n                + authResult);\n    }\n\n    SecurityContextHolder.getContext().setAuthentication(authResult);\n\n    // Fire event\n    if (this.authenticationEventPublisher != null) {\n        authenticationEventPublisher.publishAuthenticationSuccess(authResult);\n    }\n\n    // Store the saved HTTP request itself. Used by LoginController (login/callback method)\n    // for redirection after successful authentication\n    SavedRequest savedRequest = new HttpSessionRequestCache().getRequest(request, response);\n    if (savedRequest != null && request.getSession(false) != null) {\n        request.getSession(false).setAttribute(SAVED_REQUEST, savedRequest);\n    }\n\n    chain.doFilter(request, response);\n}",
                "start_point": {
                    "row": 106,
                    "column": 4
                },
                "end_point": {
                    "row": 131,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {\n    super.setApplicationEventPublisher(eventPublisher);\n    this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n}",
                "name": "setApplicationEventPublisher",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "ApplicationEventPublisher",
                        "name": "eventPublisher"
                    }
                ],
                "body": "{\n    super.setApplicationEventPublisher(eventPublisher);\n    this.authenticationEventPublisher = new DefaultAuthenticationEventPublisher(eventPublisher);\n}",
                "start_point": {
                    "row": 133,
                    "column": 4
                },
                "end_point": {
                    "row": 137,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected boolean requiresAuthentication(HttpServletRequest request, HttpServletResponse response) {\n    return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n}",
                "name": "requiresAuthentication",
                "modifiers": "@Override\n    protected",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    return super.requiresAuthentication(request, response) && !authenticated() && request.getParameter(PROVIDER_PARAMETER) != null;\n}",
                "start_point": {
                    "row": 139,
                    "column": 4
                },
                "end_point": {
                    "row": 142,
                    "column": 5
                }
            },
            {
                "definition": "private boolean authenticated() {\n    Authentication authentication = SecurityContextHolder.getContext()\n            .getAuthentication();\n    return authentication != null && authentication.isAuthenticated()\n            && !(authentication instanceof AnonymousAuthenticationToken);\n}",
                "name": "authenticated",
                "modifiers": "private",
                "return_type": null,
                "parameters": [],
                "body": "{\n    Authentication authentication = SecurityContextHolder.getContext()\n            .getAuthentication();\n    return authentication != null && authentication.isAuthenticated()\n            && !(authentication instanceof AnonymousAuthenticationToken);\n}",
                "start_point": {
                    "row": 148,
                    "column": 4
                },
                "end_point": {
                    "row": 153,
                    "column": 5
                }
            },
            {
                "definition": "private String buildRedirectUri(HttpServletRequest request) {\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n    // append provider query param to avoid redirect mismatch exception\n    builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n    return builder.build(false).toUriString();\n}",
                "name": "buildRedirectUri",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    }
                ],
                "body": "{\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(request.getRequestURL().toString());\n    // append provider query param to avoid redirect mismatch exception\n    builder.queryParam(\"provider\", request.getParameter(\"provider\"));\n\n    return builder.build(false).toUriString();\n}",
                "start_point": {
                    "row": 155,
                    "column": 4
                },
                "end_point": {
                    "row": 161,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/filter/OAuth2ClientAuthenticationFilter.java",
        "definition": "private static class NoopAuthenticationManager implements AuthenticationManager {\n\n    @Override\n    public Authentication authenticate(Authentication authentication)\n            throws AuthenticationException {\n        throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.filter;",
        "tree_path": "OAuth2ClientAuthenticationFilter.NoopAuthenticationManager",
        "name": "NoopAuthenticationManager",
        "modifiers": "private static",
        "superclass": null,
        "super_interfaces": "implements AuthenticationManager",
        "body": "{\n\n    @Override\n    public Authentication authenticate(Authentication authentication)\n            throws AuthenticationException {\n        throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n    }\n\n}",
        "start_point": {
            "row": 164,
            "column": 4
        },
        "end_point": {
            "row": 172,
            "column": 5
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/filter/OAuth2ClientAuthenticationFilter.java",
        "methods": [
            {
                "definition": "@Override\npublic Authentication authenticate(Authentication authentication)\n        throws AuthenticationException {\n    throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n}",
                "name": "authenticate",
                "modifiers": "@Override\n        public",
                "return_type": "Authentication",
                "parameters": [
                    {
                        "type": "Authentication",
                        "name": "authentication"
                    }
                ],
                "body": "{\n    throw new UnsupportedOperationException(\"No authentication should be done with this AuthenticationManager\");\n}",
                "start_point": {
                    "row": 166,
                    "column": 8
                },
                "end_point": {
                    "row": 170,
                    "column": 9
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/handler/CustomLogoutSuccessHandler.java",
        "definition": "public class CustomLogoutSuccessHandler extends SimpleUrlLogoutSuccessHandler {\n\n    private static final String LOGOUT_URL_PARAMETER = \"target_url\";\n\n    @Override\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n        if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n            setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n        }\n        return super.determineTargetUrl(request, response);\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.handler;",
        "tree_path": "CustomLogoutSuccessHandler",
        "name": "CustomLogoutSuccessHandler",
        "modifiers": "public",
        "superclass": "extends SimpleUrlLogoutSuccessHandler",
        "super_interfaces": null,
        "body": "{\n\n    private static final String LOGOUT_URL_PARAMETER = \"target_url\";\n\n    @Override\n    protected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n        String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n        if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n            setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n        }\n        return super.determineTargetUrl(request, response);\n    }\n}",
        "start_point": {
            "row": 26,
            "column": 0
        },
        "end_point": {
            "row": 38,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/handler/CustomLogoutSuccessHandler.java",
        "methods": [
            {
                "definition": "@Override\nprotected String determineTargetUrl(HttpServletRequest request, HttpServletResponse response) {\n    String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n    if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n        setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n    }\n    return super.determineTargetUrl(request, response);\n}",
                "name": "determineTargetUrl",
                "modifiers": "@Override\n    protected",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    }
                ],
                "body": "{\n    String logoutRedirectUrl = request.getParameter(LOGOUT_URL_PARAMETER);\n    if (logoutRedirectUrl != null && !logoutRedirectUrl.isEmpty()) {\n        setTargetUrlParameter(LOGOUT_URL_PARAMETER);\n    }\n    return super.determineTargetUrl(request, response);\n}",
                "start_point": {
                    "row": 30,
                    "column": 4
                },
                "end_point": {
                    "row": 37,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/provider/security/EndUserAuthentication.java",
        "definition": "public class EndUserAuthentication implements Authentication {\n\n    private final Object principal;\n    private final Object credentials;\n    private Map<String, Object> additionalInformation;\n\n    public EndUserAuthentication(Object principal, Object credentials) {\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    @Override\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public Map<String, Object> getAdditionalInformation() {\n        return additionalInformation;\n    }\n\n    public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n\n    @Override\n    public String toString() {\n        return principal.toString();\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.provider.security;",
        "tree_path": "EndUserAuthentication",
        "name": "EndUserAuthentication",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements Authentication",
        "body": "{\n\n    private final Object principal;\n    private final Object credentials;\n    private Map<String, Object> additionalInformation;\n\n    public EndUserAuthentication(Object principal, Object credentials) {\n        this.principal = principal;\n        this.credentials = credentials;\n    }\n\n    @Override\n    public Object getCredentials() {\n        return credentials;\n    }\n\n    @Override\n    public Object getPrincipal() {\n        return principal;\n    }\n\n    @Override\n    public Map<String, Object> getAdditionalInformation() {\n        return additionalInformation;\n    }\n\n    public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n        this.additionalInformation = additionalInformation;\n    }\n\n    @Override\n    public String toString() {\n        return principal.toString();\n    }\n}",
        "start_point": {
            "row": 25,
            "column": 0
        },
        "end_point": {
            "row": 59,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/provider/security/EndUserAuthentication.java",
        "methods": [
            {
                "definition": "public EndUserAuthentication(Object principal, Object credentials) {\n    this.principal = principal;\n    this.credentials = credentials;\n}",
                "name": "EndUserAuthentication",
                "modifiers": "public",
                "parameters": [
                    {
                        "type": "Object",
                        "name": "principal"
                    },
                    {
                        "type": "Object",
                        "name": "credentials"
                    }
                ],
                "body": "{\n    this.principal = principal;\n    this.credentials = credentials;\n}",
                "constructor": true,
                "start_point": {
                    "row": 31,
                    "column": 4
                },
                "end_point": {
                    "row": 34,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Object getCredentials() {\n    return credentials;\n}",
                "name": "getCredentials",
                "modifiers": "@Override\n    public",
                "return_type": "Object",
                "parameters": [],
                "body": "{\n    return credentials;\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 39,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Object getPrincipal() {\n    return principal;\n}",
                "name": "getPrincipal",
                "modifiers": "@Override\n    public",
                "return_type": "Object",
                "parameters": [],
                "body": "{\n    return principal;\n}",
                "start_point": {
                    "row": 41,
                    "column": 4
                },
                "end_point": {
                    "row": 44,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Map<String, Object> getAdditionalInformation() {\n    return additionalInformation;\n}",
                "name": "getAdditionalInformation",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return additionalInformation;\n}",
                "start_point": {
                    "row": 46,
                    "column": 4
                },
                "end_point": {
                    "row": 49,
                    "column": 5
                }
            },
            {
                "definition": "public void setAdditionalInformation(Map<String, Object> additionalInformation) {\n    this.additionalInformation = additionalInformation;\n}",
                "name": "setAdditionalInformation",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "Map<String, Object>",
                        "name": "additionalInformation"
                    }
                ],
                "body": "{\n    this.additionalInformation = additionalInformation;\n}",
                "start_point": {
                    "row": 51,
                    "column": 4
                },
                "end_point": {
                    "row": 53,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic String toString() {\n    return principal.toString();\n}",
                "name": "toString",
                "modifiers": "@Override\n    public",
                "return_type": "String",
                "parameters": [],
                "body": "{\n    return principal.toString();\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/impl/IdentityProviderManagerImpl.java",
        "definition": "public class IdentityProviderManagerImpl implements IdentityProviderManager, InitializingBean {\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(IdentityProviderManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderPluginManager identityProviderPluginManager;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    private Map<String, AuthenticationProvider> providers = new HashMap<>();\n    private Map<String, IdentityProvider> identities = new HashMap<>();\n\n    @Override\n    public AuthenticationProvider get(String id) {\n        return providers.get(id);\n    }\n\n    public IdentityProvider getIdentityProvider(String id) {\n        return identities.get(id);\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n        // TODO async call\n        List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n        identityProviders.forEach(identityProvider -> {\n            logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n            AuthenticationProvider authenticationProvider =\n                    identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                            identityProvider.getMappers(), identityProvider.getRoleMapper());\n            providers.put(identityProvider.getId(), authenticationProvider);\n            identities.put(identityProvider.getId(), identityProvider);\n        });\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.security.impl;",
        "tree_path": "IdentityProviderManagerImpl",
        "name": "IdentityProviderManagerImpl",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements IdentityProviderManager, InitializingBean",
        "body": "{\n\n    /**\n     * Logger\n     */\n    private final Logger logger = LoggerFactory.getLogger(IdentityProviderManagerImpl.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private IdentityProviderPluginManager identityProviderPluginManager;\n\n    @Autowired\n    private IdentityProviderService identityProviderService;\n\n    private Map<String, AuthenticationProvider> providers = new HashMap<>();\n    private Map<String, IdentityProvider> identities = new HashMap<>();\n\n    @Override\n    public AuthenticationProvider get(String id) {\n        return providers.get(id);\n    }\n\n    public IdentityProvider getIdentityProvider(String id) {\n        return identities.get(id);\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n        // TODO async call\n        List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n        identityProviders.forEach(identityProvider -> {\n            logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n            AuthenticationProvider authenticationProvider =\n                    identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                            identityProvider.getMappers(), identityProvider.getRoleMapper());\n            providers.put(identityProvider.getId(), authenticationProvider);\n            identities.put(identityProvider.getId(), identityProvider);\n        });\n    }\n}",
        "start_point": {
            "row": 36,
            "column": 0
        },
        "end_point": {
            "row": 80,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/security/impl/IdentityProviderManagerImpl.java",
        "methods": [
            {
                "definition": "@Override\npublic AuthenticationProvider get(String id) {\n    return providers.get(id);\n}",
                "name": "get",
                "modifiers": "@Override\n    public",
                "return_type": "AuthenticationProvider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return providers.get(id);\n}",
                "start_point": {
                    "row": 55,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "public IdentityProvider getIdentityProvider(String id) {\n    return identities.get(id);\n}",
                "name": "getIdentityProvider",
                "modifiers": "public",
                "return_type": "IdentityProvider",
                "parameters": [
                    {
                        "type": "String",
                        "name": "id"
                    }
                ],
                "body": "{\n    return identities.get(id);\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 62,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic void afterPropertiesSet() throws Exception {\n    logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n    // TODO async call\n    List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n    identityProviders.forEach(identityProvider -> {\n        logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n        AuthenticationProvider authenticationProvider =\n                identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                        identityProvider.getMappers(), identityProvider.getRoleMapper());\n        providers.put(identityProvider.getId(), authenticationProvider);\n        identities.put(identityProvider.getId(), identityProvider);\n    });\n}",
                "name": "afterPropertiesSet",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    logger.info(\"Initializing identity providers for domain {}\", domain.getName());\n    // TODO async call\n    List<IdentityProvider> identityProviders = identityProviderService.findByDomain(domain.getId()).blockingGet();\n\n    identityProviders.forEach(identityProvider -> {\n        logger.info(\"\\tInitializing identity provider: {} [{}]\", identityProvider.getName(), identityProvider.getType());\n\n        AuthenticationProvider authenticationProvider =\n                identityProviderPluginManager.create(identityProvider.getType(), identityProvider.getConfiguration(),\n                        identityProvider.getMappers(), identityProvider.getRoleMapper());\n        providers.put(identityProvider.getId(), authenticationProvider);\n        identities.put(identityProvider.getId(), identityProvider);\n    });\n}",
                "start_point": {
                    "row": 64,
                    "column": 4
                },
                "end_point": {
                    "row": 79,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/listener/AuthenticationSuccessListener.java",
        "definition": "public class AuthenticationSuccessListener implements ApplicationListener<AuthenticationSuccessEvent> {\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public void onApplicationEvent(AuthenticationSuccessEvent event) {\n        final User principal = (User) event.getAuthentication().getPrincipal();\n        Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n        try {\n            // TODO async call\n            io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n            UpdateUser updateUser = new UpdateUser();\n            if (details != null) {\n                updateUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n                updateUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n            }\n            updateUser.setLoggedAt(new Date());\n            updateUser.setLoginsCount(user.getLoginsCount() + 1);\n            updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.update(domain.getId(), user.getId(), updateUser);\n        } catch (UserNotFoundException unfe) {\n            final NewUser newUser = new NewUser();\n            newUser.setUsername(principal.getUsername());\n            if (details != null) {\n                newUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n                newUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n            }\n            newUser.setLoggedAt(new Date());\n            newUser.setLoginsCount(1l);\n            newUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.create(domain.getId(), newUser);\n        }\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.security.listener;",
        "tree_path": "AuthenticationSuccessListener",
        "name": "AuthenticationSuccessListener",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements ApplicationListener<AuthenticationSuccessEvent>",
        "body": "{\n\n    @Autowired\n    private Domain domain;\n\n    @Autowired\n    private UserService userService;\n\n    @Override\n    public void onApplicationEvent(AuthenticationSuccessEvent event) {\n        final User principal = (User) event.getAuthentication().getPrincipal();\n        Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n        try {\n            // TODO async call\n            io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n            UpdateUser updateUser = new UpdateUser();\n            if (details != null) {\n                updateUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n                updateUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n            }\n            updateUser.setLoggedAt(new Date());\n            updateUser.setLoginsCount(user.getLoginsCount() + 1);\n            updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.update(domain.getId(), user.getId(), updateUser);\n        } catch (UserNotFoundException unfe) {\n            final NewUser newUser = new NewUser();\n            newUser.setUsername(principal.getUsername());\n            if (details != null) {\n                newUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n                newUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n            }\n            newUser.setLoggedAt(new Date());\n            newUser.setLoginsCount(1l);\n            newUser.setAdditionalInformation(principal.getAdditionalInformation());\n            userService.create(domain.getId(), newUser);\n        }\n    }\n}",
        "start_point": {
            "row": 36,
            "column": 0
        },
        "end_point": {
            "row": 74,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/security/listener/AuthenticationSuccessListener.java",
        "methods": [
            {
                "definition": "@Override\npublic void onApplicationEvent(AuthenticationSuccessEvent event) {\n    final User principal = (User) event.getAuthentication().getPrincipal();\n    Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n    try {\n        // TODO async call\n        io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n        UpdateUser updateUser = new UpdateUser();\n        if (details != null) {\n            updateUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n            updateUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n        }\n        updateUser.setLoggedAt(new Date());\n        updateUser.setLoginsCount(user.getLoginsCount() + 1);\n        updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.update(domain.getId(), user.getId(), updateUser);\n    } catch (UserNotFoundException unfe) {\n        final NewUser newUser = new NewUser();\n        newUser.setUsername(principal.getUsername());\n        if (details != null) {\n            newUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n            newUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n        }\n        newUser.setLoggedAt(new Date());\n        newUser.setLoginsCount(1l);\n        newUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.create(domain.getId(), newUser);\n    }\n}",
                "name": "onApplicationEvent",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "AuthenticationSuccessEvent",
                        "name": "event"
                    }
                ],
                "body": "{\n    final User principal = (User) event.getAuthentication().getPrincipal();\n    Map<String, String> details = (Map<String, String>) event.getAuthentication().getDetails();\n\n    try {\n        // TODO async call\n        io.gravitee.am.model.User user = userService.loadUserByUsernameAndDomain(domain.getId(), principal.getUsername()).blockingGet();\n        UpdateUser updateUser = new UpdateUser();\n        if (details != null) {\n            updateUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n            updateUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n        }\n        updateUser.setLoggedAt(new Date());\n        updateUser.setLoginsCount(user.getLoginsCount() + 1);\n        updateUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.update(domain.getId(), user.getId(), updateUser);\n    } catch (UserNotFoundException unfe) {\n        final NewUser newUser = new NewUser();\n        newUser.setUsername(principal.getUsername());\n        if (details != null) {\n            newUser.setSource(details.get(RepositoryProviderUtils.SOURCE));\n            newUser.setClient(details.get(OAuth2Utils.CLIENT_ID));\n        }\n        newUser.setLoggedAt(new Date());\n        newUser.setLoginsCount(1l);\n        newUser.setAdditionalInformation(principal.getAdditionalInformation());\n        userService.create(domain.getId(), newUser);\n    }\n}",
                "start_point": {
                    "row": 44,
                    "column": 4
                },
                "end_point": {
                    "row": 73,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/security/web/XForwardedAwareRedirectStrategy.java",
        "definition": "public class XForwardedAwareRedirectStrategy implements RedirectStrategy {\n\n    private final Logger logger = LoggerFactory.getLogger(XForwardedAwareRedirectStrategy.class);\n\n    private boolean contextRelative;\n\n    @Override\n    public void sendRedirect(HttpServletRequest request, HttpServletResponse response, String url) throws IOException {\n        String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Redirecting to '{}'\", redirectUrl);\n        }\n\n        response.sendRedirect(redirectUrl);\n    }\n\n    private String calculateRedirectUrl(String contextPath, String url) {\n        if (!UrlUtils.isAbsoluteUrl(url)) {\n            if (contextRelative) {\n                return url;\n            } else {\n                return contextPath + url;\n            }\n        }\n\n        // Full URL, including http(s)://\n\n        if (!contextRelative) {\n            return url;\n        }\n\n        // Calculate the relative URL from the fully qualified URL, minus the last\n        // occurrence of the scheme and base context.\n        url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n        url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n        if (url.length() > 1 && url.charAt(0) == '/') {\n            url = url.substring(1);\n        }\n\n        return url;\n    }\n\n    /**\n     * If <tt>true</tt>, causes any redirection URLs to be calculated minus the protocol\n     * and context path (defaults to <tt>false</tt>).\n     */\n    public void setContextRelative(boolean useRelativeContext) {\n        this.contextRelative = useRelativeContext;\n    }\n\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.security.web;",
        "tree_path": "XForwardedAwareRedirectStrategy",
        "name": "XForwardedAwareRedirectStrategy",
        "modifiers": "public",
        "superclass": null,
        "super_interfaces": "implements RedirectStrategy",
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(XForwardedAwareRedirectStrategy.class);\n\n    private boolean contextRelative;\n\n    @Override\n    public void sendRedirect(HttpServletRequest request, HttpServletResponse response, String url) throws IOException {\n        String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n        String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n        if (scheme != null && !scheme.isEmpty()) {\n            builder.scheme(scheme);\n        }\n\n        String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n        if (host != null && !host.isEmpty()) {\n            if (host.contains(\":\")) {\n                // Forwarded host contains both host and port\n                String [] parts = host.split(\":\");\n                builder.host(parts[0]);\n                builder.port(parts[1]);\n            } else {\n                builder.host(host);\n            }\n        }\n\n        redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Redirecting to '{}'\", redirectUrl);\n        }\n\n        response.sendRedirect(redirectUrl);\n    }\n\n    private String calculateRedirectUrl(String contextPath, String url) {\n        if (!UrlUtils.isAbsoluteUrl(url)) {\n            if (contextRelative) {\n                return url;\n            } else {\n                return contextPath + url;\n            }\n        }\n\n        // Full URL, including http(s)://\n\n        if (!contextRelative) {\n            return url;\n        }\n\n        // Calculate the relative URL from the fully qualified URL, minus the last\n        // occurrence of the scheme and base context.\n        url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n        url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n        if (url.length() > 1 && url.charAt(0) == '/') {\n            url = url.substring(1);\n        }\n\n        return url;\n    }\n\n    /**\n     * If <tt>true</tt>, causes any redirection URLs to be calculated minus the protocol\n     * and context path (defaults to <tt>false</tt>).\n     */\n    public void setContextRelative(boolean useRelativeContext) {\n        this.contextRelative = useRelativeContext;\n    }\n\n}",
        "start_point": {
            "row": 32,
            "column": 0
        },
        "end_point": {
            "row": 105,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/security/web/XForwardedAwareRedirectStrategy.java",
        "methods": [
            {
                "definition": "@Override\npublic void sendRedirect(HttpServletRequest request, HttpServletResponse response, String url) throws IOException {\n    String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Redirecting to '{}'\", redirectUrl);\n    }\n\n    response.sendRedirect(redirectUrl);\n}",
                "name": "sendRedirect",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "HttpServletRequest",
                        "name": "request"
                    },
                    {
                        "type": "HttpServletResponse",
                        "name": "response"
                    },
                    {
                        "type": "String",
                        "name": "url"
                    }
                ],
                "body": "{\n    String redirectUrl = calculateRedirectUrl(request.getContextPath(), url);\n\n    UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(redirectUrl);\n\n    String scheme = request.getHeader(HttpHeaders.X_FORWARDED_PROTO);\n    if (scheme != null && !scheme.isEmpty()) {\n        builder.scheme(scheme);\n    }\n\n    String host = request.getHeader(HttpHeaders.X_FORWARDED_HOST);\n    if (host != null && !host.isEmpty()) {\n        if (host.contains(\":\")) {\n            // Forwarded host contains both host and port\n            String [] parts = host.split(\":\");\n            builder.host(parts[0]);\n            builder.port(parts[1]);\n        } else {\n            builder.host(host);\n        }\n    }\n\n    redirectUrl = response.encodeRedirectURL(builder.build(false).toUriString());\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Redirecting to '{}'\", redirectUrl);\n    }\n\n    response.sendRedirect(redirectUrl);\n}",
                "start_point": {
                    "row": 38,
                    "column": 4
                },
                "end_point": {
                    "row": 68,
                    "column": 5
                }
            },
            {
                "definition": "private String calculateRedirectUrl(String contextPath, String url) {\n    if (!UrlUtils.isAbsoluteUrl(url)) {\n        if (contextRelative) {\n            return url;\n        } else {\n            return contextPath + url;\n        }\n    }\n\n    // Full URL, including http(s)://\n\n    if (!contextRelative) {\n        return url;\n    }\n\n    // Calculate the relative URL from the fully qualified URL, minus the last\n    // occurrence of the scheme and base context.\n    url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n    url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n    if (url.length() > 1 && url.charAt(0) == '/') {\n        url = url.substring(1);\n    }\n\n    return url;\n}",
                "name": "calculateRedirectUrl",
                "modifiers": "private",
                "return_type": "String",
                "parameters": [
                    {
                        "type": "String",
                        "name": "contextPath"
                    },
                    {
                        "type": "String",
                        "name": "url"
                    }
                ],
                "body": "{\n    if (!UrlUtils.isAbsoluteUrl(url)) {\n        if (contextRelative) {\n            return url;\n        } else {\n            return contextPath + url;\n        }\n    }\n\n    // Full URL, including http(s)://\n\n    if (!contextRelative) {\n        return url;\n    }\n\n    // Calculate the relative URL from the fully qualified URL, minus the last\n    // occurrence of the scheme and base context.\n    url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n    url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n    if (url.length() > 1 && url.charAt(0) == '/') {\n        url = url.substring(1);\n    }\n\n    return url;\n}",
                "start_point": {
                    "row": 70,
                    "column": 4
                },
                "end_point": {
                    "row": 95,
                    "column": 5
                }
            },
            {
                "definition": "public void setContextRelative(boolean useRelativeContext) {\n    this.contextRelative = useRelativeContext;\n}",
                "name": "setContextRelative",
                "modifiers": "public",
                "return_type": null,
                "parameters": [
                    {
                        "type": "boolean",
                        "name": "useRelativeContext"
                    }
                ],
                "body": "{\n    this.contextRelative = useRelativeContext;\n}",
                "start_point": {
                    "row": 101,
                    "column": 4
                },
                "end_point": {
                    "row": 103,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/CustomAuthorizationServerEndpointsConfiguration.java",
        "definition": "public class CustomAuthorizationServerEndpointsConfiguration extends AuthorizationServerEndpointsConfiguration {\n\n    @Bean\n    public RevokeTokenEndpoint revokeTokenEndpoint() {\n        RevokeTokenEndpoint endpoint = new RevokeTokenEndpoint(\n                getEndpointsConfigurer().getTokenStore(),\n                getEndpointsConfigurer().getResourceServerTokenServices());\n        endpoint.setExceptionTranslator(getEndpointsConfigurer().getExceptionTranslator());\n        return endpoint;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2;",
        "tree_path": "CustomAuthorizationServerEndpointsConfiguration",
        "name": "CustomAuthorizationServerEndpointsConfiguration",
        "modifiers": "public",
        "superclass": "extends AuthorizationServerEndpointsConfiguration",
        "super_interfaces": null,
        "body": "{\n\n    @Bean\n    public RevokeTokenEndpoint revokeTokenEndpoint() {\n        RevokeTokenEndpoint endpoint = new RevokeTokenEndpoint(\n                getEndpointsConfigurer().getTokenStore(),\n                getEndpointsConfigurer().getResourceServerTokenServices());\n        endpoint.setExceptionTranslator(getEndpointsConfigurer().getExceptionTranslator());\n        return endpoint;\n    }\n}",
        "start_point": {
            "row": 25,
            "column": 0
        },
        "end_point": {
            "row": 35,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/spring/AdminConfiguration.java",
        "methods": [
            {
                "definition": "@Bean\npublic RevokeTokenEndpoint revokeTokenEndpoint() {\n    RevokeTokenEndpoint endpoint = new RevokeTokenEndpoint(\n            getEndpointsConfigurer().getTokenStore(),\n            getEndpointsConfigurer().getResourceServerTokenServices());\n    endpoint.setExceptionTranslator(getEndpointsConfigurer().getExceptionTranslator());\n    return endpoint;\n}",
                "name": "revokeTokenEndpoint",
                "modifiers": "@Bean\n    public",
                "return_type": "RevokeTokenEndpoint",
                "parameters": [],
                "body": "{\n    RevokeTokenEndpoint endpoint = new RevokeTokenEndpoint(\n            getEndpointsConfigurer().getTokenStore(),\n            getEndpointsConfigurer().getResourceServerTokenServices());\n    endpoint.setExceptionTranslator(getEndpointsConfigurer().getExceptionTranslator());\n    return endpoint;\n}",
                "start_point": {
                    "row": 27,
                    "column": 4
                },
                "end_point": {
                    "row": 34,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/view/DomainBasedTemplateResolver.java",
        "definition": "public class DomainBasedTemplateResolver extends StringTemplateResolver {\n\n    @Autowired\n    private Domain domain;\n\n    public DomainBasedTemplateResolver() {\n        setTemplateMode(\"HTML\");\n    }\n\n    @Override\n    protected ITemplateResource computeTemplateResource(IEngineConfiguration configuration, String ownerTemplate, String template, Map<String, Object> templateResolutionAttributes) {\n        return new StringTemplateResource(domain.getLoginForm().getContent());\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.view;",
        "tree_path": "DomainBasedTemplateResolver",
        "name": "DomainBasedTemplateResolver",
        "modifiers": "public",
        "superclass": "extends StringTemplateResolver",
        "super_interfaces": null,
        "body": "{\n\n    @Autowired\n    private Domain domain;\n\n    public DomainBasedTemplateResolver() {\n        setTemplateMode(\"HTML\");\n    }\n\n    @Override\n    protected ITemplateResource computeTemplateResource(IEngineConfiguration configuration, String ownerTemplate, String template, Map<String, Object> templateResolutionAttributes) {\n        return new StringTemplateResource(domain.getLoginForm().getContent());\n    }\n}",
        "start_point": {
            "row": 30,
            "column": 0
        },
        "end_point": {
            "row": 43,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/view/DomainBasedTemplateResolver.java",
        "methods": [
            {
                "definition": "public DomainBasedTemplateResolver() {\n    setTemplateMode(\"HTML\");\n}",
                "name": "DomainBasedTemplateResolver",
                "modifiers": "public",
                "parameters": [],
                "body": "{\n    setTemplateMode(\"HTML\");\n}",
                "constructor": true,
                "start_point": {
                    "row": 35,
                    "column": 4
                },
                "end_point": {
                    "row": 37,
                    "column": 5
                }
            },
            {
                "definition": "@Override\nprotected ITemplateResource computeTemplateResource(IEngineConfiguration configuration, String ownerTemplate, String template, Map<String, Object> templateResolutionAttributes) {\n    return new StringTemplateResource(domain.getLoginForm().getContent());\n}",
                "name": "computeTemplateResource",
                "modifiers": "@Override\n    protected",
                "return_type": "ITemplateResource",
                "parameters": [
                    {
                        "type": "IEngineConfiguration",
                        "name": "configuration"
                    },
                    {
                        "type": "String",
                        "name": "ownerTemplate"
                    },
                    {
                        "type": "String",
                        "name": "template"
                    },
                    {
                        "type": "Map<String, Object>",
                        "name": "templateResolutionAttributes"
                    }
                ],
                "body": "{\n    return new StringTemplateResource(domain.getLoginForm().getContent());\n}",
                "start_point": {
                    "row": 39,
                    "column": 4
                },
                "end_point": {
                    "row": 42,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/view/ThymeleafConfiguration.java",
        "definition": "@Configuration\npublic class ThymeleafConfiguration {\n\n    @Bean\n    public ThymeleafTemplateResolverFactory getTemplateResolver() {\n        return new ThymeleafTemplateResolverFactory();\n    }\n\n    @Bean\n    public TemplateEngine getTemplateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setEnableSpringELCompiler(true);\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    @Bean\n    public ViewResolver getViewResolver(TemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setTemplateEngine(templateEngine);\n        viewResolver.setCharacterEncoding(\"UTF-8\");\n        return viewResolver;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.view;",
        "tree_path": "ThymeleafConfiguration",
        "name": "ThymeleafConfiguration",
        "modifiers": "@Configuration\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @Bean\n    public ThymeleafTemplateResolverFactory getTemplateResolver() {\n        return new ThymeleafTemplateResolverFactory();\n    }\n\n    @Bean\n    public TemplateEngine getTemplateEngine(ITemplateResolver templateResolver) {\n        SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n        templateEngine.setEnableSpringELCompiler(true);\n        templateEngine.setTemplateResolver(templateResolver);\n        return templateEngine;\n    }\n\n    @Bean\n    public ViewResolver getViewResolver(TemplateEngine templateEngine) {\n        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n        viewResolver.setTemplateEngine(templateEngine);\n        viewResolver.setCharacterEncoding(\"UTF-8\");\n        return viewResolver;\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 52,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/view/ThymeleafConfiguration.java",
        "methods": [
            {
                "definition": "@Bean\npublic ThymeleafTemplateResolverFactory getTemplateResolver() {\n    return new ThymeleafTemplateResolverFactory();\n}",
                "name": "getTemplateResolver",
                "modifiers": "@Bean\n    public",
                "return_type": "ThymeleafTemplateResolverFactory",
                "parameters": [],
                "body": "{\n    return new ThymeleafTemplateResolverFactory();\n}",
                "start_point": {
                    "row": 32,
                    "column": 4
                },
                "end_point": {
                    "row": 35,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic TemplateEngine getTemplateEngine(ITemplateResolver templateResolver) {\n    SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n    templateEngine.setEnableSpringELCompiler(true);\n    templateEngine.setTemplateResolver(templateResolver);\n    return templateEngine;\n}",
                "name": "getTemplateEngine",
                "modifiers": "@Bean\n    public",
                "return_type": "TemplateEngine",
                "parameters": [
                    {
                        "type": "ITemplateResolver",
                        "name": "templateResolver"
                    }
                ],
                "body": "{\n    SpringTemplateEngine templateEngine = new SpringTemplateEngine();\n    templateEngine.setEnableSpringELCompiler(true);\n    templateEngine.setTemplateResolver(templateResolver);\n    return templateEngine;\n}",
                "start_point": {
                    "row": 37,
                    "column": 4
                },
                "end_point": {
                    "row": 43,
                    "column": 5
                }
            },
            {
                "definition": "@Bean\npublic ViewResolver getViewResolver(TemplateEngine templateEngine) {\n    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n    viewResolver.setTemplateEngine(templateEngine);\n    viewResolver.setCharacterEncoding(\"UTF-8\");\n    return viewResolver;\n}",
                "name": "getViewResolver",
                "modifiers": "@Bean\n    public",
                "return_type": "ViewResolver",
                "parameters": [
                    {
                        "type": "TemplateEngine",
                        "name": "templateEngine"
                    }
                ],
                "body": "{\n    ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();\n    viewResolver.setTemplateEngine(templateEngine);\n    viewResolver.setCharacterEncoding(\"UTF-8\");\n    return viewResolver;\n}",
                "start_point": {
                    "row": 45,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/main/java/io/gravitee/am/management/handlers/oauth2/view/ThymeleafTemplateResolverFactory.java",
        "definition": "public class ThymeleafTemplateResolverFactory extends AbstractAutowiringFactoryBean<ITemplateResolver> {\n\n    private final Logger logger = LoggerFactory.getLogger(ThymeleafTemplateResolverFactory.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    protected ITemplateResolver doCreateInstance() throws Exception {\n        if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n            logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n            return defaultTemplateResolver();\n        }\n\n        ITemplateResolver resolver = overrideTemplateResolver();\n\n        return (resolver != null) ? resolver : defaultTemplateResolver();\n    }\n\n    private ITemplateResolver overrideTemplateResolver() {\n        return new DomainBasedTemplateResolver();\n\n    }\n    private ITemplateResolver defaultTemplateResolver() {\n        ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n        templateResolver.setPrefix(\"/views/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(\"HTML\");\n        return templateResolver;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return ITemplateResolver.class;\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.view;",
        "tree_path": "ThymeleafTemplateResolverFactory",
        "name": "ThymeleafTemplateResolverFactory",
        "modifiers": "public",
        "superclass": "extends AbstractAutowiringFactoryBean<ITemplateResolver>",
        "super_interfaces": null,
        "body": "{\n\n    private final Logger logger = LoggerFactory.getLogger(ThymeleafTemplateResolverFactory.class);\n\n    @Autowired\n    private Domain domain;\n\n    @Override\n    protected ITemplateResolver doCreateInstance() throws Exception {\n        if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n            logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n            return defaultTemplateResolver();\n        }\n\n        ITemplateResolver resolver = overrideTemplateResolver();\n\n        return (resolver != null) ? resolver : defaultTemplateResolver();\n    }\n\n    private ITemplateResolver overrideTemplateResolver() {\n        return new DomainBasedTemplateResolver();\n\n    }\n    private ITemplateResolver defaultTemplateResolver() {\n        ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n        templateResolver.setPrefix(\"/views/\");\n        templateResolver.setSuffix(\".html\");\n        templateResolver.setTemplateMode(\"HTML\");\n        return templateResolver;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return ITemplateResolver.class;\n    }\n}",
        "start_point": {
            "row": 29,
            "column": 0
        },
        "end_point": {
            "row": 64,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/main/java/io/gravitee/am/management/handlers/admin/view/ThymeleafTemplateResolverFactory.java",
        "methods": [
            {
                "definition": "@Override\nprotected ITemplateResolver doCreateInstance() throws Exception {\n    if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n        logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n        return defaultTemplateResolver();\n    }\n\n    ITemplateResolver resolver = overrideTemplateResolver();\n\n    return (resolver != null) ? resolver : defaultTemplateResolver();\n}",
                "name": "doCreateInstance",
                "modifiers": "@Override\n    protected",
                "return_type": "ITemplateResolver",
                "parameters": [],
                "body": "{\n    if (domain.getLoginForm() == null || domain.getLoginForm().getContent() == null || !domain.getLoginForm().isEnabled()) {\n        logger.debug(\"View templating has not been overridden with custom view, returning default views.\");\n        return defaultTemplateResolver();\n    }\n\n    ITemplateResolver resolver = overrideTemplateResolver();\n\n    return (resolver != null) ? resolver : defaultTemplateResolver();\n}",
                "start_point": {
                    "row": 36,
                    "column": 4
                },
                "end_point": {
                    "row": 46,
                    "column": 5
                }
            },
            {
                "definition": "private ITemplateResolver overrideTemplateResolver() {\n    return new DomainBasedTemplateResolver();\n\n}",
                "name": "overrideTemplateResolver",
                "modifiers": "private",
                "return_type": "ITemplateResolver",
                "parameters": [],
                "body": "{\n    return new DomainBasedTemplateResolver();\n\n}",
                "start_point": {
                    "row": 48,
                    "column": 4
                },
                "end_point": {
                    "row": 51,
                    "column": 5
                }
            },
            {
                "definition": "private ITemplateResolver defaultTemplateResolver() {\n    ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n    templateResolver.setPrefix(\"/views/\");\n    templateResolver.setSuffix(\".html\");\n    templateResolver.setTemplateMode(\"HTML\");\n    return templateResolver;\n}",
                "name": "defaultTemplateResolver",
                "modifiers": "private",
                "return_type": "ITemplateResolver",
                "parameters": [],
                "body": "{\n    ClassLoaderTemplateResolver templateResolver = new ClassLoaderTemplateResolver();\n    templateResolver.setPrefix(\"/views/\");\n    templateResolver.setSuffix(\".html\");\n    templateResolver.setTemplateMode(\"HTML\");\n    return templateResolver;\n}",
                "start_point": {
                    "row": 52,
                    "column": 4
                },
                "end_point": {
                    "row": 58,
                    "column": 5
                }
            },
            {
                "definition": "@Override\npublic Class<?> getObjectType() {\n    return ITemplateResolver.class;\n}",
                "name": "getObjectType",
                "modifiers": "@Override\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    return ITemplateResolver.class;\n}",
                "start_point": {
                    "row": 60,
                    "column": 4
                },
                "end_point": {
                    "row": 63,
                    "column": 5
                }
            }
        ]
    },
    {
        "rev_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-oauth2/src/test/java/io/gravitee/am/management/handlers/oauth2/listener/AuthenticationSuccessListenerTest.java",
        "definition": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic class AuthenticationSuccessListenerTest {\n\n    @InjectMocks\n    private AuthenticationSuccessListener listener = new AuthenticationSuccessListener();\n\n    @Mock\n    private AuthenticationSuccessEvent eventMock;\n\n    @Mock\n    private Authentication authenticationMock;\n\n    @Mock\n    private User userDetailsMock;\n\n    @Mock\n    private UserService userServiceMock;\n\n    @Mock\n    private Domain domainMock;\n\n    @Mock\n    private io.gravitee.am.model.User repositoryUserMock;\n\n    @Test\n    public void shouldCreateUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n        verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n    }\n\n    @Test\n    public void shouldUpdatedUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        //when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(repositoryUserMock);\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n        verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n    }\n}",
        "package": "package io.gravitee.am.management.handlers.oauth2.listener;",
        "tree_path": "AuthenticationSuccessListenerTest",
        "name": "AuthenticationSuccessListenerTest",
        "modifiers": "@RunWith(MockitoJUnitRunner.class)\n@Ignore\npublic",
        "superclass": null,
        "super_interfaces": null,
        "body": "{\n\n    @InjectMocks\n    private AuthenticationSuccessListener listener = new AuthenticationSuccessListener();\n\n    @Mock\n    private AuthenticationSuccessEvent eventMock;\n\n    @Mock\n    private Authentication authenticationMock;\n\n    @Mock\n    private User userDetailsMock;\n\n    @Mock\n    private UserService userServiceMock;\n\n    @Mock\n    private Domain domainMock;\n\n    @Mock\n    private io.gravitee.am.model.User repositoryUserMock;\n\n    @Test\n    public void shouldCreateUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n        verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n    }\n\n    @Test\n    public void shouldUpdatedUser() {\n        when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n        when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n        //when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(repositoryUserMock);\n\n        listener.onApplicationEvent(eventMock);\n\n        verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n        verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n        verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n    }\n}",
        "start_point": {
            "row": 41,
            "column": 0
        },
        "end_point": {
            "row": 91,
            "column": 1
        },
        "file_mode": "Renamed",
        "map_path": "gravitee-am-management-api/gravitee-am-management-api-handlers/gravitee-am-management-api-handlers-admin/src/test/java/io/gravitee/am/management/handlers/oauth2/listener/AuthenticationSuccessListenerTest.java",
        "methods": [
            {
                "definition": "@Test\npublic void shouldCreateUser() {\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n    verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n}",
                "name": "shouldCreateUser",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenThrow(UserNotFoundException.class);\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).create(any(String.class), any(NewUser.class));\n    verify(userServiceMock, never()).update(any(String.class), any(String.class), any(UpdateUser.class));\n}",
                "start_point": {
                    "row": 66,
                    "column": 4
                },
                "end_point": {
                    "row": 77,
                    "column": 5
                }
            },
            {
                "definition": "@Test\npublic void shouldUpdatedUser() {\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    //when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(repositoryUserMock);\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n    verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n}",
                "name": "shouldUpdatedUser",
                "modifiers": "@Test\n    public",
                "return_type": null,
                "parameters": [],
                "body": "{\n    when(eventMock.getAuthentication()).thenReturn(authenticationMock);\n    when(authenticationMock.getPrincipal()).thenReturn(userDetailsMock);\n    //when(userServiceMock.loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername())).thenReturn(repositoryUserMock);\n\n    listener.onApplicationEvent(eventMock);\n\n    verify(userServiceMock, times(1)).loadUserByUsernameAndDomain(domainMock.getId(), userDetailsMock.getUsername());\n    verify(userServiceMock, times(1)).update(any(String.class), any(String.class), any(UpdateUser.class));\n    verify(userServiceMock, never()).create(any(String.class), any(NewUser.class));\n}",
                "start_point": {
                    "row": 79,
                    "column": 4
                },
                "end_point": {
                    "row": 90,
                    "column": 5
                }
            }
        ]
    }
]